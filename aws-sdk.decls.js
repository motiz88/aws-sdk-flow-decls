/* @flow */

/*
// We're blocked by https://github.com/facebook/flow/issues/1815 from doing:

import http from 'http';
import https from 'https';
type httpAgent = http.Agent | https.Agent;

*/

type httpAgent = Object;

declare module 'aws-sdk' {
  declare type Credentials = any;

  declare type CredentialProviderChain = any;

  declare type $ConfigOptions = {
    accessKeyId?: string,
    secretAccessKey?: string,
    sessionToken?: Credentials,
    credentials?: Credentials,
    credentialProvider?: CredentialProviderChain,
    region?: string,
    maxRetries?: number,
    maxRedirects?: number,
    sslEnabled?: boolean,
    paramValidation?: boolean | {
      min?: boolean,
      max?: boolean,
      pattern?: boolean,
      enum?: boolean
    },
    computeChecksums?: boolean,
    convertResponseTypes?: boolean,
    correctClockSkew?: boolean,
    s3ForcePathStyle?: boolean,
    s3BucketEndpoint?: boolean,
    s3DisableBodySigning?: boolean,
    retryDelayOptions?: {
      base?: number,
      customBackoff?: (retryCount: number) => number
    },
    httpOptions?: {
      proxy?: string,
      agent?: httpAgent,
      timeout?: number,
      xhrAsync?: boolean,
      xhrWithCredentials?: boolean
    },
    apiVersion?: string | Date,
    apiVersions?: {[key: string]: string | Date},
    logger?: void | {write: Function} | {log: Function},
    systemClockOffset?: number,
    signatureVersion?: string,
    signatureCache?: boolean
  }

  declare class Config {
    logger?: void | {write: Function} | {log: Function};
    accessKeyId?: string;
    secretAccessKey?: string;
    sessionToken?: Credentials;
    credentials?: Credentials;
    credentialProvider?: CredentialProviderChain;
    region?: string;
    maxRetries?: number;
    maxRedirects?: number;
    sslEnabled?: boolean;
    paramValidation?: boolean | {
      min?: boolean,
      max?: boolean,
      pattern?: boolean,
      enum?: boolean
    };
    computeChecksums?: boolean;
    convertResponseTypes?: boolean;
    correctClockSkew?: boolean;
    s3ForcePathStyle?: boolean;
    s3BucketEndpoint?: boolean;
    s3DisableBodySigning?: boolean;
    retryDelayOptions?: {
      base?: number,
      customBackoff?: (retryCount: number) => number
    };
    httpOptions?: {
      proxy?: string,
      agent?: httpAgent,
      timeout?: number,
      xhrAsync?: boolean,
      xhrWithCredentials?: boolean
    };
    apiVersion?: string | Date;
    apiVersions?: {[key: string]: string | Date};
    logger?: void | {write: Function} | {log: Function};
    systemClockOffset?: number;
    signatureVersion?: string;
    signatureCache?: boolean;
  }

  declare var config: Config;

  declare class Service {
    constructor (config?: $ConfigOptions): Service;
    apiVersions: string[];
    defineService(serviceIdentifier: string, versions: string[], features: Object): Class<Service>;
    makeRequest(operation: string, params: Object, callback: (err: ?Error, data: ?Object) => void): void;
    makeUnauthenticatedRequest(operation: string, params: Object, callback: (err: ?Error, data: ?Object) => void): void;
    setupRequestListeners(): void;
    waitFor(state: string, params: Object, callback: (err: ?Error, data: ?Object) => void): void;
  }

  declare type $Callback<T> = (error: ?Error, data: ?T) => void;

  declare class Request<T> {
    promise(): Promise<T>;
    abort(): this;
    createReadStream(): stream$Readable;
    eachItem(callback: Function): void;
    eachPage(callback: ((err: ?Error, data: ?T) => boolean) | (err: ?Error, data: ?T, done: () => void) => boolean): void;
    isPageable(): boolean;
    send(callback?: $Callback<T>): void;
  }

  declare type $APIMethod<Params, Result> = (params: Params, cb?: $Callback<Result>) => Request<Result>;

  declare type ACM$20151208$AddTagsToCertificateRequest = {
    CertificateArn: string;
    Tags: ACM$20151208$TagList;
  };
  declare type ACM$20151208$CertificateDetail = {
    CertificateArn?: string;
    DomainName?: string;
    SubjectAlternativeNames?: ACM$20151208$DomainList;
    DomainValidationOptions?: ACM$20151208$DomainValidationList;
    Serial?: string;
    Subject?: string;
    Issuer?: string;
    CreatedAt?: Date;
    IssuedAt?: Date;
    Status?: 'PENDING_VALIDATION' | 'ISSUED' | 'INACTIVE' | 'EXPIRED' | 'VALIDATION_TIMED_OUT' | 'REVOKED' | 'FAILED';
    RevokedAt?: Date;
    RevocationReason?: 'UNSPECIFIED' | 'KEY_COMPROMISE' | 'CA_COMPROMISE' | 'AFFILIATION_CHANGED' | 'SUPERCEDED' | 'CESSATION_OF_OPERATION' | 'CERTIFICATE_HOLD' | 'REMOVE_FROM_CRL' | 'PRIVILEGE_WITHDRAWN' | 'A_A_COMPROMISE';
    NotBefore?: Date;
    NotAfter?: Date;
    KeyAlgorithm?: 'RSA_2048' | 'EC_prime256v1';
    SignatureAlgorithm?: string;
    InUseBy?: ACM$20151208$InUseList;
    FailureReason?: 'NO_AVAILABLE_CONTACTS' | 'ADDITIONAL_VERIFICATION_REQUIRED' | 'DOMAIN_NOT_ALLOWED' | 'INVALID_PUBLIC_DOMAIN' | 'OTHER';
  };
  declare type ACM$20151208$CertificateStatus = 'PENDING_VALIDATION' | 'ISSUED' | 'INACTIVE' | 'EXPIRED' | 'VALIDATION_TIMED_OUT' | 'REVOKED' | 'FAILED';
  declare type ACM$20151208$CertificateStatuses = ('PENDING_VALIDATION' | 'ISSUED' | 'INACTIVE' | 'EXPIRED' | 'VALIDATION_TIMED_OUT' | 'REVOKED' | 'FAILED')[];
  declare type ACM$20151208$CertificateSummary = {
    CertificateArn?: string;
    DomainName?: string;
  };
  declare type ACM$20151208$CertificateSummaryList = ACM$20151208$CertificateSummary[];
  declare type ACM$20151208$DeleteCertificateRequest = {
    CertificateArn: string;
  };
  declare type ACM$20151208$DescribeCertificateRequest = {
    CertificateArn: string;
  };
  declare type ACM$20151208$DescribeCertificateResponse = {
    Certificate?: ACM$20151208$CertificateDetail;
  };
  declare type ACM$20151208$DomainList = string[];
  declare type ACM$20151208$DomainValidation = {
    DomainName: string;
    ValidationEmails?: ACM$20151208$ValidationEmailList;
    ValidationDomain?: string;
  };
  declare type ACM$20151208$DomainValidationList = ACM$20151208$DomainValidation[];
  declare type ACM$20151208$DomainValidationOption = {
    DomainName: string;
    ValidationDomain: string;
  };
  declare type ACM$20151208$DomainValidationOptionList = ACM$20151208$DomainValidationOption[];
  declare type ACM$20151208$FailureReason = 'NO_AVAILABLE_CONTACTS' | 'ADDITIONAL_VERIFICATION_REQUIRED' | 'DOMAIN_NOT_ALLOWED' | 'INVALID_PUBLIC_DOMAIN' | 'OTHER';
  declare type ACM$20151208$GetCertificateRequest = {
    CertificateArn: string;
  };
  declare type ACM$20151208$GetCertificateResponse = {
    Certificate?: string;
    CertificateChain?: string;
  };
  declare type ACM$20151208$InUseList = string[];
  declare type ACM$20151208$InvalidArnException = {
    message?: string;
  };
  declare type ACM$20151208$InvalidDomainValidationOptionsException = {
    message?: string;
  };
  declare type ACM$20151208$InvalidStateException = {
    message?: string;
  };
  declare type ACM$20151208$InvalidTagException = {
    message?: string;
  };
  declare type ACM$20151208$KeyAlgorithm = 'RSA_2048' | 'EC_prime256v1';
  declare type ACM$20151208$LimitExceededException = {
    message?: string;
  };
  declare type ACM$20151208$ListCertificatesRequest = {
    CertificateStatuses?: ACM$20151208$CertificateStatuses;
    NextToken?: string;
    MaxItems?: number;
  };
  declare type ACM$20151208$ListCertificatesResponse = {
    NextToken?: string;
    CertificateSummaryList?: ACM$20151208$CertificateSummaryList;
  };
  declare type ACM$20151208$ListTagsForCertificateRequest = {
    CertificateArn: string;
  };
  declare type ACM$20151208$ListTagsForCertificateResponse = {
    Tags?: ACM$20151208$TagList;
  };
  declare type ACM$20151208$RemoveTagsFromCertificateRequest = {
    CertificateArn: string;
    Tags: ACM$20151208$TagList;
  };
  declare type ACM$20151208$RequestCertificateRequest = {
    DomainName: string;
    SubjectAlternativeNames?: ACM$20151208$DomainList;
    IdempotencyToken?: string;
    DomainValidationOptions?: ACM$20151208$DomainValidationOptionList;
  };
  declare type ACM$20151208$RequestCertificateResponse = {
    CertificateArn?: string;
  };
  declare type ACM$20151208$RequestInProgressException = {
    message?: string;
  };
  declare type ACM$20151208$ResendValidationEmailRequest = {
    CertificateArn: string;
    Domain: string;
    ValidationDomain: string;
  };
  declare type ACM$20151208$ResourceInUseException = {
    message?: string;
  };
  declare type ACM$20151208$ResourceNotFoundException = {
    message?: string;
  };
  declare type ACM$20151208$RevocationReason = 'UNSPECIFIED' | 'KEY_COMPROMISE' | 'CA_COMPROMISE' | 'AFFILIATION_CHANGED' | 'SUPERCEDED' | 'CESSATION_OF_OPERATION' | 'CERTIFICATE_HOLD' | 'REMOVE_FROM_CRL' | 'PRIVILEGE_WITHDRAWN' | 'A_A_COMPROMISE';
  declare type ACM$20151208$TStamp = Date;
  declare type ACM$20151208$Tag = {
    Key: string;
    Value?: string;
  };
  declare type ACM$20151208$TagList = ACM$20151208$Tag[];
  declare type ACM$20151208$TooManyTagsException = {
    message?: string;
  };
  declare type ACM$20151208$ValidationEmailList = string[];
  declare type APIGateway$20150709$Account = {
    cloudwatchRoleArn?: string;
    throttleSettings?: APIGateway$20150709$ThrottleSettings;
  };
  declare type APIGateway$20150709$ApiKey = {
    id?: string;
    name?: string;
    description?: string;
    enabled?: boolean;
    stageKeys?: APIGateway$20150709$ListOfString;
    createdDate?: Date;
    lastUpdatedDate?: Date;
  };
  declare type APIGateway$20150709$ApiKeys = {
    position?: string;
    items?: APIGateway$20150709$ListOfApiKey;
  };
  declare type APIGateway$20150709$Authorizer = {
    id?: string;
    name?: string;
    type?: 'TOKEN' | 'COGNITO_USER_POOLS';
    providerARNs?: APIGateway$20150709$ListOfARNs;
    authType?: string;
    authorizerUri?: string;
    authorizerCredentials?: string;
    identitySource?: string;
    identityValidationExpression?: string;
    authorizerResultTtlInSeconds?: number;
  };
  declare type APIGateway$20150709$AuthorizerType = 'TOKEN' | 'COGNITO_USER_POOLS';
  declare type APIGateway$20150709$Authorizers = {
    position?: string;
    items?: APIGateway$20150709$ListOfAuthorizer;
  };
  declare type APIGateway$20150709$BadRequestException = {
    message?: string;
  };
  declare type APIGateway$20150709$BasePathMapping = {
    basePath?: string;
    restApiId?: string;
    stage?: string;
  };
  declare type APIGateway$20150709$BasePathMappings = {
    position?: string;
    items?: APIGateway$20150709$ListOfBasePathMapping;
  };
  declare type APIGateway$20150709$Blob = Buffer | $TypedArray | Blob | string;
  declare type APIGateway$20150709$CacheClusterSize = '0.5' | '1.6' | '6.1' | '13.5' | '28.4' | '58.2' | '118' | '237';
  declare type APIGateway$20150709$CacheClusterStatus = 'CREATE_IN_PROGRESS' | 'AVAILABLE' | 'DELETE_IN_PROGRESS' | 'NOT_AVAILABLE' | 'FLUSH_IN_PROGRESS';
  declare type APIGateway$20150709$ClientCertificate = {
    clientCertificateId?: string;
    description?: string;
    pemEncodedCertificate?: string;
    createdDate?: Date;
    expirationDate?: Date;
  };
  declare type APIGateway$20150709$ClientCertificates = {
    position?: string;
    items?: APIGateway$20150709$ListOfClientCertificate;
  };
  declare type APIGateway$20150709$ConflictException = {
    message?: string;
  };
  declare type APIGateway$20150709$CreateApiKeyRequest = {
    name?: string;
    description?: string;
    enabled?: boolean;
    stageKeys?: APIGateway$20150709$ListOfStageKeys;
  };
  declare type APIGateway$20150709$CreateAuthorizerRequest = {
    restApiId: string;
    name: string;
    type: 'TOKEN' | 'COGNITO_USER_POOLS';
    providerARNs?: APIGateway$20150709$ListOfARNs;
    authType?: string;
    authorizerUri?: string;
    authorizerCredentials?: string;
    identitySource: string;
    identityValidationExpression?: string;
    authorizerResultTtlInSeconds?: number;
  };
  declare type APIGateway$20150709$CreateBasePathMappingRequest = {
    domainName: string;
    basePath?: string;
    restApiId: string;
    stage?: string;
  };
  declare type APIGateway$20150709$CreateDeploymentRequest = {
    restApiId: string;
    stageName: string;
    stageDescription?: string;
    description?: string;
    cacheClusterEnabled?: boolean;
    cacheClusterSize?: '0.5' | '1.6' | '6.1' | '13.5' | '28.4' | '58.2' | '118' | '237';
    variables?: {
      [key: string]: string;
    };
  };
  declare type APIGateway$20150709$CreateDomainNameRequest = {
    domainName: string;
    certificateName: string;
    certificateBody: string;
    certificatePrivateKey: string;
    certificateChain: string;
  };
  declare type APIGateway$20150709$CreateModelRequest = {
    restApiId: string;
    name: string;
    description?: string;
    schema?: string;
    contentType: string;
  };
  declare type APIGateway$20150709$CreateResourceRequest = {
    restApiId: string;
    parentId: string;
    pathPart: string;
  };
  declare type APIGateway$20150709$CreateRestApiRequest = {
    name: string;
    description?: string;
    cloneFrom?: string;
  };
  declare type APIGateway$20150709$CreateStageRequest = {
    restApiId: string;
    stageName: string;
    deploymentId: string;
    description?: string;
    cacheClusterEnabled?: boolean;
    cacheClusterSize?: '0.5' | '1.6' | '6.1' | '13.5' | '28.4' | '58.2' | '118' | '237';
    variables?: {
      [key: string]: string;
    };
  };
  declare type APIGateway$20150709$DeleteApiKeyRequest = {
    apiKey: string;
  };
  declare type APIGateway$20150709$DeleteAuthorizerRequest = {
    restApiId: string;
    authorizerId: string;
  };
  declare type APIGateway$20150709$DeleteBasePathMappingRequest = {
    domainName: string;
    basePath: string;
  };
  declare type APIGateway$20150709$DeleteClientCertificateRequest = {
    clientCertificateId: string;
  };
  declare type APIGateway$20150709$DeleteDeploymentRequest = {
    restApiId: string;
    deploymentId: string;
  };
  declare type APIGateway$20150709$DeleteDomainNameRequest = {
    domainName: string;
  };
  declare type APIGateway$20150709$DeleteIntegrationRequest = {
    restApiId: string;
    resourceId: string;
    httpMethod: string;
  };
  declare type APIGateway$20150709$DeleteIntegrationResponseRequest = {
    restApiId: string;
    resourceId: string;
    httpMethod: string;
    statusCode: string;
  };
  declare type APIGateway$20150709$DeleteMethodRequest = {
    restApiId: string;
    resourceId: string;
    httpMethod: string;
  };
  declare type APIGateway$20150709$DeleteMethodResponseRequest = {
    restApiId: string;
    resourceId: string;
    httpMethod: string;
    statusCode: string;
  };
  declare type APIGateway$20150709$DeleteModelRequest = {
    restApiId: string;
    modelName: string;
  };
  declare type APIGateway$20150709$DeleteResourceRequest = {
    restApiId: string;
    resourceId: string;
  };
  declare type APIGateway$20150709$DeleteRestApiRequest = {
    restApiId: string;
  };
  declare type APIGateway$20150709$DeleteStageRequest = {
    restApiId: string;
    stageName: string;
  };
  declare type APIGateway$20150709$Deployment = {
    id?: string;
    description?: string;
    createdDate?: Date;
    apiSummary?: {
      [key: string]: {
        [key: string]: APIGateway$20150709$MethodSnapshot;
      };
    };
  };
  declare type APIGateway$20150709$Deployments = {
    position?: string;
    items?: APIGateway$20150709$ListOfDeployment;
  };
  declare type APIGateway$20150709$DomainName = {
    domainName?: string;
    certificateName?: string;
    certificateUploadDate?: Date;
    distributionDomainName?: string;
  };
  declare type APIGateway$20150709$DomainNames = {
    position?: string;
    items?: APIGateway$20150709$ListOfDomainName;
  };
  declare type APIGateway$20150709$ExportResponse = {
    contentType?: string;
    contentDisposition?: string;
    body?: Buffer | $TypedArray | Blob | string;
  };
  declare type APIGateway$20150709$FlushStageAuthorizersCacheRequest = {
    restApiId: string;
    stageName: string;
  };
  declare type APIGateway$20150709$FlushStageCacheRequest = {
    restApiId: string;
    stageName: string;
  };
  declare type APIGateway$20150709$GenerateClientCertificateRequest = {
    description?: string;
  };
  declare type APIGateway$20150709$GetAccountRequest = {};
  declare type APIGateway$20150709$GetApiKeyRequest = {
    apiKey: string;
  };
  declare type APIGateway$20150709$GetApiKeysRequest = {
    position?: string;
    limit?: number;
  };
  declare type APIGateway$20150709$GetAuthorizerRequest = {
    restApiId: string;
    authorizerId: string;
  };
  declare type APIGateway$20150709$GetAuthorizersRequest = {
    restApiId: string;
    position?: string;
    limit?: number;
  };
  declare type APIGateway$20150709$GetBasePathMappingRequest = {
    domainName: string;
    basePath: string;
  };
  declare type APIGateway$20150709$GetBasePathMappingsRequest = {
    domainName: string;
    position?: string;
    limit?: number;
  };
  declare type APIGateway$20150709$GetClientCertificateRequest = {
    clientCertificateId: string;
  };
  declare type APIGateway$20150709$GetClientCertificatesRequest = {
    position?: string;
    limit?: number;
  };
  declare type APIGateway$20150709$GetDeploymentRequest = {
    restApiId: string;
    deploymentId: string;
  };
  declare type APIGateway$20150709$GetDeploymentsRequest = {
    restApiId: string;
    position?: string;
    limit?: number;
  };
  declare type APIGateway$20150709$GetDomainNameRequest = {
    domainName: string;
  };
  declare type APIGateway$20150709$GetDomainNamesRequest = {
    position?: string;
    limit?: number;
  };
  declare type APIGateway$20150709$GetExportRequest = {
    restApiId: string;
    stageName: string;
    exportType: string;
    parameters?: {
      [key: string]: string;
    };
    accepts?: string;
  };
  declare type APIGateway$20150709$GetIntegrationRequest = {
    restApiId: string;
    resourceId: string;
    httpMethod: string;
  };
  declare type APIGateway$20150709$GetIntegrationResponseRequest = {
    restApiId: string;
    resourceId: string;
    httpMethod: string;
    statusCode: string;
  };
  declare type APIGateway$20150709$GetMethodRequest = {
    restApiId: string;
    resourceId: string;
    httpMethod: string;
  };
  declare type APIGateway$20150709$GetMethodResponseRequest = {
    restApiId: string;
    resourceId: string;
    httpMethod: string;
    statusCode: string;
  };
  declare type APIGateway$20150709$GetModelRequest = {
    restApiId: string;
    modelName: string;
    flatten?: boolean;
  };
  declare type APIGateway$20150709$GetModelTemplateRequest = {
    restApiId: string;
    modelName: string;
  };
  declare type APIGateway$20150709$GetModelsRequest = {
    restApiId: string;
    position?: string;
    limit?: number;
  };
  declare type APIGateway$20150709$GetResourceRequest = {
    restApiId: string;
    resourceId: string;
  };
  declare type APIGateway$20150709$GetResourcesRequest = {
    restApiId: string;
    position?: string;
    limit?: number;
  };
  declare type APIGateway$20150709$GetRestApiRequest = {
    restApiId: string;
  };
  declare type APIGateway$20150709$GetRestApisRequest = {
    position?: string;
    limit?: number;
  };
  declare type APIGateway$20150709$GetSdkRequest = {
    restApiId: string;
    stageName: string;
    sdkType: string;
    parameters?: {
      [key: string]: string;
    };
  };
  declare type APIGateway$20150709$GetStageRequest = {
    restApiId: string;
    stageName: string;
  };
  declare type APIGateway$20150709$GetStagesRequest = {
    restApiId: string;
    deploymentId?: string;
  };
  declare type APIGateway$20150709$ImportRestApiRequest = {
    failOnWarnings?: boolean;
    parameters?: {
      [key: string]: string;
    };
    body: Buffer | $TypedArray | Blob | string;
  };
  declare type APIGateway$20150709$Integration = {
    type?: 'HTTP' | 'AWS' | 'MOCK';
    httpMethod?: string;
    uri?: string;
    credentials?: string;
    requestParameters?: {
      [key: string]: string;
    };
    requestTemplates?: {
      [key: string]: string;
    };
    passthroughBehavior?: string;
    cacheNamespace?: string;
    cacheKeyParameters?: APIGateway$20150709$ListOfString;
    integrationResponses?: {
      [key: string]: APIGateway$20150709$IntegrationResponse;
    };
  };
  declare type APIGateway$20150709$IntegrationResponse = {
    statusCode?: string;
    selectionPattern?: string;
    responseParameters?: {
      [key: string]: string;
    };
    responseTemplates?: {
      [key: string]: string;
    };
  };
  declare type APIGateway$20150709$IntegrationType = 'HTTP' | 'AWS' | 'MOCK';
  declare type APIGateway$20150709$LimitExceededException = {
    retryAfterSeconds?: string;
    message?: string;
  };
  declare type APIGateway$20150709$ListOfARNs = string[];
  declare type APIGateway$20150709$ListOfApiKey = APIGateway$20150709$ApiKey[];
  declare type APIGateway$20150709$ListOfAuthorizer = APIGateway$20150709$Authorizer[];
  declare type APIGateway$20150709$ListOfBasePathMapping = APIGateway$20150709$BasePathMapping[];
  declare type APIGateway$20150709$ListOfClientCertificate = APIGateway$20150709$ClientCertificate[];
  declare type APIGateway$20150709$ListOfDeployment = APIGateway$20150709$Deployment[];
  declare type APIGateway$20150709$ListOfDomainName = APIGateway$20150709$DomainName[];
  declare type APIGateway$20150709$ListOfModel = APIGateway$20150709$Model[];
  declare type APIGateway$20150709$ListOfPatchOperation = APIGateway$20150709$PatchOperation[];
  declare type APIGateway$20150709$ListOfResource = APIGateway$20150709$Resource[];
  declare type APIGateway$20150709$ListOfRestApi = APIGateway$20150709$RestApi[];
  declare type APIGateway$20150709$ListOfStage = APIGateway$20150709$Stage[];
  declare type APIGateway$20150709$ListOfStageKeys = APIGateway$20150709$StageKey[];
  declare type APIGateway$20150709$ListOfString = string[];
  declare type APIGateway$20150709$MapOfHeaderValues = {
    [key: string]: string;
  };
  declare type APIGateway$20150709$MapOfIntegrationResponse = {
    [key: string]: APIGateway$20150709$IntegrationResponse;
  };
  declare type APIGateway$20150709$MapOfMethod = {
    [key: string]: APIGateway$20150709$Method;
  };
  declare type APIGateway$20150709$MapOfMethodResponse = {
    [key: string]: APIGateway$20150709$MethodResponse;
  };
  declare type APIGateway$20150709$MapOfMethodSettings = {
    [key: string]: APIGateway$20150709$MethodSetting;
  };
  declare type APIGateway$20150709$MapOfMethodSnapshot = {
    [key: string]: APIGateway$20150709$MethodSnapshot;
  };
  declare type APIGateway$20150709$MapOfStringToBoolean = {
    [key: string]: boolean;
  };
  declare type APIGateway$20150709$MapOfStringToList = {
    [key: string]: APIGateway$20150709$ListOfString;
  };
  declare type APIGateway$20150709$MapOfStringToString = {
    [key: string]: string;
  };
  declare type APIGateway$20150709$Method = {
    httpMethod?: string;
    authorizationType?: string;
    authorizerId?: string;
    apiKeyRequired?: boolean;
    requestParameters?: {
      [key: string]: boolean;
    };
    requestModels?: {
      [key: string]: string;
    };
    methodResponses?: {
      [key: string]: APIGateway$20150709$MethodResponse;
    };
    methodIntegration?: APIGateway$20150709$Integration;
  };
  declare type APIGateway$20150709$MethodResponse = {
    statusCode?: string;
    responseParameters?: {
      [key: string]: boolean;
    };
    responseModels?: {
      [key: string]: string;
    };
  };
  declare type APIGateway$20150709$MethodSetting = {
    metricsEnabled?: boolean;
    loggingLevel?: string;
    dataTraceEnabled?: boolean;
    throttlingBurstLimit?: number;
    throttlingRateLimit?: number;
    cachingEnabled?: boolean;
    cacheTtlInSeconds?: number;
    cacheDataEncrypted?: boolean;
    requireAuthorizationForCacheControl?: boolean;
    unauthorizedCacheControlHeaderStrategy?: 'FAIL_WITH_403' | 'SUCCEED_WITH_RESPONSE_HEADER' | 'SUCCEED_WITHOUT_RESPONSE_HEADER';
  };
  declare type APIGateway$20150709$MethodSnapshot = {
    authorizationType?: string;
    apiKeyRequired?: boolean;
  };
  declare type APIGateway$20150709$Model = {
    id?: string;
    name?: string;
    description?: string;
    schema?: string;
    contentType?: string;
  };
  declare type APIGateway$20150709$Models = {
    position?: string;
    items?: APIGateway$20150709$ListOfModel;
  };
  declare type APIGateway$20150709$NotFoundException = {
    message?: string;
  };
  declare type APIGateway$20150709$PatchOperation = {
    op?: 'add' | 'remove' | 'replace' | 'move' | 'copy' | 'test';
    path?: string;
    value?: string;
    from?: string;
  };
  declare type APIGateway$20150709$PathToMapOfMethodSnapshot = {
    [key: string]: {
      [key: string]: APIGateway$20150709$MethodSnapshot;
    };
  };
  declare type APIGateway$20150709$PutIntegrationRequest = {
    restApiId: string;
    resourceId: string;
    httpMethod: string;
    type: 'HTTP' | 'AWS' | 'MOCK';
    integrationHttpMethod?: string;
    uri?: string;
    credentials?: string;
    requestParameters?: {
      [key: string]: string;
    };
    requestTemplates?: {
      [key: string]: string;
    };
    passthroughBehavior?: string;
    cacheNamespace?: string;
    cacheKeyParameters?: APIGateway$20150709$ListOfString;
  };
  declare type APIGateway$20150709$PutIntegrationResponseRequest = {
    restApiId: string;
    resourceId: string;
    httpMethod: string;
    statusCode: string;
    selectionPattern?: string;
    responseParameters?: {
      [key: string]: string;
    };
    responseTemplates?: {
      [key: string]: string;
    };
  };
  declare type APIGateway$20150709$PutMethodRequest = {
    restApiId: string;
    resourceId: string;
    httpMethod: string;
    authorizationType: string;
    authorizerId?: string;
    apiKeyRequired?: boolean;
    requestParameters?: {
      [key: string]: boolean;
    };
    requestModels?: {
      [key: string]: string;
    };
  };
  declare type APIGateway$20150709$PutMethodResponseRequest = {
    restApiId: string;
    resourceId: string;
    httpMethod: string;
    statusCode: string;
    responseParameters?: {
      [key: string]: boolean;
    };
    responseModels?: {
      [key: string]: string;
    };
  };
  declare type APIGateway$20150709$PutMode = 'merge' | 'overwrite';
  declare type APIGateway$20150709$PutRestApiRequest = {
    restApiId: string;
    mode?: 'merge' | 'overwrite';
    failOnWarnings?: boolean;
    parameters?: {
      [key: string]: string;
    };
    body: Buffer | $TypedArray | Blob | string;
  };
  declare type APIGateway$20150709$Resource = {
    id?: string;
    parentId?: string;
    pathPart?: string;
    path?: string;
    resourceMethods?: {
      [key: string]: APIGateway$20150709$Method;
    };
  };
  declare type APIGateway$20150709$Resources = {
    position?: string;
    items?: APIGateway$20150709$ListOfResource;
  };
  declare type APIGateway$20150709$RestApi = {
    id?: string;
    name?: string;
    description?: string;
    createdDate?: Date;
    warnings?: APIGateway$20150709$ListOfString;
  };
  declare type APIGateway$20150709$RestApis = {
    position?: string;
    items?: APIGateway$20150709$ListOfRestApi;
  };
  declare type APIGateway$20150709$SdkResponse = {
    contentType?: string;
    contentDisposition?: string;
    body?: Buffer | $TypedArray | Blob | string;
  };
  declare type APIGateway$20150709$ServiceUnavailableException = {
    retryAfterSeconds?: string;
    message?: string;
  };
  declare type APIGateway$20150709$Stage = {
    deploymentId?: string;
    clientCertificateId?: string;
    stageName?: string;
    description?: string;
    cacheClusterEnabled?: boolean;
    cacheClusterSize?: '0.5' | '1.6' | '6.1' | '13.5' | '28.4' | '58.2' | '118' | '237';
    cacheClusterStatus?: 'CREATE_IN_PROGRESS' | 'AVAILABLE' | 'DELETE_IN_PROGRESS' | 'NOT_AVAILABLE' | 'FLUSH_IN_PROGRESS';
    methodSettings?: {
      [key: string]: APIGateway$20150709$MethodSetting;
    };
    variables?: {
      [key: string]: string;
    };
    createdDate?: Date;
    lastUpdatedDate?: Date;
  };
  declare type APIGateway$20150709$StageKey = {
    restApiId?: string;
    stageName?: string;
  };
  declare type APIGateway$20150709$Stages = {
    item?: APIGateway$20150709$ListOfStage;
  };
  declare type APIGateway$20150709$Template = {
    value?: string;
  };
  declare type APIGateway$20150709$TestInvokeAuthorizerRequest = {
    restApiId: string;
    authorizerId: string;
    headers?: {
      [key: string]: string;
    };
    pathWithQueryString?: string;
    body?: string;
    stageVariables?: {
      [key: string]: string;
    };
    additionalContext?: {
      [key: string]: string;
    };
  };
  declare type APIGateway$20150709$TestInvokeAuthorizerResponse = {
    clientStatus?: number;
    log?: string;
    latency?: number;
    principalId?: string;
    policy?: string;
    authorization?: {
      [key: string]: APIGateway$20150709$ListOfString;
    };
    claims?: {
      [key: string]: string;
    };
  };
  declare type APIGateway$20150709$TestInvokeMethodRequest = {
    restApiId: string;
    resourceId: string;
    httpMethod: string;
    pathWithQueryString?: string;
    body?: string;
    headers?: {
      [key: string]: string;
    };
    clientCertificateId?: string;
    stageVariables?: {
      [key: string]: string;
    };
  };
  declare type APIGateway$20150709$TestInvokeMethodResponse = {
    status?: number;
    body?: string;
    headers?: {
      [key: string]: string;
    };
    log?: string;
    latency?: number;
  };
  declare type APIGateway$20150709$ThrottleSettings = {
    burstLimit?: number;
    rateLimit?: number;
  };
  declare type APIGateway$20150709$Timestamp = Date;
  declare type APIGateway$20150709$TooManyRequestsException = {
    retryAfterSeconds?: string;
    message?: string;
  };
  declare type APIGateway$20150709$UnauthorizedCacheControlHeaderStrategy = 'FAIL_WITH_403' | 'SUCCEED_WITH_RESPONSE_HEADER' | 'SUCCEED_WITHOUT_RESPONSE_HEADER';
  declare type APIGateway$20150709$UnauthorizedException = {
    message?: string;
  };
  declare type APIGateway$20150709$UpdateAccountRequest = {
    patchOperations?: APIGateway$20150709$ListOfPatchOperation;
  };
  declare type APIGateway$20150709$UpdateApiKeyRequest = {
    apiKey: string;
    patchOperations?: APIGateway$20150709$ListOfPatchOperation;
  };
  declare type APIGateway$20150709$UpdateAuthorizerRequest = {
    restApiId: string;
    authorizerId: string;
    patchOperations?: APIGateway$20150709$ListOfPatchOperation;
  };
  declare type APIGateway$20150709$UpdateBasePathMappingRequest = {
    domainName: string;
    basePath: string;
    patchOperations?: APIGateway$20150709$ListOfPatchOperation;
  };
  declare type APIGateway$20150709$UpdateClientCertificateRequest = {
    clientCertificateId: string;
    patchOperations?: APIGateway$20150709$ListOfPatchOperation;
  };
  declare type APIGateway$20150709$UpdateDeploymentRequest = {
    restApiId: string;
    deploymentId: string;
    patchOperations?: APIGateway$20150709$ListOfPatchOperation;
  };
  declare type APIGateway$20150709$UpdateDomainNameRequest = {
    domainName: string;
    patchOperations?: APIGateway$20150709$ListOfPatchOperation;
  };
  declare type APIGateway$20150709$UpdateIntegrationRequest = {
    restApiId: string;
    resourceId: string;
    httpMethod: string;
    patchOperations?: APIGateway$20150709$ListOfPatchOperation;
  };
  declare type APIGateway$20150709$UpdateIntegrationResponseRequest = {
    restApiId: string;
    resourceId: string;
    httpMethod: string;
    statusCode: string;
    patchOperations?: APIGateway$20150709$ListOfPatchOperation;
  };
  declare type APIGateway$20150709$UpdateMethodRequest = {
    restApiId: string;
    resourceId: string;
    httpMethod: string;
    patchOperations?: APIGateway$20150709$ListOfPatchOperation;
  };
  declare type APIGateway$20150709$UpdateMethodResponseRequest = {
    restApiId: string;
    resourceId: string;
    httpMethod: string;
    statusCode: string;
    patchOperations?: APIGateway$20150709$ListOfPatchOperation;
  };
  declare type APIGateway$20150709$UpdateModelRequest = {
    restApiId: string;
    modelName: string;
    patchOperations?: APIGateway$20150709$ListOfPatchOperation;
  };
  declare type APIGateway$20150709$UpdateResourceRequest = {
    restApiId: string;
    resourceId: string;
    patchOperations?: APIGateway$20150709$ListOfPatchOperation;
  };
  declare type APIGateway$20150709$UpdateRestApiRequest = {
    restApiId: string;
    patchOperations?: APIGateway$20150709$ListOfPatchOperation;
  };
  declare type APIGateway$20150709$UpdateStageRequest = {
    restApiId: string;
    stageName: string;
    patchOperations?: APIGateway$20150709$ListOfPatchOperation;
  };
  declare type APIGateway$20150709$op = 'add' | 'remove' | 'replace' | 'move' | 'copy' | 'test';
  declare type ApplicationAutoScaling$20160206$AdjustmentType = 'ChangeInCapacity' | 'PercentChangeInCapacity' | 'ExactCapacity';
  declare type ApplicationAutoScaling$20160206$Alarm = {
    AlarmName: string;
    AlarmARN: string;
  };
  declare type ApplicationAutoScaling$20160206$Alarms = ApplicationAutoScaling$20160206$Alarm[];
  declare type ApplicationAutoScaling$20160206$ConcurrentUpdateException = {
    Message?: string;
  };
  declare type ApplicationAutoScaling$20160206$DeleteScalingPolicyRequest = {
    PolicyName: string;
    ServiceNamespace: 'ecs';
    ResourceId: string;
    ScalableDimension: 'ecs:service:DesiredCount';
  };
  declare type ApplicationAutoScaling$20160206$DeleteScalingPolicyResponse = {};
  declare type ApplicationAutoScaling$20160206$DeregisterScalableTargetRequest = {
    ServiceNamespace: 'ecs';
    ResourceId: string;
    ScalableDimension: 'ecs:service:DesiredCount';
  };
  declare type ApplicationAutoScaling$20160206$DeregisterScalableTargetResponse = {};
  declare type ApplicationAutoScaling$20160206$DescribeScalableTargetsRequest = {
    ServiceNamespace: 'ecs';
    ResourceIds?: ApplicationAutoScaling$20160206$ResourceIdsMaxLen1600;
    ScalableDimension?: 'ecs:service:DesiredCount';
    MaxResults?: number;
    NextToken?: string;
  };
  declare type ApplicationAutoScaling$20160206$DescribeScalableTargetsResponse = {
    ScalableTargets?: ApplicationAutoScaling$20160206$ScalableTargets;
    NextToken?: string;
  };
  declare type ApplicationAutoScaling$20160206$DescribeScalingActivitiesRequest = {
    ServiceNamespace: 'ecs';
    ResourceId?: string;
    ScalableDimension?: 'ecs:service:DesiredCount';
    MaxResults?: number;
    NextToken?: string;
  };
  declare type ApplicationAutoScaling$20160206$DescribeScalingActivitiesResponse = {
    ScalingActivities?: ApplicationAutoScaling$20160206$ScalingActivities;
    NextToken?: string;
  };
  declare type ApplicationAutoScaling$20160206$DescribeScalingPoliciesRequest = {
    PolicyNames?: ApplicationAutoScaling$20160206$ResourceIdsMaxLen1600;
    ServiceNamespace: 'ecs';
    ResourceId?: string;
    ScalableDimension?: 'ecs:service:DesiredCount';
    MaxResults?: number;
    NextToken?: string;
  };
  declare type ApplicationAutoScaling$20160206$DescribeScalingPoliciesResponse = {
    ScalingPolicies?: ApplicationAutoScaling$20160206$ScalingPolicies;
    NextToken?: string;
  };
  declare type ApplicationAutoScaling$20160206$FailedResourceAccessException = {
    Message?: string;
  };
  declare type ApplicationAutoScaling$20160206$InternalServiceException = {
    Message?: string;
  };
  declare type ApplicationAutoScaling$20160206$InvalidNextTokenException = {
    Message?: string;
  };
  declare type ApplicationAutoScaling$20160206$LimitExceededException = {
    Message?: string;
  };
  declare type ApplicationAutoScaling$20160206$MetricAggregationType = 'Average' | 'Minimum' | 'Maximum';
  declare type ApplicationAutoScaling$20160206$ObjectNotFoundException = {
    Message?: string;
  };
  declare type ApplicationAutoScaling$20160206$PolicyType = 'StepScaling';
  declare type ApplicationAutoScaling$20160206$PutScalingPolicyRequest = {
    PolicyName: string;
    ServiceNamespace: 'ecs';
    ResourceId: string;
    ScalableDimension: 'ecs:service:DesiredCount';
    PolicyType?: 'StepScaling';
    StepScalingPolicyConfiguration?: ApplicationAutoScaling$20160206$StepScalingPolicyConfiguration;
  };
  declare type ApplicationAutoScaling$20160206$PutScalingPolicyResponse = {
    PolicyARN: string;
  };
  declare type ApplicationAutoScaling$20160206$RegisterScalableTargetRequest = {
    ServiceNamespace: 'ecs';
    ResourceId: string;
    ScalableDimension: 'ecs:service:DesiredCount';
    MinCapacity?: number;
    MaxCapacity?: number;
    RoleARN?: string;
  };
  declare type ApplicationAutoScaling$20160206$RegisterScalableTargetResponse = {};
  declare type ApplicationAutoScaling$20160206$ResourceIdsMaxLen1600 = string[];
  declare type ApplicationAutoScaling$20160206$ScalableDimension = 'ecs:service:DesiredCount';
  declare type ApplicationAutoScaling$20160206$ScalableTarget = {
    ServiceNamespace: 'ecs';
    ResourceId: string;
    ScalableDimension: 'ecs:service:DesiredCount';
    MinCapacity: number;
    MaxCapacity: number;
    RoleARN: string;
    CreationTime: Date;
  };
  declare type ApplicationAutoScaling$20160206$ScalableTargets = ApplicationAutoScaling$20160206$ScalableTarget[];
  declare type ApplicationAutoScaling$20160206$ScalingActivities = ApplicationAutoScaling$20160206$ScalingActivity[];
  declare type ApplicationAutoScaling$20160206$ScalingActivity = {
    ActivityId: string;
    ServiceNamespace: 'ecs';
    ResourceId: string;
    ScalableDimension: 'ecs:service:DesiredCount';
    Description: string;
    Cause: string;
    StartTime: Date;
    EndTime?: Date;
    StatusCode: 'Pending' | 'InProgress' | 'Successful' | 'Overridden' | 'Unfulfilled' | 'Failed';
    StatusMessage?: string;
    Details?: string;
  };
  declare type ApplicationAutoScaling$20160206$ScalingActivityStatusCode = 'Pending' | 'InProgress' | 'Successful' | 'Overridden' | 'Unfulfilled' | 'Failed';
  declare type ApplicationAutoScaling$20160206$ScalingPolicies = ApplicationAutoScaling$20160206$ScalingPolicy[];
  declare type ApplicationAutoScaling$20160206$ScalingPolicy = {
    PolicyARN: string;
    PolicyName: string;
    ServiceNamespace: 'ecs';
    ResourceId: string;
    ScalableDimension: 'ecs:service:DesiredCount';
    PolicyType: 'StepScaling';
    StepScalingPolicyConfiguration?: ApplicationAutoScaling$20160206$StepScalingPolicyConfiguration;
    Alarms?: ApplicationAutoScaling$20160206$Alarms;
    CreationTime: Date;
  };
  declare type ApplicationAutoScaling$20160206$ServiceNamespace = 'ecs';
  declare type ApplicationAutoScaling$20160206$StepAdjustment = {
    MetricIntervalLowerBound?: number;
    MetricIntervalUpperBound?: number;
    ScalingAdjustment: number;
  };
  declare type ApplicationAutoScaling$20160206$StepAdjustments = ApplicationAutoScaling$20160206$StepAdjustment[];
  declare type ApplicationAutoScaling$20160206$StepScalingPolicyConfiguration = {
    AdjustmentType?: 'ChangeInCapacity' | 'PercentChangeInCapacity' | 'ExactCapacity';
    StepAdjustments?: ApplicationAutoScaling$20160206$StepAdjustments;
    MinAdjustmentMagnitude?: number;
    Cooldown?: number;
    MetricAggregationType?: 'Average' | 'Minimum' | 'Maximum';
  };
  declare type ApplicationAutoScaling$20160206$TimestampType = Date;
  declare type ApplicationAutoScaling$20160206$ValidationException = {
    Message?: string;
  };
  declare type AutoScaling$20110101$Activities = AutoScaling$20110101$Activity[];
  declare type AutoScaling$20110101$ActivitiesType = {
    Activities: AutoScaling$20110101$Activities;
    NextToken?: string;
  };
  declare type AutoScaling$20110101$Activity = {
    ActivityId: string;
    AutoScalingGroupName: string;
    Description?: string;
    Cause: string;
    StartTime: Date;
    EndTime?: Date;
    StatusCode: 'PendingSpotBidPlacement' | 'WaitingForSpotInstanceRequestId' | 'WaitingForSpotInstanceId' | 'WaitingForInstanceId' | 'PreInService' | 'InProgress' | 'WaitingForELBConnectionDraining' | 'MidLifecycleAction' | 'WaitingForInstanceWarmup' | 'Successful' | 'Failed' | 'Cancelled';
    StatusMessage?: string;
    Progress?: number;
    Details?: string;
  };
  declare type AutoScaling$20110101$ActivityIds = string[];
  declare type AutoScaling$20110101$ActivityType = {
    Activity?: AutoScaling$20110101$Activity;
  };
  declare type AutoScaling$20110101$AdjustmentType = {
    AdjustmentType?: string;
  };
  declare type AutoScaling$20110101$AdjustmentTypes = AutoScaling$20110101$AdjustmentType[];
  declare type AutoScaling$20110101$Alarm = {
    AlarmName?: string;
    AlarmARN?: string;
  };
  declare type AutoScaling$20110101$Alarms = AutoScaling$20110101$Alarm[];
  declare type AutoScaling$20110101$AlreadyExistsFault = {
    message?: string;
  };
  declare type AutoScaling$20110101$AttachInstancesQuery = {
    InstanceIds?: AutoScaling$20110101$InstanceIds;
    AutoScalingGroupName: string;
  };
  declare type AutoScaling$20110101$AttachLoadBalancerTargetGroupsResultType = {};
  declare type AutoScaling$20110101$AttachLoadBalancerTargetGroupsType = {
    AutoScalingGroupName: string;
    TargetGroupARNs: AutoScaling$20110101$TargetGroupARNs;
  };
  declare type AutoScaling$20110101$AttachLoadBalancersResultType = {};
  declare type AutoScaling$20110101$AttachLoadBalancersType = {
    AutoScalingGroupName: string;
    LoadBalancerNames: AutoScaling$20110101$LoadBalancerNames;
  };
  declare type AutoScaling$20110101$AutoScalingGroup = {
    AutoScalingGroupName: string;
    AutoScalingGroupARN?: string;
    LaunchConfigurationName?: string;
    MinSize: number;
    MaxSize: number;
    DesiredCapacity: number;
    DefaultCooldown: number;
    AvailabilityZones: AutoScaling$20110101$AvailabilityZones;
    LoadBalancerNames?: AutoScaling$20110101$LoadBalancerNames;
    TargetGroupARNs?: AutoScaling$20110101$TargetGroupARNs;
    HealthCheckType: string;
    HealthCheckGracePeriod?: number;
    Instances?: AutoScaling$20110101$Instances;
    CreatedTime: Date;
    SuspendedProcesses?: AutoScaling$20110101$SuspendedProcesses;
    PlacementGroup?: string;
    VPCZoneIdentifier?: string;
    EnabledMetrics?: AutoScaling$20110101$EnabledMetrics;
    Status?: string;
    Tags?: AutoScaling$20110101$TagDescriptionList;
    TerminationPolicies?: AutoScaling$20110101$TerminationPolicies;
    NewInstancesProtectedFromScaleIn?: boolean;
  };
  declare type AutoScaling$20110101$AutoScalingGroupNames = string[];
  declare type AutoScaling$20110101$AutoScalingGroupNamesType = {
    AutoScalingGroupNames?: AutoScaling$20110101$AutoScalingGroupNames;
    NextToken?: string;
    MaxRecords?: number;
  };
  declare type AutoScaling$20110101$AutoScalingGroups = AutoScaling$20110101$AutoScalingGroup[];
  declare type AutoScaling$20110101$AutoScalingGroupsType = {
    AutoScalingGroups: AutoScaling$20110101$AutoScalingGroups;
    NextToken?: string;
  };
  declare type AutoScaling$20110101$AutoScalingInstanceDetails = {
    InstanceId: string;
    AutoScalingGroupName: string;
    AvailabilityZone: string;
    LifecycleState: string;
    HealthStatus: string;
    LaunchConfigurationName: string;
    ProtectedFromScaleIn: boolean;
  };
  declare type AutoScaling$20110101$AutoScalingInstances = AutoScaling$20110101$AutoScalingInstanceDetails[];
  declare type AutoScaling$20110101$AutoScalingInstancesType = {
    AutoScalingInstances?: AutoScaling$20110101$AutoScalingInstances;
    NextToken?: string;
  };
  declare type AutoScaling$20110101$AutoScalingNotificationTypes = string[];
  declare type AutoScaling$20110101$AvailabilityZones = string[];
  declare type AutoScaling$20110101$BlockDeviceMapping = {
    VirtualName?: string;
    DeviceName: string;
    Ebs?: AutoScaling$20110101$Ebs;
    NoDevice?: boolean;
  };
  declare type AutoScaling$20110101$BlockDeviceMappings = AutoScaling$20110101$BlockDeviceMapping[];
  declare type AutoScaling$20110101$ClassicLinkVPCSecurityGroups = string[];
  declare type AutoScaling$20110101$CompleteLifecycleActionAnswer = {};
  declare type AutoScaling$20110101$CompleteLifecycleActionType = {
    LifecycleHookName: string;
    AutoScalingGroupName: string;
    LifecycleActionToken?: string;
    LifecycleActionResult: string;
    InstanceId?: string;
  };
  declare type AutoScaling$20110101$CreateAutoScalingGroupType = {
    AutoScalingGroupName: string;
    LaunchConfigurationName?: string;
    InstanceId?: string;
    MinSize: number;
    MaxSize: number;
    DesiredCapacity?: number;
    DefaultCooldown?: number;
    AvailabilityZones?: AutoScaling$20110101$AvailabilityZones;
    LoadBalancerNames?: AutoScaling$20110101$LoadBalancerNames;
    TargetGroupARNs?: AutoScaling$20110101$TargetGroupARNs;
    HealthCheckType?: string;
    HealthCheckGracePeriod?: number;
    PlacementGroup?: string;
    VPCZoneIdentifier?: string;
    TerminationPolicies?: AutoScaling$20110101$TerminationPolicies;
    NewInstancesProtectedFromScaleIn?: boolean;
    Tags?: AutoScaling$20110101$Tags;
  };
  declare type AutoScaling$20110101$CreateLaunchConfigurationType = {
    LaunchConfigurationName: string;
    ImageId?: string;
    KeyName?: string;
    SecurityGroups?: AutoScaling$20110101$SecurityGroups;
    ClassicLinkVPCId?: string;
    ClassicLinkVPCSecurityGroups?: AutoScaling$20110101$ClassicLinkVPCSecurityGroups;
    UserData?: string;
    InstanceId?: string;
    InstanceType?: string;
    KernelId?: string;
    RamdiskId?: string;
    BlockDeviceMappings?: AutoScaling$20110101$BlockDeviceMappings;
    InstanceMonitoring?: AutoScaling$20110101$InstanceMonitoring;
    SpotPrice?: string;
    IamInstanceProfile?: string;
    EbsOptimized?: boolean;
    AssociatePublicIpAddress?: boolean;
    PlacementTenancy?: string;
  };
  declare type AutoScaling$20110101$CreateOrUpdateTagsType = {
    Tags: AutoScaling$20110101$Tags;
  };
  declare type AutoScaling$20110101$DeleteAutoScalingGroupType = {
    AutoScalingGroupName: string;
    ForceDelete?: boolean;
  };
  declare type AutoScaling$20110101$DeleteLifecycleHookAnswer = {};
  declare type AutoScaling$20110101$DeleteLifecycleHookType = {
    LifecycleHookName: string;
    AutoScalingGroupName: string;
  };
  declare type AutoScaling$20110101$DeleteNotificationConfigurationType = {
    AutoScalingGroupName: string;
    TopicARN: string;
  };
  declare type AutoScaling$20110101$DeletePolicyType = {
    AutoScalingGroupName?: string;
    PolicyName: string;
  };
  declare type AutoScaling$20110101$DeleteScheduledActionType = {
    AutoScalingGroupName: string;
    ScheduledActionName: string;
  };
  declare type AutoScaling$20110101$DeleteTagsType = {
    Tags: AutoScaling$20110101$Tags;
  };
  declare type AutoScaling$20110101$DescribeAccountLimitsAnswer = {
    MaxNumberOfAutoScalingGroups?: number;
    MaxNumberOfLaunchConfigurations?: number;
    NumberOfAutoScalingGroups?: number;
    NumberOfLaunchConfigurations?: number;
  };
  declare type AutoScaling$20110101$DescribeAdjustmentTypesAnswer = {
    AdjustmentTypes?: AutoScaling$20110101$AdjustmentTypes;
  };
  declare type AutoScaling$20110101$DescribeAutoScalingInstancesType = {
    InstanceIds?: AutoScaling$20110101$InstanceIds;
    MaxRecords?: number;
    NextToken?: string;
  };
  declare type AutoScaling$20110101$DescribeAutoScalingNotificationTypesAnswer = {
    AutoScalingNotificationTypes?: AutoScaling$20110101$AutoScalingNotificationTypes;
  };
  declare type AutoScaling$20110101$DescribeLifecycleHookTypesAnswer = {
    LifecycleHookTypes?: AutoScaling$20110101$AutoScalingNotificationTypes;
  };
  declare type AutoScaling$20110101$DescribeLifecycleHooksAnswer = {
    LifecycleHooks?: AutoScaling$20110101$LifecycleHooks;
  };
  declare type AutoScaling$20110101$DescribeLifecycleHooksType = {
    AutoScalingGroupName: string;
    LifecycleHookNames?: AutoScaling$20110101$LifecycleHookNames;
  };
  declare type AutoScaling$20110101$DescribeLoadBalancerTargetGroupsRequest = {
    AutoScalingGroupName: string;
    NextToken?: string;
    MaxRecords?: number;
  };
  declare type AutoScaling$20110101$DescribeLoadBalancerTargetGroupsResponse = {
    LoadBalancerTargetGroups?: AutoScaling$20110101$LoadBalancerTargetGroupStates;
    NextToken?: string;
  };
  declare type AutoScaling$20110101$DescribeLoadBalancersRequest = {
    AutoScalingGroupName: string;
    NextToken?: string;
    MaxRecords?: number;
  };
  declare type AutoScaling$20110101$DescribeLoadBalancersResponse = {
    LoadBalancers?: AutoScaling$20110101$LoadBalancerStates;
    NextToken?: string;
  };
  declare type AutoScaling$20110101$DescribeMetricCollectionTypesAnswer = {
    Metrics?: AutoScaling$20110101$MetricCollectionTypes;
    Granularities?: AutoScaling$20110101$MetricGranularityTypes;
  };
  declare type AutoScaling$20110101$DescribeNotificationConfigurationsAnswer = {
    NotificationConfigurations: AutoScaling$20110101$NotificationConfigurations;
    NextToken?: string;
  };
  declare type AutoScaling$20110101$DescribeNotificationConfigurationsType = {
    AutoScalingGroupNames?: AutoScaling$20110101$AutoScalingGroupNames;
    NextToken?: string;
    MaxRecords?: number;
  };
  declare type AutoScaling$20110101$DescribePoliciesType = {
    AutoScalingGroupName?: string;
    PolicyNames?: AutoScaling$20110101$PolicyNames;
    PolicyTypes?: AutoScaling$20110101$PolicyTypes;
    NextToken?: string;
    MaxRecords?: number;
  };
  declare type AutoScaling$20110101$DescribeScalingActivitiesType = {
    ActivityIds?: AutoScaling$20110101$ActivityIds;
    AutoScalingGroupName?: string;
    MaxRecords?: number;
    NextToken?: string;
  };
  declare type AutoScaling$20110101$DescribeScheduledActionsType = {
    AutoScalingGroupName?: string;
    ScheduledActionNames?: AutoScaling$20110101$ScheduledActionNames;
    StartTime?: Date;
    EndTime?: Date;
    NextToken?: string;
    MaxRecords?: number;
  };
  declare type AutoScaling$20110101$DescribeTagsType = {
    Filters?: AutoScaling$20110101$Filters;
    NextToken?: string;
    MaxRecords?: number;
  };
  declare type AutoScaling$20110101$DescribeTerminationPolicyTypesAnswer = {
    TerminationPolicyTypes?: AutoScaling$20110101$TerminationPolicies;
  };
  declare type AutoScaling$20110101$DetachInstancesAnswer = {
    Activities?: AutoScaling$20110101$Activities;
  };
  declare type AutoScaling$20110101$DetachInstancesQuery = {
    InstanceIds?: AutoScaling$20110101$InstanceIds;
    AutoScalingGroupName: string;
    ShouldDecrementDesiredCapacity: boolean;
  };
  declare type AutoScaling$20110101$DetachLoadBalancerTargetGroupsResultType = {};
  declare type AutoScaling$20110101$DetachLoadBalancerTargetGroupsType = {
    AutoScalingGroupName: string;
    TargetGroupARNs: AutoScaling$20110101$TargetGroupARNs;
  };
  declare type AutoScaling$20110101$DetachLoadBalancersResultType = {};
  declare type AutoScaling$20110101$DetachLoadBalancersType = {
    AutoScalingGroupName: string;
    LoadBalancerNames: AutoScaling$20110101$LoadBalancerNames;
  };
  declare type AutoScaling$20110101$DisableMetricsCollectionQuery = {
    AutoScalingGroupName: string;
    Metrics?: AutoScaling$20110101$Metrics;
  };
  declare type AutoScaling$20110101$Ebs = {
    SnapshotId?: string;
    VolumeSize?: number;
    VolumeType?: string;
    DeleteOnTermination?: boolean;
    Iops?: number;
    Encrypted?: boolean;
  };
  declare type AutoScaling$20110101$EnableMetricsCollectionQuery = {
    AutoScalingGroupName: string;
    Metrics?: AutoScaling$20110101$Metrics;
    Granularity: string;
  };
  declare type AutoScaling$20110101$EnabledMetric = {
    Metric?: string;
    Granularity?: string;
  };
  declare type AutoScaling$20110101$EnabledMetrics = AutoScaling$20110101$EnabledMetric[];
  declare type AutoScaling$20110101$EnterStandbyAnswer = {
    Activities?: AutoScaling$20110101$Activities;
  };
  declare type AutoScaling$20110101$EnterStandbyQuery = {
    InstanceIds?: AutoScaling$20110101$InstanceIds;
    AutoScalingGroupName: string;
    ShouldDecrementDesiredCapacity: boolean;
  };
  declare type AutoScaling$20110101$ExecutePolicyType = {
    AutoScalingGroupName?: string;
    PolicyName: string;
    HonorCooldown?: boolean;
    MetricValue?: number;
    BreachThreshold?: number;
  };
  declare type AutoScaling$20110101$ExitStandbyAnswer = {
    Activities?: AutoScaling$20110101$Activities;
  };
  declare type AutoScaling$20110101$ExitStandbyQuery = {
    InstanceIds?: AutoScaling$20110101$InstanceIds;
    AutoScalingGroupName: string;
  };
  declare type AutoScaling$20110101$Filter = {
    Name?: string;
    Values?: AutoScaling$20110101$Values;
  };
  declare type AutoScaling$20110101$Filters = AutoScaling$20110101$Filter[];
  declare type AutoScaling$20110101$Instance = {
    InstanceId: string;
    AvailabilityZone: string;
    LifecycleState: 'Pending' | 'Pending:Wait' | 'Pending:Proceed' | 'Quarantined' | 'InService' | 'Terminating' | 'Terminating:Wait' | 'Terminating:Proceed' | 'Terminated' | 'Detaching' | 'Detached' | 'EnteringStandby' | 'Standby';
    HealthStatus: string;
    LaunchConfigurationName: string;
    ProtectedFromScaleIn: boolean;
  };
  declare type AutoScaling$20110101$InstanceIds = string[];
  declare type AutoScaling$20110101$InstanceMonitoring = {
    Enabled?: boolean;
  };
  declare type AutoScaling$20110101$Instances = AutoScaling$20110101$Instance[];
  declare type AutoScaling$20110101$InvalidNextToken = {
    message?: string;
  };
  declare type AutoScaling$20110101$LaunchConfiguration = {
    LaunchConfigurationName: string;
    LaunchConfigurationARN?: string;
    ImageId: string;
    KeyName?: string;
    SecurityGroups?: AutoScaling$20110101$SecurityGroups;
    ClassicLinkVPCId?: string;
    ClassicLinkVPCSecurityGroups?: AutoScaling$20110101$ClassicLinkVPCSecurityGroups;
    UserData?: string;
    InstanceType: string;
    KernelId?: string;
    RamdiskId?: string;
    BlockDeviceMappings?: AutoScaling$20110101$BlockDeviceMappings;
    InstanceMonitoring?: AutoScaling$20110101$InstanceMonitoring;
    SpotPrice?: string;
    IamInstanceProfile?: string;
    CreatedTime: Date;
    EbsOptimized?: boolean;
    AssociatePublicIpAddress?: boolean;
    PlacementTenancy?: string;
  };
  declare type AutoScaling$20110101$LaunchConfigurationNameType = {
    LaunchConfigurationName: string;
  };
  declare type AutoScaling$20110101$LaunchConfigurationNames = string[];
  declare type AutoScaling$20110101$LaunchConfigurationNamesType = {
    LaunchConfigurationNames?: AutoScaling$20110101$LaunchConfigurationNames;
    NextToken?: string;
    MaxRecords?: number;
  };
  declare type AutoScaling$20110101$LaunchConfigurations = AutoScaling$20110101$LaunchConfiguration[];
  declare type AutoScaling$20110101$LaunchConfigurationsType = {
    LaunchConfigurations: AutoScaling$20110101$LaunchConfigurations;
    NextToken?: string;
  };
  declare type AutoScaling$20110101$LifecycleHook = {
    LifecycleHookName?: string;
    AutoScalingGroupName?: string;
    LifecycleTransition?: string;
    NotificationTargetARN?: string;
    RoleARN?: string;
    NotificationMetadata?: string;
    HeartbeatTimeout?: number;
    GlobalTimeout?: number;
    DefaultResult?: string;
  };
  declare type AutoScaling$20110101$LifecycleHookNames = string[];
  declare type AutoScaling$20110101$LifecycleHooks = AutoScaling$20110101$LifecycleHook[];
  declare type AutoScaling$20110101$LifecycleState = 'Pending' | 'Pending:Wait' | 'Pending:Proceed' | 'Quarantined' | 'InService' | 'Terminating' | 'Terminating:Wait' | 'Terminating:Proceed' | 'Terminated' | 'Detaching' | 'Detached' | 'EnteringStandby' | 'Standby';
  declare type AutoScaling$20110101$LimitExceededFault = {
    message?: string;
  };
  declare type AutoScaling$20110101$LoadBalancerNames = string[];
  declare type AutoScaling$20110101$LoadBalancerState = {
    LoadBalancerName?: string;
    State?: string;
  };
  declare type AutoScaling$20110101$LoadBalancerStates = AutoScaling$20110101$LoadBalancerState[];
  declare type AutoScaling$20110101$LoadBalancerTargetGroupState = {
    LoadBalancerTargetGroupARN?: string;
    State?: string;
  };
  declare type AutoScaling$20110101$LoadBalancerTargetGroupStates = AutoScaling$20110101$LoadBalancerTargetGroupState[];
  declare type AutoScaling$20110101$MetricCollectionType = {
    Metric?: string;
  };
  declare type AutoScaling$20110101$MetricCollectionTypes = AutoScaling$20110101$MetricCollectionType[];
  declare type AutoScaling$20110101$MetricGranularityType = {
    Granularity?: string;
  };
  declare type AutoScaling$20110101$MetricGranularityTypes = AutoScaling$20110101$MetricGranularityType[];
  declare type AutoScaling$20110101$Metrics = string[];
  declare type AutoScaling$20110101$NotificationConfiguration = {
    AutoScalingGroupName?: string;
    TopicARN?: string;
    NotificationType?: string;
  };
  declare type AutoScaling$20110101$NotificationConfigurations = AutoScaling$20110101$NotificationConfiguration[];
  declare type AutoScaling$20110101$PoliciesType = {
    ScalingPolicies?: AutoScaling$20110101$ScalingPolicies;
    NextToken?: string;
  };
  declare type AutoScaling$20110101$PolicyARNType = {
    PolicyARN?: string;
  };
  declare type AutoScaling$20110101$PolicyNames = string[];
  declare type AutoScaling$20110101$PolicyTypes = string[];
  declare type AutoScaling$20110101$ProcessNames = string[];
  declare type AutoScaling$20110101$ProcessType = {
    ProcessName: string;
  };
  declare type AutoScaling$20110101$Processes = AutoScaling$20110101$ProcessType[];
  declare type AutoScaling$20110101$ProcessesType = {
    Processes?: AutoScaling$20110101$Processes;
  };
  declare type AutoScaling$20110101$PutLifecycleHookAnswer = {};
  declare type AutoScaling$20110101$PutLifecycleHookType = {
    LifecycleHookName: string;
    AutoScalingGroupName: string;
    LifecycleTransition?: string;
    RoleARN?: string;
    NotificationTargetARN?: string;
    NotificationMetadata?: string;
    HeartbeatTimeout?: number;
    DefaultResult?: string;
  };
  declare type AutoScaling$20110101$PutNotificationConfigurationType = {
    AutoScalingGroupName: string;
    TopicARN: string;
    NotificationTypes: AutoScaling$20110101$AutoScalingNotificationTypes;
  };
  declare type AutoScaling$20110101$PutScalingPolicyType = {
    AutoScalingGroupName: string;
    PolicyName: string;
    PolicyType?: string;
    AdjustmentType: string;
    MinAdjustmentStep?: number;
    MinAdjustmentMagnitude?: number;
    ScalingAdjustment?: number;
    Cooldown?: number;
    MetricAggregationType?: string;
    StepAdjustments?: AutoScaling$20110101$StepAdjustments;
    EstimatedInstanceWarmup?: number;
  };
  declare type AutoScaling$20110101$PutScheduledUpdateGroupActionType = {
    AutoScalingGroupName: string;
    ScheduledActionName: string;
    Time?: Date;
    StartTime?: Date;
    EndTime?: Date;
    Recurrence?: string;
    MinSize?: number;
    MaxSize?: number;
    DesiredCapacity?: number;
  };
  declare type AutoScaling$20110101$RecordLifecycleActionHeartbeatAnswer = {};
  declare type AutoScaling$20110101$RecordLifecycleActionHeartbeatType = {
    LifecycleHookName: string;
    AutoScalingGroupName: string;
    LifecycleActionToken?: string;
    InstanceId?: string;
  };
  declare type AutoScaling$20110101$ResourceContentionFault = {
    message?: string;
  };
  declare type AutoScaling$20110101$ResourceInUseFault = {
    message?: string;
  };
  declare type AutoScaling$20110101$ScalingActivityInProgressFault = {
    message?: string;
  };
  declare type AutoScaling$20110101$ScalingActivityStatusCode = 'PendingSpotBidPlacement' | 'WaitingForSpotInstanceRequestId' | 'WaitingForSpotInstanceId' | 'WaitingForInstanceId' | 'PreInService' | 'InProgress' | 'WaitingForELBConnectionDraining' | 'MidLifecycleAction' | 'WaitingForInstanceWarmup' | 'Successful' | 'Failed' | 'Cancelled';
  declare type AutoScaling$20110101$ScalingPolicies = AutoScaling$20110101$ScalingPolicy[];
  declare type AutoScaling$20110101$ScalingPolicy = {
    AutoScalingGroupName?: string;
    PolicyName?: string;
    PolicyARN?: string;
    PolicyType?: string;
    AdjustmentType?: string;
    MinAdjustmentStep?: number;
    MinAdjustmentMagnitude?: number;
    ScalingAdjustment?: number;
    Cooldown?: number;
    StepAdjustments?: AutoScaling$20110101$StepAdjustments;
    MetricAggregationType?: string;
    EstimatedInstanceWarmup?: number;
    Alarms?: AutoScaling$20110101$Alarms;
  };
  declare type AutoScaling$20110101$ScalingProcessQuery = {
    AutoScalingGroupName: string;
    ScalingProcesses?: AutoScaling$20110101$ProcessNames;
  };
  declare type AutoScaling$20110101$ScheduledActionNames = string[];
  declare type AutoScaling$20110101$ScheduledActionsType = {
    ScheduledUpdateGroupActions?: AutoScaling$20110101$ScheduledUpdateGroupActions;
    NextToken?: string;
  };
  declare type AutoScaling$20110101$ScheduledUpdateGroupAction = {
    AutoScalingGroupName?: string;
    ScheduledActionName?: string;
    ScheduledActionARN?: string;
    Time?: Date;
    StartTime?: Date;
    EndTime?: Date;
    Recurrence?: string;
    MinSize?: number;
    MaxSize?: number;
    DesiredCapacity?: number;
  };
  declare type AutoScaling$20110101$ScheduledUpdateGroupActions = AutoScaling$20110101$ScheduledUpdateGroupAction[];
  declare type AutoScaling$20110101$SecurityGroups = string[];
  declare type AutoScaling$20110101$SetDesiredCapacityType = {
    AutoScalingGroupName: string;
    DesiredCapacity: number;
    HonorCooldown?: boolean;
  };
  declare type AutoScaling$20110101$SetInstanceHealthQuery = {
    InstanceId: string;
    HealthStatus: string;
    ShouldRespectGracePeriod?: boolean;
  };
  declare type AutoScaling$20110101$SetInstanceProtectionAnswer = {};
  declare type AutoScaling$20110101$SetInstanceProtectionQuery = {
    InstanceIds: AutoScaling$20110101$InstanceIds;
    AutoScalingGroupName: string;
    ProtectedFromScaleIn: boolean;
  };
  declare type AutoScaling$20110101$StepAdjustment = {
    MetricIntervalLowerBound?: number;
    MetricIntervalUpperBound?: number;
    ScalingAdjustment: number;
  };
  declare type AutoScaling$20110101$StepAdjustments = AutoScaling$20110101$StepAdjustment[];
  declare type AutoScaling$20110101$SuspendedProcess = {
    ProcessName?: string;
    SuspensionReason?: string;
  };
  declare type AutoScaling$20110101$SuspendedProcesses = AutoScaling$20110101$SuspendedProcess[];
  declare type AutoScaling$20110101$Tag = {
    ResourceId?: string;
    ResourceType?: string;
    Key: string;
    Value?: string;
    PropagateAtLaunch?: boolean;
  };
  declare type AutoScaling$20110101$TagDescription = {
    ResourceId?: string;
    ResourceType?: string;
    Key?: string;
    Value?: string;
    PropagateAtLaunch?: boolean;
  };
  declare type AutoScaling$20110101$TagDescriptionList = AutoScaling$20110101$TagDescription[];
  declare type AutoScaling$20110101$Tags = AutoScaling$20110101$Tag[];
  declare type AutoScaling$20110101$TagsType = {
    Tags?: AutoScaling$20110101$TagDescriptionList;
    NextToken?: string;
  };
  declare type AutoScaling$20110101$TargetGroupARNs = string[];
  declare type AutoScaling$20110101$TerminateInstanceInAutoScalingGroupType = {
    InstanceId: string;
    ShouldDecrementDesiredCapacity: boolean;
  };
  declare type AutoScaling$20110101$TerminationPolicies = string[];
  declare type AutoScaling$20110101$TimestampType = Date;
  declare type AutoScaling$20110101$UpdateAutoScalingGroupType = {
    AutoScalingGroupName: string;
    LaunchConfigurationName?: string;
    MinSize?: number;
    MaxSize?: number;
    DesiredCapacity?: number;
    DefaultCooldown?: number;
    AvailabilityZones?: AutoScaling$20110101$AvailabilityZones;
    HealthCheckType?: string;
    HealthCheckGracePeriod?: number;
    PlacementGroup?: string;
    VPCZoneIdentifier?: string;
    TerminationPolicies?: AutoScaling$20110101$TerminationPolicies;
    NewInstancesProtectedFromScaleIn?: boolean;
  };
  declare type AutoScaling$20110101$Values = string[];
  declare type CloudFormation$20100515$AccountLimit = {
    Name?: string;
    Value?: number;
  };
  declare type CloudFormation$20100515$AccountLimitList = CloudFormation$20100515$AccountLimit[];
  declare type CloudFormation$20100515$AllowedValues = string[];
  declare type CloudFormation$20100515$AlreadyExistsException = {};
  declare type CloudFormation$20100515$CancelUpdateStackInput = {
    StackName: string;
  };
  declare type CloudFormation$20100515$Capabilities = ('CAPABILITY_IAM' | 'CAPABILITY_NAMED_IAM')[];
  declare type CloudFormation$20100515$Capability = 'CAPABILITY_IAM' | 'CAPABILITY_NAMED_IAM';
  declare type CloudFormation$20100515$Change = {
    Type?: 'Resource';
    ResourceChange?: CloudFormation$20100515$ResourceChange;
  };
  declare type CloudFormation$20100515$ChangeAction = 'Add' | 'Modify' | 'Remove';
  declare type CloudFormation$20100515$ChangeSetNotFoundException = {};
  declare type CloudFormation$20100515$ChangeSetStatus = 'CREATE_PENDING' | 'CREATE_IN_PROGRESS' | 'CREATE_COMPLETE' | 'DELETE_COMPLETE' | 'FAILED';
  declare type CloudFormation$20100515$ChangeSetSummaries = CloudFormation$20100515$ChangeSetSummary[];
  declare type CloudFormation$20100515$ChangeSetSummary = {
    StackId?: string;
    StackName?: string;
    ChangeSetId?: string;
    ChangeSetName?: string;
    ExecutionStatus?: 'UNAVAILABLE' | 'AVAILABLE' | 'EXECUTE_IN_PROGRESS' | 'EXECUTE_COMPLETE' | 'EXECUTE_FAILED' | 'OBSOLETE';
    Status?: 'CREATE_PENDING' | 'CREATE_IN_PROGRESS' | 'CREATE_COMPLETE' | 'DELETE_COMPLETE' | 'FAILED';
    StatusReason?: string;
    CreationTime?: Date;
    Description?: string;
  };
  declare type CloudFormation$20100515$ChangeSource = 'ResourceReference' | 'ParameterReference' | 'ResourceAttribute' | 'DirectModification' | 'Automatic';
  declare type CloudFormation$20100515$ChangeType = 'Resource';
  declare type CloudFormation$20100515$Changes = CloudFormation$20100515$Change[];
  declare type CloudFormation$20100515$ContinueUpdateRollbackInput = {
    StackName: string;
  };
  declare type CloudFormation$20100515$ContinueUpdateRollbackOutput = {};
  declare type CloudFormation$20100515$CreateChangeSetInput = {
    StackName: string;
    TemplateBody?: string;
    TemplateURL?: string;
    UsePreviousTemplate?: boolean;
    Parameters?: CloudFormation$20100515$Parameters;
    Capabilities?: CloudFormation$20100515$Capabilities;
    ResourceTypes?: CloudFormation$20100515$ResourceTypes;
    NotificationARNs?: CloudFormation$20100515$NotificationARNs;
    Tags?: CloudFormation$20100515$Tags;
    ChangeSetName: string;
    ClientToken?: string;
    Description?: string;
  };
  declare type CloudFormation$20100515$CreateChangeSetOutput = {
    Id?: string;
  };
  declare type CloudFormation$20100515$CreateStackInput = {
    StackName: string;
    TemplateBody?: string;
    TemplateURL?: string;
    Parameters?: CloudFormation$20100515$Parameters;
    DisableRollback?: boolean;
    TimeoutInMinutes?: number;
    NotificationARNs?: CloudFormation$20100515$NotificationARNs;
    Capabilities?: CloudFormation$20100515$Capabilities;
    ResourceTypes?: CloudFormation$20100515$ResourceTypes;
    OnFailure?: 'DO_NOTHING' | 'ROLLBACK' | 'DELETE';
    StackPolicyBody?: string;
    StackPolicyURL?: string;
    Tags?: CloudFormation$20100515$Tags;
  };
  declare type CloudFormation$20100515$CreateStackOutput = {
    StackId?: string;
  };
  declare type CloudFormation$20100515$CreationTime = Date;
  declare type CloudFormation$20100515$DeleteChangeSetInput = {
    ChangeSetName: string;
    StackName?: string;
  };
  declare type CloudFormation$20100515$DeleteChangeSetOutput = {};
  declare type CloudFormation$20100515$DeleteStackInput = {
    StackName: string;
    RetainResources?: CloudFormation$20100515$RetainResources;
  };
  declare type CloudFormation$20100515$DeletionTime = Date;
  declare type CloudFormation$20100515$DescribeAccountLimitsInput = {
    NextToken?: string;
  };
  declare type CloudFormation$20100515$DescribeAccountLimitsOutput = {
    AccountLimits?: CloudFormation$20100515$AccountLimitList;
    NextToken?: string;
  };
  declare type CloudFormation$20100515$DescribeChangeSetInput = {
    ChangeSetName: string;
    StackName?: string;
    NextToken?: string;
  };
  declare type CloudFormation$20100515$DescribeChangeSetOutput = {
    ChangeSetName?: string;
    ChangeSetId?: string;
    StackId?: string;
    StackName?: string;
    Description?: string;
    Parameters?: CloudFormation$20100515$Parameters;
    CreationTime?: Date;
    ExecutionStatus?: 'UNAVAILABLE' | 'AVAILABLE' | 'EXECUTE_IN_PROGRESS' | 'EXECUTE_COMPLETE' | 'EXECUTE_FAILED' | 'OBSOLETE';
    Status?: 'CREATE_PENDING' | 'CREATE_IN_PROGRESS' | 'CREATE_COMPLETE' | 'DELETE_COMPLETE' | 'FAILED';
    StatusReason?: string;
    NotificationARNs?: CloudFormation$20100515$NotificationARNs;
    Capabilities?: CloudFormation$20100515$Capabilities;
    Tags?: CloudFormation$20100515$Tags;
    Changes?: CloudFormation$20100515$Changes;
    NextToken?: string;
  };
  declare type CloudFormation$20100515$DescribeStackEventsInput = {
    StackName?: string;
    NextToken?: string;
  };
  declare type CloudFormation$20100515$DescribeStackEventsOutput = {
    StackEvents?: CloudFormation$20100515$StackEvents;
    NextToken?: string;
  };
  declare type CloudFormation$20100515$DescribeStackResourceInput = {
    StackName: string;
    LogicalResourceId: string;
  };
  declare type CloudFormation$20100515$DescribeStackResourceOutput = {
    StackResourceDetail?: CloudFormation$20100515$StackResourceDetail;
  };
  declare type CloudFormation$20100515$DescribeStackResourcesInput = {
    StackName?: string;
    LogicalResourceId?: string;
    PhysicalResourceId?: string;
  };
  declare type CloudFormation$20100515$DescribeStackResourcesOutput = {
    StackResources?: CloudFormation$20100515$StackResources;
  };
  declare type CloudFormation$20100515$DescribeStacksInput = {
    StackName?: string;
    NextToken?: string;
  };
  declare type CloudFormation$20100515$DescribeStacksOutput = {
    Stacks?: CloudFormation$20100515$Stacks;
    NextToken?: string;
  };
  declare type CloudFormation$20100515$EstimateTemplateCostInput = {
    TemplateBody?: string;
    TemplateURL?: string;
    Parameters?: CloudFormation$20100515$Parameters;
  };
  declare type CloudFormation$20100515$EstimateTemplateCostOutput = {
    Url?: string;
  };
  declare type CloudFormation$20100515$EvaluationType = 'Static' | 'Dynamic';
  declare type CloudFormation$20100515$ExecuteChangeSetInput = {
    ChangeSetName: string;
    StackName?: string;
  };
  declare type CloudFormation$20100515$ExecuteChangeSetOutput = {};
  declare type CloudFormation$20100515$ExecutionStatus = 'UNAVAILABLE' | 'AVAILABLE' | 'EXECUTE_IN_PROGRESS' | 'EXECUTE_COMPLETE' | 'EXECUTE_FAILED' | 'OBSOLETE';
  declare type CloudFormation$20100515$GetStackPolicyInput = {
    StackName: string;
  };
  declare type CloudFormation$20100515$GetStackPolicyOutput = {
    StackPolicyBody?: string;
  };
  declare type CloudFormation$20100515$GetTemplateInput = {
    StackName: string;
  };
  declare type CloudFormation$20100515$GetTemplateOutput = {
    TemplateBody?: string;
  };
  declare type CloudFormation$20100515$GetTemplateSummaryInput = {
    TemplateBody?: string;
    TemplateURL?: string;
    StackName?: string;
  };
  declare type CloudFormation$20100515$GetTemplateSummaryOutput = {
    Parameters?: CloudFormation$20100515$ParameterDeclarations;
    Description?: string;
    Capabilities?: CloudFormation$20100515$Capabilities;
    CapabilitiesReason?: string;
    ResourceTypes?: CloudFormation$20100515$ResourceTypes;
    Version?: string;
    Metadata?: string;
  };
  declare type CloudFormation$20100515$InsufficientCapabilitiesException = {};
  declare type CloudFormation$20100515$InvalidChangeSetStatusException = {};
  declare type CloudFormation$20100515$LastUpdatedTime = Date;
  declare type CloudFormation$20100515$LimitExceededException = {};
  declare type CloudFormation$20100515$ListChangeSetsInput = {
    StackName: string;
    NextToken?: string;
  };
  declare type CloudFormation$20100515$ListChangeSetsOutput = {
    Summaries?: CloudFormation$20100515$ChangeSetSummaries;
    NextToken?: string;
  };
  declare type CloudFormation$20100515$ListStackResourcesInput = {
    StackName: string;
    NextToken?: string;
  };
  declare type CloudFormation$20100515$ListStackResourcesOutput = {
    StackResourceSummaries?: CloudFormation$20100515$StackResourceSummaries;
    NextToken?: string;
  };
  declare type CloudFormation$20100515$ListStacksInput = {
    NextToken?: string;
    StackStatusFilter?: CloudFormation$20100515$StackStatusFilter;
  };
  declare type CloudFormation$20100515$ListStacksOutput = {
    StackSummaries?: CloudFormation$20100515$StackSummaries;
    NextToken?: string;
  };
  declare type CloudFormation$20100515$NotificationARNs = string[];
  declare type CloudFormation$20100515$OnFailure = 'DO_NOTHING' | 'ROLLBACK' | 'DELETE';
  declare type CloudFormation$20100515$Output = {
    OutputKey?: string;
    OutputValue?: string;
    Description?: string;
  };
  declare type CloudFormation$20100515$Outputs = CloudFormation$20100515$Output[];
  declare type CloudFormation$20100515$Parameter = {
    ParameterKey?: string;
    ParameterValue?: string;
    UsePreviousValue?: boolean;
  };
  declare type CloudFormation$20100515$ParameterConstraints = {
    AllowedValues?: CloudFormation$20100515$AllowedValues;
  };
  declare type CloudFormation$20100515$ParameterDeclaration = {
    ParameterKey?: string;
    DefaultValue?: string;
    ParameterType?: string;
    NoEcho?: boolean;
    Description?: string;
    ParameterConstraints?: CloudFormation$20100515$ParameterConstraints;
  };
  declare type CloudFormation$20100515$ParameterDeclarations = CloudFormation$20100515$ParameterDeclaration[];
  declare type CloudFormation$20100515$Parameters = CloudFormation$20100515$Parameter[];
  declare type CloudFormation$20100515$Replacement = 'True' | 'False' | 'Conditional';
  declare type CloudFormation$20100515$RequiresRecreation = 'Never' | 'Conditionally' | 'Always';
  declare type CloudFormation$20100515$ResourceAttribute = 'Properties' | 'Metadata' | 'CreationPolicy' | 'UpdatePolicy' | 'DeletionPolicy' | 'Tags';
  declare type CloudFormation$20100515$ResourceChange = {
    Action?: 'Add' | 'Modify' | 'Remove';
    LogicalResourceId?: string;
    PhysicalResourceId?: string;
    ResourceType?: string;
    Replacement?: 'True' | 'False' | 'Conditional';
    Scope?: CloudFormation$20100515$Scope;
    Details?: CloudFormation$20100515$ResourceChangeDetails;
  };
  declare type CloudFormation$20100515$ResourceChangeDetail = {
    Target?: CloudFormation$20100515$ResourceTargetDefinition;
    Evaluation?: 'Static' | 'Dynamic';
    ChangeSource?: 'ResourceReference' | 'ParameterReference' | 'ResourceAttribute' | 'DirectModification' | 'Automatic';
    CausingEntity?: string;
  };
  declare type CloudFormation$20100515$ResourceChangeDetails = CloudFormation$20100515$ResourceChangeDetail[];
  declare type CloudFormation$20100515$ResourceSignalStatus = 'SUCCESS' | 'FAILURE';
  declare type CloudFormation$20100515$ResourceStatus = 'CREATE_IN_PROGRESS' | 'CREATE_FAILED' | 'CREATE_COMPLETE' | 'DELETE_IN_PROGRESS' | 'DELETE_FAILED' | 'DELETE_COMPLETE' | 'DELETE_SKIPPED' | 'UPDATE_IN_PROGRESS' | 'UPDATE_FAILED' | 'UPDATE_COMPLETE';
  declare type CloudFormation$20100515$ResourceTargetDefinition = {
    Attribute?: 'Properties' | 'Metadata' | 'CreationPolicy' | 'UpdatePolicy' | 'DeletionPolicy' | 'Tags';
    Name?: string;
    RequiresRecreation?: 'Never' | 'Conditionally' | 'Always';
  };
  declare type CloudFormation$20100515$ResourceTypes = string[];
  declare type CloudFormation$20100515$RetainResources = string[];
  declare type CloudFormation$20100515$Scope = ('Properties' | 'Metadata' | 'CreationPolicy' | 'UpdatePolicy' | 'DeletionPolicy' | 'Tags')[];
  declare type CloudFormation$20100515$SetStackPolicyInput = {
    StackName: string;
    StackPolicyBody?: string;
    StackPolicyURL?: string;
  };
  declare type CloudFormation$20100515$SignalResourceInput = {
    StackName: string;
    LogicalResourceId: string;
    UniqueId: string;
    Status: 'SUCCESS' | 'FAILURE';
  };
  declare type CloudFormation$20100515$Stack = {
    StackId?: string;
    StackName: string;
    Description?: string;
    Parameters?: CloudFormation$20100515$Parameters;
    CreationTime: Date;
    LastUpdatedTime?: Date;
    StackStatus: 'CREATE_IN_PROGRESS' | 'CREATE_FAILED' | 'CREATE_COMPLETE' | 'ROLLBACK_IN_PROGRESS' | 'ROLLBACK_FAILED' | 'ROLLBACK_COMPLETE' | 'DELETE_IN_PROGRESS' | 'DELETE_FAILED' | 'DELETE_COMPLETE' | 'UPDATE_IN_PROGRESS' | 'UPDATE_COMPLETE_CLEANUP_IN_PROGRESS' | 'UPDATE_COMPLETE' | 'UPDATE_ROLLBACK_IN_PROGRESS' | 'UPDATE_ROLLBACK_FAILED' | 'UPDATE_ROLLBACK_COMPLETE_CLEANUP_IN_PROGRESS' | 'UPDATE_ROLLBACK_COMPLETE';
    StackStatusReason?: string;
    DisableRollback?: boolean;
    NotificationARNs?: CloudFormation$20100515$NotificationARNs;
    TimeoutInMinutes?: number;
    Capabilities?: CloudFormation$20100515$Capabilities;
    Outputs?: CloudFormation$20100515$Outputs;
    Tags?: CloudFormation$20100515$Tags;
  };
  declare type CloudFormation$20100515$StackEvent = {
    StackId: string;
    EventId: string;
    StackName: string;
    LogicalResourceId?: string;
    PhysicalResourceId?: string;
    ResourceType?: string;
    Timestamp: Date;
    ResourceStatus?: 'CREATE_IN_PROGRESS' | 'CREATE_FAILED' | 'CREATE_COMPLETE' | 'DELETE_IN_PROGRESS' | 'DELETE_FAILED' | 'DELETE_COMPLETE' | 'DELETE_SKIPPED' | 'UPDATE_IN_PROGRESS' | 'UPDATE_FAILED' | 'UPDATE_COMPLETE';
    ResourceStatusReason?: string;
    ResourceProperties?: string;
  };
  declare type CloudFormation$20100515$StackEvents = CloudFormation$20100515$StackEvent[];
  declare type CloudFormation$20100515$StackResource = {
    StackName?: string;
    StackId?: string;
    LogicalResourceId: string;
    PhysicalResourceId?: string;
    ResourceType: string;
    Timestamp: Date;
    ResourceStatus: 'CREATE_IN_PROGRESS' | 'CREATE_FAILED' | 'CREATE_COMPLETE' | 'DELETE_IN_PROGRESS' | 'DELETE_FAILED' | 'DELETE_COMPLETE' | 'DELETE_SKIPPED' | 'UPDATE_IN_PROGRESS' | 'UPDATE_FAILED' | 'UPDATE_COMPLETE';
    ResourceStatusReason?: string;
    Description?: string;
  };
  declare type CloudFormation$20100515$StackResourceDetail = {
    StackName?: string;
    StackId?: string;
    LogicalResourceId: string;
    PhysicalResourceId?: string;
    ResourceType: string;
    LastUpdatedTimestamp: Date;
    ResourceStatus: 'CREATE_IN_PROGRESS' | 'CREATE_FAILED' | 'CREATE_COMPLETE' | 'DELETE_IN_PROGRESS' | 'DELETE_FAILED' | 'DELETE_COMPLETE' | 'DELETE_SKIPPED' | 'UPDATE_IN_PROGRESS' | 'UPDATE_FAILED' | 'UPDATE_COMPLETE';
    ResourceStatusReason?: string;
    Description?: string;
    Metadata?: string;
  };
  declare type CloudFormation$20100515$StackResourceSummaries = CloudFormation$20100515$StackResourceSummary[];
  declare type CloudFormation$20100515$StackResourceSummary = {
    LogicalResourceId: string;
    PhysicalResourceId?: string;
    ResourceType: string;
    LastUpdatedTimestamp: Date;
    ResourceStatus: 'CREATE_IN_PROGRESS' | 'CREATE_FAILED' | 'CREATE_COMPLETE' | 'DELETE_IN_PROGRESS' | 'DELETE_FAILED' | 'DELETE_COMPLETE' | 'DELETE_SKIPPED' | 'UPDATE_IN_PROGRESS' | 'UPDATE_FAILED' | 'UPDATE_COMPLETE';
    ResourceStatusReason?: string;
  };
  declare type CloudFormation$20100515$StackResources = CloudFormation$20100515$StackResource[];
  declare type CloudFormation$20100515$StackStatus = 'CREATE_IN_PROGRESS' | 'CREATE_FAILED' | 'CREATE_COMPLETE' | 'ROLLBACK_IN_PROGRESS' | 'ROLLBACK_FAILED' | 'ROLLBACK_COMPLETE' | 'DELETE_IN_PROGRESS' | 'DELETE_FAILED' | 'DELETE_COMPLETE' | 'UPDATE_IN_PROGRESS' | 'UPDATE_COMPLETE_CLEANUP_IN_PROGRESS' | 'UPDATE_COMPLETE' | 'UPDATE_ROLLBACK_IN_PROGRESS' | 'UPDATE_ROLLBACK_FAILED' | 'UPDATE_ROLLBACK_COMPLETE_CLEANUP_IN_PROGRESS' | 'UPDATE_ROLLBACK_COMPLETE';
  declare type CloudFormation$20100515$StackStatusFilter = ('CREATE_IN_PROGRESS' | 'CREATE_FAILED' | 'CREATE_COMPLETE' | 'ROLLBACK_IN_PROGRESS' | 'ROLLBACK_FAILED' | 'ROLLBACK_COMPLETE' | 'DELETE_IN_PROGRESS' | 'DELETE_FAILED' | 'DELETE_COMPLETE' | 'UPDATE_IN_PROGRESS' | 'UPDATE_COMPLETE_CLEANUP_IN_PROGRESS' | 'UPDATE_COMPLETE' | 'UPDATE_ROLLBACK_IN_PROGRESS' | 'UPDATE_ROLLBACK_FAILED' | 'UPDATE_ROLLBACK_COMPLETE_CLEANUP_IN_PROGRESS' | 'UPDATE_ROLLBACK_COMPLETE')[];
  declare type CloudFormation$20100515$StackSummaries = CloudFormation$20100515$StackSummary[];
  declare type CloudFormation$20100515$StackSummary = {
    StackId?: string;
    StackName: string;
    TemplateDescription?: string;
    CreationTime: Date;
    LastUpdatedTime?: Date;
    DeletionTime?: Date;
    StackStatus: 'CREATE_IN_PROGRESS' | 'CREATE_FAILED' | 'CREATE_COMPLETE' | 'ROLLBACK_IN_PROGRESS' | 'ROLLBACK_FAILED' | 'ROLLBACK_COMPLETE' | 'DELETE_IN_PROGRESS' | 'DELETE_FAILED' | 'DELETE_COMPLETE' | 'UPDATE_IN_PROGRESS' | 'UPDATE_COMPLETE_CLEANUP_IN_PROGRESS' | 'UPDATE_COMPLETE' | 'UPDATE_ROLLBACK_IN_PROGRESS' | 'UPDATE_ROLLBACK_FAILED' | 'UPDATE_ROLLBACK_COMPLETE_CLEANUP_IN_PROGRESS' | 'UPDATE_ROLLBACK_COMPLETE';
    StackStatusReason?: string;
  };
  declare type CloudFormation$20100515$Stacks = CloudFormation$20100515$Stack[];
  declare type CloudFormation$20100515$Tag = {
    Key?: string;
    Value?: string;
  };
  declare type CloudFormation$20100515$Tags = CloudFormation$20100515$Tag[];
  declare type CloudFormation$20100515$TemplateParameter = {
    ParameterKey?: string;
    DefaultValue?: string;
    NoEcho?: boolean;
    Description?: string;
  };
  declare type CloudFormation$20100515$TemplateParameters = CloudFormation$20100515$TemplateParameter[];
  declare type CloudFormation$20100515$Timestamp = Date;
  declare type CloudFormation$20100515$UpdateStackInput = {
    StackName: string;
    TemplateBody?: string;
    TemplateURL?: string;
    UsePreviousTemplate?: boolean;
    StackPolicyDuringUpdateBody?: string;
    StackPolicyDuringUpdateURL?: string;
    Parameters?: CloudFormation$20100515$Parameters;
    Capabilities?: CloudFormation$20100515$Capabilities;
    ResourceTypes?: CloudFormation$20100515$ResourceTypes;
    StackPolicyBody?: string;
    StackPolicyURL?: string;
    NotificationARNs?: CloudFormation$20100515$NotificationARNs;
    Tags?: CloudFormation$20100515$Tags;
  };
  declare type CloudFormation$20100515$UpdateStackOutput = {
    StackId?: string;
  };
  declare type CloudFormation$20100515$ValidateTemplateInput = {
    TemplateBody?: string;
    TemplateURL?: string;
  };
  declare type CloudFormation$20100515$ValidateTemplateOutput = {
    Parameters?: CloudFormation$20100515$TemplateParameters;
    Description?: string;
    Capabilities?: CloudFormation$20100515$Capabilities;
    CapabilitiesReason?: string;
  };
  declare type CloudFront$20160801$AccessDenied = {
    Message?: string;
  };
  declare type CloudFront$20160801$ActiveTrustedSigners = {
    Enabled: boolean;
    Quantity: number;
    Items?: CloudFront$20160801$SignerList;
  };
  declare type CloudFront$20160801$AliasList = string[];
  declare type CloudFront$20160801$Aliases = {
    Quantity: number;
    Items?: CloudFront$20160801$AliasList;
  };
  declare type CloudFront$20160801$AllowedMethods = {
    Quantity: number;
    Items: CloudFront$20160801$MethodsList;
    CachedMethods?: CloudFront$20160801$CachedMethods;
  };
  declare type CloudFront$20160801$AwsAccountNumberList = string[];
  declare type CloudFront$20160801$BatchTooLarge = {
    Message?: string;
  };
  declare type CloudFront$20160801$CNAMEAlreadyExists = {
    Message?: string;
  };
  declare type CloudFront$20160801$CacheBehavior = {
    PathPattern: string;
    TargetOriginId: string;
    ForwardedValues: CloudFront$20160801$ForwardedValues;
    TrustedSigners: CloudFront$20160801$TrustedSigners;
    ViewerProtocolPolicy: 'allow-all' | 'https-only' | 'redirect-to-https';
    MinTTL: number;
    AllowedMethods?: CloudFront$20160801$AllowedMethods;
    SmoothStreaming?: boolean;
    DefaultTTL?: number;
    MaxTTL?: number;
    Compress?: boolean;
  };
  declare type CloudFront$20160801$CacheBehaviorList = CloudFront$20160801$CacheBehavior[];
  declare type CloudFront$20160801$CacheBehaviors = {
    Quantity: number;
    Items?: CloudFront$20160801$CacheBehaviorList;
  };
  declare type CloudFront$20160801$CachedMethods = {
    Quantity: number;
    Items: CloudFront$20160801$MethodsList;
  };
  declare type CloudFront$20160801$CertificateSource = 'cloudfront' | 'iam' | 'acm';
  declare type CloudFront$20160801$CloudFrontOriginAccessIdentity = {
    Id: string;
    S3CanonicalUserId: string;
    CloudFrontOriginAccessIdentityConfig?: CloudFront$20160801$CloudFrontOriginAccessIdentityConfig;
  };
  declare type CloudFront$20160801$CloudFrontOriginAccessIdentityAlreadyExists = {
    Message?: string;
  };
  declare type CloudFront$20160801$CloudFrontOriginAccessIdentityConfig = {
    CallerReference: string;
    Comment: string;
  };
  declare type CloudFront$20160801$CloudFrontOriginAccessIdentityInUse = {
    Message?: string;
  };
  declare type CloudFront$20160801$CloudFrontOriginAccessIdentityList = {
    Marker: string;
    NextMarker?: string;
    MaxItems: number;
    IsTruncated: boolean;
    Quantity: number;
    Items?: CloudFront$20160801$CloudFrontOriginAccessIdentitySummaryList;
  };
  declare type CloudFront$20160801$CloudFrontOriginAccessIdentitySummary = {
    Id: string;
    S3CanonicalUserId: string;
    Comment: string;
  };
  declare type CloudFront$20160801$CloudFrontOriginAccessIdentitySummaryList = CloudFront$20160801$CloudFrontOriginAccessIdentitySummary[];
  declare type CloudFront$20160801$CookieNameList = string[];
  declare type CloudFront$20160801$CookieNames = {
    Quantity: number;
    Items?: CloudFront$20160801$CookieNameList;
  };
  declare type CloudFront$20160801$CookiePreference = {
    Forward: 'none' | 'whitelist' | 'all';
    WhitelistedNames?: CloudFront$20160801$CookieNames;
  };
  declare type CloudFront$20160801$CreateCloudFrontOriginAccessIdentityRequest = {
    CloudFrontOriginAccessIdentityConfig: CloudFront$20160801$CloudFrontOriginAccessIdentityConfig;
  };
  declare type CloudFront$20160801$CreateCloudFrontOriginAccessIdentityResult = {
    CloudFrontOriginAccessIdentity?: CloudFront$20160801$CloudFrontOriginAccessIdentity;
    Location?: string;
    ETag?: string;
  };
  declare type CloudFront$20160801$CreateDistributionRequest = {
    DistributionConfig: CloudFront$20160801$DistributionConfig;
  };
  declare type CloudFront$20160801$CreateDistributionResult = {
    Distribution?: CloudFront$20160801$Distribution;
    Location?: string;
    ETag?: string;
  };
  declare type CloudFront$20160801$CreateDistributionWithTagsRequest = {
    DistributionConfigWithTags: CloudFront$20160801$DistributionConfigWithTags;
  };
  declare type CloudFront$20160801$CreateDistributionWithTagsResult = {
    Distribution?: CloudFront$20160801$Distribution;
    Location?: string;
    ETag?: string;
  };
  declare type CloudFront$20160801$CreateInvalidationRequest = {
    DistributionId: string;
    InvalidationBatch: CloudFront$20160801$InvalidationBatch;
  };
  declare type CloudFront$20160801$CreateInvalidationResult = {
    Location?: string;
    Invalidation?: CloudFront$20160801$Invalidation;
  };
  declare type CloudFront$20160801$CreateStreamingDistributionRequest = {
    StreamingDistributionConfig: CloudFront$20160801$StreamingDistributionConfig;
  };
  declare type CloudFront$20160801$CreateStreamingDistributionResult = {
    StreamingDistribution?: CloudFront$20160801$StreamingDistribution;
    Location?: string;
    ETag?: string;
  };
  declare type CloudFront$20160801$CreateStreamingDistributionWithTagsRequest = {
    StreamingDistributionConfigWithTags: CloudFront$20160801$StreamingDistributionConfigWithTags;
  };
  declare type CloudFront$20160801$CreateStreamingDistributionWithTagsResult = {
    StreamingDistribution?: CloudFront$20160801$StreamingDistribution;
    Location?: string;
    ETag?: string;
  };
  declare type CloudFront$20160801$CustomErrorResponse = {
    ErrorCode: number;
    ResponsePagePath?: string;
    ResponseCode?: string;
    ErrorCachingMinTTL?: number;
  };
  declare type CloudFront$20160801$CustomErrorResponseList = CloudFront$20160801$CustomErrorResponse[];
  declare type CloudFront$20160801$CustomErrorResponses = {
    Quantity: number;
    Items?: CloudFront$20160801$CustomErrorResponseList;
  };
  declare type CloudFront$20160801$CustomHeaders = {
    Quantity: number;
    Items?: CloudFront$20160801$OriginCustomHeadersList;
  };
  declare type CloudFront$20160801$CustomOriginConfig = {
    HTTPPort: number;
    HTTPSPort: number;
    OriginProtocolPolicy: 'http-only' | 'match-viewer' | 'https-only';
    OriginSslProtocols?: CloudFront$20160801$OriginSslProtocols;
  };
  declare type CloudFront$20160801$DefaultCacheBehavior = {
    TargetOriginId: string;
    ForwardedValues: CloudFront$20160801$ForwardedValues;
    TrustedSigners: CloudFront$20160801$TrustedSigners;
    ViewerProtocolPolicy: 'allow-all' | 'https-only' | 'redirect-to-https';
    MinTTL: number;
    AllowedMethods?: CloudFront$20160801$AllowedMethods;
    SmoothStreaming?: boolean;
    DefaultTTL?: number;
    MaxTTL?: number;
    Compress?: boolean;
  };
  declare type CloudFront$20160801$DeleteCloudFrontOriginAccessIdentityRequest = {
    Id: string;
    IfMatch?: string;
  };
  declare type CloudFront$20160801$DeleteDistributionRequest = {
    Id: string;
    IfMatch?: string;
  };
  declare type CloudFront$20160801$DeleteStreamingDistributionRequest = {
    Id: string;
    IfMatch?: string;
  };
  declare type CloudFront$20160801$Distribution = {
    Id: string;
    ARN: string;
    Status: string;
    LastModifiedTime: Date;
    InProgressInvalidationBatches: number;
    DomainName: string;
    ActiveTrustedSigners: CloudFront$20160801$ActiveTrustedSigners;
    DistributionConfig: CloudFront$20160801$DistributionConfig;
  };
  declare type CloudFront$20160801$DistributionAlreadyExists = {
    Message?: string;
  };
  declare type CloudFront$20160801$DistributionConfig = {
    CallerReference: string;
    Aliases?: CloudFront$20160801$Aliases;
    DefaultRootObject?: string;
    Origins: CloudFront$20160801$Origins;
    DefaultCacheBehavior: CloudFront$20160801$DefaultCacheBehavior;
    CacheBehaviors?: CloudFront$20160801$CacheBehaviors;
    CustomErrorResponses?: CloudFront$20160801$CustomErrorResponses;
    Comment: string;
    Logging?: CloudFront$20160801$LoggingConfig;
    PriceClass?: 'PriceClass_100' | 'PriceClass_200' | 'PriceClass_All';
    Enabled: boolean;
    ViewerCertificate?: CloudFront$20160801$ViewerCertificate;
    Restrictions?: CloudFront$20160801$Restrictions;
    WebACLId?: string;
  };
  declare type CloudFront$20160801$DistributionConfigWithTags = {
    DistributionConfig: CloudFront$20160801$DistributionConfig;
    Tags: CloudFront$20160801$Tags;
  };
  declare type CloudFront$20160801$DistributionList = {
    Marker: string;
    NextMarker?: string;
    MaxItems: number;
    IsTruncated: boolean;
    Quantity: number;
    Items?: CloudFront$20160801$DistributionSummaryList;
  };
  declare type CloudFront$20160801$DistributionNotDisabled = {
    Message?: string;
  };
  declare type CloudFront$20160801$DistributionSummary = {
    Id: string;
    ARN: string;
    Status: string;
    LastModifiedTime: Date;
    DomainName: string;
    Aliases: CloudFront$20160801$Aliases;
    Origins: CloudFront$20160801$Origins;
    DefaultCacheBehavior: CloudFront$20160801$DefaultCacheBehavior;
    CacheBehaviors: CloudFront$20160801$CacheBehaviors;
    CustomErrorResponses: CloudFront$20160801$CustomErrorResponses;
    Comment: string;
    PriceClass: 'PriceClass_100' | 'PriceClass_200' | 'PriceClass_All';
    Enabled: boolean;
    ViewerCertificate: CloudFront$20160801$ViewerCertificate;
    Restrictions: CloudFront$20160801$Restrictions;
    WebACLId: string;
  };
  declare type CloudFront$20160801$DistributionSummaryList = CloudFront$20160801$DistributionSummary[];
  declare type CloudFront$20160801$ForwardedValues = {
    QueryString: boolean;
    Cookies: CloudFront$20160801$CookiePreference;
    Headers?: CloudFront$20160801$Headers;
  };
  declare type CloudFront$20160801$GeoRestriction = {
    RestrictionType: 'blacklist' | 'whitelist' | 'none';
    Quantity: number;
    Items?: CloudFront$20160801$LocationList;
  };
  declare type CloudFront$20160801$GeoRestrictionType = 'blacklist' | 'whitelist' | 'none';
  declare type CloudFront$20160801$GetCloudFrontOriginAccessIdentityConfigRequest = {
    Id: string;
  };
  declare type CloudFront$20160801$GetCloudFrontOriginAccessIdentityConfigResult = {
    CloudFrontOriginAccessIdentityConfig?: CloudFront$20160801$CloudFrontOriginAccessIdentityConfig;
    ETag?: string;
  };
  declare type CloudFront$20160801$GetCloudFrontOriginAccessIdentityRequest = {
    Id: string;
  };
  declare type CloudFront$20160801$GetCloudFrontOriginAccessIdentityResult = {
    CloudFrontOriginAccessIdentity?: CloudFront$20160801$CloudFrontOriginAccessIdentity;
    ETag?: string;
  };
  declare type CloudFront$20160801$GetDistributionConfigRequest = {
    Id: string;
  };
  declare type CloudFront$20160801$GetDistributionConfigResult = {
    DistributionConfig?: CloudFront$20160801$DistributionConfig;
    ETag?: string;
  };
  declare type CloudFront$20160801$GetDistributionRequest = {
    Id: string;
  };
  declare type CloudFront$20160801$GetDistributionResult = {
    Distribution?: CloudFront$20160801$Distribution;
    ETag?: string;
  };
  declare type CloudFront$20160801$GetInvalidationRequest = {
    DistributionId: string;
    Id: string;
  };
  declare type CloudFront$20160801$GetInvalidationResult = {
    Invalidation?: CloudFront$20160801$Invalidation;
  };
  declare type CloudFront$20160801$GetStreamingDistributionConfigRequest = {
    Id: string;
  };
  declare type CloudFront$20160801$GetStreamingDistributionConfigResult = {
    StreamingDistributionConfig?: CloudFront$20160801$StreamingDistributionConfig;
    ETag?: string;
  };
  declare type CloudFront$20160801$GetStreamingDistributionRequest = {
    Id: string;
  };
  declare type CloudFront$20160801$GetStreamingDistributionResult = {
    StreamingDistribution?: CloudFront$20160801$StreamingDistribution;
    ETag?: string;
  };
  declare type CloudFront$20160801$HeaderList = string[];
  declare type CloudFront$20160801$Headers = {
    Quantity: number;
    Items?: CloudFront$20160801$HeaderList;
  };
  declare type CloudFront$20160801$IllegalUpdate = {
    Message?: string;
  };
  declare type CloudFront$20160801$InconsistentQuantities = {
    Message?: string;
  };
  declare type CloudFront$20160801$InvalidArgument = {
    Message?: string;
  };
  declare type CloudFront$20160801$InvalidDefaultRootObject = {
    Message?: string;
  };
  declare type CloudFront$20160801$InvalidErrorCode = {
    Message?: string;
  };
  declare type CloudFront$20160801$InvalidForwardCookies = {
    Message?: string;
  };
  declare type CloudFront$20160801$InvalidGeoRestrictionParameter = {
    Message?: string;
  };
  declare type CloudFront$20160801$InvalidHeadersForS3Origin = {
    Message?: string;
  };
  declare type CloudFront$20160801$InvalidIfMatchVersion = {
    Message?: string;
  };
  declare type CloudFront$20160801$InvalidLocationCode = {
    Message?: string;
  };
  declare type CloudFront$20160801$InvalidMinimumProtocolVersion = {
    Message?: string;
  };
  declare type CloudFront$20160801$InvalidOrigin = {
    Message?: string;
  };
  declare type CloudFront$20160801$InvalidOriginAccessIdentity = {
    Message?: string;
  };
  declare type CloudFront$20160801$InvalidProtocolSettings = {
    Message?: string;
  };
  declare type CloudFront$20160801$InvalidRelativePath = {
    Message?: string;
  };
  declare type CloudFront$20160801$InvalidRequiredProtocol = {
    Message?: string;
  };
  declare type CloudFront$20160801$InvalidResponseCode = {
    Message?: string;
  };
  declare type CloudFront$20160801$InvalidTTLOrder = {
    Message?: string;
  };
  declare type CloudFront$20160801$InvalidTagging = {
    Message?: string;
  };
  declare type CloudFront$20160801$InvalidViewerCertificate = {
    Message?: string;
  };
  declare type CloudFront$20160801$InvalidWebACLId = {
    Message?: string;
  };
  declare type CloudFront$20160801$Invalidation = {
    Id: string;
    Status: string;
    CreateTime: Date;
    InvalidationBatch: CloudFront$20160801$InvalidationBatch;
  };
  declare type CloudFront$20160801$InvalidationBatch = {
    Paths: CloudFront$20160801$Paths;
    CallerReference: string;
  };
  declare type CloudFront$20160801$InvalidationList = {
    Marker: string;
    NextMarker?: string;
    MaxItems: number;
    IsTruncated: boolean;
    Quantity: number;
    Items?: CloudFront$20160801$InvalidationSummaryList;
  };
  declare type CloudFront$20160801$InvalidationSummary = {
    Id: string;
    CreateTime: Date;
    Status: string;
  };
  declare type CloudFront$20160801$InvalidationSummaryList = CloudFront$20160801$InvalidationSummary[];
  declare type CloudFront$20160801$ItemSelection = 'none' | 'whitelist' | 'all';
  declare type CloudFront$20160801$KeyPairIdList = string[];
  declare type CloudFront$20160801$KeyPairIds = {
    Quantity: number;
    Items?: CloudFront$20160801$KeyPairIdList;
  };
  declare type CloudFront$20160801$ListCloudFrontOriginAccessIdentitiesRequest = {
    Marker?: string;
    MaxItems?: string;
  };
  declare type CloudFront$20160801$ListCloudFrontOriginAccessIdentitiesResult = {
    CloudFrontOriginAccessIdentityList?: CloudFront$20160801$CloudFrontOriginAccessIdentityList;
  };
  declare type CloudFront$20160801$ListDistributionsByWebACLIdRequest = {
    Marker?: string;
    MaxItems?: string;
    WebACLId: string;
  };
  declare type CloudFront$20160801$ListDistributionsByWebACLIdResult = {
    DistributionList?: CloudFront$20160801$DistributionList;
  };
  declare type CloudFront$20160801$ListDistributionsRequest = {
    Marker?: string;
    MaxItems?: string;
  };
  declare type CloudFront$20160801$ListDistributionsResult = {
    DistributionList?: CloudFront$20160801$DistributionList;
  };
  declare type CloudFront$20160801$ListInvalidationsRequest = {
    DistributionId: string;
    Marker?: string;
    MaxItems?: string;
  };
  declare type CloudFront$20160801$ListInvalidationsResult = {
    InvalidationList?: CloudFront$20160801$InvalidationList;
  };
  declare type CloudFront$20160801$ListStreamingDistributionsRequest = {
    Marker?: string;
    MaxItems?: string;
  };
  declare type CloudFront$20160801$ListStreamingDistributionsResult = {
    StreamingDistributionList?: CloudFront$20160801$StreamingDistributionList;
  };
  declare type CloudFront$20160801$ListTagsForResourceRequest = {
    Resource: string;
  };
  declare type CloudFront$20160801$ListTagsForResourceResult = {
    Tags: CloudFront$20160801$Tags;
  };
  declare type CloudFront$20160801$LocationList = string[];
  declare type CloudFront$20160801$LoggingConfig = {
    Enabled: boolean;
    IncludeCookies: boolean;
    Bucket: string;
    Prefix: string;
  };
  declare type CloudFront$20160801$Method = 'GET' | 'HEAD' | 'POST' | 'PUT' | 'PATCH' | 'OPTIONS' | 'DELETE';
  declare type CloudFront$20160801$MethodsList = ('GET' | 'HEAD' | 'POST' | 'PUT' | 'PATCH' | 'OPTIONS' | 'DELETE')[];
  declare type CloudFront$20160801$MinimumProtocolVersion = 'SSLv3' | 'TLSv1';
  declare type CloudFront$20160801$MissingBody = {
    Message?: string;
  };
  declare type CloudFront$20160801$NoSuchCloudFrontOriginAccessIdentity = {
    Message?: string;
  };
  declare type CloudFront$20160801$NoSuchDistribution = {
    Message?: string;
  };
  declare type CloudFront$20160801$NoSuchInvalidation = {
    Message?: string;
  };
  declare type CloudFront$20160801$NoSuchOrigin = {
    Message?: string;
  };
  declare type CloudFront$20160801$NoSuchResource = {
    Message?: string;
  };
  declare type CloudFront$20160801$NoSuchStreamingDistribution = {
    Message?: string;
  };
  declare type CloudFront$20160801$Origin = {
    Id: string;
    DomainName: string;
    OriginPath?: string;
    CustomHeaders?: CloudFront$20160801$CustomHeaders;
    S3OriginConfig?: CloudFront$20160801$S3OriginConfig;
    CustomOriginConfig?: CloudFront$20160801$CustomOriginConfig;
  };
  declare type CloudFront$20160801$OriginCustomHeader = {
    HeaderName: string;
    HeaderValue: string;
  };
  declare type CloudFront$20160801$OriginCustomHeadersList = CloudFront$20160801$OriginCustomHeader[];
  declare type CloudFront$20160801$OriginList = CloudFront$20160801$Origin[];
  declare type CloudFront$20160801$OriginProtocolPolicy = 'http-only' | 'match-viewer' | 'https-only';
  declare type CloudFront$20160801$OriginSslProtocols = {
    Quantity: number;
    Items: CloudFront$20160801$SslProtocolsList;
  };
  declare type CloudFront$20160801$Origins = {
    Quantity: number;
    Items?: CloudFront$20160801$OriginList;
  };
  declare type CloudFront$20160801$PathList = string[];
  declare type CloudFront$20160801$Paths = {
    Quantity: number;
    Items?: CloudFront$20160801$PathList;
  };
  declare type CloudFront$20160801$PreconditionFailed = {
    Message?: string;
  };
  declare type CloudFront$20160801$PriceClass = 'PriceClass_100' | 'PriceClass_200' | 'PriceClass_All';
  declare type CloudFront$20160801$Restrictions = {
    GeoRestriction: CloudFront$20160801$GeoRestriction;
  };
  declare type CloudFront$20160801$S3Origin = {
    DomainName: string;
    OriginAccessIdentity: string;
  };
  declare type CloudFront$20160801$S3OriginConfig = {
    OriginAccessIdentity: string;
  };
  declare type CloudFront$20160801$SSLSupportMethod = 'sni-only' | 'vip';
  declare type CloudFront$20160801$Signer = {
    AwsAccountNumber?: string;
    KeyPairIds?: CloudFront$20160801$KeyPairIds;
  };
  declare type CloudFront$20160801$SignerList = CloudFront$20160801$Signer[];
  declare type CloudFront$20160801$SslProtocol = 'SSLv3' | 'TLSv1' | 'TLSv1.1' | 'TLSv1.2';
  declare type CloudFront$20160801$SslProtocolsList = ('SSLv3' | 'TLSv1' | 'TLSv1.1' | 'TLSv1.2')[];
  declare type CloudFront$20160801$StreamingDistribution = {
    Id: string;
    ARN: string;
    Status: string;
    LastModifiedTime?: Date;
    DomainName: string;
    ActiveTrustedSigners: CloudFront$20160801$ActiveTrustedSigners;
    StreamingDistributionConfig: CloudFront$20160801$StreamingDistributionConfig;
  };
  declare type CloudFront$20160801$StreamingDistributionAlreadyExists = {
    Message?: string;
  };
  declare type CloudFront$20160801$StreamingDistributionConfig = {
    CallerReference: string;
    S3Origin: CloudFront$20160801$S3Origin;
    Aliases?: CloudFront$20160801$Aliases;
    Comment: string;
    Logging?: CloudFront$20160801$StreamingLoggingConfig;
    TrustedSigners: CloudFront$20160801$TrustedSigners;
    PriceClass?: 'PriceClass_100' | 'PriceClass_200' | 'PriceClass_All';
    Enabled: boolean;
  };
  declare type CloudFront$20160801$StreamingDistributionConfigWithTags = {
    StreamingDistributionConfig: CloudFront$20160801$StreamingDistributionConfig;
    Tags: CloudFront$20160801$Tags;
  };
  declare type CloudFront$20160801$StreamingDistributionList = {
    Marker: string;
    NextMarker?: string;
    MaxItems: number;
    IsTruncated: boolean;
    Quantity: number;
    Items?: CloudFront$20160801$StreamingDistributionSummaryList;
  };
  declare type CloudFront$20160801$StreamingDistributionNotDisabled = {
    Message?: string;
  };
  declare type CloudFront$20160801$StreamingDistributionSummary = {
    Id: string;
    ARN: string;
    Status: string;
    LastModifiedTime: Date;
    DomainName: string;
    S3Origin: CloudFront$20160801$S3Origin;
    Aliases: CloudFront$20160801$Aliases;
    TrustedSigners: CloudFront$20160801$TrustedSigners;
    Comment: string;
    PriceClass: 'PriceClass_100' | 'PriceClass_200' | 'PriceClass_All';
    Enabled: boolean;
  };
  declare type CloudFront$20160801$StreamingDistributionSummaryList = CloudFront$20160801$StreamingDistributionSummary[];
  declare type CloudFront$20160801$StreamingLoggingConfig = {
    Enabled: boolean;
    Bucket: string;
    Prefix: string;
  };
  declare type CloudFront$20160801$Tag = {
    Key: string;
    Value?: string;
  };
  declare type CloudFront$20160801$TagKeyList = string[];
  declare type CloudFront$20160801$TagKeys = {
    Items?: CloudFront$20160801$TagKeyList;
  };
  declare type CloudFront$20160801$TagList = CloudFront$20160801$Tag[];
  declare type CloudFront$20160801$TagResourceRequest = {
    Resource: string;
    Tags: CloudFront$20160801$Tags;
  };
  declare type CloudFront$20160801$Tags = {
    Items?: CloudFront$20160801$TagList;
  };
  declare type CloudFront$20160801$TooManyCacheBehaviors = {
    Message?: string;
  };
  declare type CloudFront$20160801$TooManyCertificates = {
    Message?: string;
  };
  declare type CloudFront$20160801$TooManyCloudFrontOriginAccessIdentities = {
    Message?: string;
  };
  declare type CloudFront$20160801$TooManyCookieNamesInWhiteList = {
    Message?: string;
  };
  declare type CloudFront$20160801$TooManyDistributionCNAMEs = {
    Message?: string;
  };
  declare type CloudFront$20160801$TooManyDistributions = {
    Message?: string;
  };
  declare type CloudFront$20160801$TooManyHeadersInForwardedValues = {
    Message?: string;
  };
  declare type CloudFront$20160801$TooManyInvalidationsInProgress = {
    Message?: string;
  };
  declare type CloudFront$20160801$TooManyOriginCustomHeaders = {
    Message?: string;
  };
  declare type CloudFront$20160801$TooManyOrigins = {
    Message?: string;
  };
  declare type CloudFront$20160801$TooManyStreamingDistributionCNAMEs = {
    Message?: string;
  };
  declare type CloudFront$20160801$TooManyStreamingDistributions = {
    Message?: string;
  };
  declare type CloudFront$20160801$TooManyTrustedSigners = {
    Message?: string;
  };
  declare type CloudFront$20160801$TrustedSignerDoesNotExist = {
    Message?: string;
  };
  declare type CloudFront$20160801$TrustedSigners = {
    Enabled: boolean;
    Quantity: number;
    Items?: CloudFront$20160801$AwsAccountNumberList;
  };
  declare type CloudFront$20160801$UntagResourceRequest = {
    Resource: string;
    TagKeys: CloudFront$20160801$TagKeys;
  };
  declare type CloudFront$20160801$UpdateCloudFrontOriginAccessIdentityRequest = {
    CloudFrontOriginAccessIdentityConfig: CloudFront$20160801$CloudFrontOriginAccessIdentityConfig;
    Id: string;
    IfMatch?: string;
  };
  declare type CloudFront$20160801$UpdateCloudFrontOriginAccessIdentityResult = {
    CloudFrontOriginAccessIdentity?: CloudFront$20160801$CloudFrontOriginAccessIdentity;
    ETag?: string;
  };
  declare type CloudFront$20160801$UpdateDistributionRequest = {
    DistributionConfig: CloudFront$20160801$DistributionConfig;
    Id: string;
    IfMatch?: string;
  };
  declare type CloudFront$20160801$UpdateDistributionResult = {
    Distribution?: CloudFront$20160801$Distribution;
    ETag?: string;
  };
  declare type CloudFront$20160801$UpdateStreamingDistributionRequest = {
    StreamingDistributionConfig: CloudFront$20160801$StreamingDistributionConfig;
    Id: string;
    IfMatch?: string;
  };
  declare type CloudFront$20160801$UpdateStreamingDistributionResult = {
    StreamingDistribution?: CloudFront$20160801$StreamingDistribution;
    ETag?: string;
  };
  declare type CloudFront$20160801$ViewerCertificate = {
    CloudFrontDefaultCertificate?: boolean;
    IAMCertificateId?: string;
    ACMCertificateArn?: string;
    SSLSupportMethod?: 'sni-only' | 'vip';
    MinimumProtocolVersion?: 'SSLv3' | 'TLSv1';
    Certificate?: string;
    CertificateSource?: 'cloudfront' | 'iam' | 'acm';
  };
  declare type CloudFront$20160801$ViewerProtocolPolicy = 'allow-all' | 'https-only' | 'redirect-to-https';
  declare type CloudFront$20160801$timestamp = Date;
  declare type CloudHSM$20140530$AZList = string[];
  declare type CloudHSM$20140530$AddTagsToResourceRequest = {
    ResourceArn: string;
    TagList: CloudHSM$20140530$TagList;
  };
  declare type CloudHSM$20140530$AddTagsToResourceResponse = {
    Status: string;
  };
  declare type CloudHSM$20140530$ClientList = string[];
  declare type CloudHSM$20140530$ClientVersion = '5.1' | '5.3';
  declare type CloudHSM$20140530$CloudHsmInternalException = {};
  declare type CloudHSM$20140530$CloudHsmObjectState = 'READY' | 'UPDATING' | 'DEGRADED';
  declare type CloudHSM$20140530$CloudHsmServiceException = {
    message?: string;
    retryable?: boolean;
  };
  declare type CloudHSM$20140530$CreateHapgRequest = {
    Label: string;
  };
  declare type CloudHSM$20140530$CreateHapgResponse = {
    HapgArn?: string;
  };
  declare type CloudHSM$20140530$CreateHsmRequest = {
    SubnetId: string;
    SshKey: string;
    EniIp?: string;
    IamRoleArn: string;
    ExternalId?: string;
    SubscriptionType: 'PRODUCTION';
    ClientToken?: string;
    SyslogIp?: string;
  };
  declare type CloudHSM$20140530$CreateHsmResponse = {
    HsmArn?: string;
  };
  declare type CloudHSM$20140530$CreateLunaClientRequest = {
    Label?: string;
    Certificate: string;
  };
  declare type CloudHSM$20140530$CreateLunaClientResponse = {
    ClientArn?: string;
  };
  declare type CloudHSM$20140530$DeleteHapgRequest = {
    HapgArn: string;
  };
  declare type CloudHSM$20140530$DeleteHapgResponse = {
    Status: string;
  };
  declare type CloudHSM$20140530$DeleteHsmRequest = {
    HsmArn: string;
  };
  declare type CloudHSM$20140530$DeleteHsmResponse = {
    Status: string;
  };
  declare type CloudHSM$20140530$DeleteLunaClientRequest = {
    ClientArn: string;
  };
  declare type CloudHSM$20140530$DeleteLunaClientResponse = {
    Status: string;
  };
  declare type CloudHSM$20140530$DescribeHapgRequest = {
    HapgArn: string;
  };
  declare type CloudHSM$20140530$DescribeHapgResponse = {
    HapgArn?: string;
    HapgSerial?: string;
    HsmsLastActionFailed?: CloudHSM$20140530$HsmList;
    HsmsPendingDeletion?: CloudHSM$20140530$HsmList;
    HsmsPendingRegistration?: CloudHSM$20140530$HsmList;
    Label?: string;
    LastModifiedTimestamp?: string;
    PartitionSerialList?: CloudHSM$20140530$PartitionSerialList;
    State?: 'READY' | 'UPDATING' | 'DEGRADED';
  };
  declare type CloudHSM$20140530$DescribeHsmRequest = {
    HsmArn?: string;
    HsmSerialNumber?: string;
  };
  declare type CloudHSM$20140530$DescribeHsmResponse = {
    HsmArn?: string;
    Status?: 'PENDING' | 'RUNNING' | 'UPDATING' | 'SUSPENDED' | 'TERMINATING' | 'TERMINATED' | 'DEGRADED';
    StatusDetails?: string;
    AvailabilityZone?: string;
    EniId?: string;
    EniIp?: string;
    SubscriptionType?: 'PRODUCTION';
    SubscriptionStartDate?: string;
    SubscriptionEndDate?: string;
    VpcId?: string;
    SubnetId?: string;
    IamRoleArn?: string;
    SerialNumber?: string;
    VendorName?: string;
    HsmType?: string;
    SoftwareVersion?: string;
    SshPublicKey?: string;
    SshKeyLastUpdated?: string;
    ServerCertUri?: string;
    ServerCertLastUpdated?: string;
    Partitions?: CloudHSM$20140530$PartitionList;
  };
  declare type CloudHSM$20140530$DescribeLunaClientRequest = {
    ClientArn?: string;
    CertificateFingerprint?: string;
  };
  declare type CloudHSM$20140530$DescribeLunaClientResponse = {
    ClientArn?: string;
    Certificate?: string;
    CertificateFingerprint?: string;
    LastModifiedTimestamp?: string;
    Label?: string;
  };
  declare type CloudHSM$20140530$GetConfigRequest = {
    ClientArn: string;
    ClientVersion: '5.1' | '5.3';
    HapgList: CloudHSM$20140530$HapgList;
  };
  declare type CloudHSM$20140530$GetConfigResponse = {
    ConfigType?: string;
    ConfigFile?: string;
    ConfigCred?: string;
  };
  declare type CloudHSM$20140530$HapgList = string[];
  declare type CloudHSM$20140530$HsmList = string[];
  declare type CloudHSM$20140530$HsmStatus = 'PENDING' | 'RUNNING' | 'UPDATING' | 'SUSPENDED' | 'TERMINATING' | 'TERMINATED' | 'DEGRADED';
  declare type CloudHSM$20140530$InvalidRequestException = {};
  declare type CloudHSM$20140530$ListAvailableZonesRequest = {};
  declare type CloudHSM$20140530$ListAvailableZonesResponse = {
    AZList?: CloudHSM$20140530$AZList;
  };
  declare type CloudHSM$20140530$ListHapgsRequest = {
    NextToken?: string;
  };
  declare type CloudHSM$20140530$ListHapgsResponse = {
    HapgList: CloudHSM$20140530$HapgList;
    NextToken?: string;
  };
  declare type CloudHSM$20140530$ListHsmsRequest = {
    NextToken?: string;
  };
  declare type CloudHSM$20140530$ListHsmsResponse = {
    HsmList?: CloudHSM$20140530$HsmList;
    NextToken?: string;
  };
  declare type CloudHSM$20140530$ListLunaClientsRequest = {
    NextToken?: string;
  };
  declare type CloudHSM$20140530$ListLunaClientsResponse = {
    ClientList: CloudHSM$20140530$ClientList;
    NextToken?: string;
  };
  declare type CloudHSM$20140530$ListTagsForResourceRequest = {
    ResourceArn: string;
  };
  declare type CloudHSM$20140530$ListTagsForResourceResponse = {
    TagList: CloudHSM$20140530$TagList;
  };
  declare type CloudHSM$20140530$ModifyHapgRequest = {
    HapgArn: string;
    Label?: string;
    PartitionSerialList?: CloudHSM$20140530$PartitionSerialList;
  };
  declare type CloudHSM$20140530$ModifyHapgResponse = {
    HapgArn?: string;
  };
  declare type CloudHSM$20140530$ModifyHsmRequest = {
    HsmArn: string;
    SubnetId?: string;
    EniIp?: string;
    IamRoleArn?: string;
    ExternalId?: string;
    SyslogIp?: string;
  };
  declare type CloudHSM$20140530$ModifyHsmResponse = {
    HsmArn?: string;
  };
  declare type CloudHSM$20140530$ModifyLunaClientRequest = {
    ClientArn: string;
    Certificate: string;
  };
  declare type CloudHSM$20140530$ModifyLunaClientResponse = {
    ClientArn?: string;
  };
  declare type CloudHSM$20140530$PartitionList = string[];
  declare type CloudHSM$20140530$PartitionSerialList = string[];
  declare type CloudHSM$20140530$RemoveTagsFromResourceRequest = {
    ResourceArn: string;
    TagKeyList: CloudHSM$20140530$TagKeyList;
  };
  declare type CloudHSM$20140530$RemoveTagsFromResourceResponse = {
    Status: string;
  };
  declare type CloudHSM$20140530$SubscriptionType = 'PRODUCTION';
  declare type CloudHSM$20140530$Tag = {
    Key: string;
    Value: string;
  };
  declare type CloudHSM$20140530$TagKeyList = string[];
  declare type CloudHSM$20140530$TagList = CloudHSM$20140530$Tag[];
  declare type CloudSearch$20110201$AccessPoliciesStatus = {
    Options: string;
    Status: CloudSearch$20110201$OptionStatus;
  };
  declare type CloudSearch$20110201$AvailabilityOptionsStatus = {
    Options: boolean;
    Status: CloudSearch$20110201$OptionStatus;
  };
  declare type CloudSearch$20110201$BaseException = {
    Code?: string;
    Message?: string;
  };
  declare type CloudSearch$20110201$CreateDomainRequest = {
    DomainName: string;
  };
  declare type CloudSearch$20110201$CreateDomainResponse = {
    DomainStatus?: CloudSearch$20110201$DomainStatus;
  };
  declare type CloudSearch$20110201$DefaultSearchFieldStatus = {
    Options: string;
    Status: CloudSearch$20110201$OptionStatus;
  };
  declare type CloudSearch$20110201$DefineIndexFieldRequest = {
    DomainName: string;
    IndexField: CloudSearch$20110201$IndexField;
  };
  declare type CloudSearch$20110201$DefineIndexFieldResponse = {
    IndexField: CloudSearch$20110201$IndexFieldStatus;
  };
  declare type CloudSearch$20110201$DefineRankExpressionRequest = {
    DomainName: string;
    RankExpression: CloudSearch$20110201$NamedRankExpression;
  };
  declare type CloudSearch$20110201$DefineRankExpressionResponse = {
    RankExpression: CloudSearch$20110201$RankExpressionStatus;
  };
  declare type CloudSearch$20110201$DeleteDomainRequest = {
    DomainName: string;
  };
  declare type CloudSearch$20110201$DeleteDomainResponse = {
    DomainStatus?: CloudSearch$20110201$DomainStatus;
  };
  declare type CloudSearch$20110201$DeleteIndexFieldRequest = {
    DomainName: string;
    IndexFieldName: string;
  };
  declare type CloudSearch$20110201$DeleteIndexFieldResponse = {
    IndexField: CloudSearch$20110201$IndexFieldStatus;
  };
  declare type CloudSearch$20110201$DeleteRankExpressionRequest = {
    DomainName: string;
    RankName: string;
  };
  declare type CloudSearch$20110201$DeleteRankExpressionResponse = {
    RankExpression: CloudSearch$20110201$RankExpressionStatus;
  };
  declare type CloudSearch$20110201$DescribeAvailabilityOptionsRequest = {
    DomainName: string;
  };
  declare type CloudSearch$20110201$DescribeAvailabilityOptionsResponse = {
    AvailabilityOptions?: CloudSearch$20110201$AvailabilityOptionsStatus;
  };
  declare type CloudSearch$20110201$DescribeDefaultSearchFieldRequest = {
    DomainName: string;
  };
  declare type CloudSearch$20110201$DescribeDefaultSearchFieldResponse = {
    DefaultSearchField: CloudSearch$20110201$DefaultSearchFieldStatus;
  };
  declare type CloudSearch$20110201$DescribeDomainsRequest = {
    DomainNames?: CloudSearch$20110201$DomainNameList;
  };
  declare type CloudSearch$20110201$DescribeDomainsResponse = {
    DomainStatusList: CloudSearch$20110201$DomainStatusList;
  };
  declare type CloudSearch$20110201$DescribeIndexFieldsRequest = {
    DomainName: string;
    FieldNames?: CloudSearch$20110201$FieldNameList;
  };
  declare type CloudSearch$20110201$DescribeIndexFieldsResponse = {
    IndexFields: CloudSearch$20110201$IndexFieldStatusList;
  };
  declare type CloudSearch$20110201$DescribeRankExpressionsRequest = {
    DomainName: string;
    RankNames?: CloudSearch$20110201$FieldNameList;
  };
  declare type CloudSearch$20110201$DescribeRankExpressionsResponse = {
    RankExpressions: CloudSearch$20110201$RankExpressionStatusList;
  };
  declare type CloudSearch$20110201$DescribeServiceAccessPoliciesRequest = {
    DomainName: string;
  };
  declare type CloudSearch$20110201$DescribeServiceAccessPoliciesResponse = {
    AccessPolicies: CloudSearch$20110201$AccessPoliciesStatus;
  };
  declare type CloudSearch$20110201$DescribeStemmingOptionsRequest = {
    DomainName: string;
  };
  declare type CloudSearch$20110201$DescribeStemmingOptionsResponse = {
    Stems: CloudSearch$20110201$StemmingOptionsStatus;
  };
  declare type CloudSearch$20110201$DescribeStopwordOptionsRequest = {
    DomainName: string;
  };
  declare type CloudSearch$20110201$DescribeStopwordOptionsResponse = {
    Stopwords: CloudSearch$20110201$StopwordOptionsStatus;
  };
  declare type CloudSearch$20110201$DescribeSynonymOptionsRequest = {
    DomainName: string;
  };
  declare type CloudSearch$20110201$DescribeSynonymOptionsResponse = {
    Synonyms: CloudSearch$20110201$SynonymOptionsStatus;
  };
  declare type CloudSearch$20110201$DisabledOperationException = {};
  declare type CloudSearch$20110201$DomainNameList = string[];
  declare type CloudSearch$20110201$DomainStatus = {
    DomainId: string;
    DomainName: string;
    Created?: boolean;
    Deleted?: boolean;
    NumSearchableDocs?: number;
    DocService?: CloudSearch$20110201$ServiceEndpoint;
    SearchService?: CloudSearch$20110201$ServiceEndpoint;
    RequiresIndexDocuments: boolean;
    Processing?: boolean;
    SearchInstanceType?: string;
    SearchPartitionCount?: number;
    SearchInstanceCount?: number;
  };
  declare type CloudSearch$20110201$DomainStatusList = CloudSearch$20110201$DomainStatus[];
  declare type CloudSearch$20110201$FieldNameList = string[];
  declare type CloudSearch$20110201$IndexDocumentsRequest = {
    DomainName: string;
  };
  declare type CloudSearch$20110201$IndexDocumentsResponse = {
    FieldNames?: CloudSearch$20110201$FieldNameList;
  };
  declare type CloudSearch$20110201$IndexField = {
    IndexFieldName: string;
    IndexFieldType: 'uint' | 'literal' | 'text';
    UIntOptions?: CloudSearch$20110201$UIntOptions;
    LiteralOptions?: CloudSearch$20110201$LiteralOptions;
    TextOptions?: CloudSearch$20110201$TextOptions;
    SourceAttributes?: CloudSearch$20110201$SourceAttributeList;
  };
  declare type CloudSearch$20110201$IndexFieldStatus = {
    Options: CloudSearch$20110201$IndexField;
    Status: CloudSearch$20110201$OptionStatus;
  };
  declare type CloudSearch$20110201$IndexFieldStatusList = CloudSearch$20110201$IndexFieldStatus[];
  declare type CloudSearch$20110201$IndexFieldType = 'uint' | 'literal' | 'text';
  declare type CloudSearch$20110201$InternalException = {};
  declare type CloudSearch$20110201$InvalidTypeException = {};
  declare type CloudSearch$20110201$LimitExceededException = {};
  declare type CloudSearch$20110201$LiteralOptions = {
    DefaultValue?: string;
    SearchEnabled?: boolean;
    FacetEnabled?: boolean;
    ResultEnabled?: boolean;
  };
  declare type CloudSearch$20110201$NamedRankExpression = {
    RankName: string;
    RankExpression: string;
  };
  declare type CloudSearch$20110201$OptionState = 'RequiresIndexDocuments' | 'Processing' | 'Active';
  declare type CloudSearch$20110201$OptionStatus = {
    CreationDate: Date;
    UpdateDate: Date;
    UpdateVersion?: number;
    State: 'RequiresIndexDocuments' | 'Processing' | 'Active';
    PendingDeletion?: boolean;
  };
  declare type CloudSearch$20110201$RankExpressionStatus = {
    Options: CloudSearch$20110201$NamedRankExpression;
    Status: CloudSearch$20110201$OptionStatus;
  };
  declare type CloudSearch$20110201$RankExpressionStatusList = CloudSearch$20110201$RankExpressionStatus[];
  declare type CloudSearch$20110201$ResourceNotFoundException = {};
  declare type CloudSearch$20110201$ServiceEndpoint = {
    Arn?: string;
    Endpoint?: string;
  };
  declare type CloudSearch$20110201$SourceAttribute = {
    SourceDataFunction: 'Copy' | 'TrimTitle' | 'Map';
    SourceDataCopy?: CloudSearch$20110201$SourceData;
    SourceDataTrimTitle?: CloudSearch$20110201$SourceDataTrimTitle;
    SourceDataMap?: CloudSearch$20110201$SourceDataMap;
  };
  declare type CloudSearch$20110201$SourceAttributeList = CloudSearch$20110201$SourceAttribute[];
  declare type CloudSearch$20110201$SourceData = {
    SourceName: string;
    DefaultValue?: string;
  };
  declare type CloudSearch$20110201$SourceDataFunction = 'Copy' | 'TrimTitle' | 'Map';
  declare type CloudSearch$20110201$SourceDataMap = {
    SourceName: string;
    DefaultValue?: string;
    Cases?: {
      [key: string]: string;
    };
  };
  declare type CloudSearch$20110201$SourceDataTrimTitle = {
    SourceName: string;
    DefaultValue?: string;
    Separator?: string;
    Language?: string;
  };
  declare type CloudSearch$20110201$StemmingOptionsStatus = {
    Options: string;
    Status: CloudSearch$20110201$OptionStatus;
  };
  declare type CloudSearch$20110201$StopwordOptionsStatus = {
    Options: string;
    Status: CloudSearch$20110201$OptionStatus;
  };
  declare type CloudSearch$20110201$StringCaseMap = {
    [key: string]: string;
  };
  declare type CloudSearch$20110201$SynonymOptionsStatus = {
    Options: string;
    Status: CloudSearch$20110201$OptionStatus;
  };
  declare type CloudSearch$20110201$TextOptions = {
    DefaultValue?: string;
    FacetEnabled?: boolean;
    ResultEnabled?: boolean;
    TextProcessor?: string;
  };
  declare type CloudSearch$20110201$UIntOptions = {
    DefaultValue?: number;
  };
  declare type CloudSearch$20110201$UpdateAvailabilityOptionsRequest = {
    DomainName: string;
    MultiAZ: boolean;
  };
  declare type CloudSearch$20110201$UpdateAvailabilityOptionsResponse = {
    AvailabilityOptions?: CloudSearch$20110201$AvailabilityOptionsStatus;
  };
  declare type CloudSearch$20110201$UpdateDefaultSearchFieldRequest = {
    DomainName: string;
    DefaultSearchField: string;
  };
  declare type CloudSearch$20110201$UpdateDefaultSearchFieldResponse = {
    DefaultSearchField: CloudSearch$20110201$DefaultSearchFieldStatus;
  };
  declare type CloudSearch$20110201$UpdateServiceAccessPoliciesRequest = {
    DomainName: string;
    AccessPolicies: string;
  };
  declare type CloudSearch$20110201$UpdateServiceAccessPoliciesResponse = {
    AccessPolicies: CloudSearch$20110201$AccessPoliciesStatus;
  };
  declare type CloudSearch$20110201$UpdateStemmingOptionsRequest = {
    DomainName: string;
    Stems: string;
  };
  declare type CloudSearch$20110201$UpdateStemmingOptionsResponse = {
    Stems: CloudSearch$20110201$StemmingOptionsStatus;
  };
  declare type CloudSearch$20110201$UpdateStopwordOptionsRequest = {
    DomainName: string;
    Stopwords: string;
  };
  declare type CloudSearch$20110201$UpdateStopwordOptionsResponse = {
    Stopwords: CloudSearch$20110201$StopwordOptionsStatus;
  };
  declare type CloudSearch$20110201$UpdateSynonymOptionsRequest = {
    DomainName: string;
    Synonyms: string;
  };
  declare type CloudSearch$20110201$UpdateSynonymOptionsResponse = {
    Synonyms: CloudSearch$20110201$SynonymOptionsStatus;
  };
  declare type CloudSearch$20110201$UpdateTimestamp = Date;
  declare type CloudSearch$20130101$AccessPoliciesStatus = {
    Options: string;
    Status: CloudSearch$20130101$OptionStatus;
  };
  declare type CloudSearch$20130101$AlgorithmicStemming = 'none' | 'minimal' | 'light' | 'full';
  declare type CloudSearch$20130101$AnalysisOptions = {
    Synonyms?: string;
    Stopwords?: string;
    StemmingDictionary?: string;
    JapaneseTokenizationDictionary?: string;
    AlgorithmicStemming?: 'none' | 'minimal' | 'light' | 'full';
  };
  declare type CloudSearch$20130101$AnalysisScheme = {
    AnalysisSchemeName: string;
    AnalysisSchemeLanguage: 'ar' | 'bg' | 'ca' | 'cs' | 'da' | 'de' | 'el' | 'en' | 'es' | 'eu' | 'fa' | 'fi' | 'fr' | 'ga' | 'gl' | 'he' | 'hi' | 'hu' | 'hy' | 'id' | 'it' | 'ja' | 'ko' | 'lv' | 'mul' | 'nl' | 'no' | 'pt' | 'ro' | 'ru' | 'sv' | 'th' | 'tr' | 'zh-Hans' | 'zh-Hant';
    AnalysisOptions?: CloudSearch$20130101$AnalysisOptions;
  };
  declare type CloudSearch$20130101$AnalysisSchemeLanguage = 'ar' | 'bg' | 'ca' | 'cs' | 'da' | 'de' | 'el' | 'en' | 'es' | 'eu' | 'fa' | 'fi' | 'fr' | 'ga' | 'gl' | 'he' | 'hi' | 'hu' | 'hy' | 'id' | 'it' | 'ja' | 'ko' | 'lv' | 'mul' | 'nl' | 'no' | 'pt' | 'ro' | 'ru' | 'sv' | 'th' | 'tr' | 'zh-Hans' | 'zh-Hant';
  declare type CloudSearch$20130101$AnalysisSchemeStatus = {
    Options: CloudSearch$20130101$AnalysisScheme;
    Status: CloudSearch$20130101$OptionStatus;
  };
  declare type CloudSearch$20130101$AnalysisSchemeStatusList = CloudSearch$20130101$AnalysisSchemeStatus[];
  declare type CloudSearch$20130101$AvailabilityOptionsStatus = {
    Options: boolean;
    Status: CloudSearch$20130101$OptionStatus;
  };
  declare type CloudSearch$20130101$BaseException = {
    Code?: string;
    Message?: string;
  };
  declare type CloudSearch$20130101$BuildSuggestersRequest = {
    DomainName: string;
  };
  declare type CloudSearch$20130101$BuildSuggestersResponse = {
    FieldNames?: CloudSearch$20130101$FieldNameList;
  };
  declare type CloudSearch$20130101$CreateDomainRequest = {
    DomainName: string;
  };
  declare type CloudSearch$20130101$CreateDomainResponse = {
    DomainStatus?: CloudSearch$20130101$DomainStatus;
  };
  declare type CloudSearch$20130101$DateArrayOptions = {
    DefaultValue?: string;
    SourceFields?: string;
    FacetEnabled?: boolean;
    SearchEnabled?: boolean;
    ReturnEnabled?: boolean;
  };
  declare type CloudSearch$20130101$DateOptions = {
    DefaultValue?: string;
    SourceField?: string;
    FacetEnabled?: boolean;
    SearchEnabled?: boolean;
    ReturnEnabled?: boolean;
    SortEnabled?: boolean;
  };
  declare type CloudSearch$20130101$DefineAnalysisSchemeRequest = {
    DomainName: string;
    AnalysisScheme: CloudSearch$20130101$AnalysisScheme;
  };
  declare type CloudSearch$20130101$DefineAnalysisSchemeResponse = {
    AnalysisScheme: CloudSearch$20130101$AnalysisSchemeStatus;
  };
  declare type CloudSearch$20130101$DefineExpressionRequest = {
    DomainName: string;
    Expression: CloudSearch$20130101$Expression;
  };
  declare type CloudSearch$20130101$DefineExpressionResponse = {
    Expression: CloudSearch$20130101$ExpressionStatus;
  };
  declare type CloudSearch$20130101$DefineIndexFieldRequest = {
    DomainName: string;
    IndexField: CloudSearch$20130101$IndexField;
  };
  declare type CloudSearch$20130101$DefineIndexFieldResponse = {
    IndexField: CloudSearch$20130101$IndexFieldStatus;
  };
  declare type CloudSearch$20130101$DefineSuggesterRequest = {
    DomainName: string;
    Suggester: CloudSearch$20130101$Suggester;
  };
  declare type CloudSearch$20130101$DefineSuggesterResponse = {
    Suggester: CloudSearch$20130101$SuggesterStatus;
  };
  declare type CloudSearch$20130101$DeleteAnalysisSchemeRequest = {
    DomainName: string;
    AnalysisSchemeName: string;
  };
  declare type CloudSearch$20130101$DeleteAnalysisSchemeResponse = {
    AnalysisScheme: CloudSearch$20130101$AnalysisSchemeStatus;
  };
  declare type CloudSearch$20130101$DeleteDomainRequest = {
    DomainName: string;
  };
  declare type CloudSearch$20130101$DeleteDomainResponse = {
    DomainStatus?: CloudSearch$20130101$DomainStatus;
  };
  declare type CloudSearch$20130101$DeleteExpressionRequest = {
    DomainName: string;
    ExpressionName: string;
  };
  declare type CloudSearch$20130101$DeleteExpressionResponse = {
    Expression: CloudSearch$20130101$ExpressionStatus;
  };
  declare type CloudSearch$20130101$DeleteIndexFieldRequest = {
    DomainName: string;
    IndexFieldName: string;
  };
  declare type CloudSearch$20130101$DeleteIndexFieldResponse = {
    IndexField: CloudSearch$20130101$IndexFieldStatus;
  };
  declare type CloudSearch$20130101$DeleteSuggesterRequest = {
    DomainName: string;
    SuggesterName: string;
  };
  declare type CloudSearch$20130101$DeleteSuggesterResponse = {
    Suggester: CloudSearch$20130101$SuggesterStatus;
  };
  declare type CloudSearch$20130101$DescribeAnalysisSchemesRequest = {
    DomainName: string;
    AnalysisSchemeNames?: CloudSearch$20130101$StandardNameList;
    Deployed?: boolean;
  };
  declare type CloudSearch$20130101$DescribeAnalysisSchemesResponse = {
    AnalysisSchemes: CloudSearch$20130101$AnalysisSchemeStatusList;
  };
  declare type CloudSearch$20130101$DescribeAvailabilityOptionsRequest = {
    DomainName: string;
    Deployed?: boolean;
  };
  declare type CloudSearch$20130101$DescribeAvailabilityOptionsResponse = {
    AvailabilityOptions?: CloudSearch$20130101$AvailabilityOptionsStatus;
  };
  declare type CloudSearch$20130101$DescribeDomainsRequest = {
    DomainNames?: CloudSearch$20130101$DomainNameList;
  };
  declare type CloudSearch$20130101$DescribeDomainsResponse = {
    DomainStatusList: CloudSearch$20130101$DomainStatusList;
  };
  declare type CloudSearch$20130101$DescribeExpressionsRequest = {
    DomainName: string;
    ExpressionNames?: CloudSearch$20130101$StandardNameList;
    Deployed?: boolean;
  };
  declare type CloudSearch$20130101$DescribeExpressionsResponse = {
    Expressions: CloudSearch$20130101$ExpressionStatusList;
  };
  declare type CloudSearch$20130101$DescribeIndexFieldsRequest = {
    DomainName: string;
    FieldNames?: CloudSearch$20130101$DynamicFieldNameList;
    Deployed?: boolean;
  };
  declare type CloudSearch$20130101$DescribeIndexFieldsResponse = {
    IndexFields: CloudSearch$20130101$IndexFieldStatusList;
  };
  declare type CloudSearch$20130101$DescribeScalingParametersRequest = {
    DomainName: string;
  };
  declare type CloudSearch$20130101$DescribeScalingParametersResponse = {
    ScalingParameters: CloudSearch$20130101$ScalingParametersStatus;
  };
  declare type CloudSearch$20130101$DescribeServiceAccessPoliciesRequest = {
    DomainName: string;
    Deployed?: boolean;
  };
  declare type CloudSearch$20130101$DescribeServiceAccessPoliciesResponse = {
    AccessPolicies: CloudSearch$20130101$AccessPoliciesStatus;
  };
  declare type CloudSearch$20130101$DescribeSuggestersRequest = {
    DomainName: string;
    SuggesterNames?: CloudSearch$20130101$StandardNameList;
    Deployed?: boolean;
  };
  declare type CloudSearch$20130101$DescribeSuggestersResponse = {
    Suggesters: CloudSearch$20130101$SuggesterStatusList;
  };
  declare type CloudSearch$20130101$DisabledOperationException = {};
  declare type CloudSearch$20130101$DocumentSuggesterOptions = {
    SourceField: string;
    FuzzyMatching?: 'none' | 'low' | 'high';
    SortExpression?: string;
  };
  declare type CloudSearch$20130101$DomainNameList = string[];
  declare type CloudSearch$20130101$DomainNameMap = {
    [key: string]: string;
  };
  declare type CloudSearch$20130101$DomainStatus = {
    DomainId: string;
    DomainName: string;
    ARN?: string;
    Created?: boolean;
    Deleted?: boolean;
    DocService?: CloudSearch$20130101$ServiceEndpoint;
    SearchService?: CloudSearch$20130101$ServiceEndpoint;
    RequiresIndexDocuments: boolean;
    Processing?: boolean;
    SearchInstanceType?: string;
    SearchPartitionCount?: number;
    SearchInstanceCount?: number;
    Limits?: CloudSearch$20130101$Limits;
  };
  declare type CloudSearch$20130101$DomainStatusList = CloudSearch$20130101$DomainStatus[];
  declare type CloudSearch$20130101$DoubleArrayOptions = {
    DefaultValue?: number;
    SourceFields?: string;
    FacetEnabled?: boolean;
    SearchEnabled?: boolean;
    ReturnEnabled?: boolean;
  };
  declare type CloudSearch$20130101$DoubleOptions = {
    DefaultValue?: number;
    SourceField?: string;
    FacetEnabled?: boolean;
    SearchEnabled?: boolean;
    ReturnEnabled?: boolean;
    SortEnabled?: boolean;
  };
  declare type CloudSearch$20130101$DynamicFieldNameList = string[];
  declare type CloudSearch$20130101$Expression = {
    ExpressionName: string;
    ExpressionValue: string;
  };
  declare type CloudSearch$20130101$ExpressionStatus = {
    Options: CloudSearch$20130101$Expression;
    Status: CloudSearch$20130101$OptionStatus;
  };
  declare type CloudSearch$20130101$ExpressionStatusList = CloudSearch$20130101$ExpressionStatus[];
  declare type CloudSearch$20130101$FieldNameList = string[];
  declare type CloudSearch$20130101$IndexDocumentsRequest = {
    DomainName: string;
  };
  declare type CloudSearch$20130101$IndexDocumentsResponse = {
    FieldNames?: CloudSearch$20130101$FieldNameList;
  };
  declare type CloudSearch$20130101$IndexField = {
    IndexFieldName: string;
    IndexFieldType: 'int' | 'double' | 'literal' | 'text' | 'date' | 'latlon' | 'int-array' | 'double-array' | 'literal-array' | 'text-array' | 'date-array';
    IntOptions?: CloudSearch$20130101$IntOptions;
    DoubleOptions?: CloudSearch$20130101$DoubleOptions;
    LiteralOptions?: CloudSearch$20130101$LiteralOptions;
    TextOptions?: CloudSearch$20130101$TextOptions;
    DateOptions?: CloudSearch$20130101$DateOptions;
    LatLonOptions?: CloudSearch$20130101$LatLonOptions;
    IntArrayOptions?: CloudSearch$20130101$IntArrayOptions;
    DoubleArrayOptions?: CloudSearch$20130101$DoubleArrayOptions;
    LiteralArrayOptions?: CloudSearch$20130101$LiteralArrayOptions;
    TextArrayOptions?: CloudSearch$20130101$TextArrayOptions;
    DateArrayOptions?: CloudSearch$20130101$DateArrayOptions;
  };
  declare type CloudSearch$20130101$IndexFieldStatus = {
    Options: CloudSearch$20130101$IndexField;
    Status: CloudSearch$20130101$OptionStatus;
  };
  declare type CloudSearch$20130101$IndexFieldStatusList = CloudSearch$20130101$IndexFieldStatus[];
  declare type CloudSearch$20130101$IndexFieldType = 'int' | 'double' | 'literal' | 'text' | 'date' | 'latlon' | 'int-array' | 'double-array' | 'literal-array' | 'text-array' | 'date-array';
  declare type CloudSearch$20130101$IntArrayOptions = {
    DefaultValue?: number;
    SourceFields?: string;
    FacetEnabled?: boolean;
    SearchEnabled?: boolean;
    ReturnEnabled?: boolean;
  };
  declare type CloudSearch$20130101$IntOptions = {
    DefaultValue?: number;
    SourceField?: string;
    FacetEnabled?: boolean;
    SearchEnabled?: boolean;
    ReturnEnabled?: boolean;
    SortEnabled?: boolean;
  };
  declare type CloudSearch$20130101$InternalException = {};
  declare type CloudSearch$20130101$InvalidTypeException = {};
  declare type CloudSearch$20130101$LatLonOptions = {
    DefaultValue?: string;
    SourceField?: string;
    FacetEnabled?: boolean;
    SearchEnabled?: boolean;
    ReturnEnabled?: boolean;
    SortEnabled?: boolean;
  };
  declare type CloudSearch$20130101$LimitExceededException = {};
  declare type CloudSearch$20130101$Limits = {
    MaximumReplicationCount: number;
    MaximumPartitionCount: number;
  };
  declare type CloudSearch$20130101$ListDomainNamesResponse = {
    DomainNames?: {
      [key: string]: string;
    };
  };
  declare type CloudSearch$20130101$LiteralArrayOptions = {
    DefaultValue?: string;
    SourceFields?: string;
    FacetEnabled?: boolean;
    SearchEnabled?: boolean;
    ReturnEnabled?: boolean;
  };
  declare type CloudSearch$20130101$LiteralOptions = {
    DefaultValue?: string;
    SourceField?: string;
    FacetEnabled?: boolean;
    SearchEnabled?: boolean;
    ReturnEnabled?: boolean;
    SortEnabled?: boolean;
  };
  declare type CloudSearch$20130101$OptionState = 'RequiresIndexDocuments' | 'Processing' | 'Active' | 'FailedToValidate';
  declare type CloudSearch$20130101$OptionStatus = {
    CreationDate: Date;
    UpdateDate: Date;
    UpdateVersion?: number;
    State: 'RequiresIndexDocuments' | 'Processing' | 'Active' | 'FailedToValidate';
    PendingDeletion?: boolean;
  };
  declare type CloudSearch$20130101$PartitionInstanceType = 'search.m1.small' | 'search.m1.large' | 'search.m2.xlarge' | 'search.m2.2xlarge' | 'search.m3.medium' | 'search.m3.large' | 'search.m3.xlarge' | 'search.m3.2xlarge';
  declare type CloudSearch$20130101$ResourceNotFoundException = {};
  declare type CloudSearch$20130101$ScalingParameters = {
    DesiredInstanceType?: 'search.m1.small' | 'search.m1.large' | 'search.m2.xlarge' | 'search.m2.2xlarge' | 'search.m3.medium' | 'search.m3.large' | 'search.m3.xlarge' | 'search.m3.2xlarge';
    DesiredReplicationCount?: number;
    DesiredPartitionCount?: number;
  };
  declare type CloudSearch$20130101$ScalingParametersStatus = {
    Options: CloudSearch$20130101$ScalingParameters;
    Status: CloudSearch$20130101$OptionStatus;
  };
  declare type CloudSearch$20130101$ServiceEndpoint = {
    Endpoint?: string;
  };
  declare type CloudSearch$20130101$StandardNameList = string[];
  declare type CloudSearch$20130101$Suggester = {
    SuggesterName: string;
    DocumentSuggesterOptions: CloudSearch$20130101$DocumentSuggesterOptions;
  };
  declare type CloudSearch$20130101$SuggesterFuzzyMatching = 'none' | 'low' | 'high';
  declare type CloudSearch$20130101$SuggesterStatus = {
    Options: CloudSearch$20130101$Suggester;
    Status: CloudSearch$20130101$OptionStatus;
  };
  declare type CloudSearch$20130101$SuggesterStatusList = CloudSearch$20130101$SuggesterStatus[];
  declare type CloudSearch$20130101$TextArrayOptions = {
    DefaultValue?: string;
    SourceFields?: string;
    ReturnEnabled?: boolean;
    HighlightEnabled?: boolean;
    AnalysisScheme?: string;
  };
  declare type CloudSearch$20130101$TextOptions = {
    DefaultValue?: string;
    SourceField?: string;
    ReturnEnabled?: boolean;
    SortEnabled?: boolean;
    HighlightEnabled?: boolean;
    AnalysisScheme?: string;
  };
  declare type CloudSearch$20130101$UpdateAvailabilityOptionsRequest = {
    DomainName: string;
    MultiAZ: boolean;
  };
  declare type CloudSearch$20130101$UpdateAvailabilityOptionsResponse = {
    AvailabilityOptions?: CloudSearch$20130101$AvailabilityOptionsStatus;
  };
  declare type CloudSearch$20130101$UpdateScalingParametersRequest = {
    DomainName: string;
    ScalingParameters: CloudSearch$20130101$ScalingParameters;
  };
  declare type CloudSearch$20130101$UpdateScalingParametersResponse = {
    ScalingParameters: CloudSearch$20130101$ScalingParametersStatus;
  };
  declare type CloudSearch$20130101$UpdateServiceAccessPoliciesRequest = {
    DomainName: string;
    AccessPolicies: string;
  };
  declare type CloudSearch$20130101$UpdateServiceAccessPoliciesResponse = {
    AccessPolicies: CloudSearch$20130101$AccessPoliciesStatus;
  };
  declare type CloudSearch$20130101$UpdateTimestamp = Date;
  declare type CloudSearchDomain$20130101$Blob = Buffer | $TypedArray | Blob | string;
  declare type CloudSearchDomain$20130101$Bucket = {
    value?: string;
    count?: number;
  };
  declare type CloudSearchDomain$20130101$BucketInfo = {
    buckets?: CloudSearchDomain$20130101$BucketList;
  };
  declare type CloudSearchDomain$20130101$BucketList = CloudSearchDomain$20130101$Bucket[];
  declare type CloudSearchDomain$20130101$ContentType = 'application/json' | 'application/xml';
  declare type CloudSearchDomain$20130101$DocumentServiceException = {
    status?: string;
    message?: string;
  };
  declare type CloudSearchDomain$20130101$DocumentServiceWarning = {
    message?: string;
  };
  declare type CloudSearchDomain$20130101$DocumentServiceWarnings = CloudSearchDomain$20130101$DocumentServiceWarning[];
  declare type CloudSearchDomain$20130101$Exprs = {
    [key: string]: string;
  };
  declare type CloudSearchDomain$20130101$Facets = {
    [key: string]: CloudSearchDomain$20130101$BucketInfo;
  };
  declare type CloudSearchDomain$20130101$FieldStats = {
    min?: string;
    max?: string;
    count?: number;
    missing?: number;
    sum?: number;
    sumOfSquares?: number;
    mean?: string;
    stddev?: number;
  };
  declare type CloudSearchDomain$20130101$FieldValue = string[];
  declare type CloudSearchDomain$20130101$Fields = {
    [key: string]: CloudSearchDomain$20130101$FieldValue;
  };
  declare type CloudSearchDomain$20130101$Highlights = {
    [key: string]: string;
  };
  declare type CloudSearchDomain$20130101$Hit = {
    id?: string;
    fields?: {
      [key: string]: CloudSearchDomain$20130101$FieldValue;
    };
    exprs?: {
      [key: string]: string;
    };
    highlights?: {
      [key: string]: string;
    };
  };
  declare type CloudSearchDomain$20130101$HitList = CloudSearchDomain$20130101$Hit[];
  declare type CloudSearchDomain$20130101$Hits = {
    found?: number;
    start?: number;
    cursor?: string;
    hit?: CloudSearchDomain$20130101$HitList;
  };
  declare type CloudSearchDomain$20130101$QueryParser = 'simple' | 'structured' | 'lucene' | 'dismax';
  declare type CloudSearchDomain$20130101$SearchException = {
    message?: string;
  };
  declare type CloudSearchDomain$20130101$SearchRequest = {
    cursor?: string;
    expr?: string;
    facet?: string;
    filterQuery?: string;
    highlight?: string;
    partial?: boolean;
    query: string;
    queryOptions?: string;
    queryParser?: 'simple' | 'structured' | 'lucene' | 'dismax';
    return?: string;
    size?: number;
    sort?: string;
    start?: number;
    stats?: string;
  };
  declare type CloudSearchDomain$20130101$SearchResponse = {
    status?: CloudSearchDomain$20130101$SearchStatus;
    hits?: CloudSearchDomain$20130101$Hits;
    facets?: {
      [key: string]: CloudSearchDomain$20130101$BucketInfo;
    };
    stats?: {
      [key: string]: CloudSearchDomain$20130101$FieldStats;
    };
  };
  declare type CloudSearchDomain$20130101$SearchStatus = {
    timems?: number;
    rid?: string;
  };
  declare type CloudSearchDomain$20130101$Stats = {
    [key: string]: CloudSearchDomain$20130101$FieldStats;
  };
  declare type CloudSearchDomain$20130101$SuggestModel = {
    query?: string;
    found?: number;
    suggestions?: CloudSearchDomain$20130101$Suggestions;
  };
  declare type CloudSearchDomain$20130101$SuggestRequest = {
    query: string;
    suggester: string;
    size?: number;
  };
  declare type CloudSearchDomain$20130101$SuggestResponse = {
    status?: CloudSearchDomain$20130101$SuggestStatus;
    suggest?: CloudSearchDomain$20130101$SuggestModel;
  };
  declare type CloudSearchDomain$20130101$SuggestStatus = {
    timems?: number;
    rid?: string;
  };
  declare type CloudSearchDomain$20130101$SuggestionMatch = {
    suggestion?: string;
    score?: number;
    id?: string;
  };
  declare type CloudSearchDomain$20130101$Suggestions = CloudSearchDomain$20130101$SuggestionMatch[];
  declare type CloudSearchDomain$20130101$UploadDocumentsRequest = {
    documents: Buffer | $TypedArray | Blob | string;
    contentType: 'application/json' | 'application/xml';
  };
  declare type CloudSearchDomain$20130101$UploadDocumentsResponse = {
    status?: string;
    adds?: number;
    deletes?: number;
    warnings?: CloudSearchDomain$20130101$DocumentServiceWarnings;
  };
  declare type CloudTrail$20131101$AddTagsRequest = {
    ResourceId: string;
    TagsList?: CloudTrail$20131101$TagsList;
  };
  declare type CloudTrail$20131101$AddTagsResponse = {};
  declare type CloudTrail$20131101$ByteBuffer = Buffer | $TypedArray | Blob | string;
  declare type CloudTrail$20131101$CloudTrailARNInvalidException = {};
  declare type CloudTrail$20131101$CloudWatchLogsDeliveryUnavailableException = {};
  declare type CloudTrail$20131101$CreateTrailRequest = {
    Name: string;
    S3BucketName: string;
    S3KeyPrefix?: string;
    SnsTopicName?: string;
    IncludeGlobalServiceEvents?: boolean;
    IsMultiRegionTrail?: boolean;
    EnableLogFileValidation?: boolean;
    CloudWatchLogsLogGroupArn?: string;
    CloudWatchLogsRoleArn?: string;
    KmsKeyId?: string;
  };
  declare type CloudTrail$20131101$CreateTrailResponse = {
    Name?: string;
    S3BucketName?: string;
    S3KeyPrefix?: string;
    SnsTopicName?: string;
    SnsTopicARN?: string;
    IncludeGlobalServiceEvents?: boolean;
    IsMultiRegionTrail?: boolean;
    TrailARN?: string;
    LogFileValidationEnabled?: boolean;
    CloudWatchLogsLogGroupArn?: string;
    CloudWatchLogsRoleArn?: string;
    KmsKeyId?: string;
  };
  declare type CloudTrail$20131101$Date = Date;
  declare type CloudTrail$20131101$DeleteTrailRequest = {
    Name: string;
  };
  declare type CloudTrail$20131101$DeleteTrailResponse = {};
  declare type CloudTrail$20131101$DescribeTrailsRequest = {
    trailNameList?: CloudTrail$20131101$TrailNameList;
    includeShadowTrails?: boolean;
  };
  declare type CloudTrail$20131101$DescribeTrailsResponse = {
    trailList?: CloudTrail$20131101$TrailList;
  };
  declare type CloudTrail$20131101$Event = {
    EventId?: string;
    EventName?: string;
    EventTime?: Date;
    Username?: string;
    Resources?: CloudTrail$20131101$ResourceList;
    CloudTrailEvent?: string;
  };
  declare type CloudTrail$20131101$EventsList = CloudTrail$20131101$Event[];
  declare type CloudTrail$20131101$GetTrailStatusRequest = {
    Name: string;
  };
  declare type CloudTrail$20131101$GetTrailStatusResponse = {
    IsLogging?: boolean;
    LatestDeliveryError?: string;
    LatestNotificationError?: string;
    LatestDeliveryTime?: Date;
    LatestNotificationTime?: Date;
    StartLoggingTime?: Date;
    StopLoggingTime?: Date;
    LatestCloudWatchLogsDeliveryError?: string;
    LatestCloudWatchLogsDeliveryTime?: Date;
    LatestDigestDeliveryTime?: Date;
    LatestDigestDeliveryError?: string;
    LatestDeliveryAttemptTime?: string;
    LatestNotificationAttemptTime?: string;
    LatestNotificationAttemptSucceeded?: string;
    LatestDeliveryAttemptSucceeded?: string;
    TimeLoggingStarted?: string;
    TimeLoggingStopped?: string;
  };
  declare type CloudTrail$20131101$InsufficientEncryptionPolicyException = {};
  declare type CloudTrail$20131101$InsufficientS3BucketPolicyException = {};
  declare type CloudTrail$20131101$InsufficientSnsTopicPolicyException = {};
  declare type CloudTrail$20131101$InvalidCloudWatchLogsLogGroupArnException = {};
  declare type CloudTrail$20131101$InvalidCloudWatchLogsRoleArnException = {};
  declare type CloudTrail$20131101$InvalidHomeRegionException = {};
  declare type CloudTrail$20131101$InvalidKmsKeyIdException = {};
  declare type CloudTrail$20131101$InvalidLookupAttributesException = {};
  declare type CloudTrail$20131101$InvalidMaxResultsException = {};
  declare type CloudTrail$20131101$InvalidNextTokenException = {};
  declare type CloudTrail$20131101$InvalidParameterCombinationException = {};
  declare type CloudTrail$20131101$InvalidS3BucketNameException = {};
  declare type CloudTrail$20131101$InvalidS3PrefixException = {};
  declare type CloudTrail$20131101$InvalidSnsTopicNameException = {};
  declare type CloudTrail$20131101$InvalidTagParameterException = {};
  declare type CloudTrail$20131101$InvalidTimeRangeException = {};
  declare type CloudTrail$20131101$InvalidTokenException = {};
  declare type CloudTrail$20131101$InvalidTrailNameException = {};
  declare type CloudTrail$20131101$KmsException = {};
  declare type CloudTrail$20131101$KmsKeyDisabledException = {};
  declare type CloudTrail$20131101$KmsKeyNotFoundException = {};
  declare type CloudTrail$20131101$ListPublicKeysRequest = {
    StartTime?: Date;
    EndTime?: Date;
    NextToken?: string;
  };
  declare type CloudTrail$20131101$ListPublicKeysResponse = {
    PublicKeyList?: CloudTrail$20131101$PublicKeyList;
    NextToken?: string;
  };
  declare type CloudTrail$20131101$ListTagsRequest = {
    ResourceIdList: CloudTrail$20131101$ResourceIdList;
    NextToken?: string;
  };
  declare type CloudTrail$20131101$ListTagsResponse = {
    ResourceTagList?: CloudTrail$20131101$ResourceTagList;
    NextToken?: string;
  };
  declare type CloudTrail$20131101$LookupAttribute = {
    AttributeKey: 'EventId' | 'EventName' | 'Username' | 'ResourceType' | 'ResourceName';
    AttributeValue: string;
  };
  declare type CloudTrail$20131101$LookupAttributeKey = 'EventId' | 'EventName' | 'Username' | 'ResourceType' | 'ResourceName';
  declare type CloudTrail$20131101$LookupAttributesList = CloudTrail$20131101$LookupAttribute[];
  declare type CloudTrail$20131101$LookupEventsRequest = {
    LookupAttributes?: CloudTrail$20131101$LookupAttributesList;
    StartTime?: Date;
    EndTime?: Date;
    MaxResults?: number;
    NextToken?: string;
  };
  declare type CloudTrail$20131101$LookupEventsResponse = {
    Events?: CloudTrail$20131101$EventsList;
    NextToken?: string;
  };
  declare type CloudTrail$20131101$MaximumNumberOfTrailsExceededException = {};
  declare type CloudTrail$20131101$OperationNotPermittedException = {};
  declare type CloudTrail$20131101$PublicKey = {
    Value?: Buffer | $TypedArray | Blob | string;
    ValidityStartTime?: Date;
    ValidityEndTime?: Date;
    Fingerprint?: string;
  };
  declare type CloudTrail$20131101$PublicKeyList = CloudTrail$20131101$PublicKey[];
  declare type CloudTrail$20131101$RemoveTagsRequest = {
    ResourceId: string;
    TagsList?: CloudTrail$20131101$TagsList;
  };
  declare type CloudTrail$20131101$RemoveTagsResponse = {};
  declare type CloudTrail$20131101$Resource = {
    ResourceType?: string;
    ResourceName?: string;
  };
  declare type CloudTrail$20131101$ResourceIdList = string[];
  declare type CloudTrail$20131101$ResourceList = CloudTrail$20131101$Resource[];
  declare type CloudTrail$20131101$ResourceNotFoundException = {};
  declare type CloudTrail$20131101$ResourceTag = {
    ResourceId?: string;
    TagsList?: CloudTrail$20131101$TagsList;
  };
  declare type CloudTrail$20131101$ResourceTagList = CloudTrail$20131101$ResourceTag[];
  declare type CloudTrail$20131101$ResourceTypeNotSupportedException = {};
  declare type CloudTrail$20131101$S3BucketDoesNotExistException = {};
  declare type CloudTrail$20131101$StartLoggingRequest = {
    Name: string;
  };
  declare type CloudTrail$20131101$StartLoggingResponse = {};
  declare type CloudTrail$20131101$StopLoggingRequest = {
    Name: string;
  };
  declare type CloudTrail$20131101$StopLoggingResponse = {};
  declare type CloudTrail$20131101$Tag = {
    Key: string;
    Value?: string;
  };
  declare type CloudTrail$20131101$TagsLimitExceededException = {};
  declare type CloudTrail$20131101$TagsList = CloudTrail$20131101$Tag[];
  declare type CloudTrail$20131101$Trail = {
    Name?: string;
    S3BucketName?: string;
    S3KeyPrefix?: string;
    SnsTopicName?: string;
    SnsTopicARN?: string;
    IncludeGlobalServiceEvents?: boolean;
    IsMultiRegionTrail?: boolean;
    HomeRegion?: string;
    TrailARN?: string;
    LogFileValidationEnabled?: boolean;
    CloudWatchLogsLogGroupArn?: string;
    CloudWatchLogsRoleArn?: string;
    KmsKeyId?: string;
  };
  declare type CloudTrail$20131101$TrailAlreadyExistsException = {};
  declare type CloudTrail$20131101$TrailList = CloudTrail$20131101$Trail[];
  declare type CloudTrail$20131101$TrailNameList = string[];
  declare type CloudTrail$20131101$TrailNotFoundException = {};
  declare type CloudTrail$20131101$TrailNotProvidedException = {};
  declare type CloudTrail$20131101$UnsupportedOperationException = {};
  declare type CloudTrail$20131101$UpdateTrailRequest = {
    Name: string;
    S3BucketName?: string;
    S3KeyPrefix?: string;
    SnsTopicName?: string;
    IncludeGlobalServiceEvents?: boolean;
    IsMultiRegionTrail?: boolean;
    EnableLogFileValidation?: boolean;
    CloudWatchLogsLogGroupArn?: string;
    CloudWatchLogsRoleArn?: string;
    KmsKeyId?: string;
  };
  declare type CloudTrail$20131101$UpdateTrailResponse = {
    Name?: string;
    S3BucketName?: string;
    S3KeyPrefix?: string;
    SnsTopicName?: string;
    SnsTopicARN?: string;
    IncludeGlobalServiceEvents?: boolean;
    IsMultiRegionTrail?: boolean;
    TrailARN?: string;
    LogFileValidationEnabled?: boolean;
    CloudWatchLogsLogGroupArn?: string;
    CloudWatchLogsRoleArn?: string;
    KmsKeyId?: string;
  };
  declare type CloudWatch$20100801$AlarmHistoryItem = {
    AlarmName?: string;
    Timestamp?: Date;
    HistoryItemType?: 'ConfigurationUpdate' | 'StateUpdate' | 'Action';
    HistorySummary?: string;
    HistoryData?: string;
  };
  declare type CloudWatch$20100801$AlarmHistoryItems = CloudWatch$20100801$AlarmHistoryItem[];
  declare type CloudWatch$20100801$AlarmNames = string[];
  declare type CloudWatch$20100801$ComparisonOperator = 'GreaterThanOrEqualToThreshold' | 'GreaterThanThreshold' | 'LessThanThreshold' | 'LessThanOrEqualToThreshold';
  declare type CloudWatch$20100801$Datapoint = {
    Timestamp?: Date;
    SampleCount?: number;
    Average?: number;
    Sum?: number;
    Minimum?: number;
    Maximum?: number;
    Unit?: 'Seconds' | 'Microseconds' | 'Milliseconds' | 'Bytes' | 'Kilobytes' | 'Megabytes' | 'Gigabytes' | 'Terabytes' | 'Bits' | 'Kilobits' | 'Megabits' | 'Gigabits' | 'Terabits' | 'Percent' | 'Count' | 'Bytes/Second' | 'Kilobytes/Second' | 'Megabytes/Second' | 'Gigabytes/Second' | 'Terabytes/Second' | 'Bits/Second' | 'Kilobits/Second' | 'Megabits/Second' | 'Gigabits/Second' | 'Terabits/Second' | 'Count/Second' | 'None';
  };
  declare type CloudWatch$20100801$Datapoints = CloudWatch$20100801$Datapoint[];
  declare type CloudWatch$20100801$DeleteAlarmsInput = {
    AlarmNames: CloudWatch$20100801$AlarmNames;
  };
  declare type CloudWatch$20100801$DescribeAlarmHistoryInput = {
    AlarmName?: string;
    HistoryItemType?: 'ConfigurationUpdate' | 'StateUpdate' | 'Action';
    StartDate?: Date;
    EndDate?: Date;
    MaxRecords?: number;
    NextToken?: string;
  };
  declare type CloudWatch$20100801$DescribeAlarmHistoryOutput = {
    AlarmHistoryItems?: CloudWatch$20100801$AlarmHistoryItems;
    NextToken?: string;
  };
  declare type CloudWatch$20100801$DescribeAlarmsForMetricInput = {
    MetricName: string;
    Namespace: string;
    Statistic?: 'SampleCount' | 'Average' | 'Sum' | 'Minimum' | 'Maximum';
    Dimensions?: CloudWatch$20100801$Dimensions;
    Period?: number;
    Unit?: 'Seconds' | 'Microseconds' | 'Milliseconds' | 'Bytes' | 'Kilobytes' | 'Megabytes' | 'Gigabytes' | 'Terabytes' | 'Bits' | 'Kilobits' | 'Megabits' | 'Gigabits' | 'Terabits' | 'Percent' | 'Count' | 'Bytes/Second' | 'Kilobytes/Second' | 'Megabytes/Second' | 'Gigabytes/Second' | 'Terabytes/Second' | 'Bits/Second' | 'Kilobits/Second' | 'Megabits/Second' | 'Gigabits/Second' | 'Terabits/Second' | 'Count/Second' | 'None';
  };
  declare type CloudWatch$20100801$DescribeAlarmsForMetricOutput = {
    MetricAlarms?: CloudWatch$20100801$MetricAlarms;
  };
  declare type CloudWatch$20100801$DescribeAlarmsInput = {
    AlarmNames?: CloudWatch$20100801$AlarmNames;
    AlarmNamePrefix?: string;
    StateValue?: 'OK' | 'ALARM' | 'INSUFFICIENT_DATA';
    ActionPrefix?: string;
    MaxRecords?: number;
    NextToken?: string;
  };
  declare type CloudWatch$20100801$DescribeAlarmsOutput = {
    MetricAlarms?: CloudWatch$20100801$MetricAlarms;
    NextToken?: string;
  };
  declare type CloudWatch$20100801$Dimension = {
    Name: string;
    Value: string;
  };
  declare type CloudWatch$20100801$DimensionFilter = {
    Name: string;
    Value?: string;
  };
  declare type CloudWatch$20100801$DimensionFilters = CloudWatch$20100801$DimensionFilter[];
  declare type CloudWatch$20100801$Dimensions = CloudWatch$20100801$Dimension[];
  declare type CloudWatch$20100801$DisableAlarmActionsInput = {
    AlarmNames: CloudWatch$20100801$AlarmNames;
  };
  declare type CloudWatch$20100801$EnableAlarmActionsInput = {
    AlarmNames: CloudWatch$20100801$AlarmNames;
  };
  declare type CloudWatch$20100801$GetMetricStatisticsInput = {
    Namespace: string;
    MetricName: string;
    Dimensions?: CloudWatch$20100801$Dimensions;
    StartTime: Date;
    EndTime: Date;
    Period: number;
    Statistics: CloudWatch$20100801$Statistics;
    Unit?: 'Seconds' | 'Microseconds' | 'Milliseconds' | 'Bytes' | 'Kilobytes' | 'Megabytes' | 'Gigabytes' | 'Terabytes' | 'Bits' | 'Kilobits' | 'Megabits' | 'Gigabits' | 'Terabits' | 'Percent' | 'Count' | 'Bytes/Second' | 'Kilobytes/Second' | 'Megabytes/Second' | 'Gigabytes/Second' | 'Terabytes/Second' | 'Bits/Second' | 'Kilobits/Second' | 'Megabits/Second' | 'Gigabits/Second' | 'Terabits/Second' | 'Count/Second' | 'None';
  };
  declare type CloudWatch$20100801$GetMetricStatisticsOutput = {
    Label?: string;
    Datapoints?: CloudWatch$20100801$Datapoints;
  };
  declare type CloudWatch$20100801$HistoryItemType = 'ConfigurationUpdate' | 'StateUpdate' | 'Action';
  declare type CloudWatch$20100801$InternalServiceFault = {
    Message?: string;
  };
  declare type CloudWatch$20100801$InvalidFormatFault = {
    message?: string;
  };
  declare type CloudWatch$20100801$InvalidNextToken = {
    message?: string;
  };
  declare type CloudWatch$20100801$InvalidParameterCombinationException = {
    message?: string;
  };
  declare type CloudWatch$20100801$InvalidParameterValueException = {
    message?: string;
  };
  declare type CloudWatch$20100801$LimitExceededFault = {
    message?: string;
  };
  declare type CloudWatch$20100801$ListMetricsInput = {
    Namespace?: string;
    MetricName?: string;
    Dimensions?: CloudWatch$20100801$DimensionFilters;
    NextToken?: string;
  };
  declare type CloudWatch$20100801$ListMetricsOutput = {
    Metrics?: CloudWatch$20100801$Metrics;
    NextToken?: string;
  };
  declare type CloudWatch$20100801$Metric = {
    Namespace?: string;
    MetricName?: string;
    Dimensions?: CloudWatch$20100801$Dimensions;
  };
  declare type CloudWatch$20100801$MetricAlarm = {
    AlarmName?: string;
    AlarmArn?: string;
    AlarmDescription?: string;
    AlarmConfigurationUpdatedTimestamp?: Date;
    ActionsEnabled?: boolean;
    OKActions?: CloudWatch$20100801$ResourceList;
    AlarmActions?: CloudWatch$20100801$ResourceList;
    InsufficientDataActions?: CloudWatch$20100801$ResourceList;
    StateValue?: 'OK' | 'ALARM' | 'INSUFFICIENT_DATA';
    StateReason?: string;
    StateReasonData?: string;
    StateUpdatedTimestamp?: Date;
    MetricName?: string;
    Namespace?: string;
    Statistic?: 'SampleCount' | 'Average' | 'Sum' | 'Minimum' | 'Maximum';
    Dimensions?: CloudWatch$20100801$Dimensions;
    Period?: number;
    Unit?: 'Seconds' | 'Microseconds' | 'Milliseconds' | 'Bytes' | 'Kilobytes' | 'Megabytes' | 'Gigabytes' | 'Terabytes' | 'Bits' | 'Kilobits' | 'Megabits' | 'Gigabits' | 'Terabits' | 'Percent' | 'Count' | 'Bytes/Second' | 'Kilobytes/Second' | 'Megabytes/Second' | 'Gigabytes/Second' | 'Terabytes/Second' | 'Bits/Second' | 'Kilobits/Second' | 'Megabits/Second' | 'Gigabits/Second' | 'Terabits/Second' | 'Count/Second' | 'None';
    EvaluationPeriods?: number;
    Threshold?: number;
    ComparisonOperator?: 'GreaterThanOrEqualToThreshold' | 'GreaterThanThreshold' | 'LessThanThreshold' | 'LessThanOrEqualToThreshold';
  };
  declare type CloudWatch$20100801$MetricAlarms = CloudWatch$20100801$MetricAlarm[];
  declare type CloudWatch$20100801$MetricData = CloudWatch$20100801$MetricDatum[];
  declare type CloudWatch$20100801$MetricDatum = {
    MetricName: string;
    Dimensions?: CloudWatch$20100801$Dimensions;
    Timestamp?: Date;
    Value?: number;
    StatisticValues?: CloudWatch$20100801$StatisticSet;
    Unit?: 'Seconds' | 'Microseconds' | 'Milliseconds' | 'Bytes' | 'Kilobytes' | 'Megabytes' | 'Gigabytes' | 'Terabytes' | 'Bits' | 'Kilobits' | 'Megabits' | 'Gigabits' | 'Terabits' | 'Percent' | 'Count' | 'Bytes/Second' | 'Kilobytes/Second' | 'Megabytes/Second' | 'Gigabytes/Second' | 'Terabytes/Second' | 'Bits/Second' | 'Kilobits/Second' | 'Megabits/Second' | 'Gigabits/Second' | 'Terabits/Second' | 'Count/Second' | 'None';
  };
  declare type CloudWatch$20100801$Metrics = CloudWatch$20100801$Metric[];
  declare type CloudWatch$20100801$MissingRequiredParameterException = {
    message?: string;
  };
  declare type CloudWatch$20100801$PutMetricAlarmInput = {
    AlarmName: string;
    AlarmDescription?: string;
    ActionsEnabled?: boolean;
    OKActions?: CloudWatch$20100801$ResourceList;
    AlarmActions?: CloudWatch$20100801$ResourceList;
    InsufficientDataActions?: CloudWatch$20100801$ResourceList;
    MetricName: string;
    Namespace: string;
    Statistic: 'SampleCount' | 'Average' | 'Sum' | 'Minimum' | 'Maximum';
    Dimensions?: CloudWatch$20100801$Dimensions;
    Period: number;
    Unit?: 'Seconds' | 'Microseconds' | 'Milliseconds' | 'Bytes' | 'Kilobytes' | 'Megabytes' | 'Gigabytes' | 'Terabytes' | 'Bits' | 'Kilobits' | 'Megabits' | 'Gigabits' | 'Terabits' | 'Percent' | 'Count' | 'Bytes/Second' | 'Kilobytes/Second' | 'Megabytes/Second' | 'Gigabytes/Second' | 'Terabytes/Second' | 'Bits/Second' | 'Kilobits/Second' | 'Megabits/Second' | 'Gigabits/Second' | 'Terabits/Second' | 'Count/Second' | 'None';
    EvaluationPeriods: number;
    Threshold: number;
    ComparisonOperator: 'GreaterThanOrEqualToThreshold' | 'GreaterThanThreshold' | 'LessThanThreshold' | 'LessThanOrEqualToThreshold';
  };
  declare type CloudWatch$20100801$PutMetricDataInput = {
    Namespace: string;
    MetricData: CloudWatch$20100801$MetricData;
  };
  declare type CloudWatch$20100801$ResourceList = string[];
  declare type CloudWatch$20100801$ResourceNotFound = {
    message?: string;
  };
  declare type CloudWatch$20100801$SetAlarmStateInput = {
    AlarmName: string;
    StateValue: 'OK' | 'ALARM' | 'INSUFFICIENT_DATA';
    StateReason: string;
    StateReasonData?: string;
  };
  declare type CloudWatch$20100801$StandardUnit = 'Seconds' | 'Microseconds' | 'Milliseconds' | 'Bytes' | 'Kilobytes' | 'Megabytes' | 'Gigabytes' | 'Terabytes' | 'Bits' | 'Kilobits' | 'Megabits' | 'Gigabits' | 'Terabits' | 'Percent' | 'Count' | 'Bytes/Second' | 'Kilobytes/Second' | 'Megabytes/Second' | 'Gigabytes/Second' | 'Terabytes/Second' | 'Bits/Second' | 'Kilobits/Second' | 'Megabits/Second' | 'Gigabits/Second' | 'Terabits/Second' | 'Count/Second' | 'None';
  declare type CloudWatch$20100801$StateValue = 'OK' | 'ALARM' | 'INSUFFICIENT_DATA';
  declare type CloudWatch$20100801$Statistic = 'SampleCount' | 'Average' | 'Sum' | 'Minimum' | 'Maximum';
  declare type CloudWatch$20100801$StatisticSet = {
    SampleCount: number;
    Sum: number;
    Minimum: number;
    Maximum: number;
  };
  declare type CloudWatch$20100801$Statistics = ('SampleCount' | 'Average' | 'Sum' | 'Minimum' | 'Maximum')[];
  declare type CloudWatch$20100801$Timestamp = Date;
  declare type CloudWatchEvents$20151007$ConcurrentModificationException = {};
  declare type CloudWatchEvents$20151007$DeleteRuleRequest = {
    Name: string;
  };
  declare type CloudWatchEvents$20151007$DescribeRuleRequest = {
    Name: string;
  };
  declare type CloudWatchEvents$20151007$DescribeRuleResponse = {
    Name?: string;
    Arn?: string;
    EventPattern?: string;
    ScheduleExpression?: string;
    State?: 'ENABLED' | 'DISABLED';
    Description?: string;
    RoleArn?: string;
  };
  declare type CloudWatchEvents$20151007$DisableRuleRequest = {
    Name: string;
  };
  declare type CloudWatchEvents$20151007$EnableRuleRequest = {
    Name: string;
  };
  declare type CloudWatchEvents$20151007$EventResourceList = string[];
  declare type CloudWatchEvents$20151007$EventTime = Date;
  declare type CloudWatchEvents$20151007$InternalException = {};
  declare type CloudWatchEvents$20151007$InvalidEventPatternException = {};
  declare type CloudWatchEvents$20151007$LimitExceededException = {};
  declare type CloudWatchEvents$20151007$ListRuleNamesByTargetRequest = {
    TargetArn: string;
    NextToken?: string;
    Limit?: number;
  };
  declare type CloudWatchEvents$20151007$ListRuleNamesByTargetResponse = {
    RuleNames?: CloudWatchEvents$20151007$RuleNameList;
    NextToken?: string;
  };
  declare type CloudWatchEvents$20151007$ListRulesRequest = {
    NamePrefix?: string;
    NextToken?: string;
    Limit?: number;
  };
  declare type CloudWatchEvents$20151007$ListRulesResponse = {
    Rules?: CloudWatchEvents$20151007$RuleResponseList;
    NextToken?: string;
  };
  declare type CloudWatchEvents$20151007$ListTargetsByRuleRequest = {
    Rule: string;
    NextToken?: string;
    Limit?: number;
  };
  declare type CloudWatchEvents$20151007$ListTargetsByRuleResponse = {
    Targets?: CloudWatchEvents$20151007$TargetList;
    NextToken?: string;
  };
  declare type CloudWatchEvents$20151007$PutEventsRequest = {
    Entries: CloudWatchEvents$20151007$PutEventsRequestEntryList;
  };
  declare type CloudWatchEvents$20151007$PutEventsRequestEntry = {
    Time?: Date;
    Source?: string;
    Resources?: CloudWatchEvents$20151007$EventResourceList;
    DetailType?: string;
    Detail?: string;
  };
  declare type CloudWatchEvents$20151007$PutEventsRequestEntryList = CloudWatchEvents$20151007$PutEventsRequestEntry[];
  declare type CloudWatchEvents$20151007$PutEventsResponse = {
    FailedEntryCount?: number;
    Entries?: CloudWatchEvents$20151007$PutEventsResultEntryList;
  };
  declare type CloudWatchEvents$20151007$PutEventsResultEntry = {
    EventId?: string;
    ErrorCode?: string;
    ErrorMessage?: string;
  };
  declare type CloudWatchEvents$20151007$PutEventsResultEntryList = CloudWatchEvents$20151007$PutEventsResultEntry[];
  declare type CloudWatchEvents$20151007$PutRuleRequest = {
    Name: string;
    ScheduleExpression?: string;
    EventPattern?: string;
    State?: 'ENABLED' | 'DISABLED';
    Description?: string;
    RoleArn?: string;
  };
  declare type CloudWatchEvents$20151007$PutRuleResponse = {
    RuleArn?: string;
  };
  declare type CloudWatchEvents$20151007$PutTargetsRequest = {
    Rule: string;
    Targets: CloudWatchEvents$20151007$TargetList;
  };
  declare type CloudWatchEvents$20151007$PutTargetsResponse = {
    FailedEntryCount?: number;
    FailedEntries?: CloudWatchEvents$20151007$PutTargetsResultEntryList;
  };
  declare type CloudWatchEvents$20151007$PutTargetsResultEntry = {
    TargetId?: string;
    ErrorCode?: string;
    ErrorMessage?: string;
  };
  declare type CloudWatchEvents$20151007$PutTargetsResultEntryList = CloudWatchEvents$20151007$PutTargetsResultEntry[];
  declare type CloudWatchEvents$20151007$RemoveTargetsRequest = {
    Rule: string;
    Ids: CloudWatchEvents$20151007$TargetIdList;
  };
  declare type CloudWatchEvents$20151007$RemoveTargetsResponse = {
    FailedEntryCount?: number;
    FailedEntries?: CloudWatchEvents$20151007$RemoveTargetsResultEntryList;
  };
  declare type CloudWatchEvents$20151007$RemoveTargetsResultEntry = {
    TargetId?: string;
    ErrorCode?: string;
    ErrorMessage?: string;
  };
  declare type CloudWatchEvents$20151007$RemoveTargetsResultEntryList = CloudWatchEvents$20151007$RemoveTargetsResultEntry[];
  declare type CloudWatchEvents$20151007$ResourceNotFoundException = {};
  declare type CloudWatchEvents$20151007$Rule = {
    Name?: string;
    Arn?: string;
    EventPattern?: string;
    State?: 'ENABLED' | 'DISABLED';
    Description?: string;
    ScheduleExpression?: string;
    RoleArn?: string;
  };
  declare type CloudWatchEvents$20151007$RuleNameList = string[];
  declare type CloudWatchEvents$20151007$RuleResponseList = CloudWatchEvents$20151007$Rule[];
  declare type CloudWatchEvents$20151007$RuleState = 'ENABLED' | 'DISABLED';
  declare type CloudWatchEvents$20151007$Target = {
    Id: string;
    Arn: string;
    Input?: string;
    InputPath?: string;
  };
  declare type CloudWatchEvents$20151007$TargetIdList = string[];
  declare type CloudWatchEvents$20151007$TargetList = CloudWatchEvents$20151007$Target[];
  declare type CloudWatchEvents$20151007$TestEventPatternRequest = {
    EventPattern: string;
    Event: string;
  };
  declare type CloudWatchEvents$20151007$TestEventPatternResponse = {
    Result?: boolean;
  };
  declare type CloudWatchLogs$20140328$CancelExportTaskRequest = {
    taskId: string;
  };
  declare type CloudWatchLogs$20140328$CreateExportTaskRequest = {
    taskName?: string;
    logGroupName: string;
    logStreamNamePrefix?: string;
    from: number;
    to: number;
    destination: string;
    destinationPrefix?: string;
  };
  declare type CloudWatchLogs$20140328$CreateExportTaskResponse = {
    taskId?: string;
  };
  declare type CloudWatchLogs$20140328$CreateLogGroupRequest = {
    logGroupName: string;
  };
  declare type CloudWatchLogs$20140328$CreateLogStreamRequest = {
    logGroupName: string;
    logStreamName: string;
  };
  declare type CloudWatchLogs$20140328$DataAlreadyAcceptedException = {
    expectedSequenceToken?: string;
  };
  declare type CloudWatchLogs$20140328$DeleteDestinationRequest = {
    destinationName: string;
  };
  declare type CloudWatchLogs$20140328$DeleteLogGroupRequest = {
    logGroupName: string;
  };
  declare type CloudWatchLogs$20140328$DeleteLogStreamRequest = {
    logGroupName: string;
    logStreamName: string;
  };
  declare type CloudWatchLogs$20140328$DeleteMetricFilterRequest = {
    logGroupName: string;
    filterName: string;
  };
  declare type CloudWatchLogs$20140328$DeleteRetentionPolicyRequest = {
    logGroupName: string;
  };
  declare type CloudWatchLogs$20140328$DeleteSubscriptionFilterRequest = {
    logGroupName: string;
    filterName: string;
  };
  declare type CloudWatchLogs$20140328$DescribeDestinationsRequest = {
    DestinationNamePrefix?: string;
    nextToken?: string;
    limit?: number;
  };
  declare type CloudWatchLogs$20140328$DescribeDestinationsResponse = {
    destinations?: CloudWatchLogs$20140328$Destinations;
    nextToken?: string;
  };
  declare type CloudWatchLogs$20140328$DescribeExportTasksRequest = {
    taskId?: string;
    statusCode?: 'CANCELLED' | 'COMPLETED' | 'FAILED' | 'PENDING' | 'PENDING_CANCEL' | 'RUNNING';
    nextToken?: string;
    limit?: number;
  };
  declare type CloudWatchLogs$20140328$DescribeExportTasksResponse = {
    exportTasks?: CloudWatchLogs$20140328$ExportTasks;
    nextToken?: string;
  };
  declare type CloudWatchLogs$20140328$DescribeLogGroupsRequest = {
    logGroupNamePrefix?: string;
    nextToken?: string;
    limit?: number;
  };
  declare type CloudWatchLogs$20140328$DescribeLogGroupsResponse = {
    logGroups?: CloudWatchLogs$20140328$LogGroups;
    nextToken?: string;
  };
  declare type CloudWatchLogs$20140328$DescribeLogStreamsRequest = {
    logGroupName: string;
    logStreamNamePrefix?: string;
    orderBy?: 'LogStreamName' | 'LastEventTime';
    descending?: boolean;
    nextToken?: string;
    limit?: number;
  };
  declare type CloudWatchLogs$20140328$DescribeLogStreamsResponse = {
    logStreams?: CloudWatchLogs$20140328$LogStreams;
    nextToken?: string;
  };
  declare type CloudWatchLogs$20140328$DescribeMetricFiltersRequest = {
    logGroupName: string;
    filterNamePrefix?: string;
    nextToken?: string;
    limit?: number;
  };
  declare type CloudWatchLogs$20140328$DescribeMetricFiltersResponse = {
    metricFilters?: CloudWatchLogs$20140328$MetricFilters;
    nextToken?: string;
  };
  declare type CloudWatchLogs$20140328$DescribeSubscriptionFiltersRequest = {
    logGroupName: string;
    filterNamePrefix?: string;
    nextToken?: string;
    limit?: number;
  };
  declare type CloudWatchLogs$20140328$DescribeSubscriptionFiltersResponse = {
    subscriptionFilters?: CloudWatchLogs$20140328$SubscriptionFilters;
    nextToken?: string;
  };
  declare type CloudWatchLogs$20140328$Destination = {
    destinationName?: string;
    targetArn?: string;
    roleArn?: string;
    accessPolicy?: string;
    arn?: string;
    creationTime?: number;
  };
  declare type CloudWatchLogs$20140328$Destinations = CloudWatchLogs$20140328$Destination[];
  declare type CloudWatchLogs$20140328$ExportTask = {
    taskId?: string;
    taskName?: string;
    logGroupName?: string;
    from?: number;
    to?: number;
    destination?: string;
    destinationPrefix?: string;
    status?: CloudWatchLogs$20140328$ExportTaskStatus;
    executionInfo?: CloudWatchLogs$20140328$ExportTaskExecutionInfo;
  };
  declare type CloudWatchLogs$20140328$ExportTaskExecutionInfo = {
    creationTime?: number;
    completionTime?: number;
  };
  declare type CloudWatchLogs$20140328$ExportTaskStatus = {
    code?: 'CANCELLED' | 'COMPLETED' | 'FAILED' | 'PENDING' | 'PENDING_CANCEL' | 'RUNNING';
    message?: string;
  };
  declare type CloudWatchLogs$20140328$ExportTaskStatusCode = 'CANCELLED' | 'COMPLETED' | 'FAILED' | 'PENDING' | 'PENDING_CANCEL' | 'RUNNING';
  declare type CloudWatchLogs$20140328$ExportTasks = CloudWatchLogs$20140328$ExportTask[];
  declare type CloudWatchLogs$20140328$ExtractedValues = {
    [key: string]: string;
  };
  declare type CloudWatchLogs$20140328$FilterLogEventsRequest = {
    logGroupName: string;
    logStreamNames?: CloudWatchLogs$20140328$InputLogStreamNames;
    startTime?: number;
    endTime?: number;
    filterPattern?: string;
    nextToken?: string;
    limit?: number;
    interleaved?: boolean;
  };
  declare type CloudWatchLogs$20140328$FilterLogEventsResponse = {
    events?: CloudWatchLogs$20140328$FilteredLogEvents;
    searchedLogStreams?: CloudWatchLogs$20140328$SearchedLogStreams;
    nextToken?: string;
  };
  declare type CloudWatchLogs$20140328$FilteredLogEvent = {
    logStreamName?: string;
    timestamp?: number;
    message?: string;
    ingestionTime?: number;
    eventId?: string;
  };
  declare type CloudWatchLogs$20140328$FilteredLogEvents = CloudWatchLogs$20140328$FilteredLogEvent[];
  declare type CloudWatchLogs$20140328$GetLogEventsRequest = {
    logGroupName: string;
    logStreamName: string;
    startTime?: number;
    endTime?: number;
    nextToken?: string;
    limit?: number;
    startFromHead?: boolean;
  };
  declare type CloudWatchLogs$20140328$GetLogEventsResponse = {
    events?: CloudWatchLogs$20140328$OutputLogEvents;
    nextForwardToken?: string;
    nextBackwardToken?: string;
  };
  declare type CloudWatchLogs$20140328$InputLogEvent = {
    timestamp: number;
    message: string;
  };
  declare type CloudWatchLogs$20140328$InputLogEvents = CloudWatchLogs$20140328$InputLogEvent[];
  declare type CloudWatchLogs$20140328$InputLogStreamNames = string[];
  declare type CloudWatchLogs$20140328$InvalidOperationException = {};
  declare type CloudWatchLogs$20140328$InvalidParameterException = {};
  declare type CloudWatchLogs$20140328$InvalidSequenceTokenException = {
    expectedSequenceToken?: string;
  };
  declare type CloudWatchLogs$20140328$LimitExceededException = {};
  declare type CloudWatchLogs$20140328$LogGroup = {
    logGroupName?: string;
    creationTime?: number;
    retentionInDays?: number;
    metricFilterCount?: number;
    arn?: string;
    storedBytes?: number;
  };
  declare type CloudWatchLogs$20140328$LogGroups = CloudWatchLogs$20140328$LogGroup[];
  declare type CloudWatchLogs$20140328$LogStream = {
    logStreamName?: string;
    creationTime?: number;
    firstEventTimestamp?: number;
    lastEventTimestamp?: number;
    lastIngestionTime?: number;
    uploadSequenceToken?: string;
    arn?: string;
    storedBytes?: number;
  };
  declare type CloudWatchLogs$20140328$LogStreams = CloudWatchLogs$20140328$LogStream[];
  declare type CloudWatchLogs$20140328$MetricFilter = {
    filterName?: string;
    filterPattern?: string;
    metricTransformations?: CloudWatchLogs$20140328$MetricTransformations;
    creationTime?: number;
  };
  declare type CloudWatchLogs$20140328$MetricFilterMatchRecord = {
    eventNumber?: number;
    eventMessage?: string;
    extractedValues?: {
      [key: string]: string;
    };
  };
  declare type CloudWatchLogs$20140328$MetricFilterMatches = CloudWatchLogs$20140328$MetricFilterMatchRecord[];
  declare type CloudWatchLogs$20140328$MetricFilters = CloudWatchLogs$20140328$MetricFilter[];
  declare type CloudWatchLogs$20140328$MetricTransformation = {
    metricName: string;
    metricNamespace: string;
    metricValue: string;
    defaultValue?: number;
  };
  declare type CloudWatchLogs$20140328$MetricTransformations = CloudWatchLogs$20140328$MetricTransformation[];
  declare type CloudWatchLogs$20140328$OperationAbortedException = {};
  declare type CloudWatchLogs$20140328$OrderBy = 'LogStreamName' | 'LastEventTime';
  declare type CloudWatchLogs$20140328$OutputLogEvent = {
    timestamp?: number;
    message?: string;
    ingestionTime?: number;
  };
  declare type CloudWatchLogs$20140328$OutputLogEvents = CloudWatchLogs$20140328$OutputLogEvent[];
  declare type CloudWatchLogs$20140328$PutDestinationPolicyRequest = {
    destinationName: string;
    accessPolicy: string;
  };
  declare type CloudWatchLogs$20140328$PutDestinationRequest = {
    destinationName: string;
    targetArn: string;
    roleArn: string;
  };
  declare type CloudWatchLogs$20140328$PutDestinationResponse = {
    destination?: CloudWatchLogs$20140328$Destination;
  };
  declare type CloudWatchLogs$20140328$PutLogEventsRequest = {
    logGroupName: string;
    logStreamName: string;
    logEvents: CloudWatchLogs$20140328$InputLogEvents;
    sequenceToken?: string;
  };
  declare type CloudWatchLogs$20140328$PutLogEventsResponse = {
    nextSequenceToken?: string;
    rejectedLogEventsInfo?: CloudWatchLogs$20140328$RejectedLogEventsInfo;
  };
  declare type CloudWatchLogs$20140328$PutMetricFilterRequest = {
    logGroupName: string;
    filterName: string;
    filterPattern: string;
    metricTransformations: CloudWatchLogs$20140328$MetricTransformations;
  };
  declare type CloudWatchLogs$20140328$PutRetentionPolicyRequest = {
    logGroupName: string;
    retentionInDays: number;
  };
  declare type CloudWatchLogs$20140328$PutSubscriptionFilterRequest = {
    logGroupName: string;
    filterName: string;
    filterPattern: string;
    destinationArn: string;
    roleArn?: string;
  };
  declare type CloudWatchLogs$20140328$RejectedLogEventsInfo = {
    tooNewLogEventStartIndex?: number;
    tooOldLogEventEndIndex?: number;
    expiredLogEventEndIndex?: number;
  };
  declare type CloudWatchLogs$20140328$ResourceAlreadyExistsException = {};
  declare type CloudWatchLogs$20140328$ResourceNotFoundException = {};
  declare type CloudWatchLogs$20140328$SearchedLogStream = {
    logStreamName?: string;
    searchedCompletely?: boolean;
  };
  declare type CloudWatchLogs$20140328$SearchedLogStreams = CloudWatchLogs$20140328$SearchedLogStream[];
  declare type CloudWatchLogs$20140328$ServiceUnavailableException = {};
  declare type CloudWatchLogs$20140328$SubscriptionFilter = {
    filterName?: string;
    logGroupName?: string;
    filterPattern?: string;
    destinationArn?: string;
    roleArn?: string;
    creationTime?: number;
  };
  declare type CloudWatchLogs$20140328$SubscriptionFilters = CloudWatchLogs$20140328$SubscriptionFilter[];
  declare type CloudWatchLogs$20140328$TestEventMessages = string[];
  declare type CloudWatchLogs$20140328$TestMetricFilterRequest = {
    filterPattern: string;
    logEventMessages: CloudWatchLogs$20140328$TestEventMessages;
  };
  declare type CloudWatchLogs$20140328$TestMetricFilterResponse = {
    matches?: CloudWatchLogs$20140328$MetricFilterMatches;
  };
  declare type CodeCommit$20150413$BatchGetRepositoriesInput = {
    repositoryNames: CodeCommit$20150413$RepositoryNameList;
  };
  declare type CodeCommit$20150413$BatchGetRepositoriesOutput = {
    repositories?: CodeCommit$20150413$RepositoryMetadataList;
    repositoriesNotFound?: CodeCommit$20150413$RepositoryNotFoundList;
  };
  declare type CodeCommit$20150413$BranchDoesNotExistException = {};
  declare type CodeCommit$20150413$BranchInfo = {
    branchName?: string;
    commitId?: string;
  };
  declare type CodeCommit$20150413$BranchNameExistsException = {};
  declare type CodeCommit$20150413$BranchNameList = string[];
  declare type CodeCommit$20150413$BranchNameRequiredException = {};
  declare type CodeCommit$20150413$Commit = {
    treeId?: string;
    parents?: CodeCommit$20150413$ParentList;
    message?: string;
    author?: CodeCommit$20150413$UserInfo;
    committer?: CodeCommit$20150413$UserInfo;
    additionalData?: string;
  };
  declare type CodeCommit$20150413$CommitDoesNotExistException = {};
  declare type CodeCommit$20150413$CommitIdDoesNotExistException = {};
  declare type CodeCommit$20150413$CommitIdRequiredException = {};
  declare type CodeCommit$20150413$CreateBranchInput = {
    repositoryName: string;
    branchName: string;
    commitId: string;
  };
  declare type CodeCommit$20150413$CreateRepositoryInput = {
    repositoryName: string;
    repositoryDescription?: string;
  };
  declare type CodeCommit$20150413$CreateRepositoryOutput = {
    repositoryMetadata?: CodeCommit$20150413$RepositoryMetadata;
  };
  declare type CodeCommit$20150413$CreationDate = Date;
  declare type CodeCommit$20150413$DeleteRepositoryInput = {
    repositoryName: string;
  };
  declare type CodeCommit$20150413$DeleteRepositoryOutput = {
    repositoryId?: string;
  };
  declare type CodeCommit$20150413$EncryptionIntegrityChecksFailedException = {};
  declare type CodeCommit$20150413$EncryptionKeyAccessDeniedException = {};
  declare type CodeCommit$20150413$EncryptionKeyDisabledException = {};
  declare type CodeCommit$20150413$EncryptionKeyNotFoundException = {};
  declare type CodeCommit$20150413$EncryptionKeyUnavailableException = {};
  declare type CodeCommit$20150413$GetBranchInput = {
    repositoryName?: string;
    branchName?: string;
  };
  declare type CodeCommit$20150413$GetBranchOutput = {
    branch?: CodeCommit$20150413$BranchInfo;
  };
  declare type CodeCommit$20150413$GetCommitInput = {
    repositoryName: string;
    commitId: string;
  };
  declare type CodeCommit$20150413$GetCommitOutput = {
    commit: CodeCommit$20150413$Commit;
  };
  declare type CodeCommit$20150413$GetRepositoryInput = {
    repositoryName: string;
  };
  declare type CodeCommit$20150413$GetRepositoryOutput = {
    repositoryMetadata?: CodeCommit$20150413$RepositoryMetadata;
  };
  declare type CodeCommit$20150413$GetRepositoryTriggersInput = {
    repositoryName?: string;
  };
  declare type CodeCommit$20150413$GetRepositoryTriggersOutput = {
    configurationId?: string;
    triggers?: CodeCommit$20150413$RepositoryTriggersList;
  };
  declare type CodeCommit$20150413$InvalidBranchNameException = {};
  declare type CodeCommit$20150413$InvalidCommitIdException = {};
  declare type CodeCommit$20150413$InvalidContinuationTokenException = {};
  declare type CodeCommit$20150413$InvalidOrderException = {};
  declare type CodeCommit$20150413$InvalidRepositoryDescriptionException = {};
  declare type CodeCommit$20150413$InvalidRepositoryNameException = {};
  declare type CodeCommit$20150413$InvalidRepositoryTriggerBranchNameException = {};
  declare type CodeCommit$20150413$InvalidRepositoryTriggerCustomDataException = {};
  declare type CodeCommit$20150413$InvalidRepositoryTriggerDestinationArnException = {};
  declare type CodeCommit$20150413$InvalidRepositoryTriggerEventsException = {};
  declare type CodeCommit$20150413$InvalidRepositoryTriggerNameException = {};
  declare type CodeCommit$20150413$InvalidRepositoryTriggerRegionException = {};
  declare type CodeCommit$20150413$InvalidSortByException = {};
  declare type CodeCommit$20150413$LastModifiedDate = Date;
  declare type CodeCommit$20150413$ListBranchesInput = {
    repositoryName: string;
    nextToken?: string;
  };
  declare type CodeCommit$20150413$ListBranchesOutput = {
    branches?: CodeCommit$20150413$BranchNameList;
    nextToken?: string;
  };
  declare type CodeCommit$20150413$ListRepositoriesInput = {
    nextToken?: string;
    sortBy?: 'repositoryName' | 'lastModifiedDate';
    order?: 'ascending' | 'descending';
  };
  declare type CodeCommit$20150413$ListRepositoriesOutput = {
    repositories?: CodeCommit$20150413$RepositoryNameIdPairList;
    nextToken?: string;
  };
  declare type CodeCommit$20150413$MaximumBranchesExceededException = {};
  declare type CodeCommit$20150413$MaximumRepositoryNamesExceededException = {};
  declare type CodeCommit$20150413$MaximumRepositoryTriggersExceededException = {};
  declare type CodeCommit$20150413$OrderEnum = 'ascending' | 'descending';
  declare type CodeCommit$20150413$ParentList = string[];
  declare type CodeCommit$20150413$PutRepositoryTriggersInput = {
    repositoryName?: string;
    triggers?: CodeCommit$20150413$RepositoryTriggersList;
  };
  declare type CodeCommit$20150413$PutRepositoryTriggersOutput = {
    configurationId?: string;
  };
  declare type CodeCommit$20150413$RepositoryDoesNotExistException = {};
  declare type CodeCommit$20150413$RepositoryLimitExceededException = {};
  declare type CodeCommit$20150413$RepositoryMetadata = {
    accountId?: string;
    repositoryId?: string;
    repositoryName?: string;
    repositoryDescription?: string;
    defaultBranch?: string;
    lastModifiedDate?: Date;
    creationDate?: Date;
    cloneUrlHttp?: string;
    cloneUrlSsh?: string;
    Arn?: string;
  };
  declare type CodeCommit$20150413$RepositoryMetadataList = CodeCommit$20150413$RepositoryMetadata[];
  declare type CodeCommit$20150413$RepositoryNameExistsException = {};
  declare type CodeCommit$20150413$RepositoryNameIdPair = {
    repositoryName?: string;
    repositoryId?: string;
  };
  declare type CodeCommit$20150413$RepositoryNameIdPairList = CodeCommit$20150413$RepositoryNameIdPair[];
  declare type CodeCommit$20150413$RepositoryNameList = string[];
  declare type CodeCommit$20150413$RepositoryNameRequiredException = {};
  declare type CodeCommit$20150413$RepositoryNamesRequiredException = {};
  declare type CodeCommit$20150413$RepositoryNotFoundList = string[];
  declare type CodeCommit$20150413$RepositoryTrigger = {
    name?: string;
    destinationArn?: string;
    customData?: string;
    branches?: CodeCommit$20150413$BranchNameList;
    events?: CodeCommit$20150413$RepositoryTriggerEventList;
  };
  declare type CodeCommit$20150413$RepositoryTriggerBranchNameListRequiredException = {};
  declare type CodeCommit$20150413$RepositoryTriggerDestinationArnRequiredException = {};
  declare type CodeCommit$20150413$RepositoryTriggerEventEnum = 'all' | 'updateReference' | 'createReference' | 'deleteReference';
  declare type CodeCommit$20150413$RepositoryTriggerEventList = ('all' | 'updateReference' | 'createReference' | 'deleteReference')[];
  declare type CodeCommit$20150413$RepositoryTriggerEventsListRequiredException = {};
  declare type CodeCommit$20150413$RepositoryTriggerExecutionFailure = {
    trigger?: string;
    failureMessage?: string;
  };
  declare type CodeCommit$20150413$RepositoryTriggerExecutionFailureList = CodeCommit$20150413$RepositoryTriggerExecutionFailure[];
  declare type CodeCommit$20150413$RepositoryTriggerNameList = string[];
  declare type CodeCommit$20150413$RepositoryTriggerNameRequiredException = {};
  declare type CodeCommit$20150413$RepositoryTriggersList = CodeCommit$20150413$RepositoryTrigger[];
  declare type CodeCommit$20150413$RepositoryTriggersListRequiredException = {};
  declare type CodeCommit$20150413$SortByEnum = 'repositoryName' | 'lastModifiedDate';
  declare type CodeCommit$20150413$TestRepositoryTriggersInput = {
    repositoryName?: string;
    triggers?: CodeCommit$20150413$RepositoryTriggersList;
  };
  declare type CodeCommit$20150413$TestRepositoryTriggersOutput = {
    successfulExecutions?: CodeCommit$20150413$RepositoryTriggerNameList;
    failedExecutions?: CodeCommit$20150413$RepositoryTriggerExecutionFailureList;
  };
  declare type CodeCommit$20150413$UpdateDefaultBranchInput = {
    repositoryName: string;
    defaultBranchName: string;
  };
  declare type CodeCommit$20150413$UpdateRepositoryDescriptionInput = {
    repositoryName: string;
    repositoryDescription?: string;
  };
  declare type CodeCommit$20150413$UpdateRepositoryNameInput = {
    oldName: string;
    newName: string;
  };
  declare type CodeCommit$20150413$UserInfo = {
    name?: string;
    email?: string;
    date?: string;
  };
  declare type CodeDeploy$20141006$AddTagsToOnPremisesInstancesInput = {
    tags: CodeDeploy$20141006$TagList;
    instanceNames: CodeDeploy$20141006$InstanceNameList;
  };
  declare type CodeDeploy$20141006$ApplicationAlreadyExistsException = {};
  declare type CodeDeploy$20141006$ApplicationDoesNotExistException = {};
  declare type CodeDeploy$20141006$ApplicationInfo = {
    applicationId?: string;
    applicationName?: string;
    createTime?: Date;
    linkedToGitHub?: boolean;
  };
  declare type CodeDeploy$20141006$ApplicationLimitExceededException = {};
  declare type CodeDeploy$20141006$ApplicationNameRequiredException = {};
  declare type CodeDeploy$20141006$ApplicationRevisionSortBy = 'registerTime' | 'firstUsedTime' | 'lastUsedTime';
  declare type CodeDeploy$20141006$ApplicationsInfoList = CodeDeploy$20141006$ApplicationInfo[];
  declare type CodeDeploy$20141006$ApplicationsList = string[];
  declare type CodeDeploy$20141006$AutoScalingGroup = {
    name?: string;
    hook?: string;
  };
  declare type CodeDeploy$20141006$AutoScalingGroupList = CodeDeploy$20141006$AutoScalingGroup[];
  declare type CodeDeploy$20141006$AutoScalingGroupNameList = string[];
  declare type CodeDeploy$20141006$BatchGetApplicationRevisionsInput = {
    applicationName: string;
    revisions: CodeDeploy$20141006$RevisionLocationList;
  };
  declare type CodeDeploy$20141006$BatchGetApplicationRevisionsOutput = {
    applicationName?: string;
    errorMessage?: string;
    revisions?: CodeDeploy$20141006$RevisionInfoList;
  };
  declare type CodeDeploy$20141006$BatchGetApplicationsInput = {
    applicationNames?: CodeDeploy$20141006$ApplicationsList;
  };
  declare type CodeDeploy$20141006$BatchGetApplicationsOutput = {
    applicationsInfo?: CodeDeploy$20141006$ApplicationsInfoList;
  };
  declare type CodeDeploy$20141006$BatchGetDeploymentGroupsInput = {
    applicationName: string;
    deploymentGroupNames: CodeDeploy$20141006$DeploymentGroupsList;
  };
  declare type CodeDeploy$20141006$BatchGetDeploymentGroupsOutput = {
    deploymentGroupsInfo?: CodeDeploy$20141006$DeploymentGroupInfoList;
    errorMessage?: string;
  };
  declare type CodeDeploy$20141006$BatchGetDeploymentInstancesInput = {
    deploymentId: string;
    instanceIds: CodeDeploy$20141006$InstancesList;
  };
  declare type CodeDeploy$20141006$BatchGetDeploymentInstancesOutput = {
    instancesSummary?: CodeDeploy$20141006$InstanceSummaryList;
    errorMessage?: string;
  };
  declare type CodeDeploy$20141006$BatchGetDeploymentsInput = {
    deploymentIds?: CodeDeploy$20141006$DeploymentsList;
  };
  declare type CodeDeploy$20141006$BatchGetDeploymentsOutput = {
    deploymentsInfo?: CodeDeploy$20141006$DeploymentsInfoList;
  };
  declare type CodeDeploy$20141006$BatchGetOnPremisesInstancesInput = {
    instanceNames?: CodeDeploy$20141006$InstanceNameList;
  };
  declare type CodeDeploy$20141006$BatchGetOnPremisesInstancesOutput = {
    instanceInfos?: CodeDeploy$20141006$InstanceInfoList;
  };
  declare type CodeDeploy$20141006$BatchLimitExceededException = {};
  declare type CodeDeploy$20141006$BucketNameFilterRequiredException = {};
  declare type CodeDeploy$20141006$BundleType = 'tar' | 'tgz' | 'zip';
  declare type CodeDeploy$20141006$CreateApplicationInput = {
    applicationName: string;
  };
  declare type CodeDeploy$20141006$CreateApplicationOutput = {
    applicationId?: string;
  };
  declare type CodeDeploy$20141006$CreateDeploymentConfigInput = {
    deploymentConfigName: string;
    minimumHealthyHosts?: CodeDeploy$20141006$MinimumHealthyHosts;
  };
  declare type CodeDeploy$20141006$CreateDeploymentConfigOutput = {
    deploymentConfigId?: string;
  };
  declare type CodeDeploy$20141006$CreateDeploymentGroupInput = {
    applicationName: string;
    deploymentGroupName: string;
    deploymentConfigName?: string;
    ec2TagFilters?: CodeDeploy$20141006$EC2TagFilterList;
    onPremisesInstanceTagFilters?: CodeDeploy$20141006$TagFilterList;
    autoScalingGroups?: CodeDeploy$20141006$AutoScalingGroupNameList;
    serviceRoleArn: string;
    triggerConfigurations?: CodeDeploy$20141006$TriggerConfigList;
  };
  declare type CodeDeploy$20141006$CreateDeploymentGroupOutput = {
    deploymentGroupId?: string;
  };
  declare type CodeDeploy$20141006$CreateDeploymentInput = {
    applicationName: string;
    deploymentGroupName?: string;
    revision?: CodeDeploy$20141006$RevisionLocation;
    deploymentConfigName?: string;
    description?: string;
    ignoreApplicationStopFailures?: boolean;
  };
  declare type CodeDeploy$20141006$CreateDeploymentOutput = {
    deploymentId?: string;
  };
  declare type CodeDeploy$20141006$DeleteApplicationInput = {
    applicationName: string;
  };
  declare type CodeDeploy$20141006$DeleteDeploymentConfigInput = {
    deploymentConfigName: string;
  };
  declare type CodeDeploy$20141006$DeleteDeploymentGroupInput = {
    applicationName: string;
    deploymentGroupName: string;
  };
  declare type CodeDeploy$20141006$DeleteDeploymentGroupOutput = {
    hooksNotCleanedUp?: CodeDeploy$20141006$AutoScalingGroupList;
  };
  declare type CodeDeploy$20141006$DeploymentAlreadyCompletedException = {};
  declare type CodeDeploy$20141006$DeploymentConfigAlreadyExistsException = {};
  declare type CodeDeploy$20141006$DeploymentConfigDoesNotExistException = {};
  declare type CodeDeploy$20141006$DeploymentConfigInUseException = {};
  declare type CodeDeploy$20141006$DeploymentConfigInfo = {
    deploymentConfigId?: string;
    deploymentConfigName?: string;
    minimumHealthyHosts?: CodeDeploy$20141006$MinimumHealthyHosts;
    createTime?: Date;
  };
  declare type CodeDeploy$20141006$DeploymentConfigLimitExceededException = {};
  declare type CodeDeploy$20141006$DeploymentConfigNameRequiredException = {};
  declare type CodeDeploy$20141006$DeploymentConfigsList = string[];
  declare type CodeDeploy$20141006$DeploymentCreator = 'user' | 'autoscaling';
  declare type CodeDeploy$20141006$DeploymentDoesNotExistException = {};
  declare type CodeDeploy$20141006$DeploymentGroupAlreadyExistsException = {};
  declare type CodeDeploy$20141006$DeploymentGroupDoesNotExistException = {};
  declare type CodeDeploy$20141006$DeploymentGroupInfo = {
    applicationName?: string;
    deploymentGroupId?: string;
    deploymentGroupName?: string;
    deploymentConfigName?: string;
    ec2TagFilters?: CodeDeploy$20141006$EC2TagFilterList;
    onPremisesInstanceTagFilters?: CodeDeploy$20141006$TagFilterList;
    autoScalingGroups?: CodeDeploy$20141006$AutoScalingGroupList;
    serviceRoleArn?: string;
    targetRevision?: CodeDeploy$20141006$RevisionLocation;
    triggerConfigurations?: CodeDeploy$20141006$TriggerConfigList;
  };
  declare type CodeDeploy$20141006$DeploymentGroupInfoList = CodeDeploy$20141006$DeploymentGroupInfo[];
  declare type CodeDeploy$20141006$DeploymentGroupLimitExceededException = {};
  declare type CodeDeploy$20141006$DeploymentGroupNameRequiredException = {};
  declare type CodeDeploy$20141006$DeploymentGroupsList = string[];
  declare type CodeDeploy$20141006$DeploymentIdRequiredException = {};
  declare type CodeDeploy$20141006$DeploymentInfo = {
    applicationName?: string;
    deploymentGroupName?: string;
    deploymentConfigName?: string;
    deploymentId?: string;
    revision?: CodeDeploy$20141006$RevisionLocation;
    status?: 'Created' | 'Queued' | 'InProgress' | 'Succeeded' | 'Failed' | 'Stopped';
    errorInformation?: CodeDeploy$20141006$ErrorInformation;
    createTime?: Date;
    startTime?: Date;
    completeTime?: Date;
    deploymentOverview?: CodeDeploy$20141006$DeploymentOverview;
    description?: string;
    creator?: 'user' | 'autoscaling';
    ignoreApplicationStopFailures?: boolean;
  };
  declare type CodeDeploy$20141006$DeploymentLimitExceededException = {};
  declare type CodeDeploy$20141006$DeploymentNotStartedException = {};
  declare type CodeDeploy$20141006$DeploymentOverview = {
    Pending?: number;
    InProgress?: number;
    Succeeded?: number;
    Failed?: number;
    Skipped?: number;
  };
  declare type CodeDeploy$20141006$DeploymentStatus = 'Created' | 'Queued' | 'InProgress' | 'Succeeded' | 'Failed' | 'Stopped';
  declare type CodeDeploy$20141006$DeploymentStatusList = ('Created' | 'Queued' | 'InProgress' | 'Succeeded' | 'Failed' | 'Stopped')[];
  declare type CodeDeploy$20141006$DeploymentsInfoList = CodeDeploy$20141006$DeploymentInfo[];
  declare type CodeDeploy$20141006$DeploymentsList = string[];
  declare type CodeDeploy$20141006$DeregisterOnPremisesInstanceInput = {
    instanceName: string;
  };
  declare type CodeDeploy$20141006$DescriptionTooLongException = {};
  declare type CodeDeploy$20141006$Diagnostics = {
    errorCode?: 'Success' | 'ScriptMissing' | 'ScriptNotExecutable' | 'ScriptTimedOut' | 'ScriptFailed' | 'UnknownError';
    scriptName?: string;
    message?: string;
    logTail?: string;
  };
  declare type CodeDeploy$20141006$EC2TagFilter = {
    Key?: string;
    Value?: string;
    Type?: 'KEY_ONLY' | 'VALUE_ONLY' | 'KEY_AND_VALUE';
  };
  declare type CodeDeploy$20141006$EC2TagFilterList = CodeDeploy$20141006$EC2TagFilter[];
  declare type CodeDeploy$20141006$EC2TagFilterType = 'KEY_ONLY' | 'VALUE_ONLY' | 'KEY_AND_VALUE';
  declare type CodeDeploy$20141006$ErrorCode = 'DEPLOYMENT_GROUP_MISSING' | 'APPLICATION_MISSING' | 'REVISION_MISSING' | 'IAM_ROLE_MISSING' | 'IAM_ROLE_PERMISSIONS' | 'NO_EC2_SUBSCRIPTION' | 'OVER_MAX_INSTANCES' | 'NO_INSTANCES' | 'TIMEOUT' | 'HEALTH_CONSTRAINTS_INVALID' | 'HEALTH_CONSTRAINTS' | 'INTERNAL_ERROR' | 'THROTTLED';
  declare type CodeDeploy$20141006$ErrorInformation = {
    code?: 'DEPLOYMENT_GROUP_MISSING' | 'APPLICATION_MISSING' | 'REVISION_MISSING' | 'IAM_ROLE_MISSING' | 'IAM_ROLE_PERMISSIONS' | 'NO_EC2_SUBSCRIPTION' | 'OVER_MAX_INSTANCES' | 'NO_INSTANCES' | 'TIMEOUT' | 'HEALTH_CONSTRAINTS_INVALID' | 'HEALTH_CONSTRAINTS' | 'INTERNAL_ERROR' | 'THROTTLED';
    message?: string;
  };
  declare type CodeDeploy$20141006$GenericRevisionInfo = {
    description?: string;
    deploymentGroups?: CodeDeploy$20141006$DeploymentGroupsList;
    firstUsedTime?: Date;
    lastUsedTime?: Date;
    registerTime?: Date;
  };
  declare type CodeDeploy$20141006$GetApplicationInput = {
    applicationName: string;
  };
  declare type CodeDeploy$20141006$GetApplicationOutput = {
    application?: CodeDeploy$20141006$ApplicationInfo;
  };
  declare type CodeDeploy$20141006$GetApplicationRevisionInput = {
    applicationName: string;
    revision: CodeDeploy$20141006$RevisionLocation;
  };
  declare type CodeDeploy$20141006$GetApplicationRevisionOutput = {
    applicationName?: string;
    revision?: CodeDeploy$20141006$RevisionLocation;
    revisionInfo?: CodeDeploy$20141006$GenericRevisionInfo;
  };
  declare type CodeDeploy$20141006$GetDeploymentConfigInput = {
    deploymentConfigName: string;
  };
  declare type CodeDeploy$20141006$GetDeploymentConfigOutput = {
    deploymentConfigInfo?: CodeDeploy$20141006$DeploymentConfigInfo;
  };
  declare type CodeDeploy$20141006$GetDeploymentGroupInput = {
    applicationName: string;
    deploymentGroupName: string;
  };
  declare type CodeDeploy$20141006$GetDeploymentGroupOutput = {
    deploymentGroupInfo?: CodeDeploy$20141006$DeploymentGroupInfo;
  };
  declare type CodeDeploy$20141006$GetDeploymentInput = {
    deploymentId: string;
  };
  declare type CodeDeploy$20141006$GetDeploymentInstanceInput = {
    deploymentId: string;
    instanceId: string;
  };
  declare type CodeDeploy$20141006$GetDeploymentInstanceOutput = {
    instanceSummary?: CodeDeploy$20141006$InstanceSummary;
  };
  declare type CodeDeploy$20141006$GetDeploymentOutput = {
    deploymentInfo?: CodeDeploy$20141006$DeploymentInfo;
  };
  declare type CodeDeploy$20141006$GetOnPremisesInstanceInput = {
    instanceName: string;
  };
  declare type CodeDeploy$20141006$GetOnPremisesInstanceOutput = {
    instanceInfo?: CodeDeploy$20141006$InstanceInfo;
  };
  declare type CodeDeploy$20141006$GitHubLocation = {
    repository?: string;
    commitId?: string;
  };
  declare type CodeDeploy$20141006$IamUserArnAlreadyRegisteredException = {};
  declare type CodeDeploy$20141006$IamUserArnRequiredException = {};
  declare type CodeDeploy$20141006$InstanceDoesNotExistException = {};
  declare type CodeDeploy$20141006$InstanceIdRequiredException = {};
  declare type CodeDeploy$20141006$InstanceInfo = {
    instanceName?: string;
    iamUserArn?: string;
    instanceArn?: string;
    registerTime?: Date;
    deregisterTime?: Date;
    tags?: CodeDeploy$20141006$TagList;
  };
  declare type CodeDeploy$20141006$InstanceInfoList = CodeDeploy$20141006$InstanceInfo[];
  declare type CodeDeploy$20141006$InstanceLimitExceededException = {};
  declare type CodeDeploy$20141006$InstanceNameAlreadyRegisteredException = {};
  declare type CodeDeploy$20141006$InstanceNameList = string[];
  declare type CodeDeploy$20141006$InstanceNameRequiredException = {};
  declare type CodeDeploy$20141006$InstanceNotRegisteredException = {};
  declare type CodeDeploy$20141006$InstanceStatus = 'Pending' | 'InProgress' | 'Succeeded' | 'Failed' | 'Skipped' | 'Unknown';
  declare type CodeDeploy$20141006$InstanceStatusList = ('Pending' | 'InProgress' | 'Succeeded' | 'Failed' | 'Skipped' | 'Unknown')[];
  declare type CodeDeploy$20141006$InstanceSummary = {
    deploymentId?: string;
    instanceId?: string;
    status?: 'Pending' | 'InProgress' | 'Succeeded' | 'Failed' | 'Skipped' | 'Unknown';
    lastUpdatedAt?: Date;
    lifecycleEvents?: CodeDeploy$20141006$LifecycleEventList;
  };
  declare type CodeDeploy$20141006$InstanceSummaryList = CodeDeploy$20141006$InstanceSummary[];
  declare type CodeDeploy$20141006$InstancesList = string[];
  declare type CodeDeploy$20141006$InvalidApplicationNameException = {};
  declare type CodeDeploy$20141006$InvalidAutoScalingGroupException = {};
  declare type CodeDeploy$20141006$InvalidBucketNameFilterException = {};
  declare type CodeDeploy$20141006$InvalidDeployedStateFilterException = {};
  declare type CodeDeploy$20141006$InvalidDeploymentConfigNameException = {};
  declare type CodeDeploy$20141006$InvalidDeploymentGroupNameException = {};
  declare type CodeDeploy$20141006$InvalidDeploymentIdException = {};
  declare type CodeDeploy$20141006$InvalidDeploymentStatusException = {};
  declare type CodeDeploy$20141006$InvalidEC2TagException = {};
  declare type CodeDeploy$20141006$InvalidIamUserArnException = {};
  declare type CodeDeploy$20141006$InvalidInstanceNameException = {};
  declare type CodeDeploy$20141006$InvalidInstanceStatusException = {};
  declare type CodeDeploy$20141006$InvalidKeyPrefixFilterException = {};
  declare type CodeDeploy$20141006$InvalidMinimumHealthyHostValueException = {};
  declare type CodeDeploy$20141006$InvalidNextTokenException = {};
  declare type CodeDeploy$20141006$InvalidOperationException = {};
  declare type CodeDeploy$20141006$InvalidRegistrationStatusException = {};
  declare type CodeDeploy$20141006$InvalidRevisionException = {};
  declare type CodeDeploy$20141006$InvalidRoleException = {};
  declare type CodeDeploy$20141006$InvalidSortByException = {};
  declare type CodeDeploy$20141006$InvalidSortOrderException = {};
  declare type CodeDeploy$20141006$InvalidTagException = {};
  declare type CodeDeploy$20141006$InvalidTagFilterException = {};
  declare type CodeDeploy$20141006$InvalidTimeRangeException = {};
  declare type CodeDeploy$20141006$InvalidTriggerConfigException = {};
  declare type CodeDeploy$20141006$LifecycleErrorCode = 'Success' | 'ScriptMissing' | 'ScriptNotExecutable' | 'ScriptTimedOut' | 'ScriptFailed' | 'UnknownError';
  declare type CodeDeploy$20141006$LifecycleEvent = {
    lifecycleEventName?: string;
    diagnostics?: CodeDeploy$20141006$Diagnostics;
    startTime?: Date;
    endTime?: Date;
    status?: 'Pending' | 'InProgress' | 'Succeeded' | 'Failed' | 'Skipped' | 'Unknown';
  };
  declare type CodeDeploy$20141006$LifecycleEventList = CodeDeploy$20141006$LifecycleEvent[];
  declare type CodeDeploy$20141006$LifecycleEventStatus = 'Pending' | 'InProgress' | 'Succeeded' | 'Failed' | 'Skipped' | 'Unknown';
  declare type CodeDeploy$20141006$LifecycleHookLimitExceededException = {};
  declare type CodeDeploy$20141006$ListApplicationRevisionsInput = {
    applicationName: string;
    sortBy?: 'registerTime' | 'firstUsedTime' | 'lastUsedTime';
    sortOrder?: 'ascending' | 'descending';
    s3Bucket?: string;
    s3KeyPrefix?: string;
    deployed?: 'include' | 'exclude' | 'ignore';
    nextToken?: string;
  };
  declare type CodeDeploy$20141006$ListApplicationRevisionsOutput = {
    revisions?: CodeDeploy$20141006$RevisionLocationList;
    nextToken?: string;
  };
  declare type CodeDeploy$20141006$ListApplicationsInput = {
    nextToken?: string;
  };
  declare type CodeDeploy$20141006$ListApplicationsOutput = {
    applications?: CodeDeploy$20141006$ApplicationsList;
    nextToken?: string;
  };
  declare type CodeDeploy$20141006$ListDeploymentConfigsInput = {
    nextToken?: string;
  };
  declare type CodeDeploy$20141006$ListDeploymentConfigsOutput = {
    deploymentConfigsList?: CodeDeploy$20141006$DeploymentConfigsList;
    nextToken?: string;
  };
  declare type CodeDeploy$20141006$ListDeploymentGroupsInput = {
    applicationName: string;
    nextToken?: string;
  };
  declare type CodeDeploy$20141006$ListDeploymentGroupsOutput = {
    applicationName?: string;
    deploymentGroups?: CodeDeploy$20141006$DeploymentGroupsList;
    nextToken?: string;
  };
  declare type CodeDeploy$20141006$ListDeploymentInstancesInput = {
    deploymentId: string;
    nextToken?: string;
    instanceStatusFilter?: CodeDeploy$20141006$InstanceStatusList;
  };
  declare type CodeDeploy$20141006$ListDeploymentInstancesOutput = {
    instancesList?: CodeDeploy$20141006$InstancesList;
    nextToken?: string;
  };
  declare type CodeDeploy$20141006$ListDeploymentsInput = {
    applicationName?: string;
    deploymentGroupName?: string;
    includeOnlyStatuses?: CodeDeploy$20141006$DeploymentStatusList;
    createTimeRange?: CodeDeploy$20141006$TimeRange;
    nextToken?: string;
  };
  declare type CodeDeploy$20141006$ListDeploymentsOutput = {
    deployments?: CodeDeploy$20141006$DeploymentsList;
    nextToken?: string;
  };
  declare type CodeDeploy$20141006$ListOnPremisesInstancesInput = {
    registrationStatus?: 'Registered' | 'Deregistered';
    tagFilters?: CodeDeploy$20141006$TagFilterList;
    nextToken?: string;
  };
  declare type CodeDeploy$20141006$ListOnPremisesInstancesOutput = {
    instanceNames?: CodeDeploy$20141006$InstanceNameList;
    nextToken?: string;
  };
  declare type CodeDeploy$20141006$ListStateFilterAction = 'include' | 'exclude' | 'ignore';
  declare type CodeDeploy$20141006$MinimumHealthyHosts = {
    value?: number;
    type?: 'HOST_COUNT' | 'FLEET_PERCENT';
  };
  declare type CodeDeploy$20141006$MinimumHealthyHostsType = 'HOST_COUNT' | 'FLEET_PERCENT';
  declare type CodeDeploy$20141006$RegisterApplicationRevisionInput = {
    applicationName: string;
    description?: string;
    revision: CodeDeploy$20141006$RevisionLocation;
  };
  declare type CodeDeploy$20141006$RegisterOnPremisesInstanceInput = {
    instanceName: string;
    iamUserArn: string;
  };
  declare type CodeDeploy$20141006$RegistrationStatus = 'Registered' | 'Deregistered';
  declare type CodeDeploy$20141006$RemoveTagsFromOnPremisesInstancesInput = {
    tags: CodeDeploy$20141006$TagList;
    instanceNames: CodeDeploy$20141006$InstanceNameList;
  };
  declare type CodeDeploy$20141006$RevisionDoesNotExistException = {};
  declare type CodeDeploy$20141006$RevisionInfo = {
    revisionLocation?: CodeDeploy$20141006$RevisionLocation;
    genericRevisionInfo?: CodeDeploy$20141006$GenericRevisionInfo;
  };
  declare type CodeDeploy$20141006$RevisionInfoList = CodeDeploy$20141006$RevisionInfo[];
  declare type CodeDeploy$20141006$RevisionLocation = {
    revisionType?: 'S3' | 'GitHub';
    s3Location?: CodeDeploy$20141006$S3Location;
    gitHubLocation?: CodeDeploy$20141006$GitHubLocation;
  };
  declare type CodeDeploy$20141006$RevisionLocationList = CodeDeploy$20141006$RevisionLocation[];
  declare type CodeDeploy$20141006$RevisionLocationType = 'S3' | 'GitHub';
  declare type CodeDeploy$20141006$RevisionRequiredException = {};
  declare type CodeDeploy$20141006$RoleRequiredException = {};
  declare type CodeDeploy$20141006$S3Location = {
    bucket?: string;
    key?: string;
    bundleType?: 'tar' | 'tgz' | 'zip';
    version?: string;
    eTag?: string;
  };
  declare type CodeDeploy$20141006$SortOrder = 'ascending' | 'descending';
  declare type CodeDeploy$20141006$StopDeploymentInput = {
    deploymentId: string;
  };
  declare type CodeDeploy$20141006$StopDeploymentOutput = {
    status?: 'Pending' | 'Succeeded';
    statusMessage?: string;
  };
  declare type CodeDeploy$20141006$StopStatus = 'Pending' | 'Succeeded';
  declare type CodeDeploy$20141006$Tag = {
    Key?: string;
    Value?: string;
  };
  declare type CodeDeploy$20141006$TagFilter = {
    Key?: string;
    Value?: string;
    Type?: 'KEY_ONLY' | 'VALUE_ONLY' | 'KEY_AND_VALUE';
  };
  declare type CodeDeploy$20141006$TagFilterList = CodeDeploy$20141006$TagFilter[];
  declare type CodeDeploy$20141006$TagFilterType = 'KEY_ONLY' | 'VALUE_ONLY' | 'KEY_AND_VALUE';
  declare type CodeDeploy$20141006$TagLimitExceededException = {};
  declare type CodeDeploy$20141006$TagList = CodeDeploy$20141006$Tag[];
  declare type CodeDeploy$20141006$TagRequiredException = {};
  declare type CodeDeploy$20141006$TimeRange = {
    start?: Date;
    end?: Date;
  };
  declare type CodeDeploy$20141006$Timestamp = Date;
  declare type CodeDeploy$20141006$TriggerConfig = {
    triggerName?: string;
    triggerTargetArn?: string;
    triggerEvents?: CodeDeploy$20141006$TriggerEventTypeList;
  };
  declare type CodeDeploy$20141006$TriggerConfigList = CodeDeploy$20141006$TriggerConfig[];
  declare type CodeDeploy$20141006$TriggerEventType = 'DeploymentStart' | 'DeploymentSuccess' | 'DeploymentFailure' | 'DeploymentStop' | 'InstanceStart' | 'InstanceSuccess' | 'InstanceFailure';
  declare type CodeDeploy$20141006$TriggerEventTypeList = ('DeploymentStart' | 'DeploymentSuccess' | 'DeploymentFailure' | 'DeploymentStop' | 'InstanceStart' | 'InstanceSuccess' | 'InstanceFailure')[];
  declare type CodeDeploy$20141006$TriggerTargetsLimitExceededException = {};
  declare type CodeDeploy$20141006$UpdateApplicationInput = {
    applicationName?: string;
    newApplicationName?: string;
  };
  declare type CodeDeploy$20141006$UpdateDeploymentGroupInput = {
    applicationName: string;
    currentDeploymentGroupName: string;
    newDeploymentGroupName?: string;
    deploymentConfigName?: string;
    ec2TagFilters?: CodeDeploy$20141006$EC2TagFilterList;
    onPremisesInstanceTagFilters?: CodeDeploy$20141006$TagFilterList;
    autoScalingGroups?: CodeDeploy$20141006$AutoScalingGroupNameList;
    serviceRoleArn?: string;
    triggerConfigurations?: CodeDeploy$20141006$TriggerConfigList;
  };
  declare type CodeDeploy$20141006$UpdateDeploymentGroupOutput = {
    hooksNotCleanedUp?: CodeDeploy$20141006$AutoScalingGroupList;
  };
  declare type CodePipeline$20150709$AWSSessionCredentials = {
    accessKeyId: string;
    secretAccessKey: string;
    sessionToken: string;
  };
  declare type CodePipeline$20150709$AcknowledgeJobInput = {
    jobId: string;
    nonce: string;
  };
  declare type CodePipeline$20150709$AcknowledgeJobOutput = {
    status?: 'Created' | 'Queued' | 'Dispatched' | 'InProgress' | 'TimedOut' | 'Succeeded' | 'Failed';
  };
  declare type CodePipeline$20150709$AcknowledgeThirdPartyJobInput = {
    jobId: string;
    nonce: string;
    clientToken: string;
  };
  declare type CodePipeline$20150709$AcknowledgeThirdPartyJobOutput = {
    status?: 'Created' | 'Queued' | 'Dispatched' | 'InProgress' | 'TimedOut' | 'Succeeded' | 'Failed';
  };
  declare type CodePipeline$20150709$ActionCategory = 'Source' | 'Build' | 'Deploy' | 'Test' | 'Invoke' | 'Approval';
  declare type CodePipeline$20150709$ActionConfiguration = {
    configuration?: {
      [key: string]: string;
    };
  };
  declare type CodePipeline$20150709$ActionConfigurationMap = {
    [key: string]: string;
  };
  declare type CodePipeline$20150709$ActionConfigurationProperty = {
    name: string;
    required: boolean;
    key: boolean;
    secret: boolean;
    queryable?: boolean;
    description?: string;
    type?: 'String' | 'Number' | 'Boolean';
  };
  declare type CodePipeline$20150709$ActionConfigurationPropertyList = CodePipeline$20150709$ActionConfigurationProperty[];
  declare type CodePipeline$20150709$ActionConfigurationPropertyType = 'String' | 'Number' | 'Boolean';
  declare type CodePipeline$20150709$ActionContext = {
    name?: string;
  };
  declare type CodePipeline$20150709$ActionDeclaration = {
    name: string;
    actionTypeId: CodePipeline$20150709$ActionTypeId;
    runOrder?: number;
    configuration?: {
      [key: string]: string;
    };
    outputArtifacts?: CodePipeline$20150709$OutputArtifactList;
    inputArtifacts?: CodePipeline$20150709$InputArtifactList;
    roleArn?: string;
  };
  declare type CodePipeline$20150709$ActionExecution = {
    status?: 'InProgress' | 'Succeeded' | 'Failed';
    summary?: string;
    lastStatusChange?: Date;
    token?: string;
    lastUpdatedBy?: string;
    externalExecutionId?: string;
    externalExecutionUrl?: string;
    percentComplete?: number;
    errorDetails?: CodePipeline$20150709$ErrorDetails;
  };
  declare type CodePipeline$20150709$ActionExecutionStatus = 'InProgress' | 'Succeeded' | 'Failed';
  declare type CodePipeline$20150709$ActionNotFoundException = {};
  declare type CodePipeline$20150709$ActionOwner = 'AWS' | 'ThirdParty' | 'Custom';
  declare type CodePipeline$20150709$ActionRevision = {
    revisionId: string;
    revisionChangeId: string;
    created: Date;
  };
  declare type CodePipeline$20150709$ActionState = {
    actionName?: string;
    currentRevision?: CodePipeline$20150709$ActionRevision;
    latestExecution?: CodePipeline$20150709$ActionExecution;
    entityUrl?: string;
    revisionUrl?: string;
  };
  declare type CodePipeline$20150709$ActionStateList = CodePipeline$20150709$ActionState[];
  declare type CodePipeline$20150709$ActionType = {
    id: CodePipeline$20150709$ActionTypeId;
    settings?: CodePipeline$20150709$ActionTypeSettings;
    actionConfigurationProperties?: CodePipeline$20150709$ActionConfigurationPropertyList;
    inputArtifactDetails: CodePipeline$20150709$ArtifactDetails;
    outputArtifactDetails: CodePipeline$20150709$ArtifactDetails;
  };
  declare type CodePipeline$20150709$ActionTypeId = {
    category: 'Source' | 'Build' | 'Deploy' | 'Test' | 'Invoke' | 'Approval';
    owner: 'AWS' | 'ThirdParty' | 'Custom';
    provider: string;
    version: string;
  };
  declare type CodePipeline$20150709$ActionTypeList = CodePipeline$20150709$ActionType[];
  declare type CodePipeline$20150709$ActionTypeNotFoundException = {};
  declare type CodePipeline$20150709$ActionTypeSettings = {
    thirdPartyConfigurationUrl?: string;
    entityUrlTemplate?: string;
    executionUrlTemplate?: string;
    revisionUrlTemplate?: string;
  };
  declare type CodePipeline$20150709$ApprovalAlreadyCompletedException = {};
  declare type CodePipeline$20150709$ApprovalResult = {
    summary: string;
    status: 'Approved' | 'Rejected';
  };
  declare type CodePipeline$20150709$ApprovalStatus = 'Approved' | 'Rejected';
  declare type CodePipeline$20150709$Artifact = {
    name?: string;
    revision?: string;
    location?: CodePipeline$20150709$ArtifactLocation;
  };
  declare type CodePipeline$20150709$ArtifactDetails = {
    minimumCount: number;
    maximumCount: number;
  };
  declare type CodePipeline$20150709$ArtifactList = CodePipeline$20150709$Artifact[];
  declare type CodePipeline$20150709$ArtifactLocation = {
    type?: 'S3';
    s3Location?: CodePipeline$20150709$S3ArtifactLocation;
  };
  declare type CodePipeline$20150709$ArtifactLocationType = 'S3';
  declare type CodePipeline$20150709$ArtifactStore = {
    type: 'S3';
    location: string;
    encryptionKey?: CodePipeline$20150709$EncryptionKey;
  };
  declare type CodePipeline$20150709$ArtifactStoreType = 'S3';
  declare type CodePipeline$20150709$BlockerDeclaration = {
    name: string;
    type: 'Schedule';
  };
  declare type CodePipeline$20150709$BlockerType = 'Schedule';
  declare type CodePipeline$20150709$CreateCustomActionTypeInput = {
    category: 'Source' | 'Build' | 'Deploy' | 'Test' | 'Invoke' | 'Approval';
    provider: string;
    version: string;
    settings?: CodePipeline$20150709$ActionTypeSettings;
    configurationProperties?: CodePipeline$20150709$ActionConfigurationPropertyList;
    inputArtifactDetails: CodePipeline$20150709$ArtifactDetails;
    outputArtifactDetails: CodePipeline$20150709$ArtifactDetails;
  };
  declare type CodePipeline$20150709$CreateCustomActionTypeOutput = {
    actionType: CodePipeline$20150709$ActionType;
  };
  declare type CodePipeline$20150709$CreatePipelineInput = {
    pipeline: CodePipeline$20150709$PipelineDeclaration;
  };
  declare type CodePipeline$20150709$CreatePipelineOutput = {
    pipeline?: CodePipeline$20150709$PipelineDeclaration;
  };
  declare type CodePipeline$20150709$CurrentRevision = {
    revision: string;
    changeIdentifier: string;
  };
  declare type CodePipeline$20150709$DeleteCustomActionTypeInput = {
    category: 'Source' | 'Build' | 'Deploy' | 'Test' | 'Invoke' | 'Approval';
    provider: string;
    version: string;
  };
  declare type CodePipeline$20150709$DeletePipelineInput = {
    name: string;
  };
  declare type CodePipeline$20150709$DisableStageTransitionInput = {
    pipelineName: string;
    stageName: string;
    transitionType: 'Inbound' | 'Outbound';
    reason: string;
  };
  declare type CodePipeline$20150709$EnableStageTransitionInput = {
    pipelineName: string;
    stageName: string;
    transitionType: 'Inbound' | 'Outbound';
  };
  declare type CodePipeline$20150709$EncryptionKey = {
    id: string;
    type: 'KMS';
  };
  declare type CodePipeline$20150709$EncryptionKeyType = 'KMS';
  declare type CodePipeline$20150709$ErrorDetails = {
    code?: string;
    message?: string;
  };
  declare type CodePipeline$20150709$ExecutionDetails = {
    summary?: string;
    externalExecutionId?: string;
    percentComplete?: number;
  };
  declare type CodePipeline$20150709$FailureDetails = {
    type: 'JobFailed' | 'ConfigurationError' | 'PermissionError' | 'RevisionOutOfSync' | 'RevisionUnavailable' | 'SystemUnavailable';
    message: string;
    externalExecutionId?: string;
  };
  declare type CodePipeline$20150709$FailureType = 'JobFailed' | 'ConfigurationError' | 'PermissionError' | 'RevisionOutOfSync' | 'RevisionUnavailable' | 'SystemUnavailable';
  declare type CodePipeline$20150709$GetJobDetailsInput = {
    jobId: string;
  };
  declare type CodePipeline$20150709$GetJobDetailsOutput = {
    jobDetails?: CodePipeline$20150709$JobDetails;
  };
  declare type CodePipeline$20150709$GetPipelineInput = {
    name: string;
    version?: number;
  };
  declare type CodePipeline$20150709$GetPipelineOutput = {
    pipeline?: CodePipeline$20150709$PipelineDeclaration;
  };
  declare type CodePipeline$20150709$GetPipelineStateInput = {
    name: string;
  };
  declare type CodePipeline$20150709$GetPipelineStateOutput = {
    pipelineName?: string;
    pipelineVersion?: number;
    stageStates?: CodePipeline$20150709$StageStateList;
    created?: Date;
    updated?: Date;
  };
  declare type CodePipeline$20150709$GetThirdPartyJobDetailsInput = {
    jobId: string;
    clientToken: string;
  };
  declare type CodePipeline$20150709$GetThirdPartyJobDetailsOutput = {
    jobDetails?: CodePipeline$20150709$ThirdPartyJobDetails;
  };
  declare type CodePipeline$20150709$InputArtifact = {
    name: string;
  };
  declare type CodePipeline$20150709$InputArtifactList = CodePipeline$20150709$InputArtifact[];
  declare type CodePipeline$20150709$InvalidActionDeclarationException = {};
  declare type CodePipeline$20150709$InvalidApprovalTokenException = {};
  declare type CodePipeline$20150709$InvalidBlockerDeclarationException = {};
  declare type CodePipeline$20150709$InvalidClientTokenException = {};
  declare type CodePipeline$20150709$InvalidJobException = {};
  declare type CodePipeline$20150709$InvalidJobStateException = {};
  declare type CodePipeline$20150709$InvalidNextTokenException = {};
  declare type CodePipeline$20150709$InvalidNonceException = {};
  declare type CodePipeline$20150709$InvalidStageDeclarationException = {};
  declare type CodePipeline$20150709$InvalidStructureException = {};
  declare type CodePipeline$20150709$Job = {
    id?: string;
    data?: CodePipeline$20150709$JobData;
    nonce?: string;
    accountId?: string;
  };
  declare type CodePipeline$20150709$JobData = {
    actionTypeId?: CodePipeline$20150709$ActionTypeId;
    actionConfiguration?: CodePipeline$20150709$ActionConfiguration;
    pipelineContext?: CodePipeline$20150709$PipelineContext;
    inputArtifacts?: CodePipeline$20150709$ArtifactList;
    outputArtifacts?: CodePipeline$20150709$ArtifactList;
    artifactCredentials?: CodePipeline$20150709$AWSSessionCredentials;
    continuationToken?: string;
    encryptionKey?: CodePipeline$20150709$EncryptionKey;
  };
  declare type CodePipeline$20150709$JobDetails = {
    id?: string;
    data?: CodePipeline$20150709$JobData;
    accountId?: string;
  };
  declare type CodePipeline$20150709$JobList = CodePipeline$20150709$Job[];
  declare type CodePipeline$20150709$JobNotFoundException = {};
  declare type CodePipeline$20150709$JobStatus = 'Created' | 'Queued' | 'Dispatched' | 'InProgress' | 'TimedOut' | 'Succeeded' | 'Failed';
  declare type CodePipeline$20150709$LastChangedAt = Date;
  declare type CodePipeline$20150709$LimitExceededException = {};
  declare type CodePipeline$20150709$ListActionTypesInput = {
    actionOwnerFilter?: 'AWS' | 'ThirdParty' | 'Custom';
    nextToken?: string;
  };
  declare type CodePipeline$20150709$ListActionTypesOutput = {
    actionTypes: CodePipeline$20150709$ActionTypeList;
    nextToken?: string;
  };
  declare type CodePipeline$20150709$ListPipelinesInput = {
    nextToken?: string;
  };
  declare type CodePipeline$20150709$ListPipelinesOutput = {
    pipelines?: CodePipeline$20150709$PipelineList;
    nextToken?: string;
  };
  declare type CodePipeline$20150709$NotLatestPipelineExecutionException = {};
  declare type CodePipeline$20150709$OutputArtifact = {
    name: string;
  };
  declare type CodePipeline$20150709$OutputArtifactList = CodePipeline$20150709$OutputArtifact[];
  declare type CodePipeline$20150709$PipelineContext = {
    pipelineName?: string;
    stage?: CodePipeline$20150709$StageContext;
    action?: CodePipeline$20150709$ActionContext;
  };
  declare type CodePipeline$20150709$PipelineDeclaration = {
    name: string;
    roleArn: string;
    artifactStore: CodePipeline$20150709$ArtifactStore;
    stages: CodePipeline$20150709$PipelineStageDeclarationList;
    version?: number;
  };
  declare type CodePipeline$20150709$PipelineList = CodePipeline$20150709$PipelineSummary[];
  declare type CodePipeline$20150709$PipelineNameInUseException = {};
  declare type CodePipeline$20150709$PipelineNotFoundException = {};
  declare type CodePipeline$20150709$PipelineStageDeclarationList = CodePipeline$20150709$StageDeclaration[];
  declare type CodePipeline$20150709$PipelineSummary = {
    name?: string;
    version?: number;
    created?: Date;
    updated?: Date;
  };
  declare type CodePipeline$20150709$PipelineVersionNotFoundException = {};
  declare type CodePipeline$20150709$PollForJobsInput = {
    actionTypeId: CodePipeline$20150709$ActionTypeId;
    maxBatchSize?: number;
    queryParam?: {
      [key: string]: string;
    };
  };
  declare type CodePipeline$20150709$PollForJobsOutput = {
    jobs?: CodePipeline$20150709$JobList;
  };
  declare type CodePipeline$20150709$PollForThirdPartyJobsInput = {
    actionTypeId: CodePipeline$20150709$ActionTypeId;
    maxBatchSize?: number;
  };
  declare type CodePipeline$20150709$PollForThirdPartyJobsOutput = {
    jobs?: CodePipeline$20150709$ThirdPartyJobList;
  };
  declare type CodePipeline$20150709$PutActionRevisionInput = {
    pipelineName: string;
    stageName: string;
    actionName: string;
    actionRevision: CodePipeline$20150709$ActionRevision;
  };
  declare type CodePipeline$20150709$PutActionRevisionOutput = {
    newRevision?: boolean;
    pipelineExecutionId?: string;
  };
  declare type CodePipeline$20150709$PutApprovalResultInput = {
    pipelineName: string;
    stageName: string;
    actionName: string;
    result: CodePipeline$20150709$ApprovalResult;
    token?: string;
  };
  declare type CodePipeline$20150709$PutApprovalResultOutput = {
    approvedAt?: Date;
  };
  declare type CodePipeline$20150709$PutJobFailureResultInput = {
    jobId: string;
    failureDetails: CodePipeline$20150709$FailureDetails;
  };
  declare type CodePipeline$20150709$PutJobSuccessResultInput = {
    jobId: string;
    currentRevision?: CodePipeline$20150709$CurrentRevision;
    continuationToken?: string;
    executionDetails?: CodePipeline$20150709$ExecutionDetails;
  };
  declare type CodePipeline$20150709$PutThirdPartyJobFailureResultInput = {
    jobId: string;
    clientToken: string;
    failureDetails: CodePipeline$20150709$FailureDetails;
  };
  declare type CodePipeline$20150709$PutThirdPartyJobSuccessResultInput = {
    jobId: string;
    clientToken: string;
    currentRevision?: CodePipeline$20150709$CurrentRevision;
    continuationToken?: string;
    executionDetails?: CodePipeline$20150709$ExecutionDetails;
  };
  declare type CodePipeline$20150709$QueryParamMap = {
    [key: string]: string;
  };
  declare type CodePipeline$20150709$RetryStageExecutionInput = {
    pipelineName: string;
    stageName: string;
    pipelineExecutionId: string;
    retryMode: 'FAILED_ACTIONS';
  };
  declare type CodePipeline$20150709$RetryStageExecutionOutput = {
    pipelineExecutionId?: string;
  };
  declare type CodePipeline$20150709$S3ArtifactLocation = {
    bucketName: string;
    objectKey: string;
  };
  declare type CodePipeline$20150709$StageActionDeclarationList = CodePipeline$20150709$ActionDeclaration[];
  declare type CodePipeline$20150709$StageBlockerDeclarationList = CodePipeline$20150709$BlockerDeclaration[];
  declare type CodePipeline$20150709$StageContext = {
    name?: string;
  };
  declare type CodePipeline$20150709$StageDeclaration = {
    name: string;
    blockers?: CodePipeline$20150709$StageBlockerDeclarationList;
    actions: CodePipeline$20150709$StageActionDeclarationList;
  };
  declare type CodePipeline$20150709$StageExecution = {
    pipelineExecutionId: string;
    status: 'InProgress' | 'Failed' | 'Succeeded';
  };
  declare type CodePipeline$20150709$StageExecutionStatus = 'InProgress' | 'Failed' | 'Succeeded';
  declare type CodePipeline$20150709$StageNotFoundException = {};
  declare type CodePipeline$20150709$StageNotRetryableException = {};
  declare type CodePipeline$20150709$StageRetryMode = 'FAILED_ACTIONS';
  declare type CodePipeline$20150709$StageState = {
    stageName?: string;
    inboundTransitionState?: CodePipeline$20150709$TransitionState;
    actionStates?: CodePipeline$20150709$ActionStateList;
    latestExecution?: CodePipeline$20150709$StageExecution;
  };
  declare type CodePipeline$20150709$StageStateList = CodePipeline$20150709$StageState[];
  declare type CodePipeline$20150709$StageTransitionType = 'Inbound' | 'Outbound';
  declare type CodePipeline$20150709$StartPipelineExecutionInput = {
    name: string;
  };
  declare type CodePipeline$20150709$StartPipelineExecutionOutput = {
    pipelineExecutionId?: string;
  };
  declare type CodePipeline$20150709$ThirdPartyJob = {
    clientId?: string;
    jobId?: string;
  };
  declare type CodePipeline$20150709$ThirdPartyJobData = {
    actionTypeId?: CodePipeline$20150709$ActionTypeId;
    actionConfiguration?: CodePipeline$20150709$ActionConfiguration;
    pipelineContext?: CodePipeline$20150709$PipelineContext;
    inputArtifacts?: CodePipeline$20150709$ArtifactList;
    outputArtifacts?: CodePipeline$20150709$ArtifactList;
    artifactCredentials?: CodePipeline$20150709$AWSSessionCredentials;
    continuationToken?: string;
    encryptionKey?: CodePipeline$20150709$EncryptionKey;
  };
  declare type CodePipeline$20150709$ThirdPartyJobDetails = {
    id?: string;
    data?: CodePipeline$20150709$ThirdPartyJobData;
    nonce?: string;
  };
  declare type CodePipeline$20150709$ThirdPartyJobList = CodePipeline$20150709$ThirdPartyJob[];
  declare type CodePipeline$20150709$Timestamp = Date;
  declare type CodePipeline$20150709$TransitionState = {
    enabled?: boolean;
    lastChangedBy?: string;
    lastChangedAt?: Date;
    disabledReason?: string;
  };
  declare type CodePipeline$20150709$UpdatePipelineInput = {
    pipeline: CodePipeline$20150709$PipelineDeclaration;
  };
  declare type CodePipeline$20150709$UpdatePipelineOutput = {
    pipeline?: CodePipeline$20150709$PipelineDeclaration;
  };
  declare type CodePipeline$20150709$ValidationException = {};
  declare type CognitoIdentity$20140630$CognitoIdentityProvider = {
    ProviderName?: string;
    ClientId?: string;
  };
  declare type CognitoIdentity$20140630$CognitoIdentityProviderList = CognitoIdentity$20140630$CognitoIdentityProvider[];
  declare type CognitoIdentity$20140630$ConcurrentModificationException = {
    message?: string;
  };
  declare type CognitoIdentity$20140630$CreateIdentityPoolInput = {
    IdentityPoolName: string;
    AllowUnauthenticatedIdentities: boolean;
    SupportedLoginProviders?: {
      [key: string]: string;
    };
    DeveloperProviderName?: string;
    OpenIdConnectProviderARNs?: CognitoIdentity$20140630$OIDCProviderList;
    CognitoIdentityProviders?: CognitoIdentity$20140630$CognitoIdentityProviderList;
    SamlProviderARNs?: CognitoIdentity$20140630$SAMLProviderList;
  };
  declare type CognitoIdentity$20140630$Credentials = {
    AccessKeyId?: string;
    SecretKey?: string;
    SessionToken?: string;
    Expiration?: Date;
  };
  declare type CognitoIdentity$20140630$DateType = Date;
  declare type CognitoIdentity$20140630$DeleteIdentitiesInput = {
    IdentityIdsToDelete: CognitoIdentity$20140630$IdentityIdList;
  };
  declare type CognitoIdentity$20140630$DeleteIdentitiesResponse = {
    UnprocessedIdentityIds?: CognitoIdentity$20140630$UnprocessedIdentityIdList;
  };
  declare type CognitoIdentity$20140630$DeleteIdentityPoolInput = {
    IdentityPoolId: string;
  };
  declare type CognitoIdentity$20140630$DescribeIdentityInput = {
    IdentityId: string;
  };
  declare type CognitoIdentity$20140630$DescribeIdentityPoolInput = {
    IdentityPoolId: string;
  };
  declare type CognitoIdentity$20140630$DeveloperUserAlreadyRegisteredException = {
    message?: string;
  };
  declare type CognitoIdentity$20140630$DeveloperUserIdentifierList = string[];
  declare type CognitoIdentity$20140630$ErrorCode = 'AccessDenied' | 'InternalServerError';
  declare type CognitoIdentity$20140630$ExternalServiceException = {
    message?: string;
  };
  declare type CognitoIdentity$20140630$GetCredentialsForIdentityInput = {
    IdentityId: string;
    Logins?: {
      [key: string]: string;
    };
    CustomRoleArn?: string;
  };
  declare type CognitoIdentity$20140630$GetCredentialsForIdentityResponse = {
    IdentityId?: string;
    Credentials?: CognitoIdentity$20140630$Credentials;
  };
  declare type CognitoIdentity$20140630$GetIdInput = {
    AccountId?: string;
    IdentityPoolId: string;
    Logins?: {
      [key: string]: string;
    };
  };
  declare type CognitoIdentity$20140630$GetIdResponse = {
    IdentityId?: string;
  };
  declare type CognitoIdentity$20140630$GetIdentityPoolRolesInput = {
    IdentityPoolId: string;
  };
  declare type CognitoIdentity$20140630$GetIdentityPoolRolesResponse = {
    IdentityPoolId?: string;
    Roles?: {
      [key: string]: string;
    };
  };
  declare type CognitoIdentity$20140630$GetOpenIdTokenForDeveloperIdentityInput = {
    IdentityPoolId: string;
    IdentityId?: string;
    Logins: {
      [key: string]: string;
    };
    TokenDuration?: number;
  };
  declare type CognitoIdentity$20140630$GetOpenIdTokenForDeveloperIdentityResponse = {
    IdentityId?: string;
    Token?: string;
  };
  declare type CognitoIdentity$20140630$GetOpenIdTokenInput = {
    IdentityId: string;
    Logins?: {
      [key: string]: string;
    };
  };
  declare type CognitoIdentity$20140630$GetOpenIdTokenResponse = {
    IdentityId?: string;
    Token?: string;
  };
  declare type CognitoIdentity$20140630$IdentitiesList = CognitoIdentity$20140630$IdentityDescription[];
  declare type CognitoIdentity$20140630$IdentityDescription = {
    IdentityId?: string;
    Logins?: CognitoIdentity$20140630$LoginsList;
    CreationDate?: Date;
    LastModifiedDate?: Date;
  };
  declare type CognitoIdentity$20140630$IdentityIdList = string[];
  declare type CognitoIdentity$20140630$IdentityPool = {
    IdentityPoolId: string;
    IdentityPoolName: string;
    AllowUnauthenticatedIdentities: boolean;
    SupportedLoginProviders?: {
      [key: string]: string;
    };
    DeveloperProviderName?: string;
    OpenIdConnectProviderARNs?: CognitoIdentity$20140630$OIDCProviderList;
    CognitoIdentityProviders?: CognitoIdentity$20140630$CognitoIdentityProviderList;
    SamlProviderARNs?: CognitoIdentity$20140630$SAMLProviderList;
  };
  declare type CognitoIdentity$20140630$IdentityPoolShortDescription = {
    IdentityPoolId?: string;
    IdentityPoolName?: string;
  };
  declare type CognitoIdentity$20140630$IdentityPoolsList = CognitoIdentity$20140630$IdentityPoolShortDescription[];
  declare type CognitoIdentity$20140630$IdentityProviders = {
    [key: string]: string;
  };
  declare type CognitoIdentity$20140630$InternalErrorException = {
    message?: string;
  };
  declare type CognitoIdentity$20140630$InvalidIdentityPoolConfigurationException = {
    message?: string;
  };
  declare type CognitoIdentity$20140630$InvalidParameterException = {
    message?: string;
  };
  declare type CognitoIdentity$20140630$LimitExceededException = {
    message?: string;
  };
  declare type CognitoIdentity$20140630$ListIdentitiesInput = {
    IdentityPoolId: string;
    MaxResults: number;
    NextToken?: string;
    HideDisabled?: boolean;
  };
  declare type CognitoIdentity$20140630$ListIdentitiesResponse = {
    IdentityPoolId?: string;
    Identities?: CognitoIdentity$20140630$IdentitiesList;
    NextToken?: string;
  };
  declare type CognitoIdentity$20140630$ListIdentityPoolsInput = {
    MaxResults: number;
    NextToken?: string;
  };
  declare type CognitoIdentity$20140630$ListIdentityPoolsResponse = {
    IdentityPools?: CognitoIdentity$20140630$IdentityPoolsList;
    NextToken?: string;
  };
  declare type CognitoIdentity$20140630$LoginsList = string[];
  declare type CognitoIdentity$20140630$LoginsMap = {
    [key: string]: string;
  };
  declare type CognitoIdentity$20140630$LookupDeveloperIdentityInput = {
    IdentityPoolId: string;
    IdentityId?: string;
    DeveloperUserIdentifier?: string;
    MaxResults?: number;
    NextToken?: string;
  };
  declare type CognitoIdentity$20140630$LookupDeveloperIdentityResponse = {
    IdentityId?: string;
    DeveloperUserIdentifierList?: CognitoIdentity$20140630$DeveloperUserIdentifierList;
    NextToken?: string;
  };
  declare type CognitoIdentity$20140630$MergeDeveloperIdentitiesInput = {
    SourceUserIdentifier: string;
    DestinationUserIdentifier: string;
    DeveloperProviderName: string;
    IdentityPoolId: string;
  };
  declare type CognitoIdentity$20140630$MergeDeveloperIdentitiesResponse = {
    IdentityId?: string;
  };
  declare type CognitoIdentity$20140630$NotAuthorizedException = {
    message?: string;
  };
  declare type CognitoIdentity$20140630$OIDCProviderList = string[];
  declare type CognitoIdentity$20140630$ResourceConflictException = {
    message?: string;
  };
  declare type CognitoIdentity$20140630$ResourceNotFoundException = {
    message?: string;
  };
  declare type CognitoIdentity$20140630$RolesMap = {
    [key: string]: string;
  };
  declare type CognitoIdentity$20140630$SAMLProviderList = string[];
  declare type CognitoIdentity$20140630$SetIdentityPoolRolesInput = {
    IdentityPoolId: string;
    Roles: {
      [key: string]: string;
    };
  };
  declare type CognitoIdentity$20140630$TooManyRequestsException = {
    message?: string;
  };
  declare type CognitoIdentity$20140630$UnlinkDeveloperIdentityInput = {
    IdentityId: string;
    IdentityPoolId: string;
    DeveloperProviderName: string;
    DeveloperUserIdentifier: string;
  };
  declare type CognitoIdentity$20140630$UnlinkIdentityInput = {
    IdentityId: string;
    Logins: {
      [key: string]: string;
    };
    LoginsToRemove: CognitoIdentity$20140630$LoginsList;
  };
  declare type CognitoIdentity$20140630$UnprocessedIdentityId = {
    IdentityId?: string;
    ErrorCode?: 'AccessDenied' | 'InternalServerError';
  };
  declare type CognitoIdentity$20140630$UnprocessedIdentityIdList = CognitoIdentity$20140630$UnprocessedIdentityId[];
  declare type CognitoIdentityServiceProvider$20160418$AddCustomAttributesRequest = {
    UserPoolId: string;
    CustomAttributes: CognitoIdentityServiceProvider$20160418$CustomAttributesListType;
  };
  declare type CognitoIdentityServiceProvider$20160418$AddCustomAttributesResponse = {};
  declare type CognitoIdentityServiceProvider$20160418$AdminConfirmSignUpRequest = {
    UserPoolId: string;
    Username: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$AdminConfirmSignUpResponse = {};
  declare type CognitoIdentityServiceProvider$20160418$AdminDeleteUserAttributesRequest = {
    UserPoolId: string;
    Username: string;
    UserAttributeNames: CognitoIdentityServiceProvider$20160418$AttributeNameListType;
  };
  declare type CognitoIdentityServiceProvider$20160418$AdminDeleteUserAttributesResponse = {};
  declare type CognitoIdentityServiceProvider$20160418$AdminDeleteUserRequest = {
    UserPoolId: string;
    Username: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$AdminDisableUserRequest = {
    UserPoolId: string;
    Username: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$AdminDisableUserResponse = {};
  declare type CognitoIdentityServiceProvider$20160418$AdminEnableUserRequest = {
    UserPoolId: string;
    Username: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$AdminEnableUserResponse = {};
  declare type CognitoIdentityServiceProvider$20160418$AdminForgetDeviceRequest = {
    UserPoolId: string;
    Username: string;
    DeviceKey: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$AdminGetDeviceRequest = {
    DeviceKey: string;
    UserPoolId: string;
    Username: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$AdminGetDeviceResponse = {
    Device: CognitoIdentityServiceProvider$20160418$DeviceType;
  };
  declare type CognitoIdentityServiceProvider$20160418$AdminGetUserRequest = {
    UserPoolId: string;
    Username: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$AdminGetUserResponse = {
    Username: string;
    UserAttributes?: CognitoIdentityServiceProvider$20160418$AttributeListType;
    UserCreateDate?: Date;
    UserLastModifiedDate?: Date;
    Enabled?: boolean;
    UserStatus?: 'UNCONFIRMED' | 'CONFIRMED' | 'ARCHIVED' | 'COMPROMISED' | 'UNKNOWN' | 'RESET_REQUIRED';
    MFAOptions?: CognitoIdentityServiceProvider$20160418$MFAOptionListType;
  };
  declare type CognitoIdentityServiceProvider$20160418$AdminInitiateAuthRequest = {
    UserPoolId: string;
    ClientId: string;
    AuthFlow: 'USER_SRP_AUTH' | 'REFRESH_TOKEN_AUTH' | 'CUSTOM_AUTH' | 'ADMIN_NO_SRP_AUTH';
    AuthParameters?: {
      [key: string]: string;
    };
    ClientMetadata?: {
      [key: string]: string;
    };
  };
  declare type CognitoIdentityServiceProvider$20160418$AdminInitiateAuthResponse = {
    ChallengeName?: 'SMS_MFA' | 'PASSWORD_VERIFIER' | 'CUSTOM_CHALLENGE' | 'DEVICE_SRP_AUTH' | 'DEVICE_PASSWORD_VERIFIER' | 'ADMIN_NO_SRP_AUTH';
    Session?: string;
    ChallengeParameters?: {
      [key: string]: string;
    };
    AuthenticationResult?: CognitoIdentityServiceProvider$20160418$AuthenticationResultType;
  };
  declare type CognitoIdentityServiceProvider$20160418$AdminListDevicesRequest = {
    UserPoolId: string;
    Username: string;
    Limit?: number;
    PaginationToken?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$AdminListDevicesResponse = {
    Devices?: CognitoIdentityServiceProvider$20160418$DeviceListType;
    PaginationToken?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$AdminResetUserPasswordRequest = {
    UserPoolId: string;
    Username: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$AdminResetUserPasswordResponse = {};
  declare type CognitoIdentityServiceProvider$20160418$AdminRespondToAuthChallengeRequest = {
    UserPoolId: string;
    ClientId: string;
    ChallengeName: 'SMS_MFA' | 'PASSWORD_VERIFIER' | 'CUSTOM_CHALLENGE' | 'DEVICE_SRP_AUTH' | 'DEVICE_PASSWORD_VERIFIER' | 'ADMIN_NO_SRP_AUTH';
    ChallengeResponses?: {
      [key: string]: string;
    };
    Session?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$AdminRespondToAuthChallengeResponse = {
    ChallengeName?: 'SMS_MFA' | 'PASSWORD_VERIFIER' | 'CUSTOM_CHALLENGE' | 'DEVICE_SRP_AUTH' | 'DEVICE_PASSWORD_VERIFIER' | 'ADMIN_NO_SRP_AUTH';
    Session?: string;
    ChallengeParameters?: {
      [key: string]: string;
    };
    AuthenticationResult?: CognitoIdentityServiceProvider$20160418$AuthenticationResultType;
  };
  declare type CognitoIdentityServiceProvider$20160418$AdminSetUserSettingsRequest = {
    UserPoolId: string;
    Username: string;
    MFAOptions: CognitoIdentityServiceProvider$20160418$MFAOptionListType;
  };
  declare type CognitoIdentityServiceProvider$20160418$AdminSetUserSettingsResponse = {};
  declare type CognitoIdentityServiceProvider$20160418$AdminUpdateDeviceStatusRequest = {
    UserPoolId: string;
    Username: string;
    DeviceKey: string;
    DeviceRememberedStatus?: 'remembered' | 'not_remembered';
  };
  declare type CognitoIdentityServiceProvider$20160418$AdminUpdateDeviceStatusResponse = {};
  declare type CognitoIdentityServiceProvider$20160418$AdminUpdateUserAttributesRequest = {
    UserPoolId: string;
    Username: string;
    UserAttributes: CognitoIdentityServiceProvider$20160418$AttributeListType;
  };
  declare type CognitoIdentityServiceProvider$20160418$AdminUpdateUserAttributesResponse = {};
  declare type CognitoIdentityServiceProvider$20160418$AdminUserGlobalSignOutRequest = {
    UserPoolId: string;
    Username: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$AdminUserGlobalSignOutResponse = {};
  declare type CognitoIdentityServiceProvider$20160418$AliasAttributeType = 'phone_number' | 'email' | 'preferred_username';
  declare type CognitoIdentityServiceProvider$20160418$AliasAttributesListType = ('phone_number' | 'email' | 'preferred_username')[];
  declare type CognitoIdentityServiceProvider$20160418$AliasExistsException = {
    message?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$AttributeDataType = 'String' | 'Number' | 'DateTime' | 'Boolean';
  declare type CognitoIdentityServiceProvider$20160418$AttributeListType = CognitoIdentityServiceProvider$20160418$AttributeType[];
  declare type CognitoIdentityServiceProvider$20160418$AttributeNameListType = string[];
  declare type CognitoIdentityServiceProvider$20160418$AttributeType = {
    Name: string;
    Value?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$AuthFlowType = 'USER_SRP_AUTH' | 'REFRESH_TOKEN_AUTH' | 'CUSTOM_AUTH' | 'ADMIN_NO_SRP_AUTH';
  declare type CognitoIdentityServiceProvider$20160418$AuthParametersType = {
    [key: string]: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$AuthenticationResultType = {
    AccessToken?: string;
    ExpiresIn?: number;
    TokenType?: string;
    RefreshToken?: string;
    IdToken?: string;
    NewDeviceMetadata?: CognitoIdentityServiceProvider$20160418$NewDeviceMetadataType;
  };
  declare type CognitoIdentityServiceProvider$20160418$ChallengeNameType = 'SMS_MFA' | 'PASSWORD_VERIFIER' | 'CUSTOM_CHALLENGE' | 'DEVICE_SRP_AUTH' | 'DEVICE_PASSWORD_VERIFIER' | 'ADMIN_NO_SRP_AUTH';
  declare type CognitoIdentityServiceProvider$20160418$ChallengeParametersType = {
    [key: string]: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$ChallengeResponsesType = {
    [key: string]: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$ChangePasswordRequest = {
    PreviousPassword: string;
    ProposedPassword: string;
    AccessToken?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$ChangePasswordResponse = {};
  declare type CognitoIdentityServiceProvider$20160418$ClientMetadataType = {
    [key: string]: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$ClientPermissionListType = string[];
  declare type CognitoIdentityServiceProvider$20160418$CodeDeliveryDetailsListType = CognitoIdentityServiceProvider$20160418$CodeDeliveryDetailsType[];
  declare type CognitoIdentityServiceProvider$20160418$CodeDeliveryDetailsType = {
    Destination?: string;
    DeliveryMedium?: 'SMS' | 'EMAIL';
    AttributeName?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$CodeDeliveryFailureException = {
    message?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$CodeMismatchException = {
    message?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$ConcurrentModificationException = {
    message?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$ConfirmDeviceRequest = {
    AccessToken: string;
    DeviceKey: string;
    DeviceSecretVerifierConfig?: CognitoIdentityServiceProvider$20160418$DeviceSecretVerifierConfigType;
    DeviceName?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$ConfirmDeviceResponse = {
    UserConfirmationNecessary?: boolean;
  };
  declare type CognitoIdentityServiceProvider$20160418$ConfirmForgotPasswordRequest = {
    ClientId: string;
    SecretHash?: string;
    Username: string;
    ConfirmationCode: string;
    Password: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$ConfirmForgotPasswordResponse = {};
  declare type CognitoIdentityServiceProvider$20160418$ConfirmSignUpRequest = {
    ClientId: string;
    SecretHash?: string;
    Username: string;
    ConfirmationCode: string;
    ForceAliasCreation?: boolean;
  };
  declare type CognitoIdentityServiceProvider$20160418$ConfirmSignUpResponse = {};
  declare type CognitoIdentityServiceProvider$20160418$CreateUserPoolClientRequest = {
    UserPoolId: string;
    ClientName: string;
    GenerateSecret?: boolean;
    RefreshTokenValidity?: number;
    ReadAttributes?: CognitoIdentityServiceProvider$20160418$ClientPermissionListType;
    WriteAttributes?: CognitoIdentityServiceProvider$20160418$ClientPermissionListType;
    ExplicitAuthFlows?: CognitoIdentityServiceProvider$20160418$ExplicitAuthFlowsListType;
  };
  declare type CognitoIdentityServiceProvider$20160418$CreateUserPoolClientResponse = {
    UserPoolClient?: CognitoIdentityServiceProvider$20160418$UserPoolClientType;
  };
  declare type CognitoIdentityServiceProvider$20160418$CreateUserPoolRequest = {
    PoolName: string;
    Policies?: CognitoIdentityServiceProvider$20160418$UserPoolPolicyType;
    LambdaConfig?: CognitoIdentityServiceProvider$20160418$LambdaConfigType;
    AutoVerifiedAttributes?: CognitoIdentityServiceProvider$20160418$VerifiedAttributesListType;
    AliasAttributes?: CognitoIdentityServiceProvider$20160418$AliasAttributesListType;
    SmsVerificationMessage?: string;
    EmailVerificationMessage?: string;
    EmailVerificationSubject?: string;
    SmsAuthenticationMessage?: string;
    MfaConfiguration?: 'OFF' | 'ON' | 'OPTIONAL';
    DeviceConfiguration?: CognitoIdentityServiceProvider$20160418$DeviceConfigurationType;
    EmailConfiguration?: CognitoIdentityServiceProvider$20160418$EmailConfigurationType;
    SmsConfiguration?: CognitoIdentityServiceProvider$20160418$SmsConfigurationType;
  };
  declare type CognitoIdentityServiceProvider$20160418$CreateUserPoolResponse = {
    UserPool?: CognitoIdentityServiceProvider$20160418$UserPoolType;
  };
  declare type CognitoIdentityServiceProvider$20160418$CustomAttributesListType = CognitoIdentityServiceProvider$20160418$SchemaAttributeType[];
  declare type CognitoIdentityServiceProvider$20160418$DateType = Date;
  declare type CognitoIdentityServiceProvider$20160418$DeleteUserAttributesRequest = {
    UserAttributeNames: CognitoIdentityServiceProvider$20160418$AttributeNameListType;
    AccessToken?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$DeleteUserAttributesResponse = {};
  declare type CognitoIdentityServiceProvider$20160418$DeleteUserPoolClientRequest = {
    UserPoolId: string;
    ClientId: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$DeleteUserPoolRequest = {
    UserPoolId: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$DeleteUserRequest = {
    AccessToken?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$DeliveryMediumType = 'SMS' | 'EMAIL';
  declare type CognitoIdentityServiceProvider$20160418$DescribeUserPoolClientRequest = {
    UserPoolId: string;
    ClientId: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$DescribeUserPoolClientResponse = {
    UserPoolClient?: CognitoIdentityServiceProvider$20160418$UserPoolClientType;
  };
  declare type CognitoIdentityServiceProvider$20160418$DescribeUserPoolRequest = {
    UserPoolId: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$DescribeUserPoolResponse = {
    UserPool?: CognitoIdentityServiceProvider$20160418$UserPoolType;
  };
  declare type CognitoIdentityServiceProvider$20160418$DeviceConfigurationType = {
    ChallengeRequiredOnNewDevice?: boolean;
    DeviceOnlyRememberedOnUserPrompt?: boolean;
  };
  declare type CognitoIdentityServiceProvider$20160418$DeviceListType = CognitoIdentityServiceProvider$20160418$DeviceType[];
  declare type CognitoIdentityServiceProvider$20160418$DeviceRememberedStatusType = 'remembered' | 'not_remembered';
  declare type CognitoIdentityServiceProvider$20160418$DeviceSecretVerifierConfigType = {
    PasswordVerifier?: string;
    Salt?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$DeviceType = {
    DeviceKey?: string;
    DeviceAttributes?: CognitoIdentityServiceProvider$20160418$AttributeListType;
    DeviceCreateDate?: Date;
    DeviceLastModifiedDate?: Date;
    DeviceLastAuthenticatedDate?: Date;
  };
  declare type CognitoIdentityServiceProvider$20160418$EmailConfigurationType = {
    SourceArn?: string;
    ReplyToEmailAddress?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$ExpiredCodeException = {
    message?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$ExplicitAuthFlowsListType = ('ADMIN_NO_SRP_AUTH')[];
  declare type CognitoIdentityServiceProvider$20160418$ExplicitAuthFlowsType = 'ADMIN_NO_SRP_AUTH';
  declare type CognitoIdentityServiceProvider$20160418$ForgetDeviceRequest = {
    AccessToken?: string;
    DeviceKey: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$ForgotPasswordRequest = {
    ClientId: string;
    SecretHash?: string;
    Username: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$ForgotPasswordResponse = {
    CodeDeliveryDetails?: CognitoIdentityServiceProvider$20160418$CodeDeliveryDetailsType;
  };
  declare type CognitoIdentityServiceProvider$20160418$GetDeviceRequest = {
    DeviceKey: string;
    AccessToken?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$GetDeviceResponse = {
    Device: CognitoIdentityServiceProvider$20160418$DeviceType;
  };
  declare type CognitoIdentityServiceProvider$20160418$GetUserAttributeVerificationCodeRequest = {
    AccessToken?: string;
    AttributeName: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$GetUserAttributeVerificationCodeResponse = {
    CodeDeliveryDetails?: CognitoIdentityServiceProvider$20160418$CodeDeliveryDetailsType;
  };
  declare type CognitoIdentityServiceProvider$20160418$GetUserRequest = {
    AccessToken?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$GetUserResponse = {
    Username: string;
    UserAttributes: CognitoIdentityServiceProvider$20160418$AttributeListType;
    MFAOptions?: CognitoIdentityServiceProvider$20160418$MFAOptionListType;
  };
  declare type CognitoIdentityServiceProvider$20160418$GlobalSignOutRequest = {
    AccessToken?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$GlobalSignOutResponse = {};
  declare type CognitoIdentityServiceProvider$20160418$InitiateAuthRequest = {
    AuthFlow: 'USER_SRP_AUTH' | 'REFRESH_TOKEN_AUTH' | 'CUSTOM_AUTH' | 'ADMIN_NO_SRP_AUTH';
    AuthParameters?: {
      [key: string]: string;
    };
    ClientMetadata?: {
      [key: string]: string;
    };
    ClientId: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$InitiateAuthResponse = {
    ChallengeName?: 'SMS_MFA' | 'PASSWORD_VERIFIER' | 'CUSTOM_CHALLENGE' | 'DEVICE_SRP_AUTH' | 'DEVICE_PASSWORD_VERIFIER' | 'ADMIN_NO_SRP_AUTH';
    Session?: string;
    ChallengeParameters?: {
      [key: string]: string;
    };
    AuthenticationResult?: CognitoIdentityServiceProvider$20160418$AuthenticationResultType;
  };
  declare type CognitoIdentityServiceProvider$20160418$InternalErrorException = {
    message?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$InvalidEmailRoleAccessPolicyException = {
    message?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$InvalidLambdaResponseException = {
    message?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$InvalidParameterException = {
    message?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$InvalidPasswordException = {
    message?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$InvalidSmsRoleAccessPolicyException = {
    message?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$InvalidSmsRoleTrustRelationshipException = {
    message?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$InvalidUserPoolConfigurationException = {
    message?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$LambdaConfigType = {
    PreSignUp?: string;
    CustomMessage?: string;
    PostConfirmation?: string;
    PreAuthentication?: string;
    PostAuthentication?: string;
    DefineAuthChallenge?: string;
    CreateAuthChallenge?: string;
    VerifyAuthChallengeResponse?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$LimitExceededException = {
    message?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$ListDevicesRequest = {
    AccessToken: string;
    Limit?: number;
    PaginationToken?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$ListDevicesResponse = {
    Devices?: CognitoIdentityServiceProvider$20160418$DeviceListType;
    PaginationToken?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$ListUserPoolClientsRequest = {
    UserPoolId: string;
    MaxResults?: number;
    NextToken?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$ListUserPoolClientsResponse = {
    UserPoolClients?: CognitoIdentityServiceProvider$20160418$UserPoolClientListType;
    NextToken?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$ListUserPoolsRequest = {
    NextToken?: string;
    MaxResults: number;
  };
  declare type CognitoIdentityServiceProvider$20160418$ListUserPoolsResponse = {
    UserPools?: CognitoIdentityServiceProvider$20160418$UserPoolListType;
    NextToken?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$ListUsersRequest = {
    UserPoolId: string;
    AttributesToGet?: CognitoIdentityServiceProvider$20160418$SearchedAttributeNamesListType;
    Limit?: number;
    PaginationToken?: string;
    Filter?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$ListUsersResponse = {
    Users?: CognitoIdentityServiceProvider$20160418$UsersListType;
    PaginationToken?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$MFAMethodNotFoundException = {
    message?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$MFAOptionListType = CognitoIdentityServiceProvider$20160418$MFAOptionType[];
  declare type CognitoIdentityServiceProvider$20160418$MFAOptionType = {
    DeliveryMedium?: 'SMS' | 'EMAIL';
    AttributeName?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$NewDeviceMetadataType = {
    DeviceKey?: string;
    DeviceGroupKey?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$NotAuthorizedException = {
    message?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$NumberAttributeConstraintsType = {
    MinValue?: string;
    MaxValue?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$PasswordPolicyType = {
    MinimumLength?: number;
    RequireUppercase?: boolean;
    RequireLowercase?: boolean;
    RequireNumbers?: boolean;
    RequireSymbols?: boolean;
  };
  declare type CognitoIdentityServiceProvider$20160418$PasswordResetRequiredException = {
    message?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$ResendConfirmationCodeRequest = {
    ClientId: string;
    SecretHash?: string;
    Username: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$ResendConfirmationCodeResponse = {
    CodeDeliveryDetails?: CognitoIdentityServiceProvider$20160418$CodeDeliveryDetailsType;
  };
  declare type CognitoIdentityServiceProvider$20160418$ResourceNotFoundException = {
    message?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$RespondToAuthChallengeRequest = {
    ClientId: string;
    ChallengeName: 'SMS_MFA' | 'PASSWORD_VERIFIER' | 'CUSTOM_CHALLENGE' | 'DEVICE_SRP_AUTH' | 'DEVICE_PASSWORD_VERIFIER' | 'ADMIN_NO_SRP_AUTH';
    Session?: string;
    ChallengeResponses?: {
      [key: string]: string;
    };
  };
  declare type CognitoIdentityServiceProvider$20160418$RespondToAuthChallengeResponse = {
    ChallengeName?: 'SMS_MFA' | 'PASSWORD_VERIFIER' | 'CUSTOM_CHALLENGE' | 'DEVICE_SRP_AUTH' | 'DEVICE_PASSWORD_VERIFIER' | 'ADMIN_NO_SRP_AUTH';
    Session?: string;
    ChallengeParameters?: {
      [key: string]: string;
    };
    AuthenticationResult?: CognitoIdentityServiceProvider$20160418$AuthenticationResultType;
  };
  declare type CognitoIdentityServiceProvider$20160418$SchemaAttributeType = {
    Name?: string;
    AttributeDataType?: 'String' | 'Number' | 'DateTime' | 'Boolean';
    DeveloperOnlyAttribute?: boolean;
    Mutable?: boolean;
    Required?: boolean;
    NumberAttributeConstraints?: CognitoIdentityServiceProvider$20160418$NumberAttributeConstraintsType;
    StringAttributeConstraints?: CognitoIdentityServiceProvider$20160418$StringAttributeConstraintsType;
  };
  declare type CognitoIdentityServiceProvider$20160418$SchemaAttributesListType = CognitoIdentityServiceProvider$20160418$SchemaAttributeType[];
  declare type CognitoIdentityServiceProvider$20160418$SearchedAttributeNamesListType = string[];
  declare type CognitoIdentityServiceProvider$20160418$SetUserSettingsRequest = {
    AccessToken: string;
    MFAOptions: CognitoIdentityServiceProvider$20160418$MFAOptionListType;
  };
  declare type CognitoIdentityServiceProvider$20160418$SetUserSettingsResponse = {};
  declare type CognitoIdentityServiceProvider$20160418$SignUpRequest = {
    ClientId: string;
    SecretHash?: string;
    Username: string;
    Password: string;
    UserAttributes?: CognitoIdentityServiceProvider$20160418$AttributeListType;
    ValidationData?: CognitoIdentityServiceProvider$20160418$AttributeListType;
  };
  declare type CognitoIdentityServiceProvider$20160418$SignUpResponse = {
    UserConfirmed?: boolean;
    CodeDeliveryDetails?: CognitoIdentityServiceProvider$20160418$CodeDeliveryDetailsType;
  };
  declare type CognitoIdentityServiceProvider$20160418$SmsConfigurationType = {
    SnsCallerArn?: string;
    ExternalId?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$StatusType = 'Enabled' | 'Disabled';
  declare type CognitoIdentityServiceProvider$20160418$StringAttributeConstraintsType = {
    MinLength?: string;
    MaxLength?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$TooManyFailedAttemptsException = {
    message?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$TooManyRequestsException = {
    message?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$UnexpectedLambdaException = {
    message?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$UpdateDeviceStatusRequest = {
    AccessToken: string;
    DeviceKey: string;
    DeviceRememberedStatus?: 'remembered' | 'not_remembered';
  };
  declare type CognitoIdentityServiceProvider$20160418$UpdateDeviceStatusResponse = {};
  declare type CognitoIdentityServiceProvider$20160418$UpdateUserAttributesRequest = {
    UserAttributes: CognitoIdentityServiceProvider$20160418$AttributeListType;
    AccessToken?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$UpdateUserAttributesResponse = {
    CodeDeliveryDetailsList?: CognitoIdentityServiceProvider$20160418$CodeDeliveryDetailsListType;
  };
  declare type CognitoIdentityServiceProvider$20160418$UpdateUserPoolClientRequest = {
    UserPoolId: string;
    ClientId: string;
    ClientName?: string;
    RefreshTokenValidity?: number;
    ReadAttributes?: CognitoIdentityServiceProvider$20160418$ClientPermissionListType;
    WriteAttributes?: CognitoIdentityServiceProvider$20160418$ClientPermissionListType;
    ExplicitAuthFlows?: CognitoIdentityServiceProvider$20160418$ExplicitAuthFlowsListType;
  };
  declare type CognitoIdentityServiceProvider$20160418$UpdateUserPoolClientResponse = {
    UserPoolClient?: CognitoIdentityServiceProvider$20160418$UserPoolClientType;
  };
  declare type CognitoIdentityServiceProvider$20160418$UpdateUserPoolRequest = {
    UserPoolId: string;
    Policies?: CognitoIdentityServiceProvider$20160418$UserPoolPolicyType;
    LambdaConfig?: CognitoIdentityServiceProvider$20160418$LambdaConfigType;
    AutoVerifiedAttributes?: CognitoIdentityServiceProvider$20160418$VerifiedAttributesListType;
    SmsVerificationMessage?: string;
    EmailVerificationMessage?: string;
    EmailVerificationSubject?: string;
    SmsAuthenticationMessage?: string;
    MfaConfiguration?: 'OFF' | 'ON' | 'OPTIONAL';
    DeviceConfiguration?: CognitoIdentityServiceProvider$20160418$DeviceConfigurationType;
    EmailConfiguration?: CognitoIdentityServiceProvider$20160418$EmailConfigurationType;
    SmsConfiguration?: CognitoIdentityServiceProvider$20160418$SmsConfigurationType;
  };
  declare type CognitoIdentityServiceProvider$20160418$UpdateUserPoolResponse = {};
  declare type CognitoIdentityServiceProvider$20160418$UserLambdaValidationException = {
    message?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$UserNotConfirmedException = {
    message?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$UserNotFoundException = {
    message?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$UserPoolClientDescription = {
    ClientId?: string;
    UserPoolId?: string;
    ClientName?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$UserPoolClientListType = CognitoIdentityServiceProvider$20160418$UserPoolClientDescription[];
  declare type CognitoIdentityServiceProvider$20160418$UserPoolClientType = {
    UserPoolId?: string;
    ClientName?: string;
    ClientId?: string;
    ClientSecret?: string;
    LastModifiedDate?: Date;
    CreationDate?: Date;
    RefreshTokenValidity?: number;
    ReadAttributes?: CognitoIdentityServiceProvider$20160418$ClientPermissionListType;
    WriteAttributes?: CognitoIdentityServiceProvider$20160418$ClientPermissionListType;
    ExplicitAuthFlows?: CognitoIdentityServiceProvider$20160418$ExplicitAuthFlowsListType;
  };
  declare type CognitoIdentityServiceProvider$20160418$UserPoolDescriptionType = {
    Id?: string;
    Name?: string;
    LambdaConfig?: CognitoIdentityServiceProvider$20160418$LambdaConfigType;
    Status?: 'Enabled' | 'Disabled';
    LastModifiedDate?: Date;
    CreationDate?: Date;
  };
  declare type CognitoIdentityServiceProvider$20160418$UserPoolListType = CognitoIdentityServiceProvider$20160418$UserPoolDescriptionType[];
  declare type CognitoIdentityServiceProvider$20160418$UserPoolMfaType = 'OFF' | 'ON' | 'OPTIONAL';
  declare type CognitoIdentityServiceProvider$20160418$UserPoolPolicyType = {
    PasswordPolicy?: CognitoIdentityServiceProvider$20160418$PasswordPolicyType;
  };
  declare type CognitoIdentityServiceProvider$20160418$UserPoolType = {
    Id?: string;
    Name?: string;
    Policies?: CognitoIdentityServiceProvider$20160418$UserPoolPolicyType;
    LambdaConfig?: CognitoIdentityServiceProvider$20160418$LambdaConfigType;
    Status?: 'Enabled' | 'Disabled';
    LastModifiedDate?: Date;
    CreationDate?: Date;
    SchemaAttributes?: CognitoIdentityServiceProvider$20160418$SchemaAttributesListType;
    AutoVerifiedAttributes?: CognitoIdentityServiceProvider$20160418$VerifiedAttributesListType;
    AliasAttributes?: CognitoIdentityServiceProvider$20160418$AliasAttributesListType;
    SmsVerificationMessage?: string;
    EmailVerificationMessage?: string;
    EmailVerificationSubject?: string;
    SmsAuthenticationMessage?: string;
    MfaConfiguration?: 'OFF' | 'ON' | 'OPTIONAL';
    DeviceConfiguration?: CognitoIdentityServiceProvider$20160418$DeviceConfigurationType;
    EstimatedNumberOfUsers?: number;
    EmailConfiguration?: CognitoIdentityServiceProvider$20160418$EmailConfigurationType;
    SmsConfiguration?: CognitoIdentityServiceProvider$20160418$SmsConfigurationType;
    SmsConfigurationFailure?: string;
    EmailConfigurationFailure?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$UserStatusType = 'UNCONFIRMED' | 'CONFIRMED' | 'ARCHIVED' | 'COMPROMISED' | 'UNKNOWN' | 'RESET_REQUIRED';
  declare type CognitoIdentityServiceProvider$20160418$UserType = {
    Username?: string;
    Attributes?: CognitoIdentityServiceProvider$20160418$AttributeListType;
    UserCreateDate?: Date;
    UserLastModifiedDate?: Date;
    Enabled?: boolean;
    UserStatus?: 'UNCONFIRMED' | 'CONFIRMED' | 'ARCHIVED' | 'COMPROMISED' | 'UNKNOWN' | 'RESET_REQUIRED';
  };
  declare type CognitoIdentityServiceProvider$20160418$UsernameExistsException = {
    message?: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$UsersListType = CognitoIdentityServiceProvider$20160418$UserType[];
  declare type CognitoIdentityServiceProvider$20160418$VerifiedAttributeType = 'phone_number' | 'email';
  declare type CognitoIdentityServiceProvider$20160418$VerifiedAttributesListType = ('phone_number' | 'email')[];
  declare type CognitoIdentityServiceProvider$20160418$VerifyUserAttributeRequest = {
    AccessToken?: string;
    AttributeName: string;
    Code: string;
  };
  declare type CognitoIdentityServiceProvider$20160418$VerifyUserAttributeResponse = {};
  declare type CognitoSync$20140630$AlreadyStreamedException = {
    message: string;
  };
  declare type CognitoSync$20140630$ApplicationArnList = string[];
  declare type CognitoSync$20140630$BulkPublishRequest = {
    IdentityPoolId: string;
  };
  declare type CognitoSync$20140630$BulkPublishResponse = {
    IdentityPoolId?: string;
  };
  declare type CognitoSync$20140630$BulkPublishStatus = 'NOT_STARTED' | 'IN_PROGRESS' | 'FAILED' | 'SUCCEEDED';
  declare type CognitoSync$20140630$CognitoStreams = {
    StreamName?: string;
    RoleArn?: string;
    StreamingStatus?: 'ENABLED' | 'DISABLED';
  };
  declare type CognitoSync$20140630$ConcurrentModificationException = {
    message: string;
  };
  declare type CognitoSync$20140630$Dataset = {
    IdentityId?: string;
    DatasetName?: string;
    CreationDate?: Date;
    LastModifiedDate?: Date;
    LastModifiedBy?: string;
    DataStorage?: number;
    NumRecords?: number;
  };
  declare type CognitoSync$20140630$DatasetList = CognitoSync$20140630$Dataset[];
  declare type CognitoSync$20140630$Date = Date;
  declare type CognitoSync$20140630$DeleteDatasetRequest = {
    IdentityPoolId: string;
    IdentityId: string;
    DatasetName: string;
  };
  declare type CognitoSync$20140630$DeleteDatasetResponse = {
    Dataset?: CognitoSync$20140630$Dataset;
  };
  declare type CognitoSync$20140630$DescribeDatasetRequest = {
    IdentityPoolId: string;
    IdentityId: string;
    DatasetName: string;
  };
  declare type CognitoSync$20140630$DescribeDatasetResponse = {
    Dataset?: CognitoSync$20140630$Dataset;
  };
  declare type CognitoSync$20140630$DescribeIdentityPoolUsageRequest = {
    IdentityPoolId: string;
  };
  declare type CognitoSync$20140630$DescribeIdentityPoolUsageResponse = {
    IdentityPoolUsage?: CognitoSync$20140630$IdentityPoolUsage;
  };
  declare type CognitoSync$20140630$DescribeIdentityUsageRequest = {
    IdentityPoolId: string;
    IdentityId: string;
  };
  declare type CognitoSync$20140630$DescribeIdentityUsageResponse = {
    IdentityUsage?: CognitoSync$20140630$IdentityUsage;
  };
  declare type CognitoSync$20140630$DuplicateRequestException = {
    message: string;
  };
  declare type CognitoSync$20140630$Events = {
    [key: string]: string;
  };
  declare type CognitoSync$20140630$GetBulkPublishDetailsRequest = {
    IdentityPoolId: string;
  };
  declare type CognitoSync$20140630$GetBulkPublishDetailsResponse = {
    IdentityPoolId?: string;
    BulkPublishStartTime?: Date;
    BulkPublishCompleteTime?: Date;
    BulkPublishStatus?: 'NOT_STARTED' | 'IN_PROGRESS' | 'FAILED' | 'SUCCEEDED';
    FailureMessage?: string;
  };
  declare type CognitoSync$20140630$GetCognitoEventsRequest = {
    IdentityPoolId: string;
  };
  declare type CognitoSync$20140630$GetCognitoEventsResponse = {
    Events?: {
      [key: string]: string;
    };
  };
  declare type CognitoSync$20140630$GetIdentityPoolConfigurationRequest = {
    IdentityPoolId: string;
  };
  declare type CognitoSync$20140630$GetIdentityPoolConfigurationResponse = {
    IdentityPoolId?: string;
    PushSync?: CognitoSync$20140630$PushSync;
    CognitoStreams?: CognitoSync$20140630$CognitoStreams;
  };
  declare type CognitoSync$20140630$IdentityPoolUsage = {
    IdentityPoolId?: string;
    SyncSessionsCount?: number;
    DataStorage?: number;
    LastModifiedDate?: Date;
  };
  declare type CognitoSync$20140630$IdentityPoolUsageList = CognitoSync$20140630$IdentityPoolUsage[];
  declare type CognitoSync$20140630$IdentityUsage = {
    IdentityId?: string;
    IdentityPoolId?: string;
    LastModifiedDate?: Date;
    DatasetCount?: number;
    DataStorage?: number;
  };
  declare type CognitoSync$20140630$InternalErrorException = {
    message: string;
  };
  declare type CognitoSync$20140630$InvalidConfigurationException = {
    message: string;
  };
  declare type CognitoSync$20140630$InvalidLambdaFunctionOutputException = {
    message: string;
  };
  declare type CognitoSync$20140630$InvalidParameterException = {
    message: string;
  };
  declare type CognitoSync$20140630$LambdaThrottledException = {
    message: string;
  };
  declare type CognitoSync$20140630$LimitExceededException = {
    message: string;
  };
  declare type CognitoSync$20140630$ListDatasetsRequest = {
    IdentityPoolId: string;
    IdentityId: string;
    NextToken?: string;
    MaxResults?: number;
  };
  declare type CognitoSync$20140630$ListDatasetsResponse = {
    Datasets?: CognitoSync$20140630$DatasetList;
    Count?: number;
    NextToken?: string;
  };
  declare type CognitoSync$20140630$ListIdentityPoolUsageRequest = {
    NextToken?: string;
    MaxResults?: number;
  };
  declare type CognitoSync$20140630$ListIdentityPoolUsageResponse = {
    IdentityPoolUsages?: CognitoSync$20140630$IdentityPoolUsageList;
    MaxResults?: number;
    Count?: number;
    NextToken?: string;
  };
  declare type CognitoSync$20140630$ListRecordsRequest = {
    IdentityPoolId: string;
    IdentityId: string;
    DatasetName: string;
    LastSyncCount?: number;
    NextToken?: string;
    MaxResults?: number;
    SyncSessionToken?: string;
  };
  declare type CognitoSync$20140630$ListRecordsResponse = {
    Records?: CognitoSync$20140630$RecordList;
    NextToken?: string;
    Count?: number;
    DatasetSyncCount?: number;
    LastModifiedBy?: string;
    MergedDatasetNames?: CognitoSync$20140630$MergedDatasetNameList;
    DatasetExists?: boolean;
    DatasetDeletedAfterRequestedSyncCount?: boolean;
    SyncSessionToken?: string;
  };
  declare type CognitoSync$20140630$MergedDatasetNameList = string[];
  declare type CognitoSync$20140630$NotAuthorizedException = {
    message: string;
  };
  declare type CognitoSync$20140630$Operation = 'replace' | 'remove';
  declare type CognitoSync$20140630$Platform = 'APNS' | 'APNS_SANDBOX' | 'GCM' | 'ADM';
  declare type CognitoSync$20140630$PushSync = {
    ApplicationArns?: CognitoSync$20140630$ApplicationArnList;
    RoleArn?: string;
  };
  declare type CognitoSync$20140630$Record = {
    Key?: string;
    Value?: string;
    SyncCount?: number;
    LastModifiedDate?: Date;
    LastModifiedBy?: string;
    DeviceLastModifiedDate?: Date;
  };
  declare type CognitoSync$20140630$RecordList = CognitoSync$20140630$Record[];
  declare type CognitoSync$20140630$RecordPatch = {
    Op: 'replace' | 'remove';
    Key: string;
    Value?: string;
    SyncCount: number;
    DeviceLastModifiedDate?: Date;
  };
  declare type CognitoSync$20140630$RecordPatchList = CognitoSync$20140630$RecordPatch[];
  declare type CognitoSync$20140630$RegisterDeviceRequest = {
    IdentityPoolId: string;
    IdentityId: string;
    Platform: 'APNS' | 'APNS_SANDBOX' | 'GCM' | 'ADM';
    Token: string;
  };
  declare type CognitoSync$20140630$RegisterDeviceResponse = {
    DeviceId?: string;
  };
  declare type CognitoSync$20140630$ResourceConflictException = {
    message: string;
  };
  declare type CognitoSync$20140630$ResourceNotFoundException = {
    message: string;
  };
  declare type CognitoSync$20140630$SetCognitoEventsRequest = {
    IdentityPoolId: string;
    Events: {
      [key: string]: string;
    };
  };
  declare type CognitoSync$20140630$SetIdentityPoolConfigurationRequest = {
    IdentityPoolId: string;
    PushSync?: CognitoSync$20140630$PushSync;
    CognitoStreams?: CognitoSync$20140630$CognitoStreams;
  };
  declare type CognitoSync$20140630$SetIdentityPoolConfigurationResponse = {
    IdentityPoolId?: string;
    PushSync?: CognitoSync$20140630$PushSync;
    CognitoStreams?: CognitoSync$20140630$CognitoStreams;
  };
  declare type CognitoSync$20140630$StreamingStatus = 'ENABLED' | 'DISABLED';
  declare type CognitoSync$20140630$SubscribeToDatasetRequest = {
    IdentityPoolId: string;
    IdentityId: string;
    DatasetName: string;
    DeviceId: string;
  };
  declare type CognitoSync$20140630$SubscribeToDatasetResponse = {};
  declare type CognitoSync$20140630$TooManyRequestsException = {
    message: string;
  };
  declare type CognitoSync$20140630$UnsubscribeFromDatasetRequest = {
    IdentityPoolId: string;
    IdentityId: string;
    DatasetName: string;
    DeviceId: string;
  };
  declare type CognitoSync$20140630$UnsubscribeFromDatasetResponse = {};
  declare type CognitoSync$20140630$UpdateRecordsRequest = {
    IdentityPoolId: string;
    IdentityId: string;
    DatasetName: string;
    DeviceId?: string;
    RecordPatches?: CognitoSync$20140630$RecordPatchList;
    SyncSessionToken: string;
    ClientContext?: string;
  };
  declare type CognitoSync$20140630$UpdateRecordsResponse = {
    Records?: CognitoSync$20140630$RecordList;
  };
  declare type ConfigService$20141112$ChronologicalOrder = 'Reverse' | 'Forward';
  declare type ConfigService$20141112$Compliance = {
    ComplianceType?: 'COMPLIANT' | 'NON_COMPLIANT' | 'NOT_APPLICABLE' | 'INSUFFICIENT_DATA';
    ComplianceContributorCount?: ConfigService$20141112$ComplianceContributorCount;
  };
  declare type ConfigService$20141112$ComplianceByConfigRule = {
    ConfigRuleName?: string;
    Compliance?: ConfigService$20141112$Compliance;
  };
  declare type ConfigService$20141112$ComplianceByConfigRules = ConfigService$20141112$ComplianceByConfigRule[];
  declare type ConfigService$20141112$ComplianceByResource = {
    ResourceType?: string;
    ResourceId?: string;
    Compliance?: ConfigService$20141112$Compliance;
  };
  declare type ConfigService$20141112$ComplianceByResources = ConfigService$20141112$ComplianceByResource[];
  declare type ConfigService$20141112$ComplianceContributorCount = {
    CappedCount?: number;
    CapExceeded?: boolean;
  };
  declare type ConfigService$20141112$ComplianceResourceTypes = string[];
  declare type ConfigService$20141112$ComplianceSummariesByResourceType = ConfigService$20141112$ComplianceSummaryByResourceType[];
  declare type ConfigService$20141112$ComplianceSummary = {
    CompliantResourceCount?: ConfigService$20141112$ComplianceContributorCount;
    NonCompliantResourceCount?: ConfigService$20141112$ComplianceContributorCount;
    ComplianceSummaryTimestamp?: Date;
  };
  declare type ConfigService$20141112$ComplianceSummaryByResourceType = {
    ResourceType?: string;
    ComplianceSummary?: ConfigService$20141112$ComplianceSummary;
  };
  declare type ConfigService$20141112$ComplianceType = 'COMPLIANT' | 'NON_COMPLIANT' | 'NOT_APPLICABLE' | 'INSUFFICIENT_DATA';
  declare type ConfigService$20141112$ComplianceTypes = ('COMPLIANT' | 'NON_COMPLIANT' | 'NOT_APPLICABLE' | 'INSUFFICIENT_DATA')[];
  declare type ConfigService$20141112$ConfigExportDeliveryInfo = {
    lastStatus?: 'Success' | 'Failure' | 'Not_Applicable';
    lastErrorCode?: string;
    lastErrorMessage?: string;
    lastAttemptTime?: Date;
    lastSuccessfulTime?: Date;
    nextDeliveryTime?: Date;
  };
  declare type ConfigService$20141112$ConfigRule = {
    ConfigRuleName?: string;
    ConfigRuleArn?: string;
    ConfigRuleId?: string;
    Description?: string;
    Scope?: ConfigService$20141112$Scope;
    Source: ConfigService$20141112$Source;
    InputParameters?: string;
    MaximumExecutionFrequency?: 'One_Hour' | 'Three_Hours' | 'Six_Hours' | 'Twelve_Hours' | 'TwentyFour_Hours';
    ConfigRuleState?: 'ACTIVE' | 'DELETING' | 'DELETING_RESULTS' | 'EVALUATING';
  };
  declare type ConfigService$20141112$ConfigRuleEvaluationStatus = {
    ConfigRuleName?: string;
    ConfigRuleArn?: string;
    ConfigRuleId?: string;
    LastSuccessfulInvocationTime?: Date;
    LastFailedInvocationTime?: Date;
    LastSuccessfulEvaluationTime?: Date;
    LastFailedEvaluationTime?: Date;
    FirstActivatedTime?: Date;
    LastErrorCode?: string;
    LastErrorMessage?: string;
    FirstEvaluationStarted?: boolean;
  };
  declare type ConfigService$20141112$ConfigRuleEvaluationStatusList = ConfigService$20141112$ConfigRuleEvaluationStatus[];
  declare type ConfigService$20141112$ConfigRuleNames = string[];
  declare type ConfigService$20141112$ConfigRuleState = 'ACTIVE' | 'DELETING' | 'DELETING_RESULTS' | 'EVALUATING';
  declare type ConfigService$20141112$ConfigRules = ConfigService$20141112$ConfigRule[];
  declare type ConfigService$20141112$ConfigSnapshotDeliveryProperties = {
    deliveryFrequency?: 'One_Hour' | 'Three_Hours' | 'Six_Hours' | 'Twelve_Hours' | 'TwentyFour_Hours';
  };
  declare type ConfigService$20141112$ConfigStreamDeliveryInfo = {
    lastStatus?: 'Success' | 'Failure' | 'Not_Applicable';
    lastErrorCode?: string;
    lastErrorMessage?: string;
    lastStatusChangeTime?: Date;
  };
  declare type ConfigService$20141112$ConfigurationItem = {
    version?: string;
    accountId?: string;
    configurationItemCaptureTime?: Date;
    configurationItemStatus?: 'Ok' | 'Failed' | 'Discovered' | 'Deleted';
    configurationStateId?: string;
    configurationItemMD5Hash?: string;
    arn?: string;
    resourceType?: 'AWS::EC2::CustomerGateway' | 'AWS::EC2::EIP' | 'AWS::EC2::Host' | 'AWS::EC2::Instance' | 'AWS::EC2::InternetGateway' | 'AWS::EC2::NetworkAcl' | 'AWS::EC2::NetworkInterface' | 'AWS::EC2::RouteTable' | 'AWS::EC2::SecurityGroup' | 'AWS::EC2::Subnet' | 'AWS::CloudTrail::Trail' | 'AWS::EC2::Volume' | 'AWS::EC2::VPC' | 'AWS::EC2::VPNConnection' | 'AWS::EC2::VPNGateway' | 'AWS::IAM::Group' | 'AWS::IAM::Policy' | 'AWS::IAM::Role' | 'AWS::IAM::User' | 'AWS::ACM::Certificate' | 'AWS::RDS::DBInstance' | 'AWS::RDS::DBSubnetGroup' | 'AWS::RDS::DBSecurityGroup' | 'AWS::RDS::DBSnapshot' | 'AWS::RDS::EventSubscription';
    resourceId?: string;
    resourceName?: string;
    awsRegion?: string;
    availabilityZone?: string;
    resourceCreationTime?: Date;
    tags?: {
      [key: string]: string;
    };
    relatedEvents?: ConfigService$20141112$RelatedEventList;
    relationships?: ConfigService$20141112$RelationshipList;
    configuration?: string;
    supplementaryConfiguration?: {
      [key: string]: string;
    };
  };
  declare type ConfigService$20141112$ConfigurationItemCaptureTime = Date;
  declare type ConfigService$20141112$ConfigurationItemList = ConfigService$20141112$ConfigurationItem[];
  declare type ConfigService$20141112$ConfigurationItemStatus = 'Ok' | 'Failed' | 'Discovered' | 'Deleted';
  declare type ConfigService$20141112$ConfigurationRecorder = {
    name?: string;
    roleARN?: string;
    recordingGroup?: ConfigService$20141112$RecordingGroup;
  };
  declare type ConfigService$20141112$ConfigurationRecorderList = ConfigService$20141112$ConfigurationRecorder[];
  declare type ConfigService$20141112$ConfigurationRecorderNameList = string[];
  declare type ConfigService$20141112$ConfigurationRecorderStatus = {
    name?: string;
    lastStartTime?: Date;
    lastStopTime?: Date;
    recording?: boolean;
    lastStatus?: 'Pending' | 'Success' | 'Failure';
    lastErrorCode?: string;
    lastErrorMessage?: string;
    lastStatusChangeTime?: Date;
  };
  declare type ConfigService$20141112$ConfigurationRecorderStatusList = ConfigService$20141112$ConfigurationRecorderStatus[];
  declare type ConfigService$20141112$Date = Date;
  declare type ConfigService$20141112$DeleteConfigRuleRequest = {
    ConfigRuleName: string;
  };
  declare type ConfigService$20141112$DeleteConfigurationRecorderRequest = {
    ConfigurationRecorderName: string;
  };
  declare type ConfigService$20141112$DeleteDeliveryChannelRequest = {
    DeliveryChannelName: string;
  };
  declare type ConfigService$20141112$DeleteEvaluationResultsRequest = {
    ConfigRuleName: string;
  };
  declare type ConfigService$20141112$DeleteEvaluationResultsResponse = {};
  declare type ConfigService$20141112$DeliverConfigSnapshotRequest = {
    deliveryChannelName: string;
  };
  declare type ConfigService$20141112$DeliverConfigSnapshotResponse = {
    configSnapshotId?: string;
  };
  declare type ConfigService$20141112$DeliveryChannel = {
    name?: string;
    s3BucketName?: string;
    s3KeyPrefix?: string;
    snsTopicARN?: string;
    configSnapshotDeliveryProperties?: ConfigService$20141112$ConfigSnapshotDeliveryProperties;
  };
  declare type ConfigService$20141112$DeliveryChannelList = ConfigService$20141112$DeliveryChannel[];
  declare type ConfigService$20141112$DeliveryChannelNameList = string[];
  declare type ConfigService$20141112$DeliveryChannelStatus = {
    name?: string;
    configSnapshotDeliveryInfo?: ConfigService$20141112$ConfigExportDeliveryInfo;
    configHistoryDeliveryInfo?: ConfigService$20141112$ConfigExportDeliveryInfo;
    configStreamDeliveryInfo?: ConfigService$20141112$ConfigStreamDeliveryInfo;
  };
  declare type ConfigService$20141112$DeliveryChannelStatusList = ConfigService$20141112$DeliveryChannelStatus[];
  declare type ConfigService$20141112$DeliveryStatus = 'Success' | 'Failure' | 'Not_Applicable';
  declare type ConfigService$20141112$DescribeComplianceByConfigRuleRequest = {
    ConfigRuleNames?: ConfigService$20141112$ConfigRuleNames;
    ComplianceTypes?: ConfigService$20141112$ComplianceTypes;
    NextToken?: string;
  };
  declare type ConfigService$20141112$DescribeComplianceByConfigRuleResponse = {
    ComplianceByConfigRules?: ConfigService$20141112$ComplianceByConfigRules;
    NextToken?: string;
  };
  declare type ConfigService$20141112$DescribeComplianceByResourceRequest = {
    ResourceType?: string;
    ResourceId?: string;
    ComplianceTypes?: ConfigService$20141112$ComplianceTypes;
    Limit?: number;
    NextToken?: string;
  };
  declare type ConfigService$20141112$DescribeComplianceByResourceResponse = {
    ComplianceByResources?: ConfigService$20141112$ComplianceByResources;
    NextToken?: string;
  };
  declare type ConfigService$20141112$DescribeConfigRuleEvaluationStatusRequest = {
    ConfigRuleNames?: ConfigService$20141112$ConfigRuleNames;
  };
  declare type ConfigService$20141112$DescribeConfigRuleEvaluationStatusResponse = {
    ConfigRulesEvaluationStatus?: ConfigService$20141112$ConfigRuleEvaluationStatusList;
  };
  declare type ConfigService$20141112$DescribeConfigRulesRequest = {
    ConfigRuleNames?: ConfigService$20141112$ConfigRuleNames;
    NextToken?: string;
  };
  declare type ConfigService$20141112$DescribeConfigRulesResponse = {
    ConfigRules?: ConfigService$20141112$ConfigRules;
    NextToken?: string;
  };
  declare type ConfigService$20141112$DescribeConfigurationRecorderStatusRequest = {
    ConfigurationRecorderNames?: ConfigService$20141112$ConfigurationRecorderNameList;
  };
  declare type ConfigService$20141112$DescribeConfigurationRecorderStatusResponse = {
    ConfigurationRecordersStatus?: ConfigService$20141112$ConfigurationRecorderStatusList;
  };
  declare type ConfigService$20141112$DescribeConfigurationRecordersRequest = {
    ConfigurationRecorderNames?: ConfigService$20141112$ConfigurationRecorderNameList;
  };
  declare type ConfigService$20141112$DescribeConfigurationRecordersResponse = {
    ConfigurationRecorders?: ConfigService$20141112$ConfigurationRecorderList;
  };
  declare type ConfigService$20141112$DescribeDeliveryChannelStatusRequest = {
    DeliveryChannelNames?: ConfigService$20141112$DeliveryChannelNameList;
  };
  declare type ConfigService$20141112$DescribeDeliveryChannelStatusResponse = {
    DeliveryChannelsStatus?: ConfigService$20141112$DeliveryChannelStatusList;
  };
  declare type ConfigService$20141112$DescribeDeliveryChannelsRequest = {
    DeliveryChannelNames?: ConfigService$20141112$DeliveryChannelNameList;
  };
  declare type ConfigService$20141112$DescribeDeliveryChannelsResponse = {
    DeliveryChannels?: ConfigService$20141112$DeliveryChannelList;
  };
  declare type ConfigService$20141112$EarlierTime = Date;
  declare type ConfigService$20141112$Evaluation = {
    ComplianceResourceType: string;
    ComplianceResourceId: string;
    ComplianceType: 'COMPLIANT' | 'NON_COMPLIANT' | 'NOT_APPLICABLE' | 'INSUFFICIENT_DATA';
    Annotation?: string;
    OrderingTimestamp: Date;
  };
  declare type ConfigService$20141112$EvaluationResult = {
    EvaluationResultIdentifier?: ConfigService$20141112$EvaluationResultIdentifier;
    ComplianceType?: 'COMPLIANT' | 'NON_COMPLIANT' | 'NOT_APPLICABLE' | 'INSUFFICIENT_DATA';
    ResultRecordedTime?: Date;
    ConfigRuleInvokedTime?: Date;
    Annotation?: string;
    ResultToken?: string;
  };
  declare type ConfigService$20141112$EvaluationResultIdentifier = {
    EvaluationResultQualifier?: ConfigService$20141112$EvaluationResultQualifier;
    OrderingTimestamp?: Date;
  };
  declare type ConfigService$20141112$EvaluationResultQualifier = {
    ConfigRuleName?: string;
    ResourceType?: string;
    ResourceId?: string;
  };
  declare type ConfigService$20141112$EvaluationResults = ConfigService$20141112$EvaluationResult[];
  declare type ConfigService$20141112$Evaluations = ConfigService$20141112$Evaluation[];
  declare type ConfigService$20141112$EventSource = 'aws.config';
  declare type ConfigService$20141112$GetComplianceDetailsByConfigRuleRequest = {
    ConfigRuleName: string;
    ComplianceTypes?: ConfigService$20141112$ComplianceTypes;
    Limit?: number;
    NextToken?: string;
  };
  declare type ConfigService$20141112$GetComplianceDetailsByConfigRuleResponse = {
    EvaluationResults?: ConfigService$20141112$EvaluationResults;
    NextToken?: string;
  };
  declare type ConfigService$20141112$GetComplianceDetailsByResourceRequest = {
    ResourceType: string;
    ResourceId: string;
    ComplianceTypes?: ConfigService$20141112$ComplianceTypes;
    NextToken?: string;
  };
  declare type ConfigService$20141112$GetComplianceDetailsByResourceResponse = {
    EvaluationResults?: ConfigService$20141112$EvaluationResults;
    NextToken?: string;
  };
  declare type ConfigService$20141112$GetComplianceSummaryByConfigRuleResponse = {
    ComplianceSummary?: ConfigService$20141112$ComplianceSummary;
  };
  declare type ConfigService$20141112$GetComplianceSummaryByResourceTypeRequest = {
    ResourceTypes?: ConfigService$20141112$ResourceTypes;
  };
  declare type ConfigService$20141112$GetComplianceSummaryByResourceTypeResponse = {
    ComplianceSummariesByResourceType?: ConfigService$20141112$ComplianceSummariesByResourceType;
  };
  declare type ConfigService$20141112$GetResourceConfigHistoryRequest = {
    resourceType: 'AWS::EC2::CustomerGateway' | 'AWS::EC2::EIP' | 'AWS::EC2::Host' | 'AWS::EC2::Instance' | 'AWS::EC2::InternetGateway' | 'AWS::EC2::NetworkAcl' | 'AWS::EC2::NetworkInterface' | 'AWS::EC2::RouteTable' | 'AWS::EC2::SecurityGroup' | 'AWS::EC2::Subnet' | 'AWS::CloudTrail::Trail' | 'AWS::EC2::Volume' | 'AWS::EC2::VPC' | 'AWS::EC2::VPNConnection' | 'AWS::EC2::VPNGateway' | 'AWS::IAM::Group' | 'AWS::IAM::Policy' | 'AWS::IAM::Role' | 'AWS::IAM::User' | 'AWS::ACM::Certificate' | 'AWS::RDS::DBInstance' | 'AWS::RDS::DBSubnetGroup' | 'AWS::RDS::DBSecurityGroup' | 'AWS::RDS::DBSnapshot' | 'AWS::RDS::EventSubscription';
    resourceId: string;
    laterTime?: Date;
    earlierTime?: Date;
    chronologicalOrder?: 'Reverse' | 'Forward';
    limit?: number;
    nextToken?: string;
  };
  declare type ConfigService$20141112$GetResourceConfigHistoryResponse = {
    configurationItems?: ConfigService$20141112$ConfigurationItemList;
    nextToken?: string;
  };
  declare type ConfigService$20141112$InsufficientDeliveryPolicyException = {};
  declare type ConfigService$20141112$InsufficientPermissionsException = {};
  declare type ConfigService$20141112$InvalidConfigurationRecorderNameException = {};
  declare type ConfigService$20141112$InvalidDeliveryChannelNameException = {};
  declare type ConfigService$20141112$InvalidLimitException = {};
  declare type ConfigService$20141112$InvalidNextTokenException = {};
  declare type ConfigService$20141112$InvalidParameterValueException = {};
  declare type ConfigService$20141112$InvalidRecordingGroupException = {};
  declare type ConfigService$20141112$InvalidResultTokenException = {};
  declare type ConfigService$20141112$InvalidRoleException = {};
  declare type ConfigService$20141112$InvalidS3KeyPrefixException = {};
  declare type ConfigService$20141112$InvalidSNSTopicARNException = {};
  declare type ConfigService$20141112$InvalidTimeRangeException = {};
  declare type ConfigService$20141112$LastDeliveryChannelDeleteFailedException = {};
  declare type ConfigService$20141112$LaterTime = Date;
  declare type ConfigService$20141112$LimitExceededException = {};
  declare type ConfigService$20141112$ListDiscoveredResourcesRequest = {
    resourceType: 'AWS::EC2::CustomerGateway' | 'AWS::EC2::EIP' | 'AWS::EC2::Host' | 'AWS::EC2::Instance' | 'AWS::EC2::InternetGateway' | 'AWS::EC2::NetworkAcl' | 'AWS::EC2::NetworkInterface' | 'AWS::EC2::RouteTable' | 'AWS::EC2::SecurityGroup' | 'AWS::EC2::Subnet' | 'AWS::CloudTrail::Trail' | 'AWS::EC2::Volume' | 'AWS::EC2::VPC' | 'AWS::EC2::VPNConnection' | 'AWS::EC2::VPNGateway' | 'AWS::IAM::Group' | 'AWS::IAM::Policy' | 'AWS::IAM::Role' | 'AWS::IAM::User' | 'AWS::ACM::Certificate' | 'AWS::RDS::DBInstance' | 'AWS::RDS::DBSubnetGroup' | 'AWS::RDS::DBSecurityGroup' | 'AWS::RDS::DBSnapshot' | 'AWS::RDS::EventSubscription';
    resourceIds?: ConfigService$20141112$ResourceIdList;
    resourceName?: string;
    limit?: number;
    includeDeletedResources?: boolean;
    nextToken?: string;
  };
  declare type ConfigService$20141112$ListDiscoveredResourcesResponse = {
    resourceIdentifiers?: ConfigService$20141112$ResourceIdentifierList;
    nextToken?: string;
  };
  declare type ConfigService$20141112$MaxNumberOfConfigRulesExceededException = {};
  declare type ConfigService$20141112$MaxNumberOfConfigurationRecordersExceededException = {};
  declare type ConfigService$20141112$MaxNumberOfDeliveryChannelsExceededException = {};
  declare type ConfigService$20141112$MaximumExecutionFrequency = 'One_Hour' | 'Three_Hours' | 'Six_Hours' | 'Twelve_Hours' | 'TwentyFour_Hours';
  declare type ConfigService$20141112$MessageType = 'ConfigurationItemChangeNotification' | 'ConfigurationSnapshotDeliveryCompleted' | 'ScheduledNotification';
  declare type ConfigService$20141112$NoAvailableConfigurationRecorderException = {};
  declare type ConfigService$20141112$NoAvailableDeliveryChannelException = {};
  declare type ConfigService$20141112$NoRunningConfigurationRecorderException = {};
  declare type ConfigService$20141112$NoSuchBucketException = {};
  declare type ConfigService$20141112$NoSuchConfigRuleException = {};
  declare type ConfigService$20141112$NoSuchConfigurationRecorderException = {};
  declare type ConfigService$20141112$NoSuchDeliveryChannelException = {};
  declare type ConfigService$20141112$OrderingTimestamp = Date;
  declare type ConfigService$20141112$Owner = 'CUSTOM_LAMBDA' | 'AWS';
  declare type ConfigService$20141112$PutConfigRuleRequest = {
    ConfigRule: ConfigService$20141112$ConfigRule;
  };
  declare type ConfigService$20141112$PutConfigurationRecorderRequest = {
    ConfigurationRecorder: ConfigService$20141112$ConfigurationRecorder;
  };
  declare type ConfigService$20141112$PutDeliveryChannelRequest = {
    DeliveryChannel: ConfigService$20141112$DeliveryChannel;
  };
  declare type ConfigService$20141112$PutEvaluationsRequest = {
    Evaluations?: ConfigService$20141112$Evaluations;
    ResultToken: string;
  };
  declare type ConfigService$20141112$PutEvaluationsResponse = {
    FailedEvaluations?: ConfigService$20141112$Evaluations;
  };
  declare type ConfigService$20141112$RecorderStatus = 'Pending' | 'Success' | 'Failure';
  declare type ConfigService$20141112$RecordingGroup = {
    allSupported?: boolean;
    includeGlobalResourceTypes?: boolean;
    resourceTypes?: ConfigService$20141112$ResourceTypeList;
  };
  declare type ConfigService$20141112$ReevaluateConfigRuleNames = string[];
  declare type ConfigService$20141112$RelatedEventList = string[];
  declare type ConfigService$20141112$Relationship = {
    resourceType?: 'AWS::EC2::CustomerGateway' | 'AWS::EC2::EIP' | 'AWS::EC2::Host' | 'AWS::EC2::Instance' | 'AWS::EC2::InternetGateway' | 'AWS::EC2::NetworkAcl' | 'AWS::EC2::NetworkInterface' | 'AWS::EC2::RouteTable' | 'AWS::EC2::SecurityGroup' | 'AWS::EC2::Subnet' | 'AWS::CloudTrail::Trail' | 'AWS::EC2::Volume' | 'AWS::EC2::VPC' | 'AWS::EC2::VPNConnection' | 'AWS::EC2::VPNGateway' | 'AWS::IAM::Group' | 'AWS::IAM::Policy' | 'AWS::IAM::Role' | 'AWS::IAM::User' | 'AWS::ACM::Certificate' | 'AWS::RDS::DBInstance' | 'AWS::RDS::DBSubnetGroup' | 'AWS::RDS::DBSecurityGroup' | 'AWS::RDS::DBSnapshot' | 'AWS::RDS::EventSubscription';
    resourceId?: string;
    resourceName?: string;
    relationshipName?: string;
  };
  declare type ConfigService$20141112$RelationshipList = ConfigService$20141112$Relationship[];
  declare type ConfigService$20141112$ResourceCreationTime = Date;
  declare type ConfigService$20141112$ResourceDeletionTime = Date;
  declare type ConfigService$20141112$ResourceIdList = string[];
  declare type ConfigService$20141112$ResourceIdentifier = {
    resourceType?: 'AWS::EC2::CustomerGateway' | 'AWS::EC2::EIP' | 'AWS::EC2::Host' | 'AWS::EC2::Instance' | 'AWS::EC2::InternetGateway' | 'AWS::EC2::NetworkAcl' | 'AWS::EC2::NetworkInterface' | 'AWS::EC2::RouteTable' | 'AWS::EC2::SecurityGroup' | 'AWS::EC2::Subnet' | 'AWS::CloudTrail::Trail' | 'AWS::EC2::Volume' | 'AWS::EC2::VPC' | 'AWS::EC2::VPNConnection' | 'AWS::EC2::VPNGateway' | 'AWS::IAM::Group' | 'AWS::IAM::Policy' | 'AWS::IAM::Role' | 'AWS::IAM::User' | 'AWS::ACM::Certificate' | 'AWS::RDS::DBInstance' | 'AWS::RDS::DBSubnetGroup' | 'AWS::RDS::DBSecurityGroup' | 'AWS::RDS::DBSnapshot' | 'AWS::RDS::EventSubscription';
    resourceId?: string;
    resourceName?: string;
    resourceDeletionTime?: Date;
  };
  declare type ConfigService$20141112$ResourceIdentifierList = ConfigService$20141112$ResourceIdentifier[];
  declare type ConfigService$20141112$ResourceInUseException = {};
  declare type ConfigService$20141112$ResourceNotDiscoveredException = {};
  declare type ConfigService$20141112$ResourceType = 'AWS::EC2::CustomerGateway' | 'AWS::EC2::EIP' | 'AWS::EC2::Host' | 'AWS::EC2::Instance' | 'AWS::EC2::InternetGateway' | 'AWS::EC2::NetworkAcl' | 'AWS::EC2::NetworkInterface' | 'AWS::EC2::RouteTable' | 'AWS::EC2::SecurityGroup' | 'AWS::EC2::Subnet' | 'AWS::CloudTrail::Trail' | 'AWS::EC2::Volume' | 'AWS::EC2::VPC' | 'AWS::EC2::VPNConnection' | 'AWS::EC2::VPNGateway' | 'AWS::IAM::Group' | 'AWS::IAM::Policy' | 'AWS::IAM::Role' | 'AWS::IAM::User' | 'AWS::ACM::Certificate' | 'AWS::RDS::DBInstance' | 'AWS::RDS::DBSubnetGroup' | 'AWS::RDS::DBSecurityGroup' | 'AWS::RDS::DBSnapshot' | 'AWS::RDS::EventSubscription';
  declare type ConfigService$20141112$ResourceTypeList = ('AWS::EC2::CustomerGateway' | 'AWS::EC2::EIP' | 'AWS::EC2::Host' | 'AWS::EC2::Instance' | 'AWS::EC2::InternetGateway' | 'AWS::EC2::NetworkAcl' | 'AWS::EC2::NetworkInterface' | 'AWS::EC2::RouteTable' | 'AWS::EC2::SecurityGroup' | 'AWS::EC2::Subnet' | 'AWS::CloudTrail::Trail' | 'AWS::EC2::Volume' | 'AWS::EC2::VPC' | 'AWS::EC2::VPNConnection' | 'AWS::EC2::VPNGateway' | 'AWS::IAM::Group' | 'AWS::IAM::Policy' | 'AWS::IAM::Role' | 'AWS::IAM::User' | 'AWS::ACM::Certificate' | 'AWS::RDS::DBInstance' | 'AWS::RDS::DBSubnetGroup' | 'AWS::RDS::DBSecurityGroup' | 'AWS::RDS::DBSnapshot' | 'AWS::RDS::EventSubscription')[];
  declare type ConfigService$20141112$ResourceTypes = string[];
  declare type ConfigService$20141112$Scope = {
    ComplianceResourceTypes?: ConfigService$20141112$ComplianceResourceTypes;
    TagKey?: string;
    TagValue?: string;
    ComplianceResourceId?: string;
  };
  declare type ConfigService$20141112$Source = {
    Owner?: 'CUSTOM_LAMBDA' | 'AWS';
    SourceIdentifier?: string;
    SourceDetails?: ConfigService$20141112$SourceDetails;
  };
  declare type ConfigService$20141112$SourceDetail = {
    EventSource?: 'aws.config';
    MessageType?: 'ConfigurationItemChangeNotification' | 'ConfigurationSnapshotDeliveryCompleted' | 'ScheduledNotification';
    MaximumExecutionFrequency?: 'One_Hour' | 'Three_Hours' | 'Six_Hours' | 'Twelve_Hours' | 'TwentyFour_Hours';
  };
  declare type ConfigService$20141112$SourceDetails = ConfigService$20141112$SourceDetail[];
  declare type ConfigService$20141112$StartConfigRulesEvaluationRequest = {
    ConfigRuleNames?: ConfigService$20141112$ReevaluateConfigRuleNames;
  };
  declare type ConfigService$20141112$StartConfigRulesEvaluationResponse = {};
  declare type ConfigService$20141112$StartConfigurationRecorderRequest = {
    ConfigurationRecorderName: string;
  };
  declare type ConfigService$20141112$StopConfigurationRecorderRequest = {
    ConfigurationRecorderName: string;
  };
  declare type ConfigService$20141112$SupplementaryConfiguration = {
    [key: string]: string;
  };
  declare type ConfigService$20141112$Tags = {
    [key: string]: string;
  };
  declare type ConfigService$20141112$ValidationException = {};
  declare type DataPipeline$20121029$ActivatePipelineInput = {
    pipelineId: string;
    parameterValues?: DataPipeline$20121029$ParameterValueList;
    startTimestamp?: Date;
  };
  declare type DataPipeline$20121029$ActivatePipelineOutput = {};
  declare type DataPipeline$20121029$AddTagsInput = {
    pipelineId: string;
    tags: DataPipeline$20121029$tagList;
  };
  declare type DataPipeline$20121029$AddTagsOutput = {};
  declare type DataPipeline$20121029$CreatePipelineInput = {
    name: string;
    uniqueId: string;
    description?: string;
    tags?: DataPipeline$20121029$tagList;
  };
  declare type DataPipeline$20121029$CreatePipelineOutput = {
    pipelineId: string;
  };
  declare type DataPipeline$20121029$DeactivatePipelineInput = {
    pipelineId: string;
    cancelActive?: boolean;
  };
  declare type DataPipeline$20121029$DeactivatePipelineOutput = {};
  declare type DataPipeline$20121029$DeletePipelineInput = {
    pipelineId: string;
  };
  declare type DataPipeline$20121029$DescribeObjectsInput = {
    pipelineId: string;
    objectIds: DataPipeline$20121029$idList;
    evaluateExpressions?: boolean;
    marker?: string;
  };
  declare type DataPipeline$20121029$DescribeObjectsOutput = {
    pipelineObjects: DataPipeline$20121029$PipelineObjectList;
    marker?: string;
    hasMoreResults?: boolean;
  };
  declare type DataPipeline$20121029$DescribePipelinesInput = {
    pipelineIds: DataPipeline$20121029$idList;
  };
  declare type DataPipeline$20121029$DescribePipelinesOutput = {
    pipelineDescriptionList: DataPipeline$20121029$PipelineDescriptionList;
  };
  declare type DataPipeline$20121029$EvaluateExpressionInput = {
    pipelineId: string;
    objectId: string;
    expression: string;
  };
  declare type DataPipeline$20121029$EvaluateExpressionOutput = {
    evaluatedExpression: string;
  };
  declare type DataPipeline$20121029$Field = {
    key: string;
    stringValue?: string;
    refValue?: string;
  };
  declare type DataPipeline$20121029$GetPipelineDefinitionInput = {
    pipelineId: string;
    version?: string;
  };
  declare type DataPipeline$20121029$GetPipelineDefinitionOutput = {
    pipelineObjects?: DataPipeline$20121029$PipelineObjectList;
    parameterObjects?: DataPipeline$20121029$ParameterObjectList;
    parameterValues?: DataPipeline$20121029$ParameterValueList;
  };
  declare type DataPipeline$20121029$InstanceIdentity = {
    document?: string;
    signature?: string;
  };
  declare type DataPipeline$20121029$InternalServiceError = {
    message?: string;
  };
  declare type DataPipeline$20121029$InvalidRequestException = {
    message?: string;
  };
  declare type DataPipeline$20121029$ListPipelinesInput = {
    marker?: string;
  };
  declare type DataPipeline$20121029$ListPipelinesOutput = {
    pipelineIdList: DataPipeline$20121029$pipelineList;
    marker?: string;
    hasMoreResults?: boolean;
  };
  declare type DataPipeline$20121029$Operator = {
    type?: 'EQ' | 'REF_EQ' | 'LE' | 'GE' | 'BETWEEN';
    values?: DataPipeline$20121029$stringList;
  };
  declare type DataPipeline$20121029$OperatorType = 'EQ' | 'REF_EQ' | 'LE' | 'GE' | 'BETWEEN';
  declare type DataPipeline$20121029$ParameterAttribute = {
    key: string;
    stringValue: string;
  };
  declare type DataPipeline$20121029$ParameterAttributeList = DataPipeline$20121029$ParameterAttribute[];
  declare type DataPipeline$20121029$ParameterObject = {
    id: string;
    attributes: DataPipeline$20121029$ParameterAttributeList;
  };
  declare type DataPipeline$20121029$ParameterObjectList = DataPipeline$20121029$ParameterObject[];
  declare type DataPipeline$20121029$ParameterValue = {
    id: string;
    stringValue: string;
  };
  declare type DataPipeline$20121029$ParameterValueList = DataPipeline$20121029$ParameterValue[];
  declare type DataPipeline$20121029$PipelineDeletedException = {
    message?: string;
  };
  declare type DataPipeline$20121029$PipelineDescription = {
    pipelineId: string;
    name: string;
    fields: DataPipeline$20121029$fieldList;
    description?: string;
    tags?: DataPipeline$20121029$tagList;
  };
  declare type DataPipeline$20121029$PipelineDescriptionList = DataPipeline$20121029$PipelineDescription[];
  declare type DataPipeline$20121029$PipelineIdName = {
    id?: string;
    name?: string;
  };
  declare type DataPipeline$20121029$PipelineNotFoundException = {
    message?: string;
  };
  declare type DataPipeline$20121029$PipelineObject = {
    id: string;
    name: string;
    fields: DataPipeline$20121029$fieldList;
  };
  declare type DataPipeline$20121029$PipelineObjectList = DataPipeline$20121029$PipelineObject[];
  declare type DataPipeline$20121029$PipelineObjectMap = {
    [key: string]: DataPipeline$20121029$PipelineObject;
  };
  declare type DataPipeline$20121029$PollForTaskInput = {
    workerGroup: string;
    hostname?: string;
    instanceIdentity?: DataPipeline$20121029$InstanceIdentity;
  };
  declare type DataPipeline$20121029$PollForTaskOutput = {
    taskObject?: DataPipeline$20121029$TaskObject;
  };
  declare type DataPipeline$20121029$PutPipelineDefinitionInput = {
    pipelineId: string;
    pipelineObjects: DataPipeline$20121029$PipelineObjectList;
    parameterObjects?: DataPipeline$20121029$ParameterObjectList;
    parameterValues?: DataPipeline$20121029$ParameterValueList;
  };
  declare type DataPipeline$20121029$PutPipelineDefinitionOutput = {
    validationErrors?: DataPipeline$20121029$ValidationErrors;
    validationWarnings?: DataPipeline$20121029$ValidationWarnings;
    errored: boolean;
  };
  declare type DataPipeline$20121029$Query = {
    selectors?: DataPipeline$20121029$SelectorList;
  };
  declare type DataPipeline$20121029$QueryObjectsInput = {
    pipelineId: string;
    query?: DataPipeline$20121029$Query;
    sphere: string;
    marker?: string;
    limit?: number;
  };
  declare type DataPipeline$20121029$QueryObjectsOutput = {
    ids?: DataPipeline$20121029$idList;
    marker?: string;
    hasMoreResults?: boolean;
  };
  declare type DataPipeline$20121029$RemoveTagsInput = {
    pipelineId: string;
    tagKeys: DataPipeline$20121029$stringList;
  };
  declare type DataPipeline$20121029$RemoveTagsOutput = {};
  declare type DataPipeline$20121029$ReportTaskProgressInput = {
    taskId: string;
    fields?: DataPipeline$20121029$fieldList;
  };
  declare type DataPipeline$20121029$ReportTaskProgressOutput = {
    canceled: boolean;
  };
  declare type DataPipeline$20121029$ReportTaskRunnerHeartbeatInput = {
    taskrunnerId: string;
    workerGroup?: string;
    hostname?: string;
  };
  declare type DataPipeline$20121029$ReportTaskRunnerHeartbeatOutput = {
    terminate: boolean;
  };
  declare type DataPipeline$20121029$Selector = {
    fieldName?: string;
    operator?: DataPipeline$20121029$Operator;
  };
  declare type DataPipeline$20121029$SelectorList = DataPipeline$20121029$Selector[];
  declare type DataPipeline$20121029$SetStatusInput = {
    pipelineId: string;
    objectIds: DataPipeline$20121029$idList;
    status: string;
  };
  declare type DataPipeline$20121029$SetTaskStatusInput = {
    taskId: string;
    taskStatus: 'FINISHED' | 'FAILED' | 'FALSE';
    errorId?: string;
    errorMessage?: string;
    errorStackTrace?: string;
  };
  declare type DataPipeline$20121029$SetTaskStatusOutput = {};
  declare type DataPipeline$20121029$Tag = {
    key: string;
    value: string;
  };
  declare type DataPipeline$20121029$TaskNotFoundException = {
    message?: string;
  };
  declare type DataPipeline$20121029$TaskObject = {
    taskId?: string;
    pipelineId?: string;
    attemptId?: string;
    objects?: {
      [key: string]: DataPipeline$20121029$PipelineObject;
    };
  };
  declare type DataPipeline$20121029$TaskStatus = 'FINISHED' | 'FAILED' | 'FALSE';
  declare type DataPipeline$20121029$ValidatePipelineDefinitionInput = {
    pipelineId: string;
    pipelineObjects: DataPipeline$20121029$PipelineObjectList;
    parameterObjects?: DataPipeline$20121029$ParameterObjectList;
    parameterValues?: DataPipeline$20121029$ParameterValueList;
  };
  declare type DataPipeline$20121029$ValidatePipelineDefinitionOutput = {
    validationErrors?: DataPipeline$20121029$ValidationErrors;
    validationWarnings?: DataPipeline$20121029$ValidationWarnings;
    errored: boolean;
  };
  declare type DataPipeline$20121029$ValidationError = {
    id?: string;
    errors?: DataPipeline$20121029$validationMessages;
  };
  declare type DataPipeline$20121029$ValidationErrors = DataPipeline$20121029$ValidationError[];
  declare type DataPipeline$20121029$ValidationWarning = {
    id?: string;
    warnings?: DataPipeline$20121029$validationMessages;
  };
  declare type DataPipeline$20121029$ValidationWarnings = DataPipeline$20121029$ValidationWarning[];
  declare type DataPipeline$20121029$fieldList = DataPipeline$20121029$Field[];
  declare type DataPipeline$20121029$idList = string[];
  declare type DataPipeline$20121029$pipelineList = DataPipeline$20121029$PipelineIdName[];
  declare type DataPipeline$20121029$stringList = string[];
  declare type DataPipeline$20121029$tagList = DataPipeline$20121029$Tag[];
  declare type DataPipeline$20121029$timestamp = Date;
  declare type DataPipeline$20121029$validationMessages = string[];
  declare type DeviceFarm$20150623$AccountSettings = {
    awsAccountNumber?: string;
    unmeteredDevices?: {
      [key: 'ANDROID' | 'IOS']: number;
    };
    unmeteredRemoteAccessDevices?: {
      [key: 'ANDROID' | 'IOS']: number;
    };
  };
  declare type DeviceFarm$20150623$AmazonResourceNames = string[];
  declare type DeviceFarm$20150623$ArgumentException = {
    message?: string;
  };
  declare type DeviceFarm$20150623$Artifact = {
    arn?: string;
    name?: string;
    type?: 'UNKNOWN' | 'SCREENSHOT' | 'DEVICE_LOG' | 'MESSAGE_LOG' | 'VIDEO_LOG' | 'RESULT_LOG' | 'SERVICE_LOG' | 'WEBKIT_LOG' | 'INSTRUMENTATION_OUTPUT' | 'EXERCISER_MONKEY_OUTPUT' | 'CALABASH_JSON_OUTPUT' | 'CALABASH_PRETTY_OUTPUT' | 'CALABASH_STANDARD_OUTPUT' | 'CALABASH_JAVA_XML_OUTPUT' | 'AUTOMATION_OUTPUT' | 'APPIUM_SERVER_OUTPUT' | 'APPIUM_JAVA_OUTPUT' | 'APPIUM_JAVA_XML_OUTPUT' | 'APPIUM_PYTHON_OUTPUT' | 'APPIUM_PYTHON_XML_OUTPUT' | 'EXPLORER_EVENT_LOG' | 'EXPLORER_SUMMARY_LOG' | 'APPLICATION_CRASH_REPORT' | 'XCTEST_LOG' | 'VIDEO';
    extension?: string;
    url?: string;
  };
  declare type DeviceFarm$20150623$ArtifactCategory = 'SCREENSHOT' | 'FILE' | 'LOG';
  declare type DeviceFarm$20150623$ArtifactType = 'UNKNOWN' | 'SCREENSHOT' | 'DEVICE_LOG' | 'MESSAGE_LOG' | 'VIDEO_LOG' | 'RESULT_LOG' | 'SERVICE_LOG' | 'WEBKIT_LOG' | 'INSTRUMENTATION_OUTPUT' | 'EXERCISER_MONKEY_OUTPUT' | 'CALABASH_JSON_OUTPUT' | 'CALABASH_PRETTY_OUTPUT' | 'CALABASH_STANDARD_OUTPUT' | 'CALABASH_JAVA_XML_OUTPUT' | 'AUTOMATION_OUTPUT' | 'APPIUM_SERVER_OUTPUT' | 'APPIUM_JAVA_OUTPUT' | 'APPIUM_JAVA_XML_OUTPUT' | 'APPIUM_PYTHON_OUTPUT' | 'APPIUM_PYTHON_XML_OUTPUT' | 'EXPLORER_EVENT_LOG' | 'EXPLORER_SUMMARY_LOG' | 'APPLICATION_CRASH_REPORT' | 'XCTEST_LOG' | 'VIDEO';
  declare type DeviceFarm$20150623$Artifacts = DeviceFarm$20150623$Artifact[];
  declare type DeviceFarm$20150623$BillingMethod = 'METERED' | 'UNMETERED';
  declare type DeviceFarm$20150623$CPU = {
    frequency?: string;
    architecture?: string;
    clock?: number;
  };
  declare type DeviceFarm$20150623$Counters = {
    total?: number;
    passed?: number;
    failed?: number;
    warned?: number;
    errored?: number;
    stopped?: number;
    skipped?: number;
  };
  declare type DeviceFarm$20150623$CreateDevicePoolRequest = {
    projectArn: string;
    name: string;
    description?: string;
    rules: DeviceFarm$20150623$Rules;
  };
  declare type DeviceFarm$20150623$CreateDevicePoolResult = {
    devicePool?: DeviceFarm$20150623$DevicePool;
  };
  declare type DeviceFarm$20150623$CreateProjectRequest = {
    name: string;
  };
  declare type DeviceFarm$20150623$CreateProjectResult = {
    project?: DeviceFarm$20150623$Project;
  };
  declare type DeviceFarm$20150623$CreateRemoteAccessSessionConfiguration = {
    billingMethod?: 'METERED' | 'UNMETERED';
  };
  declare type DeviceFarm$20150623$CreateRemoteAccessSessionRequest = {
    projectArn: string;
    deviceArn: string;
    name?: string;
    configuration?: DeviceFarm$20150623$CreateRemoteAccessSessionConfiguration;
  };
  declare type DeviceFarm$20150623$CreateRemoteAccessSessionResult = {
    remoteAccessSession?: DeviceFarm$20150623$RemoteAccessSession;
  };
  declare type DeviceFarm$20150623$CreateUploadRequest = {
    projectArn: string;
    name: string;
    type: 'ANDROID_APP' | 'IOS_APP' | 'WEB_APP' | 'EXTERNAL_DATA' | 'APPIUM_JAVA_JUNIT_TEST_PACKAGE' | 'APPIUM_JAVA_TESTNG_TEST_PACKAGE' | 'APPIUM_PYTHON_TEST_PACKAGE' | 'APPIUM_WEB_JAVA_JUNIT_TEST_PACKAGE' | 'APPIUM_WEB_JAVA_TESTNG_TEST_PACKAGE' | 'APPIUM_WEB_PYTHON_TEST_PACKAGE' | 'CALABASH_TEST_PACKAGE' | 'INSTRUMENTATION_TEST_PACKAGE' | 'UIAUTOMATION_TEST_PACKAGE' | 'UIAUTOMATOR_TEST_PACKAGE' | 'XCTEST_TEST_PACKAGE' | 'XCTEST_UI_TEST_PACKAGE';
    contentType?: string;
  };
  declare type DeviceFarm$20150623$CreateUploadResult = {
    upload?: DeviceFarm$20150623$Upload;
  };
  declare type DeviceFarm$20150623$CurrencyCode = 'USD';
  declare type DeviceFarm$20150623$DateTime = Date;
  declare type DeviceFarm$20150623$DeleteDevicePoolRequest = {
    arn: string;
  };
  declare type DeviceFarm$20150623$DeleteDevicePoolResult = {};
  declare type DeviceFarm$20150623$DeleteProjectRequest = {
    arn: string;
  };
  declare type DeviceFarm$20150623$DeleteProjectResult = {};
  declare type DeviceFarm$20150623$DeleteRemoteAccessSessionRequest = {
    arn: string;
  };
  declare type DeviceFarm$20150623$DeleteRemoteAccessSessionResult = {};
  declare type DeviceFarm$20150623$DeleteRunRequest = {
    arn: string;
  };
  declare type DeviceFarm$20150623$DeleteRunResult = {};
  declare type DeviceFarm$20150623$DeleteUploadRequest = {
    arn: string;
  };
  declare type DeviceFarm$20150623$DeleteUploadResult = {};
  declare type DeviceFarm$20150623$Device = {
    arn?: string;
    name?: string;
    manufacturer?: string;
    model?: string;
    formFactor?: 'PHONE' | 'TABLET';
    platform?: 'ANDROID' | 'IOS';
    os?: string;
    cpu?: DeviceFarm$20150623$CPU;
    resolution?: DeviceFarm$20150623$Resolution;
    heapSize?: number;
    memory?: number;
    image?: string;
    carrier?: string;
    radio?: string;
    remoteAccessEnabled?: boolean;
    fleetType?: string;
    fleetName?: string;
  };
  declare type DeviceFarm$20150623$DeviceAttribute = 'ARN' | 'PLATFORM' | 'FORM_FACTOR' | 'MANUFACTURER' | 'REMOTE_ACCESS_ENABLED';
  declare type DeviceFarm$20150623$DeviceFormFactor = 'PHONE' | 'TABLET';
  declare type DeviceFarm$20150623$DeviceMinutes = {
    total?: number;
    metered?: number;
    unmetered?: number;
  };
  declare type DeviceFarm$20150623$DevicePlatform = 'ANDROID' | 'IOS';
  declare type DeviceFarm$20150623$DevicePool = {
    arn?: string;
    name?: string;
    description?: string;
    type?: 'CURATED' | 'PRIVATE';
    rules?: DeviceFarm$20150623$Rules;
  };
  declare type DeviceFarm$20150623$DevicePoolCompatibilityResult = {
    device?: DeviceFarm$20150623$Device;
    compatible?: boolean;
    incompatibilityMessages?: DeviceFarm$20150623$IncompatibilityMessages;
  };
  declare type DeviceFarm$20150623$DevicePoolCompatibilityResults = DeviceFarm$20150623$DevicePoolCompatibilityResult[];
  declare type DeviceFarm$20150623$DevicePoolType = 'CURATED' | 'PRIVATE';
  declare type DeviceFarm$20150623$DevicePools = DeviceFarm$20150623$DevicePool[];
  declare type DeviceFarm$20150623$Devices = DeviceFarm$20150623$Device[];
  declare type DeviceFarm$20150623$ExecutionResult = 'PENDING' | 'PASSED' | 'WARNED' | 'FAILED' | 'SKIPPED' | 'ERRORED' | 'STOPPED';
  declare type DeviceFarm$20150623$ExecutionStatus = 'PENDING' | 'PENDING_CONCURRENCY' | 'PENDING_DEVICE' | 'PROCESSING' | 'SCHEDULING' | 'PREPARING' | 'RUNNING' | 'COMPLETED' | 'STOPPING';
  declare type DeviceFarm$20150623$GetAccountSettingsRequest = {};
  declare type DeviceFarm$20150623$GetAccountSettingsResult = {
    accountSettings?: DeviceFarm$20150623$AccountSettings;
  };
  declare type DeviceFarm$20150623$GetDevicePoolCompatibilityRequest = {
    devicePoolArn: string;
    appArn?: string;
    testType?: 'BUILTIN_FUZZ' | 'BUILTIN_EXPLORER' | 'APPIUM_JAVA_JUNIT' | 'APPIUM_JAVA_TESTNG' | 'APPIUM_PYTHON' | 'APPIUM_WEB_JAVA_JUNIT' | 'APPIUM_WEB_JAVA_TESTNG' | 'APPIUM_WEB_PYTHON' | 'CALABASH' | 'INSTRUMENTATION' | 'UIAUTOMATION' | 'UIAUTOMATOR' | 'XCTEST' | 'XCTEST_UI';
  };
  declare type DeviceFarm$20150623$GetDevicePoolCompatibilityResult = {
    compatibleDevices?: DeviceFarm$20150623$DevicePoolCompatibilityResults;
    incompatibleDevices?: DeviceFarm$20150623$DevicePoolCompatibilityResults;
  };
  declare type DeviceFarm$20150623$GetDevicePoolRequest = {
    arn: string;
  };
  declare type DeviceFarm$20150623$GetDevicePoolResult = {
    devicePool?: DeviceFarm$20150623$DevicePool;
  };
  declare type DeviceFarm$20150623$GetDeviceRequest = {
    arn: string;
  };
  declare type DeviceFarm$20150623$GetDeviceResult = {
    device?: DeviceFarm$20150623$Device;
  };
  declare type DeviceFarm$20150623$GetJobRequest = {
    arn: string;
  };
  declare type DeviceFarm$20150623$GetJobResult = {
    job?: DeviceFarm$20150623$Job;
  };
  declare type DeviceFarm$20150623$GetOfferingStatusRequest = {
    nextToken?: string;
  };
  declare type DeviceFarm$20150623$GetOfferingStatusResult = {
    current?: {
      [key: string]: DeviceFarm$20150623$OfferingStatus;
    };
    nextPeriod?: {
      [key: string]: DeviceFarm$20150623$OfferingStatus;
    };
    nextToken?: string;
  };
  declare type DeviceFarm$20150623$GetProjectRequest = {
    arn: string;
  };
  declare type DeviceFarm$20150623$GetProjectResult = {
    project?: DeviceFarm$20150623$Project;
  };
  declare type DeviceFarm$20150623$GetRemoteAccessSessionRequest = {
    arn: string;
  };
  declare type DeviceFarm$20150623$GetRemoteAccessSessionResult = {
    remoteAccessSession?: DeviceFarm$20150623$RemoteAccessSession;
  };
  declare type DeviceFarm$20150623$GetRunRequest = {
    arn: string;
  };
  declare type DeviceFarm$20150623$GetRunResult = {
    run?: DeviceFarm$20150623$Run;
  };
  declare type DeviceFarm$20150623$GetSuiteRequest = {
    arn: string;
  };
  declare type DeviceFarm$20150623$GetSuiteResult = {
    suite?: DeviceFarm$20150623$Suite;
  };
  declare type DeviceFarm$20150623$GetTestRequest = {
    arn: string;
  };
  declare type DeviceFarm$20150623$GetTestResult = {
    test?: DeviceFarm$20150623$Test;
  };
  declare type DeviceFarm$20150623$GetUploadRequest = {
    arn: string;
  };
  declare type DeviceFarm$20150623$GetUploadResult = {
    upload?: DeviceFarm$20150623$Upload;
  };
  declare type DeviceFarm$20150623$IdempotencyException = {
    message?: string;
  };
  declare type DeviceFarm$20150623$IncompatibilityMessage = {
    message?: string;
    type?: 'ARN' | 'PLATFORM' | 'FORM_FACTOR' | 'MANUFACTURER' | 'REMOTE_ACCESS_ENABLED';
  };
  declare type DeviceFarm$20150623$IncompatibilityMessages = DeviceFarm$20150623$IncompatibilityMessage[];
  declare type DeviceFarm$20150623$InstallToRemoteAccessSessionRequest = {
    remoteAccessSessionArn: string;
    appArn: string;
  };
  declare type DeviceFarm$20150623$InstallToRemoteAccessSessionResult = {
    appUpload?: DeviceFarm$20150623$Upload;
  };
  declare type DeviceFarm$20150623$Job = {
    arn?: string;
    name?: string;
    type?: 'BUILTIN_FUZZ' | 'BUILTIN_EXPLORER' | 'APPIUM_JAVA_JUNIT' | 'APPIUM_JAVA_TESTNG' | 'APPIUM_PYTHON' | 'APPIUM_WEB_JAVA_JUNIT' | 'APPIUM_WEB_JAVA_TESTNG' | 'APPIUM_WEB_PYTHON' | 'CALABASH' | 'INSTRUMENTATION' | 'UIAUTOMATION' | 'UIAUTOMATOR' | 'XCTEST' | 'XCTEST_UI';
    created?: Date;
    status?: 'PENDING' | 'PENDING_CONCURRENCY' | 'PENDING_DEVICE' | 'PROCESSING' | 'SCHEDULING' | 'PREPARING' | 'RUNNING' | 'COMPLETED' | 'STOPPING';
    result?: 'PENDING' | 'PASSED' | 'WARNED' | 'FAILED' | 'SKIPPED' | 'ERRORED' | 'STOPPED';
    started?: Date;
    stopped?: Date;
    counters?: DeviceFarm$20150623$Counters;
    message?: string;
    device?: DeviceFarm$20150623$Device;
    deviceMinutes?: DeviceFarm$20150623$DeviceMinutes;
  };
  declare type DeviceFarm$20150623$Jobs = DeviceFarm$20150623$Job[];
  declare type DeviceFarm$20150623$LimitExceededException = {
    message?: string;
  };
  declare type DeviceFarm$20150623$ListArtifactsRequest = {
    arn: string;
    type: 'SCREENSHOT' | 'FILE' | 'LOG';
    nextToken?: string;
  };
  declare type DeviceFarm$20150623$ListArtifactsResult = {
    artifacts?: DeviceFarm$20150623$Artifacts;
    nextToken?: string;
  };
  declare type DeviceFarm$20150623$ListDevicePoolsRequest = {
    arn: string;
    type?: 'CURATED' | 'PRIVATE';
    nextToken?: string;
  };
  declare type DeviceFarm$20150623$ListDevicePoolsResult = {
    devicePools?: DeviceFarm$20150623$DevicePools;
    nextToken?: string;
  };
  declare type DeviceFarm$20150623$ListDevicesRequest = {
    arn?: string;
    nextToken?: string;
  };
  declare type DeviceFarm$20150623$ListDevicesResult = {
    devices?: DeviceFarm$20150623$Devices;
    nextToken?: string;
  };
  declare type DeviceFarm$20150623$ListJobsRequest = {
    arn: string;
    nextToken?: string;
  };
  declare type DeviceFarm$20150623$ListJobsResult = {
    jobs?: DeviceFarm$20150623$Jobs;
    nextToken?: string;
  };
  declare type DeviceFarm$20150623$ListOfferingTransactionsRequest = {
    nextToken?: string;
  };
  declare type DeviceFarm$20150623$ListOfferingTransactionsResult = {
    offeringTransactions?: DeviceFarm$20150623$OfferingTransactions;
    nextToken?: string;
  };
  declare type DeviceFarm$20150623$ListOfferingsRequest = {
    nextToken?: string;
  };
  declare type DeviceFarm$20150623$ListOfferingsResult = {
    offerings?: DeviceFarm$20150623$Offerings;
    nextToken?: string;
  };
  declare type DeviceFarm$20150623$ListProjectsRequest = {
    arn?: string;
    nextToken?: string;
  };
  declare type DeviceFarm$20150623$ListProjectsResult = {
    projects?: DeviceFarm$20150623$Projects;
    nextToken?: string;
  };
  declare type DeviceFarm$20150623$ListRemoteAccessSessionsRequest = {
    arn: string;
    nextToken?: string;
  };
  declare type DeviceFarm$20150623$ListRemoteAccessSessionsResult = {
    remoteAccessSessions?: DeviceFarm$20150623$RemoteAccessSessions;
    nextToken?: string;
  };
  declare type DeviceFarm$20150623$ListRunsRequest = {
    arn: string;
    nextToken?: string;
  };
  declare type DeviceFarm$20150623$ListRunsResult = {
    runs?: DeviceFarm$20150623$Runs;
    nextToken?: string;
  };
  declare type DeviceFarm$20150623$ListSamplesRequest = {
    arn: string;
    nextToken?: string;
  };
  declare type DeviceFarm$20150623$ListSamplesResult = {
    samples?: DeviceFarm$20150623$Samples;
    nextToken?: string;
  };
  declare type DeviceFarm$20150623$ListSuitesRequest = {
    arn: string;
    nextToken?: string;
  };
  declare type DeviceFarm$20150623$ListSuitesResult = {
    suites?: DeviceFarm$20150623$Suites;
    nextToken?: string;
  };
  declare type DeviceFarm$20150623$ListTestsRequest = {
    arn: string;
    nextToken?: string;
  };
  declare type DeviceFarm$20150623$ListTestsResult = {
    tests?: DeviceFarm$20150623$Tests;
    nextToken?: string;
  };
  declare type DeviceFarm$20150623$ListUniqueProblemsRequest = {
    arn: string;
    nextToken?: string;
  };
  declare type DeviceFarm$20150623$ListUniqueProblemsResult = {
    uniqueProblems?: {
      [key: 'PENDING' | 'PASSED' | 'WARNED' | 'FAILED' | 'SKIPPED' | 'ERRORED' | 'STOPPED']: DeviceFarm$20150623$UniqueProblems;
    };
    nextToken?: string;
  };
  declare type DeviceFarm$20150623$ListUploadsRequest = {
    arn: string;
    nextToken?: string;
  };
  declare type DeviceFarm$20150623$ListUploadsResult = {
    uploads?: DeviceFarm$20150623$Uploads;
    nextToken?: string;
  };
  declare type DeviceFarm$20150623$Location = {
    latitude: number;
    longitude: number;
  };
  declare type DeviceFarm$20150623$MonetaryAmount = {
    amount?: number;
    currencyCode?: 'USD';
  };
  declare type DeviceFarm$20150623$NotEligibleException = {
    message?: string;
  };
  declare type DeviceFarm$20150623$NotFoundException = {
    message?: string;
  };
  declare type DeviceFarm$20150623$Offering = {
    id?: string;
    description?: string;
    type?: 'RECURRING';
    platform?: 'ANDROID' | 'IOS';
    recurringCharges?: DeviceFarm$20150623$RecurringCharges;
  };
  declare type DeviceFarm$20150623$OfferingStatus = {
    type?: 'PURCHASE' | 'RENEW' | 'SYSTEM';
    offering?: DeviceFarm$20150623$Offering;
    quantity?: number;
    effectiveOn?: Date;
  };
  declare type DeviceFarm$20150623$OfferingStatusMap = {
    [key: string]: DeviceFarm$20150623$OfferingStatus;
  };
  declare type DeviceFarm$20150623$OfferingTransaction = {
    offeringStatus?: DeviceFarm$20150623$OfferingStatus;
    transactionId?: string;
    createdOn?: Date;
    cost?: DeviceFarm$20150623$MonetaryAmount;
  };
  declare type DeviceFarm$20150623$OfferingTransactionType = 'PURCHASE' | 'RENEW' | 'SYSTEM';
  declare type DeviceFarm$20150623$OfferingTransactions = DeviceFarm$20150623$OfferingTransaction[];
  declare type DeviceFarm$20150623$OfferingType = 'RECURRING';
  declare type DeviceFarm$20150623$Offerings = DeviceFarm$20150623$Offering[];
  declare type DeviceFarm$20150623$Problem = {
    run?: DeviceFarm$20150623$ProblemDetail;
    job?: DeviceFarm$20150623$ProblemDetail;
    suite?: DeviceFarm$20150623$ProblemDetail;
    test?: DeviceFarm$20150623$ProblemDetail;
    device?: DeviceFarm$20150623$Device;
    result?: 'PENDING' | 'PASSED' | 'WARNED' | 'FAILED' | 'SKIPPED' | 'ERRORED' | 'STOPPED';
    message?: string;
  };
  declare type DeviceFarm$20150623$ProblemDetail = {
    arn?: string;
    name?: string;
  };
  declare type DeviceFarm$20150623$Problems = DeviceFarm$20150623$Problem[];
  declare type DeviceFarm$20150623$Project = {
    arn?: string;
    name?: string;
    created?: Date;
  };
  declare type DeviceFarm$20150623$Projects = DeviceFarm$20150623$Project[];
  declare type DeviceFarm$20150623$PurchaseOfferingRequest = {
    offeringId?: string;
    quantity?: number;
  };
  declare type DeviceFarm$20150623$PurchaseOfferingResult = {
    offeringTransaction?: DeviceFarm$20150623$OfferingTransaction;
  };
  declare type DeviceFarm$20150623$PurchasedDevicesMap = {
    [key: 'ANDROID' | 'IOS']: number;
  };
  declare type DeviceFarm$20150623$Radios = {
    wifi?: boolean;
    bluetooth?: boolean;
    nfc?: boolean;
    gps?: boolean;
  };
  declare type DeviceFarm$20150623$RecurringCharge = {
    cost?: DeviceFarm$20150623$MonetaryAmount;
    frequency?: 'MONTHLY';
  };
  declare type DeviceFarm$20150623$RecurringChargeFrequency = 'MONTHLY';
  declare type DeviceFarm$20150623$RecurringCharges = DeviceFarm$20150623$RecurringCharge[];
  declare type DeviceFarm$20150623$RemoteAccessSession = {
    arn?: string;
    name?: string;
    created?: Date;
    status?: 'PENDING' | 'PENDING_CONCURRENCY' | 'PENDING_DEVICE' | 'PROCESSING' | 'SCHEDULING' | 'PREPARING' | 'RUNNING' | 'COMPLETED' | 'STOPPING';
    result?: 'PENDING' | 'PASSED' | 'WARNED' | 'FAILED' | 'SKIPPED' | 'ERRORED' | 'STOPPED';
    message?: string;
    started?: Date;
    stopped?: Date;
    device?: DeviceFarm$20150623$Device;
    billingMethod?: 'METERED' | 'UNMETERED';
    deviceMinutes?: DeviceFarm$20150623$DeviceMinutes;
    endpoint?: string;
  };
  declare type DeviceFarm$20150623$RemoteAccessSessions = DeviceFarm$20150623$RemoteAccessSession[];
  declare type DeviceFarm$20150623$RenewOfferingRequest = {
    offeringId?: string;
    quantity?: number;
  };
  declare type DeviceFarm$20150623$RenewOfferingResult = {
    offeringTransaction?: DeviceFarm$20150623$OfferingTransaction;
  };
  declare type DeviceFarm$20150623$Resolution = {
    width?: number;
    height?: number;
  };
  declare type DeviceFarm$20150623$Rule = {
    attribute?: 'ARN' | 'PLATFORM' | 'FORM_FACTOR' | 'MANUFACTURER' | 'REMOTE_ACCESS_ENABLED';
    operator?: 'EQUALS' | 'LESS_THAN' | 'GREATER_THAN' | 'IN' | 'NOT_IN';
    value?: string;
  };
  declare type DeviceFarm$20150623$RuleOperator = 'EQUALS' | 'LESS_THAN' | 'GREATER_THAN' | 'IN' | 'NOT_IN';
  declare type DeviceFarm$20150623$Rules = DeviceFarm$20150623$Rule[];
  declare type DeviceFarm$20150623$Run = {
    arn?: string;
    name?: string;
    type?: 'BUILTIN_FUZZ' | 'BUILTIN_EXPLORER' | 'APPIUM_JAVA_JUNIT' | 'APPIUM_JAVA_TESTNG' | 'APPIUM_PYTHON' | 'APPIUM_WEB_JAVA_JUNIT' | 'APPIUM_WEB_JAVA_TESTNG' | 'APPIUM_WEB_PYTHON' | 'CALABASH' | 'INSTRUMENTATION' | 'UIAUTOMATION' | 'UIAUTOMATOR' | 'XCTEST' | 'XCTEST_UI';
    platform?: 'ANDROID' | 'IOS';
    created?: Date;
    status?: 'PENDING' | 'PENDING_CONCURRENCY' | 'PENDING_DEVICE' | 'PROCESSING' | 'SCHEDULING' | 'PREPARING' | 'RUNNING' | 'COMPLETED' | 'STOPPING';
    result?: 'PENDING' | 'PASSED' | 'WARNED' | 'FAILED' | 'SKIPPED' | 'ERRORED' | 'STOPPED';
    started?: Date;
    stopped?: Date;
    counters?: DeviceFarm$20150623$Counters;
    message?: string;
    totalJobs?: number;
    completedJobs?: number;
    billingMethod?: 'METERED' | 'UNMETERED';
    deviceMinutes?: DeviceFarm$20150623$DeviceMinutes;
  };
  declare type DeviceFarm$20150623$Runs = DeviceFarm$20150623$Run[];
  declare type DeviceFarm$20150623$Sample = {
    arn?: string;
    type?: 'CPU' | 'MEMORY' | 'THREADS' | 'RX_RATE' | 'TX_RATE' | 'RX' | 'TX' | 'NATIVE_FRAMES' | 'NATIVE_FPS' | 'NATIVE_MIN_DRAWTIME' | 'NATIVE_AVG_DRAWTIME' | 'NATIVE_MAX_DRAWTIME' | 'OPENGL_FRAMES' | 'OPENGL_FPS' | 'OPENGL_MIN_DRAWTIME' | 'OPENGL_AVG_DRAWTIME' | 'OPENGL_MAX_DRAWTIME';
    url?: string;
  };
  declare type DeviceFarm$20150623$SampleType = 'CPU' | 'MEMORY' | 'THREADS' | 'RX_RATE' | 'TX_RATE' | 'RX' | 'TX' | 'NATIVE_FRAMES' | 'NATIVE_FPS' | 'NATIVE_MIN_DRAWTIME' | 'NATIVE_AVG_DRAWTIME' | 'NATIVE_MAX_DRAWTIME' | 'OPENGL_FRAMES' | 'OPENGL_FPS' | 'OPENGL_MIN_DRAWTIME' | 'OPENGL_AVG_DRAWTIME' | 'OPENGL_MAX_DRAWTIME';
  declare type DeviceFarm$20150623$Samples = DeviceFarm$20150623$Sample[];
  declare type DeviceFarm$20150623$ScheduleRunConfiguration = {
    extraDataPackageArn?: string;
    networkProfileArn?: string;
    locale?: string;
    location?: DeviceFarm$20150623$Location;
    radios?: DeviceFarm$20150623$Radios;
    auxiliaryApps?: DeviceFarm$20150623$AmazonResourceNames;
    billingMethod?: 'METERED' | 'UNMETERED';
  };
  declare type DeviceFarm$20150623$ScheduleRunRequest = {
    projectArn: string;
    appArn?: string;
    devicePoolArn: string;
    name?: string;
    test: DeviceFarm$20150623$ScheduleRunTest;
    configuration?: DeviceFarm$20150623$ScheduleRunConfiguration;
  };
  declare type DeviceFarm$20150623$ScheduleRunResult = {
    run?: DeviceFarm$20150623$Run;
  };
  declare type DeviceFarm$20150623$ScheduleRunTest = {
    type: 'BUILTIN_FUZZ' | 'BUILTIN_EXPLORER' | 'APPIUM_JAVA_JUNIT' | 'APPIUM_JAVA_TESTNG' | 'APPIUM_PYTHON' | 'APPIUM_WEB_JAVA_JUNIT' | 'APPIUM_WEB_JAVA_TESTNG' | 'APPIUM_WEB_PYTHON' | 'CALABASH' | 'INSTRUMENTATION' | 'UIAUTOMATION' | 'UIAUTOMATOR' | 'XCTEST' | 'XCTEST_UI';
    testPackageArn?: string;
    filter?: string;
    parameters?: {
      [key: string]: string;
    };
  };
  declare type DeviceFarm$20150623$ServiceAccountException = {
    message?: string;
  };
  declare type DeviceFarm$20150623$StopRemoteAccessSessionRequest = {
    arn: string;
  };
  declare type DeviceFarm$20150623$StopRemoteAccessSessionResult = {
    remoteAccessSession?: DeviceFarm$20150623$RemoteAccessSession;
  };
  declare type DeviceFarm$20150623$StopRunRequest = {
    arn: string;
  };
  declare type DeviceFarm$20150623$StopRunResult = {
    run?: DeviceFarm$20150623$Run;
  };
  declare type DeviceFarm$20150623$Suite = {
    arn?: string;
    name?: string;
    type?: 'BUILTIN_FUZZ' | 'BUILTIN_EXPLORER' | 'APPIUM_JAVA_JUNIT' | 'APPIUM_JAVA_TESTNG' | 'APPIUM_PYTHON' | 'APPIUM_WEB_JAVA_JUNIT' | 'APPIUM_WEB_JAVA_TESTNG' | 'APPIUM_WEB_PYTHON' | 'CALABASH' | 'INSTRUMENTATION' | 'UIAUTOMATION' | 'UIAUTOMATOR' | 'XCTEST' | 'XCTEST_UI';
    created?: Date;
    status?: 'PENDING' | 'PENDING_CONCURRENCY' | 'PENDING_DEVICE' | 'PROCESSING' | 'SCHEDULING' | 'PREPARING' | 'RUNNING' | 'COMPLETED' | 'STOPPING';
    result?: 'PENDING' | 'PASSED' | 'WARNED' | 'FAILED' | 'SKIPPED' | 'ERRORED' | 'STOPPED';
    started?: Date;
    stopped?: Date;
    counters?: DeviceFarm$20150623$Counters;
    message?: string;
    deviceMinutes?: DeviceFarm$20150623$DeviceMinutes;
  };
  declare type DeviceFarm$20150623$Suites = DeviceFarm$20150623$Suite[];
  declare type DeviceFarm$20150623$Test = {
    arn?: string;
    name?: string;
    type?: 'BUILTIN_FUZZ' | 'BUILTIN_EXPLORER' | 'APPIUM_JAVA_JUNIT' | 'APPIUM_JAVA_TESTNG' | 'APPIUM_PYTHON' | 'APPIUM_WEB_JAVA_JUNIT' | 'APPIUM_WEB_JAVA_TESTNG' | 'APPIUM_WEB_PYTHON' | 'CALABASH' | 'INSTRUMENTATION' | 'UIAUTOMATION' | 'UIAUTOMATOR' | 'XCTEST' | 'XCTEST_UI';
    created?: Date;
    status?: 'PENDING' | 'PENDING_CONCURRENCY' | 'PENDING_DEVICE' | 'PROCESSING' | 'SCHEDULING' | 'PREPARING' | 'RUNNING' | 'COMPLETED' | 'STOPPING';
    result?: 'PENDING' | 'PASSED' | 'WARNED' | 'FAILED' | 'SKIPPED' | 'ERRORED' | 'STOPPED';
    started?: Date;
    stopped?: Date;
    counters?: DeviceFarm$20150623$Counters;
    message?: string;
    deviceMinutes?: DeviceFarm$20150623$DeviceMinutes;
  };
  declare type DeviceFarm$20150623$TestParameters = {
    [key: string]: string;
  };
  declare type DeviceFarm$20150623$TestType = 'BUILTIN_FUZZ' | 'BUILTIN_EXPLORER' | 'APPIUM_JAVA_JUNIT' | 'APPIUM_JAVA_TESTNG' | 'APPIUM_PYTHON' | 'APPIUM_WEB_JAVA_JUNIT' | 'APPIUM_WEB_JAVA_TESTNG' | 'APPIUM_WEB_PYTHON' | 'CALABASH' | 'INSTRUMENTATION' | 'UIAUTOMATION' | 'UIAUTOMATOR' | 'XCTEST' | 'XCTEST_UI';
  declare type DeviceFarm$20150623$Tests = DeviceFarm$20150623$Test[];
  declare type DeviceFarm$20150623$UniqueProblem = {
    message?: string;
    problems?: DeviceFarm$20150623$Problems;
  };
  declare type DeviceFarm$20150623$UniqueProblems = DeviceFarm$20150623$UniqueProblem[];
  declare type DeviceFarm$20150623$UniqueProblemsByExecutionResultMap = {
    [key: 'PENDING' | 'PASSED' | 'WARNED' | 'FAILED' | 'SKIPPED' | 'ERRORED' | 'STOPPED']: DeviceFarm$20150623$UniqueProblems;
  };
  declare type DeviceFarm$20150623$UpdateDevicePoolRequest = {
    arn: string;
    name?: string;
    description?: string;
    rules?: DeviceFarm$20150623$Rules;
  };
  declare type DeviceFarm$20150623$UpdateDevicePoolResult = {
    devicePool?: DeviceFarm$20150623$DevicePool;
  };
  declare type DeviceFarm$20150623$UpdateProjectRequest = {
    arn: string;
    name?: string;
  };
  declare type DeviceFarm$20150623$UpdateProjectResult = {
    project?: DeviceFarm$20150623$Project;
  };
  declare type DeviceFarm$20150623$Upload = {
    arn?: string;
    name?: string;
    created?: Date;
    type?: 'ANDROID_APP' | 'IOS_APP' | 'WEB_APP' | 'EXTERNAL_DATA' | 'APPIUM_JAVA_JUNIT_TEST_PACKAGE' | 'APPIUM_JAVA_TESTNG_TEST_PACKAGE' | 'APPIUM_PYTHON_TEST_PACKAGE' | 'APPIUM_WEB_JAVA_JUNIT_TEST_PACKAGE' | 'APPIUM_WEB_JAVA_TESTNG_TEST_PACKAGE' | 'APPIUM_WEB_PYTHON_TEST_PACKAGE' | 'CALABASH_TEST_PACKAGE' | 'INSTRUMENTATION_TEST_PACKAGE' | 'UIAUTOMATION_TEST_PACKAGE' | 'UIAUTOMATOR_TEST_PACKAGE' | 'XCTEST_TEST_PACKAGE' | 'XCTEST_UI_TEST_PACKAGE';
    status?: 'INITIALIZED' | 'PROCESSING' | 'SUCCEEDED' | 'FAILED';
    url?: string;
    metadata?: string;
    contentType?: string;
    message?: string;
  };
  declare type DeviceFarm$20150623$UploadStatus = 'INITIALIZED' | 'PROCESSING' | 'SUCCEEDED' | 'FAILED';
  declare type DeviceFarm$20150623$UploadType = 'ANDROID_APP' | 'IOS_APP' | 'WEB_APP' | 'EXTERNAL_DATA' | 'APPIUM_JAVA_JUNIT_TEST_PACKAGE' | 'APPIUM_JAVA_TESTNG_TEST_PACKAGE' | 'APPIUM_PYTHON_TEST_PACKAGE' | 'APPIUM_WEB_JAVA_JUNIT_TEST_PACKAGE' | 'APPIUM_WEB_JAVA_TESTNG_TEST_PACKAGE' | 'APPIUM_WEB_PYTHON_TEST_PACKAGE' | 'CALABASH_TEST_PACKAGE' | 'INSTRUMENTATION_TEST_PACKAGE' | 'UIAUTOMATION_TEST_PACKAGE' | 'UIAUTOMATOR_TEST_PACKAGE' | 'XCTEST_TEST_PACKAGE' | 'XCTEST_UI_TEST_PACKAGE';
  declare type DeviceFarm$20150623$Uploads = DeviceFarm$20150623$Upload[];
  declare type DirectConnect$20121025$AllocateConnectionOnInterconnectRequest = {
    bandwidth: string;
    connectionName: string;
    ownerAccount: string;
    interconnectId: string;
    vlan: number;
  };
  declare type DirectConnect$20121025$AllocatePrivateVirtualInterfaceRequest = {
    connectionId: string;
    ownerAccount: string;
    newPrivateVirtualInterfaceAllocation: DirectConnect$20121025$NewPrivateVirtualInterfaceAllocation;
  };
  declare type DirectConnect$20121025$AllocatePublicVirtualInterfaceRequest = {
    connectionId: string;
    ownerAccount: string;
    newPublicVirtualInterfaceAllocation: DirectConnect$20121025$NewPublicVirtualInterfaceAllocation;
  };
  declare type DirectConnect$20121025$ConfirmConnectionRequest = {
    connectionId: string;
  };
  declare type DirectConnect$20121025$ConfirmConnectionResponse = {
    connectionState?: 'ordering' | 'requested' | 'pending' | 'available' | 'down' | 'deleting' | 'deleted' | 'rejected';
  };
  declare type DirectConnect$20121025$ConfirmPrivateVirtualInterfaceRequest = {
    virtualInterfaceId: string;
    virtualGatewayId: string;
  };
  declare type DirectConnect$20121025$ConfirmPrivateVirtualInterfaceResponse = {
    virtualInterfaceState?: 'confirming' | 'verifying' | 'pending' | 'available' | 'down' | 'deleting' | 'deleted' | 'rejected';
  };
  declare type DirectConnect$20121025$ConfirmPublicVirtualInterfaceRequest = {
    virtualInterfaceId: string;
  };
  declare type DirectConnect$20121025$ConfirmPublicVirtualInterfaceResponse = {
    virtualInterfaceState?: 'confirming' | 'verifying' | 'pending' | 'available' | 'down' | 'deleting' | 'deleted' | 'rejected';
  };
  declare type DirectConnect$20121025$Connection = {
    ownerAccount?: string;
    connectionId?: string;
    connectionName?: string;
    connectionState?: 'ordering' | 'requested' | 'pending' | 'available' | 'down' | 'deleting' | 'deleted' | 'rejected';
    region?: string;
    location?: string;
    bandwidth?: string;
    vlan?: number;
    partnerName?: string;
    loaIssueTime?: Date;
  };
  declare type DirectConnect$20121025$ConnectionList = DirectConnect$20121025$Connection[];
  declare type DirectConnect$20121025$ConnectionState = 'ordering' | 'requested' | 'pending' | 'available' | 'down' | 'deleting' | 'deleted' | 'rejected';
  declare type DirectConnect$20121025$Connections = {
    connections?: DirectConnect$20121025$ConnectionList;
  };
  declare type DirectConnect$20121025$CreateConnectionRequest = {
    location: string;
    bandwidth: string;
    connectionName: string;
  };
  declare type DirectConnect$20121025$CreateInterconnectRequest = {
    interconnectName: string;
    bandwidth: string;
    location: string;
  };
  declare type DirectConnect$20121025$CreatePrivateVirtualInterfaceRequest = {
    connectionId: string;
    newPrivateVirtualInterface: DirectConnect$20121025$NewPrivateVirtualInterface;
  };
  declare type DirectConnect$20121025$CreatePublicVirtualInterfaceRequest = {
    connectionId: string;
    newPublicVirtualInterface: DirectConnect$20121025$NewPublicVirtualInterface;
  };
  declare type DirectConnect$20121025$DeleteConnectionRequest = {
    connectionId: string;
  };
  declare type DirectConnect$20121025$DeleteInterconnectRequest = {
    interconnectId: string;
  };
  declare type DirectConnect$20121025$DeleteInterconnectResponse = {
    interconnectState?: 'requested' | 'pending' | 'available' | 'down' | 'deleting' | 'deleted';
  };
  declare type DirectConnect$20121025$DeleteVirtualInterfaceRequest = {
    virtualInterfaceId: string;
  };
  declare type DirectConnect$20121025$DeleteVirtualInterfaceResponse = {
    virtualInterfaceState?: 'confirming' | 'verifying' | 'pending' | 'available' | 'down' | 'deleting' | 'deleted' | 'rejected';
  };
  declare type DirectConnect$20121025$DescribeConnectionLoaRequest = {
    connectionId: string;
    providerName?: string;
    loaContentType?: 'application/pdf';
  };
  declare type DirectConnect$20121025$DescribeConnectionLoaResponse = {
    loa?: DirectConnect$20121025$Loa;
  };
  declare type DirectConnect$20121025$DescribeConnectionsOnInterconnectRequest = {
    interconnectId: string;
  };
  declare type DirectConnect$20121025$DescribeConnectionsRequest = {
    connectionId?: string;
  };
  declare type DirectConnect$20121025$DescribeInterconnectLoaRequest = {
    interconnectId: string;
    providerName?: string;
    loaContentType?: 'application/pdf';
  };
  declare type DirectConnect$20121025$DescribeInterconnectLoaResponse = {
    loa?: DirectConnect$20121025$Loa;
  };
  declare type DirectConnect$20121025$DescribeInterconnectsRequest = {
    interconnectId?: string;
  };
  declare type DirectConnect$20121025$DescribeVirtualInterfacesRequest = {
    connectionId?: string;
    virtualInterfaceId?: string;
  };
  declare type DirectConnect$20121025$DirectConnectClientException = {
    message?: string;
  };
  declare type DirectConnect$20121025$DirectConnectServerException = {
    message?: string;
  };
  declare type DirectConnect$20121025$Interconnect = {
    interconnectId?: string;
    interconnectName?: string;
    interconnectState?: 'requested' | 'pending' | 'available' | 'down' | 'deleting' | 'deleted';
    region?: string;
    location?: string;
    bandwidth?: string;
    loaIssueTime?: Date;
  };
  declare type DirectConnect$20121025$InterconnectList = DirectConnect$20121025$Interconnect[];
  declare type DirectConnect$20121025$InterconnectState = 'requested' | 'pending' | 'available' | 'down' | 'deleting' | 'deleted';
  declare type DirectConnect$20121025$Interconnects = {
    interconnects?: DirectConnect$20121025$InterconnectList;
  };
  declare type DirectConnect$20121025$Loa = {
    loaContent?: Buffer | $TypedArray | Blob | string;
    loaContentType?: 'application/pdf';
  };
  declare type DirectConnect$20121025$LoaContent = Buffer | $TypedArray | Blob | string;
  declare type DirectConnect$20121025$LoaContentType = 'application/pdf';
  declare type DirectConnect$20121025$LoaIssueTime = Date;
  declare type DirectConnect$20121025$Location = {
    locationCode?: string;
    locationName?: string;
  };
  declare type DirectConnect$20121025$LocationList = DirectConnect$20121025$Location[];
  declare type DirectConnect$20121025$Locations = {
    locations?: DirectConnect$20121025$LocationList;
  };
  declare type DirectConnect$20121025$NewPrivateVirtualInterface = {
    virtualInterfaceName: string;
    vlan: number;
    asn: number;
    authKey?: string;
    amazonAddress?: string;
    customerAddress?: string;
    virtualGatewayId: string;
  };
  declare type DirectConnect$20121025$NewPrivateVirtualInterfaceAllocation = {
    virtualInterfaceName: string;
    vlan: number;
    asn: number;
    authKey?: string;
    amazonAddress?: string;
    customerAddress?: string;
  };
  declare type DirectConnect$20121025$NewPublicVirtualInterface = {
    virtualInterfaceName: string;
    vlan: number;
    asn: number;
    authKey?: string;
    amazonAddress: string;
    customerAddress: string;
    routeFilterPrefixes: DirectConnect$20121025$RouteFilterPrefixList;
  };
  declare type DirectConnect$20121025$NewPublicVirtualInterfaceAllocation = {
    virtualInterfaceName: string;
    vlan: number;
    asn: number;
    authKey?: string;
    amazonAddress: string;
    customerAddress: string;
    routeFilterPrefixes: DirectConnect$20121025$RouteFilterPrefixList;
  };
  declare type DirectConnect$20121025$RouteFilterPrefix = {
    cidr?: string;
  };
  declare type DirectConnect$20121025$RouteFilterPrefixList = DirectConnect$20121025$RouteFilterPrefix[];
  declare type DirectConnect$20121025$VirtualGateway = {
    virtualGatewayId?: string;
    virtualGatewayState?: string;
  };
  declare type DirectConnect$20121025$VirtualGatewayList = DirectConnect$20121025$VirtualGateway[];
  declare type DirectConnect$20121025$VirtualGateways = {
    virtualGateways?: DirectConnect$20121025$VirtualGatewayList;
  };
  declare type DirectConnect$20121025$VirtualInterface = {
    ownerAccount?: string;
    virtualInterfaceId?: string;
    location?: string;
    connectionId?: string;
    virtualInterfaceType?: string;
    virtualInterfaceName?: string;
    vlan?: number;
    asn?: number;
    authKey?: string;
    amazonAddress?: string;
    customerAddress?: string;
    virtualInterfaceState?: 'confirming' | 'verifying' | 'pending' | 'available' | 'down' | 'deleting' | 'deleted' | 'rejected';
    customerRouterConfig?: string;
    virtualGatewayId?: string;
    routeFilterPrefixes?: DirectConnect$20121025$RouteFilterPrefixList;
  };
  declare type DirectConnect$20121025$VirtualInterfaceList = DirectConnect$20121025$VirtualInterface[];
  declare type DirectConnect$20121025$VirtualInterfaceState = 'confirming' | 'verifying' | 'pending' | 'available' | 'down' | 'deleting' | 'deleted' | 'rejected';
  declare type DirectConnect$20121025$VirtualInterfaces = {
    virtualInterfaces?: DirectConnect$20121025$VirtualInterfaceList;
  };
  declare type DirectoryService$20150416$AddIpRoutesRequest = {
    DirectoryId: string;
    IpRoutes: DirectoryService$20150416$IpRoutes;
    UpdateSecurityGroupForDirectoryControllers?: boolean;
  };
  declare type DirectoryService$20150416$AddIpRoutesResult = {};
  declare type DirectoryService$20150416$AddTagsToResourceRequest = {
    ResourceId: string;
    Tags: DirectoryService$20150416$Tags;
  };
  declare type DirectoryService$20150416$AddTagsToResourceResult = {};
  declare type DirectoryService$20150416$AddedDateTime = Date;
  declare type DirectoryService$20150416$Attribute = {
    Name?: string;
    Value?: string;
  };
  declare type DirectoryService$20150416$Attributes = DirectoryService$20150416$Attribute[];
  declare type DirectoryService$20150416$AuthenticationFailedException = {
    Message?: string;
    RequestId?: string;
  };
  declare type DirectoryService$20150416$AvailabilityZones = string[];
  declare type DirectoryService$20150416$CidrIps = string[];
  declare type DirectoryService$20150416$ClientException = {
    Message?: string;
    RequestId?: string;
  };
  declare type DirectoryService$20150416$Computer = {
    ComputerId?: string;
    ComputerName?: string;
    ComputerAttributes?: DirectoryService$20150416$Attributes;
  };
  declare type DirectoryService$20150416$ConditionalForwarder = {
    RemoteDomainName?: string;
    DnsIpAddrs?: DirectoryService$20150416$DnsIpAddrs;
    ReplicationScope?: 'Domain';
  };
  declare type DirectoryService$20150416$ConditionalForwarders = DirectoryService$20150416$ConditionalForwarder[];
  declare type DirectoryService$20150416$ConnectDirectoryRequest = {
    Name: string;
    ShortName?: string;
    Password: string;
    Description?: string;
    Size: 'Small' | 'Large';
    ConnectSettings: DirectoryService$20150416$DirectoryConnectSettings;
  };
  declare type DirectoryService$20150416$ConnectDirectoryResult = {
    DirectoryId?: string;
  };
  declare type DirectoryService$20150416$CreateAliasRequest = {
    DirectoryId: string;
    Alias: string;
  };
  declare type DirectoryService$20150416$CreateAliasResult = {
    DirectoryId?: string;
    Alias?: string;
  };
  declare type DirectoryService$20150416$CreateComputerRequest = {
    DirectoryId: string;
    ComputerName: string;
    Password: string;
    OrganizationalUnitDistinguishedName?: string;
    ComputerAttributes?: DirectoryService$20150416$Attributes;
  };
  declare type DirectoryService$20150416$CreateComputerResult = {
    Computer?: DirectoryService$20150416$Computer;
  };
  declare type DirectoryService$20150416$CreateConditionalForwarderRequest = {
    DirectoryId: string;
    RemoteDomainName: string;
    DnsIpAddrs: DirectoryService$20150416$DnsIpAddrs;
  };
  declare type DirectoryService$20150416$CreateConditionalForwarderResult = {};
  declare type DirectoryService$20150416$CreateDirectoryRequest = {
    Name: string;
    ShortName?: string;
    Password: string;
    Description?: string;
    Size: 'Small' | 'Large';
    VpcSettings?: DirectoryService$20150416$DirectoryVpcSettings;
  };
  declare type DirectoryService$20150416$CreateDirectoryResult = {
    DirectoryId?: string;
  };
  declare type DirectoryService$20150416$CreateMicrosoftADRequest = {
    Name: string;
    ShortName?: string;
    Password: string;
    Description?: string;
    VpcSettings: DirectoryService$20150416$DirectoryVpcSettings;
  };
  declare type DirectoryService$20150416$CreateMicrosoftADResult = {
    DirectoryId?: string;
  };
  declare type DirectoryService$20150416$CreateSnapshotRequest = {
    DirectoryId: string;
    Name?: string;
  };
  declare type DirectoryService$20150416$CreateSnapshotResult = {
    SnapshotId?: string;
  };
  declare type DirectoryService$20150416$CreateTrustRequest = {
    DirectoryId: string;
    RemoteDomainName: string;
    TrustPassword: string;
    TrustDirection: 'One-Way: Outgoing' | 'One-Way: Incoming' | 'Two-Way';
    TrustType?: 'Forest';
    ConditionalForwarderIpAddrs?: DirectoryService$20150416$DnsIpAddrs;
  };
  declare type DirectoryService$20150416$CreateTrustResult = {
    TrustId?: string;
  };
  declare type DirectoryService$20150416$CreatedDateTime = Date;
  declare type DirectoryService$20150416$DeleteConditionalForwarderRequest = {
    DirectoryId: string;
    RemoteDomainName: string;
  };
  declare type DirectoryService$20150416$DeleteConditionalForwarderResult = {};
  declare type DirectoryService$20150416$DeleteDirectoryRequest = {
    DirectoryId: string;
  };
  declare type DirectoryService$20150416$DeleteDirectoryResult = {
    DirectoryId?: string;
  };
  declare type DirectoryService$20150416$DeleteSnapshotRequest = {
    SnapshotId: string;
  };
  declare type DirectoryService$20150416$DeleteSnapshotResult = {
    SnapshotId?: string;
  };
  declare type DirectoryService$20150416$DeleteTrustRequest = {
    TrustId: string;
    DeleteAssociatedConditionalForwarder?: boolean;
  };
  declare type DirectoryService$20150416$DeleteTrustResult = {
    TrustId?: string;
  };
  declare type DirectoryService$20150416$DeregisterEventTopicRequest = {
    DirectoryId: string;
    TopicName: string;
  };
  declare type DirectoryService$20150416$DeregisterEventTopicResult = {};
  declare type DirectoryService$20150416$DescribeConditionalForwardersRequest = {
    DirectoryId: string;
    RemoteDomainNames?: DirectoryService$20150416$RemoteDomainNames;
  };
  declare type DirectoryService$20150416$DescribeConditionalForwardersResult = {
    ConditionalForwarders?: DirectoryService$20150416$ConditionalForwarders;
  };
  declare type DirectoryService$20150416$DescribeDirectoriesRequest = {
    DirectoryIds?: DirectoryService$20150416$DirectoryIds;
    NextToken?: string;
    Limit?: number;
  };
  declare type DirectoryService$20150416$DescribeDirectoriesResult = {
    DirectoryDescriptions?: DirectoryService$20150416$DirectoryDescriptions;
    NextToken?: string;
  };
  declare type DirectoryService$20150416$DescribeEventTopicsRequest = {
    DirectoryId?: string;
    TopicNames?: DirectoryService$20150416$TopicNames;
  };
  declare type DirectoryService$20150416$DescribeEventTopicsResult = {
    EventTopics?: DirectoryService$20150416$EventTopics;
  };
  declare type DirectoryService$20150416$DescribeSnapshotsRequest = {
    DirectoryId?: string;
    SnapshotIds?: DirectoryService$20150416$SnapshotIds;
    NextToken?: string;
    Limit?: number;
  };
  declare type DirectoryService$20150416$DescribeSnapshotsResult = {
    Snapshots?: DirectoryService$20150416$Snapshots;
    NextToken?: string;
  };
  declare type DirectoryService$20150416$DescribeTrustsRequest = {
    DirectoryId?: string;
    TrustIds?: DirectoryService$20150416$TrustIds;
    NextToken?: string;
    Limit?: number;
  };
  declare type DirectoryService$20150416$DescribeTrustsResult = {
    Trusts?: DirectoryService$20150416$Trusts;
    NextToken?: string;
  };
  declare type DirectoryService$20150416$DirectoryConnectSettings = {
    VpcId: string;
    SubnetIds: DirectoryService$20150416$SubnetIds;
    CustomerDnsIps: DirectoryService$20150416$DnsIpAddrs;
    CustomerUserName: string;
  };
  declare type DirectoryService$20150416$DirectoryConnectSettingsDescription = {
    VpcId?: string;
    SubnetIds?: DirectoryService$20150416$SubnetIds;
    CustomerUserName?: string;
    SecurityGroupId?: string;
    AvailabilityZones?: DirectoryService$20150416$AvailabilityZones;
    ConnectIps?: DirectoryService$20150416$IpAddrs;
  };
  declare type DirectoryService$20150416$DirectoryDescription = {
    DirectoryId?: string;
    Name?: string;
    ShortName?: string;
    Size?: 'Small' | 'Large';
    Alias?: string;
    AccessUrl?: string;
    Description?: string;
    DnsIpAddrs?: DirectoryService$20150416$DnsIpAddrs;
    Stage?: 'Requested' | 'Creating' | 'Created' | 'Active' | 'Inoperable' | 'Impaired' | 'Restoring' | 'RestoreFailed' | 'Deleting' | 'Deleted' | 'Failed';
    LaunchTime?: Date;
    StageLastUpdatedDateTime?: Date;
    Type?: 'SimpleAD' | 'ADConnector' | 'MicrosoftAD';
    VpcSettings?: DirectoryService$20150416$DirectoryVpcSettingsDescription;
    ConnectSettings?: DirectoryService$20150416$DirectoryConnectSettingsDescription;
    RadiusSettings?: DirectoryService$20150416$RadiusSettings;
    RadiusStatus?: 'Creating' | 'Completed' | 'Failed';
    StageReason?: string;
    SsoEnabled?: boolean;
  };
  declare type DirectoryService$20150416$DirectoryDescriptions = DirectoryService$20150416$DirectoryDescription[];
  declare type DirectoryService$20150416$DirectoryIds = string[];
  declare type DirectoryService$20150416$DirectoryLimitExceededException = {
    Message?: string;
    RequestId?: string;
  };
  declare type DirectoryService$20150416$DirectoryLimits = {
    CloudOnlyDirectoriesLimit?: number;
    CloudOnlyDirectoriesCurrentCount?: number;
    CloudOnlyDirectoriesLimitReached?: boolean;
    CloudOnlyMicrosoftADLimit?: number;
    CloudOnlyMicrosoftADCurrentCount?: number;
    CloudOnlyMicrosoftADLimitReached?: boolean;
    ConnectedDirectoriesLimit?: number;
    ConnectedDirectoriesCurrentCount?: number;
    ConnectedDirectoriesLimitReached?: boolean;
  };
  declare type DirectoryService$20150416$DirectorySize = 'Small' | 'Large';
  declare type DirectoryService$20150416$DirectoryStage = 'Requested' | 'Creating' | 'Created' | 'Active' | 'Inoperable' | 'Impaired' | 'Restoring' | 'RestoreFailed' | 'Deleting' | 'Deleted' | 'Failed';
  declare type DirectoryService$20150416$DirectoryType = 'SimpleAD' | 'ADConnector' | 'MicrosoftAD';
  declare type DirectoryService$20150416$DirectoryUnavailableException = {
    Message?: string;
    RequestId?: string;
  };
  declare type DirectoryService$20150416$DirectoryVpcSettings = {
    VpcId: string;
    SubnetIds: DirectoryService$20150416$SubnetIds;
  };
  declare type DirectoryService$20150416$DirectoryVpcSettingsDescription = {
    VpcId?: string;
    SubnetIds?: DirectoryService$20150416$SubnetIds;
    SecurityGroupId?: string;
    AvailabilityZones?: DirectoryService$20150416$AvailabilityZones;
  };
  declare type DirectoryService$20150416$DisableRadiusRequest = {
    DirectoryId: string;
  };
  declare type DirectoryService$20150416$DisableRadiusResult = {};
  declare type DirectoryService$20150416$DisableSsoRequest = {
    DirectoryId: string;
    UserName?: string;
    Password?: string;
  };
  declare type DirectoryService$20150416$DisableSsoResult = {};
  declare type DirectoryService$20150416$DnsIpAddrs = string[];
  declare type DirectoryService$20150416$EnableRadiusRequest = {
    DirectoryId: string;
    RadiusSettings: DirectoryService$20150416$RadiusSettings;
  };
  declare type DirectoryService$20150416$EnableRadiusResult = {};
  declare type DirectoryService$20150416$EnableSsoRequest = {
    DirectoryId: string;
    UserName?: string;
    Password?: string;
  };
  declare type DirectoryService$20150416$EnableSsoResult = {};
  declare type DirectoryService$20150416$EntityAlreadyExistsException = {
    Message?: string;
    RequestId?: string;
  };
  declare type DirectoryService$20150416$EntityDoesNotExistException = {
    Message?: string;
    RequestId?: string;
  };
  declare type DirectoryService$20150416$EventTopic = {
    DirectoryId?: string;
    TopicName?: string;
    TopicArn?: string;
    CreatedDateTime?: Date;
    Status?: 'Registered' | 'Topic not found' | 'Failed' | 'Deleted';
  };
  declare type DirectoryService$20150416$EventTopics = DirectoryService$20150416$EventTopic[];
  declare type DirectoryService$20150416$GetDirectoryLimitsRequest = {};
  declare type DirectoryService$20150416$GetDirectoryLimitsResult = {
    DirectoryLimits?: DirectoryService$20150416$DirectoryLimits;
  };
  declare type DirectoryService$20150416$GetSnapshotLimitsRequest = {
    DirectoryId: string;
  };
  declare type DirectoryService$20150416$GetSnapshotLimitsResult = {
    SnapshotLimits?: DirectoryService$20150416$SnapshotLimits;
  };
  declare type DirectoryService$20150416$InsufficientPermissionsException = {
    Message?: string;
    RequestId?: string;
  };
  declare type DirectoryService$20150416$InvalidNextTokenException = {
    Message?: string;
    RequestId?: string;
  };
  declare type DirectoryService$20150416$InvalidParameterException = {
    Message?: string;
    RequestId?: string;
  };
  declare type DirectoryService$20150416$IpAddrs = string[];
  declare type DirectoryService$20150416$IpRoute = {
    CidrIp?: string;
    Description?: string;
  };
  declare type DirectoryService$20150416$IpRouteInfo = {
    DirectoryId?: string;
    CidrIp?: string;
    IpRouteStatusMsg?: 'Adding' | 'Added' | 'Removing' | 'Removed' | 'AddFailed' | 'RemoveFailed';
    AddedDateTime?: Date;
    IpRouteStatusReason?: string;
    Description?: string;
  };
  declare type DirectoryService$20150416$IpRouteLimitExceededException = {
    Message?: string;
    RequestId?: string;
  };
  declare type DirectoryService$20150416$IpRouteStatusMsg = 'Adding' | 'Added' | 'Removing' | 'Removed' | 'AddFailed' | 'RemoveFailed';
  declare type DirectoryService$20150416$IpRoutes = DirectoryService$20150416$IpRoute[];
  declare type DirectoryService$20150416$IpRoutesInfo = DirectoryService$20150416$IpRouteInfo[];
  declare type DirectoryService$20150416$LastUpdatedDateTime = Date;
  declare type DirectoryService$20150416$LaunchTime = Date;
  declare type DirectoryService$20150416$ListIpRoutesRequest = {
    DirectoryId: string;
    NextToken?: string;
    Limit?: number;
  };
  declare type DirectoryService$20150416$ListIpRoutesResult = {
    IpRoutesInfo?: DirectoryService$20150416$IpRoutesInfo;
    NextToken?: string;
  };
  declare type DirectoryService$20150416$ListTagsForResourceRequest = {
    ResourceId: string;
    NextToken?: string;
    Limit?: number;
  };
  declare type DirectoryService$20150416$ListTagsForResourceResult = {
    Tags?: DirectoryService$20150416$Tags;
    NextToken?: string;
  };
  declare type DirectoryService$20150416$RadiusAuthenticationProtocol = 'PAP' | 'CHAP' | 'MS-CHAPv1' | 'MS-CHAPv2';
  declare type DirectoryService$20150416$RadiusSettings = {
    RadiusServers?: DirectoryService$20150416$Servers;
    RadiusPort?: number;
    RadiusTimeout?: number;
    RadiusRetries?: number;
    SharedSecret?: string;
    AuthenticationProtocol?: 'PAP' | 'CHAP' | 'MS-CHAPv1' | 'MS-CHAPv2';
    DisplayLabel?: string;
    UseSameUsername?: boolean;
  };
  declare type DirectoryService$20150416$RadiusStatus = 'Creating' | 'Completed' | 'Failed';
  declare type DirectoryService$20150416$RegisterEventTopicRequest = {
    DirectoryId: string;
    TopicName: string;
  };
  declare type DirectoryService$20150416$RegisterEventTopicResult = {};
  declare type DirectoryService$20150416$RemoteDomainNames = string[];
  declare type DirectoryService$20150416$RemoveIpRoutesRequest = {
    DirectoryId: string;
    CidrIps: DirectoryService$20150416$CidrIps;
  };
  declare type DirectoryService$20150416$RemoveIpRoutesResult = {};
  declare type DirectoryService$20150416$RemoveTagsFromResourceRequest = {
    ResourceId: string;
    TagKeys: DirectoryService$20150416$TagKeys;
  };
  declare type DirectoryService$20150416$RemoveTagsFromResourceResult = {};
  declare type DirectoryService$20150416$ReplicationScope = 'Domain';
  declare type DirectoryService$20150416$RestoreFromSnapshotRequest = {
    SnapshotId: string;
  };
  declare type DirectoryService$20150416$RestoreFromSnapshotResult = {};
  declare type DirectoryService$20150416$Servers = string[];
  declare type DirectoryService$20150416$ServiceException = {
    Message?: string;
    RequestId?: string;
  };
  declare type DirectoryService$20150416$Snapshot = {
    DirectoryId?: string;
    SnapshotId?: string;
    Type?: 'Auto' | 'Manual';
    Name?: string;
    Status?: 'Creating' | 'Completed' | 'Failed';
    StartTime?: Date;
  };
  declare type DirectoryService$20150416$SnapshotIds = string[];
  declare type DirectoryService$20150416$SnapshotLimitExceededException = {
    Message?: string;
    RequestId?: string;
  };
  declare type DirectoryService$20150416$SnapshotLimits = {
    ManualSnapshotsLimit?: number;
    ManualSnapshotsCurrentCount?: number;
    ManualSnapshotsLimitReached?: boolean;
  };
  declare type DirectoryService$20150416$SnapshotStatus = 'Creating' | 'Completed' | 'Failed';
  declare type DirectoryService$20150416$SnapshotType = 'Auto' | 'Manual';
  declare type DirectoryService$20150416$Snapshots = DirectoryService$20150416$Snapshot[];
  declare type DirectoryService$20150416$StartTime = Date;
  declare type DirectoryService$20150416$StateLastUpdatedDateTime = Date;
  declare type DirectoryService$20150416$SubnetIds = string[];
  declare type DirectoryService$20150416$Tag = {
    Key: string;
    Value: string;
  };
  declare type DirectoryService$20150416$TagKeys = string[];
  declare type DirectoryService$20150416$TagLimitExceededException = {
    Message?: string;
    RequestId?: string;
  };
  declare type DirectoryService$20150416$Tags = DirectoryService$20150416$Tag[];
  declare type DirectoryService$20150416$TopicNames = string[];
  declare type DirectoryService$20150416$TopicStatus = 'Registered' | 'Topic not found' | 'Failed' | 'Deleted';
  declare type DirectoryService$20150416$Trust = {
    DirectoryId?: string;
    TrustId?: string;
    RemoteDomainName?: string;
    TrustType?: 'Forest';
    TrustDirection?: 'One-Way: Outgoing' | 'One-Way: Incoming' | 'Two-Way';
    TrustState?: 'Creating' | 'Created' | 'Verifying' | 'VerifyFailed' | 'Verified' | 'Deleting' | 'Deleted' | 'Failed';
    CreatedDateTime?: Date;
    LastUpdatedDateTime?: Date;
    StateLastUpdatedDateTime?: Date;
    TrustStateReason?: string;
  };
  declare type DirectoryService$20150416$TrustDirection = 'One-Way: Outgoing' | 'One-Way: Incoming' | 'Two-Way';
  declare type DirectoryService$20150416$TrustIds = string[];
  declare type DirectoryService$20150416$TrustState = 'Creating' | 'Created' | 'Verifying' | 'VerifyFailed' | 'Verified' | 'Deleting' | 'Deleted' | 'Failed';
  declare type DirectoryService$20150416$TrustType = 'Forest';
  declare type DirectoryService$20150416$Trusts = DirectoryService$20150416$Trust[];
  declare type DirectoryService$20150416$UnsupportedOperationException = {
    Message?: string;
    RequestId?: string;
  };
  declare type DirectoryService$20150416$UpdateConditionalForwarderRequest = {
    DirectoryId: string;
    RemoteDomainName: string;
    DnsIpAddrs: DirectoryService$20150416$DnsIpAddrs;
  };
  declare type DirectoryService$20150416$UpdateConditionalForwarderResult = {};
  declare type DirectoryService$20150416$UpdateRadiusRequest = {
    DirectoryId: string;
    RadiusSettings: DirectoryService$20150416$RadiusSettings;
  };
  declare type DirectoryService$20150416$UpdateRadiusResult = {};
  declare type DirectoryService$20150416$VerifyTrustRequest = {
    TrustId: string;
  };
  declare type DirectoryService$20150416$VerifyTrustResult = {
    TrustId?: string;
  };
  declare type Discovery$20151101$AgentConfigurationStatus = {
    agentId?: string;
    operationSucceeded?: boolean;
    description?: string;
  };
  declare type Discovery$20151101$AgentConfigurationStatusList = Discovery$20151101$AgentConfigurationStatus[];
  declare type Discovery$20151101$AgentIds = string[];
  declare type Discovery$20151101$AgentInfo = {
    agentId?: string;
    hostName?: string;
    agentNetworkInfoList?: Discovery$20151101$AgentNetworkInfoList;
    connectorId?: string;
    version?: string;
    health?: 'HEALTHY' | 'UNHEALTHY' | 'RUNNING' | 'UNKNOWN' | 'BLACKLISTED' | 'SHUTDOWN';
  };
  declare type Discovery$20151101$AgentNetworkInfo = {
    ipAddress?: string;
    macAddress?: string;
  };
  declare type Discovery$20151101$AgentNetworkInfoList = Discovery$20151101$AgentNetworkInfo[];
  declare type Discovery$20151101$AgentStatus = 'HEALTHY' | 'UNHEALTHY' | 'RUNNING' | 'UNKNOWN' | 'BLACKLISTED' | 'SHUTDOWN';
  declare type Discovery$20151101$AgentsInfo = Discovery$20151101$AgentInfo[];
  declare type Discovery$20151101$AuthorizationErrorException = {
    message?: string;
  };
  declare type Discovery$20151101$Configuration = {
    [key: string]: string;
  };
  declare type Discovery$20151101$ConfigurationIdList = string[];
  declare type Discovery$20151101$ConfigurationItemType = 'SERVER' | 'PROCESS' | 'CONNECTION';
  declare type Discovery$20151101$ConfigurationTag = {
    configurationType?: 'SERVER' | 'PROCESS' | 'CONNECTION';
    configurationId?: string;
    key?: string;
    value?: string;
    timeOfCreation?: Date;
  };
  declare type Discovery$20151101$ConfigurationTagSet = Discovery$20151101$ConfigurationTag[];
  declare type Discovery$20151101$Configurations = ({
    [key: string]: string;
  })[];
  declare type Discovery$20151101$CreateTagsRequest = {
    configurationIds: Discovery$20151101$ConfigurationIdList;
    tags: Discovery$20151101$TagSet;
  };
  declare type Discovery$20151101$CreateTagsResponse = {};
  declare type Discovery$20151101$DeleteTagsRequest = {
    configurationIds: Discovery$20151101$ConfigurationIdList;
    tags?: Discovery$20151101$TagSet;
  };
  declare type Discovery$20151101$DeleteTagsResponse = {};
  declare type Discovery$20151101$DescribeAgentsRequest = {
    agentIds?: Discovery$20151101$AgentIds;
    maxResults?: number;
    nextToken?: string;
  };
  declare type Discovery$20151101$DescribeAgentsResponse = {
    agentsInfo?: Discovery$20151101$AgentsInfo;
    nextToken?: string;
  };
  declare type Discovery$20151101$DescribeConfigurationsAttribute = {
    [key: string]: string;
  };
  declare type Discovery$20151101$DescribeConfigurationsAttributes = ({
    [key: string]: string;
  })[];
  declare type Discovery$20151101$DescribeConfigurationsRequest = {
    configurationIds: Discovery$20151101$ConfigurationIdList;
  };
  declare type Discovery$20151101$DescribeConfigurationsResponse = {
    configurations?: Discovery$20151101$DescribeConfigurationsAttributes;
  };
  declare type Discovery$20151101$DescribeExportConfigurationsRequest = {
    exportIds?: Discovery$20151101$ExportIds;
    maxResults?: number;
    nextToken?: string;
  };
  declare type Discovery$20151101$DescribeExportConfigurationsResponse = {
    exportsInfo?: Discovery$20151101$ExportsInfo;
    nextToken?: string;
  };
  declare type Discovery$20151101$DescribeTagsRequest = {
    filters?: Discovery$20151101$TagFilters;
    maxResults?: number;
    nextToken?: string;
  };
  declare type Discovery$20151101$DescribeTagsResponse = {
    tags?: Discovery$20151101$ConfigurationTagSet;
    nextToken?: string;
  };
  declare type Discovery$20151101$ExportConfigurationsResponse = {
    exportId?: string;
  };
  declare type Discovery$20151101$ExportIds = string[];
  declare type Discovery$20151101$ExportInfo = {
    exportId: string;
    exportStatus: 'FAILED' | 'SUCCEEDED' | 'IN_PROGRESS';
    statusMessage: string;
    configurationsDownloadUrl?: string;
    exportRequestTime: Date;
  };
  declare type Discovery$20151101$ExportRequestTime = Date;
  declare type Discovery$20151101$ExportStatus = 'FAILED' | 'SUCCEEDED' | 'IN_PROGRESS';
  declare type Discovery$20151101$ExportsInfo = Discovery$20151101$ExportInfo[];
  declare type Discovery$20151101$Filter = {
    name: string;
    values: Discovery$20151101$FilterValues;
    condition: string;
  };
  declare type Discovery$20151101$FilterValues = string[];
  declare type Discovery$20151101$Filters = Discovery$20151101$Filter[];
  declare type Discovery$20151101$InvalidParameterException = {
    message?: string;
  };
  declare type Discovery$20151101$InvalidParameterValueException = {
    message?: string;
  };
  declare type Discovery$20151101$ListConfigurationsRequest = {
    configurationType: 'SERVER' | 'PROCESS' | 'CONNECTION';
    filters?: Discovery$20151101$Filters;
    maxResults?: number;
    nextToken?: string;
  };
  declare type Discovery$20151101$ListConfigurationsResponse = {
    configurations?: Discovery$20151101$Configurations;
    nextToken?: string;
  };
  declare type Discovery$20151101$OperationNotPermittedException = {
    message?: string;
  };
  declare type Discovery$20151101$ResourceNotFoundException = {
    message?: string;
  };
  declare type Discovery$20151101$ServerInternalErrorException = {
    message?: string;
  };
  declare type Discovery$20151101$StartDataCollectionByAgentIdsRequest = {
    agentIds: Discovery$20151101$AgentIds;
  };
  declare type Discovery$20151101$StartDataCollectionByAgentIdsResponse = {
    agentsConfigurationStatus?: Discovery$20151101$AgentConfigurationStatusList;
  };
  declare type Discovery$20151101$StopDataCollectionByAgentIdsRequest = {
    agentIds: Discovery$20151101$AgentIds;
  };
  declare type Discovery$20151101$StopDataCollectionByAgentIdsResponse = {
    agentsConfigurationStatus?: Discovery$20151101$AgentConfigurationStatusList;
  };
  declare type Discovery$20151101$Tag = {
    key: string;
    value: string;
  };
  declare type Discovery$20151101$TagFilter = {
    name: string;
    values: Discovery$20151101$FilterValues;
  };
  declare type Discovery$20151101$TagFilters = Discovery$20151101$TagFilter[];
  declare type Discovery$20151101$TagSet = Discovery$20151101$Tag[];
  declare type Discovery$20151101$TimeStamp = Date;
  declare type DMS$20160101$AccessDeniedFault = {
    message?: string;
  };
  declare type DMS$20160101$AccountQuota = {
    AccountQuotaName?: string;
    Used?: number;
    Max?: number;
  };
  declare type DMS$20160101$AccountQuotaList = DMS$20160101$AccountQuota[];
  declare type DMS$20160101$AddTagsToResourceMessage = {
    ResourceArn: string;
    Tags: DMS$20160101$TagList;
  };
  declare type DMS$20160101$AddTagsToResourceResponse = {};
  declare type DMS$20160101$AvailabilityZone = {
    Name?: string;
  };
  declare type DMS$20160101$Certificate = {
    CertificateIdentifier?: string;
    CertificateCreationDate?: Date;
    CertificatePem?: string;
    CertificateArn?: string;
    CertificateOwner?: string;
    ValidFromDate?: Date;
    ValidToDate?: Date;
    SigningAlgorithm?: string;
    KeyLength?: number;
  };
  declare type DMS$20160101$CertificateList = DMS$20160101$Certificate[];
  declare type DMS$20160101$Connection = {
    ReplicationInstanceArn?: string;
    EndpointArn?: string;
    Status?: string;
    LastFailureMessage?: string;
    EndpointIdentifier?: string;
    ReplicationInstanceIdentifier?: string;
  };
  declare type DMS$20160101$ConnectionList = DMS$20160101$Connection[];
  declare type DMS$20160101$CreateEndpointMessage = {
    EndpointIdentifier: string;
    EndpointType: 'source' | 'target';
    EngineName: string;
    Username: string;
    Password: string;
    ServerName: string;
    Port: number;
    DatabaseName?: string;
    ExtraConnectionAttributes?: string;
    KmsKeyId?: string;
    Tags?: DMS$20160101$TagList;
    CertificateArn?: string;
    SslMode?: 'none' | 'require' | 'verify-ca' | 'verify-full';
  };
  declare type DMS$20160101$CreateEndpointResponse = {
    Endpoint?: DMS$20160101$Endpoint;
  };
  declare type DMS$20160101$CreateReplicationInstanceMessage = {
    ReplicationInstanceIdentifier: string;
    AllocatedStorage?: number;
    ReplicationInstanceClass: string;
    VpcSecurityGroupIds?: DMS$20160101$VpcSecurityGroupIdList;
    AvailabilityZone?: string;
    ReplicationSubnetGroupIdentifier?: string;
    PreferredMaintenanceWindow?: string;
    MultiAZ?: boolean;
    EngineVersion?: string;
    AutoMinorVersionUpgrade?: boolean;
    Tags?: DMS$20160101$TagList;
    KmsKeyId?: string;
    PubliclyAccessible?: boolean;
  };
  declare type DMS$20160101$CreateReplicationInstanceResponse = {
    ReplicationInstance?: DMS$20160101$ReplicationInstance;
  };
  declare type DMS$20160101$CreateReplicationSubnetGroupMessage = {
    ReplicationSubnetGroupIdentifier: string;
    ReplicationSubnetGroupDescription: string;
    SubnetIds: DMS$20160101$SubnetIdentifierList;
    Tags?: DMS$20160101$TagList;
  };
  declare type DMS$20160101$CreateReplicationSubnetGroupResponse = {
    ReplicationSubnetGroup?: DMS$20160101$ReplicationSubnetGroup;
  };
  declare type DMS$20160101$CreateReplicationTaskMessage = {
    ReplicationTaskIdentifier: string;
    SourceEndpointArn: string;
    TargetEndpointArn: string;
    ReplicationInstanceArn: string;
    MigrationType: 'full-load' | 'cdc' | 'full-load-and-cdc';
    TableMappings: string;
    ReplicationTaskSettings?: string;
    CdcStartTime?: Date;
    Tags?: DMS$20160101$TagList;
  };
  declare type DMS$20160101$CreateReplicationTaskResponse = {
    ReplicationTask?: DMS$20160101$ReplicationTask;
  };
  declare type DMS$20160101$DeleteCertificateMessage = {
    CertificateArn: string;
  };
  declare type DMS$20160101$DeleteCertificateResponse = {
    Certificate?: DMS$20160101$Certificate;
  };
  declare type DMS$20160101$DeleteEndpointMessage = {
    EndpointArn: string;
  };
  declare type DMS$20160101$DeleteEndpointResponse = {
    Endpoint?: DMS$20160101$Endpoint;
  };
  declare type DMS$20160101$DeleteReplicationInstanceMessage = {
    ReplicationInstanceArn: string;
  };
  declare type DMS$20160101$DeleteReplicationInstanceResponse = {
    ReplicationInstance?: DMS$20160101$ReplicationInstance;
  };
  declare type DMS$20160101$DeleteReplicationSubnetGroupMessage = {
    ReplicationSubnetGroupIdentifier: string;
  };
  declare type DMS$20160101$DeleteReplicationSubnetGroupResponse = {};
  declare type DMS$20160101$DeleteReplicationTaskMessage = {
    ReplicationTaskArn: string;
  };
  declare type DMS$20160101$DeleteReplicationTaskResponse = {
    ReplicationTask?: DMS$20160101$ReplicationTask;
  };
  declare type DMS$20160101$DescribeAccountAttributesMessage = {};
  declare type DMS$20160101$DescribeAccountAttributesResponse = {
    AccountQuotas?: DMS$20160101$AccountQuotaList;
  };
  declare type DMS$20160101$DescribeCertificatesMessage = {
    Filters?: DMS$20160101$FilterList;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type DMS$20160101$DescribeCertificatesResponse = {
    Marker?: string;
    Certificates?: DMS$20160101$CertificateList;
  };
  declare type DMS$20160101$DescribeConnectionsMessage = {
    Filters?: DMS$20160101$FilterList;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type DMS$20160101$DescribeConnectionsResponse = {
    Marker?: string;
    Connections?: DMS$20160101$ConnectionList;
  };
  declare type DMS$20160101$DescribeEndpointTypesMessage = {
    Filters?: DMS$20160101$FilterList;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type DMS$20160101$DescribeEndpointTypesResponse = {
    Marker?: string;
    SupportedEndpointTypes?: DMS$20160101$SupportedEndpointTypeList;
  };
  declare type DMS$20160101$DescribeEndpointsMessage = {
    Filters?: DMS$20160101$FilterList;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type DMS$20160101$DescribeEndpointsResponse = {
    Marker?: string;
    Endpoints?: DMS$20160101$EndpointList;
  };
  declare type DMS$20160101$DescribeOrderableReplicationInstancesMessage = {
    MaxRecords?: number;
    Marker?: string;
  };
  declare type DMS$20160101$DescribeOrderableReplicationInstancesResponse = {
    OrderableReplicationInstances?: DMS$20160101$OrderableReplicationInstanceList;
    Marker?: string;
  };
  declare type DMS$20160101$DescribeRefreshSchemasStatusMessage = {
    EndpointArn: string;
  };
  declare type DMS$20160101$DescribeRefreshSchemasStatusResponse = {
    RefreshSchemasStatus?: DMS$20160101$RefreshSchemasStatus;
  };
  declare type DMS$20160101$DescribeReplicationInstancesMessage = {
    Filters?: DMS$20160101$FilterList;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type DMS$20160101$DescribeReplicationInstancesResponse = {
    Marker?: string;
    ReplicationInstances?: DMS$20160101$ReplicationInstanceList;
  };
  declare type DMS$20160101$DescribeReplicationSubnetGroupsMessage = {
    Filters?: DMS$20160101$FilterList;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type DMS$20160101$DescribeReplicationSubnetGroupsResponse = {
    Marker?: string;
    ReplicationSubnetGroups?: DMS$20160101$ReplicationSubnetGroups;
  };
  declare type DMS$20160101$DescribeReplicationTasksMessage = {
    Filters?: DMS$20160101$FilterList;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type DMS$20160101$DescribeReplicationTasksResponse = {
    Marker?: string;
    ReplicationTasks?: DMS$20160101$ReplicationTaskList;
  };
  declare type DMS$20160101$DescribeSchemasMessage = {
    EndpointArn: string;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type DMS$20160101$DescribeSchemasResponse = {
    Marker?: string;
    Schemas?: DMS$20160101$SchemaList;
  };
  declare type DMS$20160101$DescribeTableStatisticsMessage = {
    ReplicationTaskArn: string;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type DMS$20160101$DescribeTableStatisticsResponse = {
    ReplicationTaskArn?: string;
    TableStatistics?: DMS$20160101$TableStatisticsList;
    Marker?: string;
  };
  declare type DMS$20160101$DmsSslModeValue = 'none' | 'require' | 'verify-ca' | 'verify-full';
  declare type DMS$20160101$Endpoint = {
    EndpointIdentifier?: string;
    EndpointType?: 'source' | 'target';
    EngineName?: string;
    Username?: string;
    ServerName?: string;
    Port?: number;
    DatabaseName?: string;
    ExtraConnectionAttributes?: string;
    Status?: string;
    KmsKeyId?: string;
    EndpointArn?: string;
    CertificateArn?: string;
    SslMode?: 'none' | 'require' | 'verify-ca' | 'verify-full';
  };
  declare type DMS$20160101$EndpointList = DMS$20160101$Endpoint[];
  declare type DMS$20160101$Filter = {
    Name: string;
    Values: DMS$20160101$FilterValueList;
  };
  declare type DMS$20160101$FilterList = DMS$20160101$Filter[];
  declare type DMS$20160101$FilterValueList = string[];
  declare type DMS$20160101$ImportCertificateMessage = {
    CertificateIdentifier: string;
    CertificatePem?: string;
  };
  declare type DMS$20160101$ImportCertificateResponse = {
    Certificate?: DMS$20160101$Certificate;
  };
  declare type DMS$20160101$InsufficientResourceCapacityFault = {
    message?: string;
  };
  declare type DMS$20160101$InvalidCertificateFault = {
    message?: string;
  };
  declare type DMS$20160101$InvalidResourceStateFault = {
    message?: string;
  };
  declare type DMS$20160101$InvalidSubnet = {
    message?: string;
  };
  declare type DMS$20160101$KMSKeyNotAccessibleFault = {
    message?: string;
  };
  declare type DMS$20160101$KeyList = string[];
  declare type DMS$20160101$ListTagsForResourceMessage = {
    ResourceArn: string;
  };
  declare type DMS$20160101$ListTagsForResourceResponse = {
    TagList?: DMS$20160101$TagList;
  };
  declare type DMS$20160101$MigrationTypeValue = 'full-load' | 'cdc' | 'full-load-and-cdc';
  declare type DMS$20160101$ModifyEndpointMessage = {
    EndpointArn: string;
    EndpointIdentifier?: string;
    EndpointType?: 'source' | 'target';
    EngineName?: string;
    Username?: string;
    Password?: string;
    ServerName?: string;
    Port?: number;
    DatabaseName?: string;
    ExtraConnectionAttributes?: string;
    CertificateArn?: string;
    SslMode?: 'none' | 'require' | 'verify-ca' | 'verify-full';
  };
  declare type DMS$20160101$ModifyEndpointResponse = {
    Endpoint?: DMS$20160101$Endpoint;
  };
  declare type DMS$20160101$ModifyReplicationInstanceMessage = {
    ReplicationInstanceArn: string;
    AllocatedStorage?: number;
    ApplyImmediately?: boolean;
    ReplicationInstanceClass?: string;
    VpcSecurityGroupIds?: DMS$20160101$VpcSecurityGroupIdList;
    PreferredMaintenanceWindow?: string;
    MultiAZ?: boolean;
    EngineVersion?: string;
    AllowMajorVersionUpgrade?: boolean;
    AutoMinorVersionUpgrade?: boolean;
    ReplicationInstanceIdentifier?: string;
  };
  declare type DMS$20160101$ModifyReplicationInstanceResponse = {
    ReplicationInstance?: DMS$20160101$ReplicationInstance;
  };
  declare type DMS$20160101$ModifyReplicationSubnetGroupMessage = {
    ReplicationSubnetGroupIdentifier: string;
    ReplicationSubnetGroupDescription?: string;
    SubnetIds: DMS$20160101$SubnetIdentifierList;
  };
  declare type DMS$20160101$ModifyReplicationSubnetGroupResponse = {
    ReplicationSubnetGroup?: DMS$20160101$ReplicationSubnetGroup;
  };
  declare type DMS$20160101$OrderableReplicationInstance = {
    EngineVersion?: string;
    ReplicationInstanceClass?: string;
    StorageType?: string;
    MinAllocatedStorage?: number;
    MaxAllocatedStorage?: number;
    DefaultAllocatedStorage?: number;
    IncludedAllocatedStorage?: number;
  };
  declare type DMS$20160101$OrderableReplicationInstanceList = DMS$20160101$OrderableReplicationInstance[];
  declare type DMS$20160101$RefreshSchemasMessage = {
    EndpointArn: string;
    ReplicationInstanceArn: string;
  };
  declare type DMS$20160101$RefreshSchemasResponse = {
    RefreshSchemasStatus?: DMS$20160101$RefreshSchemasStatus;
  };
  declare type DMS$20160101$RefreshSchemasStatus = {
    EndpointArn?: string;
    ReplicationInstanceArn?: string;
    Status?: 'successful' | 'failed' | 'refreshing';
    LastRefreshDate?: Date;
    LastFailureMessage?: string;
  };
  declare type DMS$20160101$RefreshSchemasStatusTypeValue = 'successful' | 'failed' | 'refreshing';
  declare type DMS$20160101$RemoveTagsFromResourceMessage = {
    ResourceArn: string;
    TagKeys: DMS$20160101$KeyList;
  };
  declare type DMS$20160101$RemoveTagsFromResourceResponse = {};
  declare type DMS$20160101$ReplicationEndpointTypeValue = 'source' | 'target';
  declare type DMS$20160101$ReplicationInstance = {
    ReplicationInstanceIdentifier?: string;
    ReplicationInstanceClass?: string;
    ReplicationInstanceStatus?: string;
    AllocatedStorage?: number;
    InstanceCreateTime?: Date;
    VpcSecurityGroups?: DMS$20160101$VpcSecurityGroupMembershipList;
    AvailabilityZone?: string;
    ReplicationSubnetGroup?: DMS$20160101$ReplicationSubnetGroup;
    PreferredMaintenanceWindow?: string;
    PendingModifiedValues?: DMS$20160101$ReplicationPendingModifiedValues;
    MultiAZ?: boolean;
    EngineVersion?: string;
    AutoMinorVersionUpgrade?: boolean;
    KmsKeyId?: string;
    ReplicationInstanceArn?: string;
    ReplicationInstancePublicIpAddress?: string;
    ReplicationInstancePrivateIpAddress?: string;
    ReplicationInstancePublicIpAddresses?: DMS$20160101$ReplicationInstancePublicIpAddressList;
    ReplicationInstancePrivateIpAddresses?: DMS$20160101$ReplicationInstancePrivateIpAddressList;
    PubliclyAccessible?: boolean;
  };
  declare type DMS$20160101$ReplicationInstanceList = DMS$20160101$ReplicationInstance[];
  declare type DMS$20160101$ReplicationInstancePrivateIpAddressList = string[];
  declare type DMS$20160101$ReplicationInstancePublicIpAddressList = string[];
  declare type DMS$20160101$ReplicationPendingModifiedValues = {
    ReplicationInstanceClass?: string;
    AllocatedStorage?: number;
    MultiAZ?: boolean;
    EngineVersion?: string;
  };
  declare type DMS$20160101$ReplicationSubnetGroup = {
    ReplicationSubnetGroupIdentifier?: string;
    ReplicationSubnetGroupDescription?: string;
    VpcId?: string;
    SubnetGroupStatus?: string;
    Subnets?: DMS$20160101$SubnetList;
  };
  declare type DMS$20160101$ReplicationSubnetGroupDoesNotCoverEnoughAZs = {
    message?: string;
  };
  declare type DMS$20160101$ReplicationSubnetGroups = DMS$20160101$ReplicationSubnetGroup[];
  declare type DMS$20160101$ReplicationTask = {
    ReplicationTaskIdentifier?: string;
    SourceEndpointArn?: string;
    TargetEndpointArn?: string;
    ReplicationInstanceArn?: string;
    MigrationType?: 'full-load' | 'cdc' | 'full-load-and-cdc';
    TableMappings?: string;
    ReplicationTaskSettings?: string;
    Status?: string;
    LastFailureMessage?: string;
    ReplicationTaskCreationDate?: Date;
    ReplicationTaskStartDate?: Date;
    ReplicationTaskArn?: string;
    ReplicationTaskStats?: DMS$20160101$ReplicationTaskStats;
  };
  declare type DMS$20160101$ReplicationTaskList = DMS$20160101$ReplicationTask[];
  declare type DMS$20160101$ReplicationTaskStats = {
    FullLoadProgressPercent?: number;
    ElapsedTimeMillis?: number;
    TablesLoaded?: number;
    TablesLoading?: number;
    TablesQueued?: number;
    TablesErrored?: number;
  };
  declare type DMS$20160101$ResourceAlreadyExistsFault = {
    message?: string;
  };
  declare type DMS$20160101$ResourceNotFoundFault = {
    message?: string;
  };
  declare type DMS$20160101$ResourceQuotaExceededFault = {
    message?: string;
  };
  declare type DMS$20160101$SchemaList = string[];
  declare type DMS$20160101$StartReplicationTaskMessage = {
    ReplicationTaskArn: string;
    StartReplicationTaskType: 'start-replication' | 'resume-processing' | 'reload-target';
    CdcStartTime?: Date;
  };
  declare type DMS$20160101$StartReplicationTaskResponse = {
    ReplicationTask?: DMS$20160101$ReplicationTask;
  };
  declare type DMS$20160101$StartReplicationTaskTypeValue = 'start-replication' | 'resume-processing' | 'reload-target';
  declare type DMS$20160101$StopReplicationTaskMessage = {
    ReplicationTaskArn: string;
  };
  declare type DMS$20160101$StopReplicationTaskResponse = {
    ReplicationTask?: DMS$20160101$ReplicationTask;
  };
  declare type DMS$20160101$StorageQuotaExceededFault = {
    message?: string;
  };
  declare type DMS$20160101$Subnet = {
    SubnetIdentifier?: string;
    SubnetAvailabilityZone?: DMS$20160101$AvailabilityZone;
    SubnetStatus?: string;
  };
  declare type DMS$20160101$SubnetAlreadyInUse = {
    message?: string;
  };
  declare type DMS$20160101$SubnetIdentifierList = string[];
  declare type DMS$20160101$SubnetList = DMS$20160101$Subnet[];
  declare type DMS$20160101$SupportedEndpointType = {
    EngineName?: string;
    SupportsCDC?: boolean;
    EndpointType?: 'source' | 'target';
  };
  declare type DMS$20160101$SupportedEndpointTypeList = DMS$20160101$SupportedEndpointType[];
  declare type DMS$20160101$TStamp = Date;
  declare type DMS$20160101$TableStatistics = {
    SchemaName?: string;
    TableName?: string;
    Inserts?: number;
    Deletes?: number;
    Updates?: number;
    Ddls?: number;
    FullLoadRows?: number;
    LastUpdateTime?: Date;
    TableState?: string;
  };
  declare type DMS$20160101$TableStatisticsList = DMS$20160101$TableStatistics[];
  declare type DMS$20160101$Tag = {
    Key?: string;
    Value?: string;
  };
  declare type DMS$20160101$TagList = DMS$20160101$Tag[];
  declare type DMS$20160101$TestConnectionMessage = {
    ReplicationInstanceArn: string;
    EndpointArn: string;
  };
  declare type DMS$20160101$TestConnectionResponse = {
    Connection?: DMS$20160101$Connection;
  };
  declare type DMS$20160101$UpgradeDependencyFailureFault = {
    message?: string;
  };
  declare type DMS$20160101$VpcSecurityGroupIdList = string[];
  declare type DMS$20160101$VpcSecurityGroupMembership = {
    VpcSecurityGroupId?: string;
    Status?: string;
  };
  declare type DMS$20160101$VpcSecurityGroupMembershipList = DMS$20160101$VpcSecurityGroupMembership[];
  declare type DynamoDB$20111205$AttributeAction = 'ADD' | 'PUT' | 'DELETE';
  declare type DynamoDB$20111205$AttributeMap = {
    [key: string]: DynamoDB$20111205$AttributeValue;
  };
  declare type DynamoDB$20111205$AttributeNameList = string[];
  declare type DynamoDB$20111205$AttributeUpdates = {
    [key: string]: DynamoDB$20111205$AttributeValueUpdate;
  };
  declare type DynamoDB$20111205$AttributeValue = {
    S?: string;
    N?: string;
    B?: Buffer | $TypedArray | Blob | string;
    SS?: DynamoDB$20111205$StringSetAttributeValue;
    NS?: DynamoDB$20111205$NumberSetAttributeValue;
    BS?: DynamoDB$20111205$BinarySetAttributeValue;
  };
  declare type DynamoDB$20111205$AttributeValueList = DynamoDB$20111205$AttributeValue[];
  declare type DynamoDB$20111205$AttributeValueUpdate = {
    Value?: DynamoDB$20111205$AttributeValue;
    Action?: 'ADD' | 'PUT' | 'DELETE';
  };
  declare type DynamoDB$20111205$BatchGetItemInput = {
    RequestItems: {
      [key: string]: DynamoDB$20111205$KeysAndAttributes;
    };
  };
  declare type DynamoDB$20111205$BatchGetItemOutput = {
    Responses?: {
      [key: string]: DynamoDB$20111205$BatchResponse;
    };
    UnprocessedKeys?: {
      [key: string]: DynamoDB$20111205$KeysAndAttributes;
    };
  };
  declare type DynamoDB$20111205$BatchGetRequestMap = {
    [key: string]: DynamoDB$20111205$KeysAndAttributes;
  };
  declare type DynamoDB$20111205$BatchGetResponseMap = {
    [key: string]: DynamoDB$20111205$BatchResponse;
  };
  declare type DynamoDB$20111205$BatchResponse = {
    Items?: DynamoDB$20111205$ItemList;
    ConsumedCapacityUnits?: number;
  };
  declare type DynamoDB$20111205$BatchWriteItemInput = {
    RequestItems: {
      [key: string]: DynamoDB$20111205$WriteRequests;
    };
  };
  declare type DynamoDB$20111205$BatchWriteItemOutput = {
    Responses?: {
      [key: string]: DynamoDB$20111205$BatchWriteResponse;
    };
    UnprocessedItems?: {
      [key: string]: DynamoDB$20111205$WriteRequests;
    };
  };
  declare type DynamoDB$20111205$BatchWriteItemRequestMap = {
    [key: string]: DynamoDB$20111205$WriteRequests;
  };
  declare type DynamoDB$20111205$BatchWriteResponse = {
    ConsumedCapacityUnits?: number;
  };
  declare type DynamoDB$20111205$BatchWriteResponseMap = {
    [key: string]: DynamoDB$20111205$BatchWriteResponse;
  };
  declare type DynamoDB$20111205$BinaryAttributeValue = Buffer | $TypedArray | Blob | string;
  declare type DynamoDB$20111205$BinarySetAttributeValue = (Buffer | $TypedArray | Blob | string)[];
  declare type DynamoDB$20111205$ComparisonOperator = 'EQ' | 'NE' | 'IN' | 'LE' | 'LT' | 'GE' | 'GT' | 'BETWEEN' | 'NOT_NULL' | 'NULL' | 'CONTAINS' | 'NOT_CONTAINS' | 'BEGINS_WITH';
  declare type DynamoDB$20111205$Condition = {
    AttributeValueList?: DynamoDB$20111205$AttributeValueList;
    ComparisonOperator: 'EQ' | 'NE' | 'IN' | 'LE' | 'LT' | 'GE' | 'GT' | 'BETWEEN' | 'NOT_NULL' | 'NULL' | 'CONTAINS' | 'NOT_CONTAINS' | 'BEGINS_WITH';
  };
  declare type DynamoDB$20111205$ConditionalCheckFailedException = {
    message?: string;
  };
  declare type DynamoDB$20111205$CreateTableInput = {
    TableName: string;
    KeySchema: DynamoDB$20111205$KeySchema;
    ProvisionedThroughput: DynamoDB$20111205$ProvisionedThroughput;
  };
  declare type DynamoDB$20111205$CreateTableOutput = {
    TableDescription?: DynamoDB$20111205$TableDescription;
  };
  declare type DynamoDB$20111205$Date = Date;
  declare type DynamoDB$20111205$DeleteItemInput = {
    TableName: string;
    Key: DynamoDB$20111205$Key;
    Expected?: {
      [key: string]: DynamoDB$20111205$ExpectedAttributeValue;
    };
    ReturnValues?: 'NONE' | 'ALL_OLD' | 'UPDATED_OLD' | 'ALL_NEW' | 'UPDATED_NEW';
  };
  declare type DynamoDB$20111205$DeleteItemOutput = {
    Attributes?: {
      [key: string]: DynamoDB$20111205$AttributeValue;
    };
    ConsumedCapacityUnits?: number;
  };
  declare type DynamoDB$20111205$DeleteRequest = {
    Key: DynamoDB$20111205$Key;
  };
  declare type DynamoDB$20111205$DeleteTableInput = {
    TableName: string;
  };
  declare type DynamoDB$20111205$DeleteTableOutput = {
    TableDescription?: DynamoDB$20111205$TableDescription;
  };
  declare type DynamoDB$20111205$DescribeTableInput = {
    TableName: string;
  };
  declare type DynamoDB$20111205$DescribeTableOutput = {
    Table?: DynamoDB$20111205$TableDescription;
  };
  declare type DynamoDB$20111205$ExpectedAttributeMap = {
    [key: string]: DynamoDB$20111205$ExpectedAttributeValue;
  };
  declare type DynamoDB$20111205$ExpectedAttributeValue = {
    Value?: DynamoDB$20111205$AttributeValue;
    Exists?: boolean;
  };
  declare type DynamoDB$20111205$FilterConditionMap = {
    [key: string]: DynamoDB$20111205$Condition;
  };
  declare type DynamoDB$20111205$GetItemInput = {
    TableName: string;
    Key: DynamoDB$20111205$Key;
    AttributesToGet?: DynamoDB$20111205$AttributeNameList;
    ConsistentRead?: boolean;
  };
  declare type DynamoDB$20111205$GetItemOutput = {
    Item?: {
      [key: string]: DynamoDB$20111205$AttributeValue;
    };
    ConsumedCapacityUnits?: number;
  };
  declare type DynamoDB$20111205$InternalServerError = {
    message?: string;
  };
  declare type DynamoDB$20111205$ItemList = ({
    [key: string]: DynamoDB$20111205$AttributeValue;
  })[];
  declare type DynamoDB$20111205$Key = {
    HashKeyElement: DynamoDB$20111205$AttributeValue;
    RangeKeyElement?: DynamoDB$20111205$AttributeValue;
  };
  declare type DynamoDB$20111205$KeyList = DynamoDB$20111205$Key[];
  declare type DynamoDB$20111205$KeySchema = {
    HashKeyElement: DynamoDB$20111205$KeySchemaElement;
    RangeKeyElement?: DynamoDB$20111205$KeySchemaElement;
  };
  declare type DynamoDB$20111205$KeySchemaElement = {
    AttributeName: string;
    AttributeType: 'S' | 'N' | 'B';
  };
  declare type DynamoDB$20111205$KeysAndAttributes = {
    Keys: DynamoDB$20111205$KeyList;
    AttributesToGet?: DynamoDB$20111205$AttributeNameList;
    ConsistentRead?: boolean;
  };
  declare type DynamoDB$20111205$LimitExceededException = {
    message?: string;
  };
  declare type DynamoDB$20111205$ListTablesInput = {
    ExclusiveStartTableName?: string;
    Limit?: number;
  };
  declare type DynamoDB$20111205$ListTablesOutput = {
    TableNames?: DynamoDB$20111205$TableNameList;
    LastEvaluatedTableName?: string;
  };
  declare type DynamoDB$20111205$NumberSetAttributeValue = string[];
  declare type DynamoDB$20111205$ProvisionedThroughput = {
    ReadCapacityUnits: number;
    WriteCapacityUnits: number;
  };
  declare type DynamoDB$20111205$ProvisionedThroughputDescription = {
    LastIncreaseDateTime?: Date;
    LastDecreaseDateTime?: Date;
    NumberOfDecreasesToday?: number;
    ReadCapacityUnits?: number;
    WriteCapacityUnits?: number;
  };
  declare type DynamoDB$20111205$ProvisionedThroughputExceededException = {
    message?: string;
  };
  declare type DynamoDB$20111205$PutItemInput = {
    TableName: string;
    Item: {
      [key: string]: DynamoDB$20111205$AttributeValue;
    };
    Expected?: {
      [key: string]: DynamoDB$20111205$ExpectedAttributeValue;
    };
    ReturnValues?: 'NONE' | 'ALL_OLD' | 'UPDATED_OLD' | 'ALL_NEW' | 'UPDATED_NEW';
  };
  declare type DynamoDB$20111205$PutItemInputAttributeMap = {
    [key: string]: DynamoDB$20111205$AttributeValue;
  };
  declare type DynamoDB$20111205$PutItemOutput = {
    Attributes?: {
      [key: string]: DynamoDB$20111205$AttributeValue;
    };
    ConsumedCapacityUnits?: number;
  };
  declare type DynamoDB$20111205$PutRequest = {
    Item: {
      [key: string]: DynamoDB$20111205$AttributeValue;
    };
  };
  declare type DynamoDB$20111205$QueryInput = {
    TableName: string;
    AttributesToGet?: DynamoDB$20111205$AttributeNameList;
    Limit?: number;
    ConsistentRead?: boolean;
    Count?: boolean;
    HashKeyValue: DynamoDB$20111205$AttributeValue;
    RangeKeyCondition?: DynamoDB$20111205$Condition;
    ScanIndexForward?: boolean;
    ExclusiveStartKey?: DynamoDB$20111205$Key;
  };
  declare type DynamoDB$20111205$QueryOutput = {
    Items?: DynamoDB$20111205$ItemList;
    Count?: number;
    LastEvaluatedKey?: DynamoDB$20111205$Key;
    ConsumedCapacityUnits?: number;
  };
  declare type DynamoDB$20111205$ResourceInUseException = {
    message?: string;
  };
  declare type DynamoDB$20111205$ResourceNotFoundException = {
    message?: string;
  };
  declare type DynamoDB$20111205$ReturnValue = 'NONE' | 'ALL_OLD' | 'UPDATED_OLD' | 'ALL_NEW' | 'UPDATED_NEW';
  declare type DynamoDB$20111205$ScalarAttributeType = 'S' | 'N' | 'B';
  declare type DynamoDB$20111205$ScanInput = {
    TableName: string;
    AttributesToGet?: DynamoDB$20111205$AttributeNameList;
    Limit?: number;
    Count?: boolean;
    ScanFilter?: {
      [key: string]: DynamoDB$20111205$Condition;
    };
    ExclusiveStartKey?: DynamoDB$20111205$Key;
  };
  declare type DynamoDB$20111205$ScanOutput = {
    Items?: DynamoDB$20111205$ItemList;
    Count?: number;
    ScannedCount?: number;
    LastEvaluatedKey?: DynamoDB$20111205$Key;
    ConsumedCapacityUnits?: number;
  };
  declare type DynamoDB$20111205$StringSetAttributeValue = string[];
  declare type DynamoDB$20111205$TableDescription = {
    TableName?: string;
    KeySchema?: DynamoDB$20111205$KeySchema;
    TableStatus?: 'CREATING' | 'UPDATING' | 'DELETING' | 'ACTIVE';
    CreationDateTime?: Date;
    ProvisionedThroughput?: DynamoDB$20111205$ProvisionedThroughputDescription;
    TableSizeBytes?: number;
    ItemCount?: number;
  };
  declare type DynamoDB$20111205$TableNameList = string[];
  declare type DynamoDB$20111205$TableStatus = 'CREATING' | 'UPDATING' | 'DELETING' | 'ACTIVE';
  declare type DynamoDB$20111205$UpdateItemInput = {
    TableName: string;
    Key: DynamoDB$20111205$Key;
    AttributeUpdates: {
      [key: string]: DynamoDB$20111205$AttributeValueUpdate;
    };
    Expected?: {
      [key: string]: DynamoDB$20111205$ExpectedAttributeValue;
    };
    ReturnValues?: 'NONE' | 'ALL_OLD' | 'UPDATED_OLD' | 'ALL_NEW' | 'UPDATED_NEW';
  };
  declare type DynamoDB$20111205$UpdateItemOutput = {
    Attributes?: {
      [key: string]: DynamoDB$20111205$AttributeValue;
    };
    ConsumedCapacityUnits?: number;
  };
  declare type DynamoDB$20111205$UpdateTableInput = {
    TableName: string;
    ProvisionedThroughput: DynamoDB$20111205$ProvisionedThroughput;
  };
  declare type DynamoDB$20111205$UpdateTableOutput = {
    TableDescription?: DynamoDB$20111205$TableDescription;
  };
  declare type DynamoDB$20111205$WriteRequest = {
    PutRequest?: DynamoDB$20111205$PutRequest;
    DeleteRequest?: DynamoDB$20111205$DeleteRequest;
  };
  declare type DynamoDB$20111205$WriteRequests = DynamoDB$20111205$WriteRequest[];
  declare type DynamoDB$20120810$AttributeAction = 'ADD' | 'PUT' | 'DELETE';
  declare type DynamoDB$20120810$AttributeDefinition = {
    AttributeName: string;
    AttributeType: 'S' | 'N' | 'B';
  };
  declare type DynamoDB$20120810$AttributeDefinitions = DynamoDB$20120810$AttributeDefinition[];
  declare type DynamoDB$20120810$AttributeMap = {
    [key: string]: DynamoDB$20120810$AttributeValue;
  };
  declare type DynamoDB$20120810$AttributeNameList = string[];
  declare type DynamoDB$20120810$AttributeUpdates = {
    [key: string]: DynamoDB$20120810$AttributeValueUpdate;
  };
  declare type DynamoDB$20120810$AttributeValue = {
    S?: string;
    N?: string;
    B?: Buffer | $TypedArray | Blob | string;
    SS?: DynamoDB$20120810$StringSetAttributeValue;
    NS?: DynamoDB$20120810$NumberSetAttributeValue;
    BS?: DynamoDB$20120810$BinarySetAttributeValue;
    M?: {
      [key: string]: DynamoDB$20120810$AttributeValue;
    };
    L?: DynamoDB$20120810$ListAttributeValue;
    NULL?: boolean;
    BOOL?: boolean;
  };
  declare type DynamoDB$20120810$AttributeValueList = DynamoDB$20120810$AttributeValue[];
  declare type DynamoDB$20120810$AttributeValueUpdate = {
    Value?: DynamoDB$20120810$AttributeValue;
    Action?: 'ADD' | 'PUT' | 'DELETE';
  };
  declare type DynamoDB$20120810$BatchGetItemInput = {
    RequestItems: {
      [key: string]: DynamoDB$20120810$KeysAndAttributes;
    };
    ReturnConsumedCapacity?: 'INDEXES' | 'TOTAL' | 'NONE';
  };
  declare type DynamoDB$20120810$BatchGetItemOutput = {
    Responses?: {
      [key: string]: DynamoDB$20120810$ItemList;
    };
    UnprocessedKeys?: {
      [key: string]: DynamoDB$20120810$KeysAndAttributes;
    };
    ConsumedCapacity?: DynamoDB$20120810$ConsumedCapacityMultiple;
  };
  declare type DynamoDB$20120810$BatchGetRequestMap = {
    [key: string]: DynamoDB$20120810$KeysAndAttributes;
  };
  declare type DynamoDB$20120810$BatchGetResponseMap = {
    [key: string]: DynamoDB$20120810$ItemList;
  };
  declare type DynamoDB$20120810$BatchWriteItemInput = {
    RequestItems: {
      [key: string]: DynamoDB$20120810$WriteRequests;
    };
    ReturnConsumedCapacity?: 'INDEXES' | 'TOTAL' | 'NONE';
    ReturnItemCollectionMetrics?: 'SIZE' | 'NONE';
  };
  declare type DynamoDB$20120810$BatchWriteItemOutput = {
    UnprocessedItems?: {
      [key: string]: DynamoDB$20120810$WriteRequests;
    };
    ItemCollectionMetrics?: {
      [key: string]: DynamoDB$20120810$ItemCollectionMetricsMultiple;
    };
    ConsumedCapacity?: DynamoDB$20120810$ConsumedCapacityMultiple;
  };
  declare type DynamoDB$20120810$BatchWriteItemRequestMap = {
    [key: string]: DynamoDB$20120810$WriteRequests;
  };
  declare type DynamoDB$20120810$BinaryAttributeValue = Buffer | $TypedArray | Blob | string;
  declare type DynamoDB$20120810$BinarySetAttributeValue = (Buffer | $TypedArray | Blob | string)[];
  declare type DynamoDB$20120810$Capacity = {
    CapacityUnits?: number;
  };
  declare type DynamoDB$20120810$ComparisonOperator = 'EQ' | 'NE' | 'IN' | 'LE' | 'LT' | 'GE' | 'GT' | 'BETWEEN' | 'NOT_NULL' | 'NULL' | 'CONTAINS' | 'NOT_CONTAINS' | 'BEGINS_WITH';
  declare type DynamoDB$20120810$Condition = {
    AttributeValueList?: DynamoDB$20120810$AttributeValueList;
    ComparisonOperator: 'EQ' | 'NE' | 'IN' | 'LE' | 'LT' | 'GE' | 'GT' | 'BETWEEN' | 'NOT_NULL' | 'NULL' | 'CONTAINS' | 'NOT_CONTAINS' | 'BEGINS_WITH';
  };
  declare type DynamoDB$20120810$ConditionalCheckFailedException = {
    message?: string;
  };
  declare type DynamoDB$20120810$ConditionalOperator = 'AND' | 'OR';
  declare type DynamoDB$20120810$ConsumedCapacity = {
    TableName?: string;
    CapacityUnits?: number;
    Table?: DynamoDB$20120810$Capacity;
    LocalSecondaryIndexes?: {
      [key: string]: DynamoDB$20120810$Capacity;
    };
    GlobalSecondaryIndexes?: {
      [key: string]: DynamoDB$20120810$Capacity;
    };
  };
  declare type DynamoDB$20120810$ConsumedCapacityMultiple = DynamoDB$20120810$ConsumedCapacity[];
  declare type DynamoDB$20120810$CreateGlobalSecondaryIndexAction = {
    IndexName: string;
    KeySchema: DynamoDB$20120810$KeySchema;
    Projection: DynamoDB$20120810$Projection;
    ProvisionedThroughput: DynamoDB$20120810$ProvisionedThroughput;
  };
  declare type DynamoDB$20120810$CreateTableInput = {
    AttributeDefinitions: DynamoDB$20120810$AttributeDefinitions;
    TableName: string;
    KeySchema: DynamoDB$20120810$KeySchema;
    LocalSecondaryIndexes?: DynamoDB$20120810$LocalSecondaryIndexList;
    GlobalSecondaryIndexes?: DynamoDB$20120810$GlobalSecondaryIndexList;
    ProvisionedThroughput: DynamoDB$20120810$ProvisionedThroughput;
    StreamSpecification?: DynamoDB$20120810$StreamSpecification;
  };
  declare type DynamoDB$20120810$CreateTableOutput = {
    TableDescription?: DynamoDB$20120810$TableDescription;
  };
  declare type DynamoDB$20120810$Date = Date;
  declare type DynamoDB$20120810$DeleteGlobalSecondaryIndexAction = {
    IndexName: string;
  };
  declare type DynamoDB$20120810$DeleteItemInput = {
    TableName: string;
    Key: {
      [key: string]: DynamoDB$20120810$AttributeValue;
    };
    Expected?: {
      [key: string]: DynamoDB$20120810$ExpectedAttributeValue;
    };
    ConditionalOperator?: 'AND' | 'OR';
    ReturnValues?: 'NONE' | 'ALL_OLD' | 'UPDATED_OLD' | 'ALL_NEW' | 'UPDATED_NEW';
    ReturnConsumedCapacity?: 'INDEXES' | 'TOTAL' | 'NONE';
    ReturnItemCollectionMetrics?: 'SIZE' | 'NONE';
    ConditionExpression?: string;
    ExpressionAttributeNames?: {
      [key: string]: string;
    };
    ExpressionAttributeValues?: {
      [key: string]: DynamoDB$20120810$AttributeValue;
    };
  };
  declare type DynamoDB$20120810$DeleteItemOutput = {
    Attributes?: {
      [key: string]: DynamoDB$20120810$AttributeValue;
    };
    ConsumedCapacity?: DynamoDB$20120810$ConsumedCapacity;
    ItemCollectionMetrics?: DynamoDB$20120810$ItemCollectionMetrics;
  };
  declare type DynamoDB$20120810$DeleteRequest = {
    Key: {
      [key: string]: DynamoDB$20120810$AttributeValue;
    };
  };
  declare type DynamoDB$20120810$DeleteTableInput = {
    TableName: string;
  };
  declare type DynamoDB$20120810$DeleteTableOutput = {
    TableDescription?: DynamoDB$20120810$TableDescription;
  };
  declare type DynamoDB$20120810$DescribeLimitsInput = {};
  declare type DynamoDB$20120810$DescribeLimitsOutput = {
    AccountMaxReadCapacityUnits?: number;
    AccountMaxWriteCapacityUnits?: number;
    TableMaxReadCapacityUnits?: number;
    TableMaxWriteCapacityUnits?: number;
  };
  declare type DynamoDB$20120810$DescribeTableInput = {
    TableName: string;
  };
  declare type DynamoDB$20120810$DescribeTableOutput = {
    Table?: DynamoDB$20120810$TableDescription;
  };
  declare type DynamoDB$20120810$ExpectedAttributeMap = {
    [key: string]: DynamoDB$20120810$ExpectedAttributeValue;
  };
  declare type DynamoDB$20120810$ExpectedAttributeValue = {
    Value?: DynamoDB$20120810$AttributeValue;
    Exists?: boolean;
    ComparisonOperator?: 'EQ' | 'NE' | 'IN' | 'LE' | 'LT' | 'GE' | 'GT' | 'BETWEEN' | 'NOT_NULL' | 'NULL' | 'CONTAINS' | 'NOT_CONTAINS' | 'BEGINS_WITH';
    AttributeValueList?: DynamoDB$20120810$AttributeValueList;
  };
  declare type DynamoDB$20120810$ExpressionAttributeNameMap = {
    [key: string]: string;
  };
  declare type DynamoDB$20120810$ExpressionAttributeValueMap = {
    [key: string]: DynamoDB$20120810$AttributeValue;
  };
  declare type DynamoDB$20120810$FilterConditionMap = {
    [key: string]: DynamoDB$20120810$Condition;
  };
  declare type DynamoDB$20120810$GetItemInput = {
    TableName: string;
    Key: {
      [key: string]: DynamoDB$20120810$AttributeValue;
    };
    AttributesToGet?: DynamoDB$20120810$AttributeNameList;
    ConsistentRead?: boolean;
    ReturnConsumedCapacity?: 'INDEXES' | 'TOTAL' | 'NONE';
    ProjectionExpression?: string;
    ExpressionAttributeNames?: {
      [key: string]: string;
    };
  };
  declare type DynamoDB$20120810$GetItemOutput = {
    Item?: {
      [key: string]: DynamoDB$20120810$AttributeValue;
    };
    ConsumedCapacity?: DynamoDB$20120810$ConsumedCapacity;
  };
  declare type DynamoDB$20120810$GlobalSecondaryIndex = {
    IndexName: string;
    KeySchema: DynamoDB$20120810$KeySchema;
    Projection: DynamoDB$20120810$Projection;
    ProvisionedThroughput: DynamoDB$20120810$ProvisionedThroughput;
  };
  declare type DynamoDB$20120810$GlobalSecondaryIndexDescription = {
    IndexName?: string;
    KeySchema?: DynamoDB$20120810$KeySchema;
    Projection?: DynamoDB$20120810$Projection;
    IndexStatus?: 'CREATING' | 'UPDATING' | 'DELETING' | 'ACTIVE';
    Backfilling?: boolean;
    ProvisionedThroughput?: DynamoDB$20120810$ProvisionedThroughputDescription;
    IndexSizeBytes?: number;
    ItemCount?: number;
    IndexArn?: string;
  };
  declare type DynamoDB$20120810$GlobalSecondaryIndexDescriptionList = DynamoDB$20120810$GlobalSecondaryIndexDescription[];
  declare type DynamoDB$20120810$GlobalSecondaryIndexList = DynamoDB$20120810$GlobalSecondaryIndex[];
  declare type DynamoDB$20120810$GlobalSecondaryIndexUpdate = {
    Update?: DynamoDB$20120810$UpdateGlobalSecondaryIndexAction;
    Create?: DynamoDB$20120810$CreateGlobalSecondaryIndexAction;
    Delete?: DynamoDB$20120810$DeleteGlobalSecondaryIndexAction;
  };
  declare type DynamoDB$20120810$GlobalSecondaryIndexUpdateList = DynamoDB$20120810$GlobalSecondaryIndexUpdate[];
  declare type DynamoDB$20120810$IndexStatus = 'CREATING' | 'UPDATING' | 'DELETING' | 'ACTIVE';
  declare type DynamoDB$20120810$InternalServerError = {
    message?: string;
  };
  declare type DynamoDB$20120810$ItemCollectionKeyAttributeMap = {
    [key: string]: DynamoDB$20120810$AttributeValue;
  };
  declare type DynamoDB$20120810$ItemCollectionMetrics = {
    ItemCollectionKey?: {
      [key: string]: DynamoDB$20120810$AttributeValue;
    };
    SizeEstimateRangeGB?: DynamoDB$20120810$ItemCollectionSizeEstimateRange;
  };
  declare type DynamoDB$20120810$ItemCollectionMetricsMultiple = DynamoDB$20120810$ItemCollectionMetrics[];
  declare type DynamoDB$20120810$ItemCollectionMetricsPerTable = {
    [key: string]: DynamoDB$20120810$ItemCollectionMetricsMultiple;
  };
  declare type DynamoDB$20120810$ItemCollectionSizeEstimateRange = number[];
  declare type DynamoDB$20120810$ItemCollectionSizeLimitExceededException = {
    message?: string;
  };
  declare type DynamoDB$20120810$ItemList = ({
    [key: string]: DynamoDB$20120810$AttributeValue;
  })[];
  declare type DynamoDB$20120810$Key = {
    [key: string]: DynamoDB$20120810$AttributeValue;
  };
  declare type DynamoDB$20120810$KeyConditions = {
    [key: string]: DynamoDB$20120810$Condition;
  };
  declare type DynamoDB$20120810$KeyList = ({
    [key: string]: DynamoDB$20120810$AttributeValue;
  })[];
  declare type DynamoDB$20120810$KeySchema = DynamoDB$20120810$KeySchemaElement[];
  declare type DynamoDB$20120810$KeySchemaElement = {
    AttributeName: string;
    KeyType: 'HASH' | 'RANGE';
  };
  declare type DynamoDB$20120810$KeyType = 'HASH' | 'RANGE';
  declare type DynamoDB$20120810$KeysAndAttributes = {
    Keys: DynamoDB$20120810$KeyList;
    AttributesToGet?: DynamoDB$20120810$AttributeNameList;
    ConsistentRead?: boolean;
    ProjectionExpression?: string;
    ExpressionAttributeNames?: {
      [key: string]: string;
    };
  };
  declare type DynamoDB$20120810$LimitExceededException = {
    message?: string;
  };
  declare type DynamoDB$20120810$ListAttributeValue = DynamoDB$20120810$AttributeValue[];
  declare type DynamoDB$20120810$ListTablesInput = {
    ExclusiveStartTableName?: string;
    Limit?: number;
  };
  declare type DynamoDB$20120810$ListTablesOutput = {
    TableNames?: DynamoDB$20120810$TableNameList;
    LastEvaluatedTableName?: string;
  };
  declare type DynamoDB$20120810$LocalSecondaryIndex = {
    IndexName: string;
    KeySchema: DynamoDB$20120810$KeySchema;
    Projection: DynamoDB$20120810$Projection;
  };
  declare type DynamoDB$20120810$LocalSecondaryIndexDescription = {
    IndexName?: string;
    KeySchema?: DynamoDB$20120810$KeySchema;
    Projection?: DynamoDB$20120810$Projection;
    IndexSizeBytes?: number;
    ItemCount?: number;
    IndexArn?: string;
  };
  declare type DynamoDB$20120810$LocalSecondaryIndexDescriptionList = DynamoDB$20120810$LocalSecondaryIndexDescription[];
  declare type DynamoDB$20120810$LocalSecondaryIndexList = DynamoDB$20120810$LocalSecondaryIndex[];
  declare type DynamoDB$20120810$MapAttributeValue = {
    [key: string]: DynamoDB$20120810$AttributeValue;
  };
  declare type DynamoDB$20120810$NonKeyAttributeNameList = string[];
  declare type DynamoDB$20120810$NumberSetAttributeValue = string[];
  declare type DynamoDB$20120810$Projection = {
    ProjectionType?: 'ALL' | 'KEYS_ONLY' | 'INCLUDE';
    NonKeyAttributes?: DynamoDB$20120810$NonKeyAttributeNameList;
  };
  declare type DynamoDB$20120810$ProjectionType = 'ALL' | 'KEYS_ONLY' | 'INCLUDE';
  declare type DynamoDB$20120810$ProvisionedThroughput = {
    ReadCapacityUnits: number;
    WriteCapacityUnits: number;
  };
  declare type DynamoDB$20120810$ProvisionedThroughputDescription = {
    LastIncreaseDateTime?: Date;
    LastDecreaseDateTime?: Date;
    NumberOfDecreasesToday?: number;
    ReadCapacityUnits?: number;
    WriteCapacityUnits?: number;
  };
  declare type DynamoDB$20120810$ProvisionedThroughputExceededException = {
    message?: string;
  };
  declare type DynamoDB$20120810$PutItemInput = {
    TableName: string;
    Item: {
      [key: string]: DynamoDB$20120810$AttributeValue;
    };
    Expected?: {
      [key: string]: DynamoDB$20120810$ExpectedAttributeValue;
    };
    ReturnValues?: 'NONE' | 'ALL_OLD' | 'UPDATED_OLD' | 'ALL_NEW' | 'UPDATED_NEW';
    ReturnConsumedCapacity?: 'INDEXES' | 'TOTAL' | 'NONE';
    ReturnItemCollectionMetrics?: 'SIZE' | 'NONE';
    ConditionalOperator?: 'AND' | 'OR';
    ConditionExpression?: string;
    ExpressionAttributeNames?: {
      [key: string]: string;
    };
    ExpressionAttributeValues?: {
      [key: string]: DynamoDB$20120810$AttributeValue;
    };
  };
  declare type DynamoDB$20120810$PutItemInputAttributeMap = {
    [key: string]: DynamoDB$20120810$AttributeValue;
  };
  declare type DynamoDB$20120810$PutItemOutput = {
    Attributes?: {
      [key: string]: DynamoDB$20120810$AttributeValue;
    };
    ConsumedCapacity?: DynamoDB$20120810$ConsumedCapacity;
    ItemCollectionMetrics?: DynamoDB$20120810$ItemCollectionMetrics;
  };
  declare type DynamoDB$20120810$PutRequest = {
    Item: {
      [key: string]: DynamoDB$20120810$AttributeValue;
    };
  };
  declare type DynamoDB$20120810$QueryInput = {
    TableName: string;
    IndexName?: string;
    Select?: 'ALL_ATTRIBUTES' | 'ALL_PROJECTED_ATTRIBUTES' | 'SPECIFIC_ATTRIBUTES' | 'COUNT';
    AttributesToGet?: DynamoDB$20120810$AttributeNameList;
    Limit?: number;
    ConsistentRead?: boolean;
    KeyConditions?: {
      [key: string]: DynamoDB$20120810$Condition;
    };
    QueryFilter?: {
      [key: string]: DynamoDB$20120810$Condition;
    };
    ConditionalOperator?: 'AND' | 'OR';
    ScanIndexForward?: boolean;
    ExclusiveStartKey?: {
      [key: string]: DynamoDB$20120810$AttributeValue;
    };
    ReturnConsumedCapacity?: 'INDEXES' | 'TOTAL' | 'NONE';
    ProjectionExpression?: string;
    FilterExpression?: string;
    KeyConditionExpression?: string;
    ExpressionAttributeNames?: {
      [key: string]: string;
    };
    ExpressionAttributeValues?: {
      [key: string]: DynamoDB$20120810$AttributeValue;
    };
  };
  declare type DynamoDB$20120810$QueryOutput = {
    Items?: DynamoDB$20120810$ItemList;
    Count?: number;
    ScannedCount?: number;
    LastEvaluatedKey?: {
      [key: string]: DynamoDB$20120810$AttributeValue;
    };
    ConsumedCapacity?: DynamoDB$20120810$ConsumedCapacity;
  };
  declare type DynamoDB$20120810$ResourceInUseException = {
    message?: string;
  };
  declare type DynamoDB$20120810$ResourceNotFoundException = {
    message?: string;
  };
  declare type DynamoDB$20120810$ReturnConsumedCapacity = 'INDEXES' | 'TOTAL' | 'NONE';
  declare type DynamoDB$20120810$ReturnItemCollectionMetrics = 'SIZE' | 'NONE';
  declare type DynamoDB$20120810$ReturnValue = 'NONE' | 'ALL_OLD' | 'UPDATED_OLD' | 'ALL_NEW' | 'UPDATED_NEW';
  declare type DynamoDB$20120810$ScalarAttributeType = 'S' | 'N' | 'B';
  declare type DynamoDB$20120810$ScanInput = {
    TableName: string;
    IndexName?: string;
    AttributesToGet?: DynamoDB$20120810$AttributeNameList;
    Limit?: number;
    Select?: 'ALL_ATTRIBUTES' | 'ALL_PROJECTED_ATTRIBUTES' | 'SPECIFIC_ATTRIBUTES' | 'COUNT';
    ScanFilter?: {
      [key: string]: DynamoDB$20120810$Condition;
    };
    ConditionalOperator?: 'AND' | 'OR';
    ExclusiveStartKey?: {
      [key: string]: DynamoDB$20120810$AttributeValue;
    };
    ReturnConsumedCapacity?: 'INDEXES' | 'TOTAL' | 'NONE';
    TotalSegments?: number;
    Segment?: number;
    ProjectionExpression?: string;
    FilterExpression?: string;
    ExpressionAttributeNames?: {
      [key: string]: string;
    };
    ExpressionAttributeValues?: {
      [key: string]: DynamoDB$20120810$AttributeValue;
    };
    ConsistentRead?: boolean;
  };
  declare type DynamoDB$20120810$ScanOutput = {
    Items?: DynamoDB$20120810$ItemList;
    Count?: number;
    ScannedCount?: number;
    LastEvaluatedKey?: {
      [key: string]: DynamoDB$20120810$AttributeValue;
    };
    ConsumedCapacity?: DynamoDB$20120810$ConsumedCapacity;
  };
  declare type DynamoDB$20120810$SecondaryIndexesCapacityMap = {
    [key: string]: DynamoDB$20120810$Capacity;
  };
  declare type DynamoDB$20120810$Select = 'ALL_ATTRIBUTES' | 'ALL_PROJECTED_ATTRIBUTES' | 'SPECIFIC_ATTRIBUTES' | 'COUNT';
  declare type DynamoDB$20120810$StreamSpecification = {
    StreamEnabled?: boolean;
    StreamViewType?: 'NEW_IMAGE' | 'OLD_IMAGE' | 'NEW_AND_OLD_IMAGES' | 'KEYS_ONLY';
  };
  declare type DynamoDB$20120810$StreamViewType = 'NEW_IMAGE' | 'OLD_IMAGE' | 'NEW_AND_OLD_IMAGES' | 'KEYS_ONLY';
  declare type DynamoDB$20120810$StringSetAttributeValue = string[];
  declare type DynamoDB$20120810$TableDescription = {
    AttributeDefinitions?: DynamoDB$20120810$AttributeDefinitions;
    TableName?: string;
    KeySchema?: DynamoDB$20120810$KeySchema;
    TableStatus?: 'CREATING' | 'UPDATING' | 'DELETING' | 'ACTIVE';
    CreationDateTime?: Date;
    ProvisionedThroughput?: DynamoDB$20120810$ProvisionedThroughputDescription;
    TableSizeBytes?: number;
    ItemCount?: number;
    TableArn?: string;
    LocalSecondaryIndexes?: DynamoDB$20120810$LocalSecondaryIndexDescriptionList;
    GlobalSecondaryIndexes?: DynamoDB$20120810$GlobalSecondaryIndexDescriptionList;
    StreamSpecification?: DynamoDB$20120810$StreamSpecification;
    LatestStreamLabel?: string;
    LatestStreamArn?: string;
  };
  declare type DynamoDB$20120810$TableNameList = string[];
  declare type DynamoDB$20120810$TableStatus = 'CREATING' | 'UPDATING' | 'DELETING' | 'ACTIVE';
  declare type DynamoDB$20120810$UpdateGlobalSecondaryIndexAction = {
    IndexName: string;
    ProvisionedThroughput: DynamoDB$20120810$ProvisionedThroughput;
  };
  declare type DynamoDB$20120810$UpdateItemInput = {
    TableName: string;
    Key: {
      [key: string]: DynamoDB$20120810$AttributeValue;
    };
    AttributeUpdates?: {
      [key: string]: DynamoDB$20120810$AttributeValueUpdate;
    };
    Expected?: {
      [key: string]: DynamoDB$20120810$ExpectedAttributeValue;
    };
    ConditionalOperator?: 'AND' | 'OR';
    ReturnValues?: 'NONE' | 'ALL_OLD' | 'UPDATED_OLD' | 'ALL_NEW' | 'UPDATED_NEW';
    ReturnConsumedCapacity?: 'INDEXES' | 'TOTAL' | 'NONE';
    ReturnItemCollectionMetrics?: 'SIZE' | 'NONE';
    UpdateExpression?: string;
    ConditionExpression?: string;
    ExpressionAttributeNames?: {
      [key: string]: string;
    };
    ExpressionAttributeValues?: {
      [key: string]: DynamoDB$20120810$AttributeValue;
    };
  };
  declare type DynamoDB$20120810$UpdateItemOutput = {
    Attributes?: {
      [key: string]: DynamoDB$20120810$AttributeValue;
    };
    ConsumedCapacity?: DynamoDB$20120810$ConsumedCapacity;
    ItemCollectionMetrics?: DynamoDB$20120810$ItemCollectionMetrics;
  };
  declare type DynamoDB$20120810$UpdateTableInput = {
    AttributeDefinitions?: DynamoDB$20120810$AttributeDefinitions;
    TableName: string;
    ProvisionedThroughput?: DynamoDB$20120810$ProvisionedThroughput;
    GlobalSecondaryIndexUpdates?: DynamoDB$20120810$GlobalSecondaryIndexUpdateList;
    StreamSpecification?: DynamoDB$20120810$StreamSpecification;
  };
  declare type DynamoDB$20120810$UpdateTableOutput = {
    TableDescription?: DynamoDB$20120810$TableDescription;
  };
  declare type DynamoDB$20120810$WriteRequest = {
    PutRequest?: DynamoDB$20120810$PutRequest;
    DeleteRequest?: DynamoDB$20120810$DeleteRequest;
  };
  declare type DynamoDB$20120810$WriteRequests = DynamoDB$20120810$WriteRequest[];
  declare type DynamoDBStreams$20120810$AttributeMap = {
    [key: string]: DynamoDBStreams$20120810$AttributeValue;
  };
  declare type DynamoDBStreams$20120810$AttributeValue = {
    S?: string;
    N?: string;
    B?: Buffer | $TypedArray | Blob | string;
    SS?: DynamoDBStreams$20120810$StringSetAttributeValue;
    NS?: DynamoDBStreams$20120810$NumberSetAttributeValue;
    BS?: DynamoDBStreams$20120810$BinarySetAttributeValue;
    M?: {
      [key: string]: DynamoDBStreams$20120810$AttributeValue;
    };
    L?: DynamoDBStreams$20120810$ListAttributeValue;
    NULL?: boolean;
    BOOL?: boolean;
  };
  declare type DynamoDBStreams$20120810$BinaryAttributeValue = Buffer | $TypedArray | Blob | string;
  declare type DynamoDBStreams$20120810$BinarySetAttributeValue = (Buffer | $TypedArray | Blob | string)[];
  declare type DynamoDBStreams$20120810$Date = Date;
  declare type DynamoDBStreams$20120810$DescribeStreamInput = {
    StreamArn: string;
    Limit?: number;
    ExclusiveStartShardId?: string;
  };
  declare type DynamoDBStreams$20120810$DescribeStreamOutput = {
    StreamDescription?: DynamoDBStreams$20120810$StreamDescription;
  };
  declare type DynamoDBStreams$20120810$ExpiredIteratorException = {
    message?: string;
  };
  declare type DynamoDBStreams$20120810$GetRecordsInput = {
    ShardIterator: string;
    Limit?: number;
  };
  declare type DynamoDBStreams$20120810$GetRecordsOutput = {
    Records?: DynamoDBStreams$20120810$RecordList;
    NextShardIterator?: string;
  };
  declare type DynamoDBStreams$20120810$GetShardIteratorInput = {
    StreamArn: string;
    ShardId: string;
    ShardIteratorType: 'TRIM_HORIZON' | 'LATEST' | 'AT_SEQUENCE_NUMBER' | 'AFTER_SEQUENCE_NUMBER';
    SequenceNumber?: string;
  };
  declare type DynamoDBStreams$20120810$GetShardIteratorOutput = {
    ShardIterator?: string;
  };
  declare type DynamoDBStreams$20120810$InternalServerError = {
    message?: string;
  };
  declare type DynamoDBStreams$20120810$KeySchema = DynamoDBStreams$20120810$KeySchemaElement[];
  declare type DynamoDBStreams$20120810$KeySchemaElement = {
    AttributeName: string;
    KeyType: 'HASH' | 'RANGE';
  };
  declare type DynamoDBStreams$20120810$KeyType = 'HASH' | 'RANGE';
  declare type DynamoDBStreams$20120810$LimitExceededException = {
    message?: string;
  };
  declare type DynamoDBStreams$20120810$ListAttributeValue = DynamoDBStreams$20120810$AttributeValue[];
  declare type DynamoDBStreams$20120810$ListStreamsInput = {
    TableName?: string;
    Limit?: number;
    ExclusiveStartStreamArn?: string;
  };
  declare type DynamoDBStreams$20120810$ListStreamsOutput = {
    Streams?: DynamoDBStreams$20120810$StreamList;
    LastEvaluatedStreamArn?: string;
  };
  declare type DynamoDBStreams$20120810$MapAttributeValue = {
    [key: string]: DynamoDBStreams$20120810$AttributeValue;
  };
  declare type DynamoDBStreams$20120810$NumberSetAttributeValue = string[];
  declare type DynamoDBStreams$20120810$OperationType = 'INSERT' | 'MODIFY' | 'REMOVE';
  declare type DynamoDBStreams$20120810$Record = {
    eventID?: string;
    eventName?: 'INSERT' | 'MODIFY' | 'REMOVE';
    eventVersion?: string;
    eventSource?: string;
    awsRegion?: string;
    dynamodb?: DynamoDBStreams$20120810$StreamRecord;
  };
  declare type DynamoDBStreams$20120810$RecordList = DynamoDBStreams$20120810$Record[];
  declare type DynamoDBStreams$20120810$ResourceNotFoundException = {
    message?: string;
  };
  declare type DynamoDBStreams$20120810$SequenceNumberRange = {
    StartingSequenceNumber?: string;
    EndingSequenceNumber?: string;
  };
  declare type DynamoDBStreams$20120810$Shard = {
    ShardId?: string;
    SequenceNumberRange?: DynamoDBStreams$20120810$SequenceNumberRange;
    ParentShardId?: string;
  };
  declare type DynamoDBStreams$20120810$ShardDescriptionList = DynamoDBStreams$20120810$Shard[];
  declare type DynamoDBStreams$20120810$ShardIteratorType = 'TRIM_HORIZON' | 'LATEST' | 'AT_SEQUENCE_NUMBER' | 'AFTER_SEQUENCE_NUMBER';
  declare type DynamoDBStreams$20120810$Stream = {
    StreamArn?: string;
    TableName?: string;
    StreamLabel?: string;
  };
  declare type DynamoDBStreams$20120810$StreamDescription = {
    StreamArn?: string;
    StreamLabel?: string;
    StreamStatus?: 'ENABLING' | 'ENABLED' | 'DISABLING' | 'DISABLED';
    StreamViewType?: 'NEW_IMAGE' | 'OLD_IMAGE' | 'NEW_AND_OLD_IMAGES' | 'KEYS_ONLY';
    CreationRequestDateTime?: Date;
    TableName?: string;
    KeySchema?: DynamoDBStreams$20120810$KeySchema;
    Shards?: DynamoDBStreams$20120810$ShardDescriptionList;
    LastEvaluatedShardId?: string;
  };
  declare type DynamoDBStreams$20120810$StreamList = DynamoDBStreams$20120810$Stream[];
  declare type DynamoDBStreams$20120810$StreamRecord = {
    ApproximateCreationDateTime?: Date;
    Keys?: {
      [key: string]: DynamoDBStreams$20120810$AttributeValue;
    };
    NewImage?: {
      [key: string]: DynamoDBStreams$20120810$AttributeValue;
    };
    OldImage?: {
      [key: string]: DynamoDBStreams$20120810$AttributeValue;
    };
    SequenceNumber?: string;
    SizeBytes?: number;
    StreamViewType?: 'NEW_IMAGE' | 'OLD_IMAGE' | 'NEW_AND_OLD_IMAGES' | 'KEYS_ONLY';
  };
  declare type DynamoDBStreams$20120810$StreamStatus = 'ENABLING' | 'ENABLED' | 'DISABLING' | 'DISABLED';
  declare type DynamoDBStreams$20120810$StreamViewType = 'NEW_IMAGE' | 'OLD_IMAGE' | 'NEW_AND_OLD_IMAGES' | 'KEYS_ONLY';
  declare type DynamoDBStreams$20120810$StringSetAttributeValue = string[];
  declare type DynamoDBStreams$20120810$TrimmedDataAccessException = {
    message?: string;
  };
  declare type EC2$20160401$AcceptVpcPeeringConnectionRequest = {
    DryRun?: boolean;
    VpcPeeringConnectionId?: string;
  };
  declare type EC2$20160401$AcceptVpcPeeringConnectionResult = {
    VpcPeeringConnection?: EC2$20160401$VpcPeeringConnection;
  };
  declare type EC2$20160401$AccountAttribute = {
    AttributeName?: string;
    AttributeValues?: EC2$20160401$AccountAttributeValueList;
  };
  declare type EC2$20160401$AccountAttributeList = EC2$20160401$AccountAttribute[];
  declare type EC2$20160401$AccountAttributeName = 'supported-platforms' | 'default-vpc';
  declare type EC2$20160401$AccountAttributeNameStringList = ('supported-platforms' | 'default-vpc')[];
  declare type EC2$20160401$AccountAttributeValue = {
    AttributeValue?: string;
  };
  declare type EC2$20160401$AccountAttributeValueList = EC2$20160401$AccountAttributeValue[];
  declare type EC2$20160401$ActiveInstance = {
    InstanceType?: string;
    InstanceId?: string;
    SpotInstanceRequestId?: string;
  };
  declare type EC2$20160401$ActiveInstanceSet = EC2$20160401$ActiveInstance[];
  declare type EC2$20160401$Address = {
    InstanceId?: string;
    PublicIp?: string;
    AllocationId?: string;
    AssociationId?: string;
    Domain?: 'vpc' | 'standard';
    NetworkInterfaceId?: string;
    NetworkInterfaceOwnerId?: string;
    PrivateIpAddress?: string;
  };
  declare type EC2$20160401$AddressList = EC2$20160401$Address[];
  declare type EC2$20160401$Affinity = 'default' | 'host';
  declare type EC2$20160401$AllocateAddressRequest = {
    DryRun?: boolean;
    Domain?: 'vpc' | 'standard';
  };
  declare type EC2$20160401$AllocateAddressResult = {
    PublicIp?: string;
    Domain?: 'vpc' | 'standard';
    AllocationId?: string;
  };
  declare type EC2$20160401$AllocateHostsRequest = {
    AutoPlacement?: 'on' | 'off';
    ClientToken?: string;
    InstanceType: string;
    Quantity: number;
    AvailabilityZone: string;
  };
  declare type EC2$20160401$AllocateHostsResult = {
    HostIds?: EC2$20160401$ResponseHostIdList;
  };
  declare type EC2$20160401$AllocationIdList = string[];
  declare type EC2$20160401$AllocationState = 'available' | 'under-assessment' | 'permanent-failure' | 'released' | 'released-permanent-failure';
  declare type EC2$20160401$AllocationStrategy = 'lowestPrice' | 'diversified';
  declare type EC2$20160401$ArchitectureValues = 'i386' | 'x86_64';
  declare type EC2$20160401$AssignPrivateIpAddressesRequest = {
    NetworkInterfaceId: string;
    PrivateIpAddresses?: EC2$20160401$PrivateIpAddressStringList;
    SecondaryPrivateIpAddressCount?: number;
    AllowReassignment?: boolean;
  };
  declare type EC2$20160401$AssociateAddressRequest = {
    DryRun?: boolean;
    InstanceId?: string;
    PublicIp?: string;
    AllocationId?: string;
    NetworkInterfaceId?: string;
    PrivateIpAddress?: string;
    AllowReassociation?: boolean;
  };
  declare type EC2$20160401$AssociateAddressResult = {
    AssociationId?: string;
  };
  declare type EC2$20160401$AssociateDhcpOptionsRequest = {
    DryRun?: boolean;
    DhcpOptionsId: string;
    VpcId: string;
  };
  declare type EC2$20160401$AssociateRouteTableRequest = {
    DryRun?: boolean;
    SubnetId: string;
    RouteTableId: string;
  };
  declare type EC2$20160401$AssociateRouteTableResult = {
    AssociationId?: string;
  };
  declare type EC2$20160401$AttachClassicLinkVpcRequest = {
    DryRun?: boolean;
    InstanceId: string;
    VpcId: string;
    Groups: EC2$20160401$GroupIdStringList;
  };
  declare type EC2$20160401$AttachClassicLinkVpcResult = {
    Return?: boolean;
  };
  declare type EC2$20160401$AttachInternetGatewayRequest = {
    DryRun?: boolean;
    InternetGatewayId: string;
    VpcId: string;
  };
  declare type EC2$20160401$AttachNetworkInterfaceRequest = {
    DryRun?: boolean;
    NetworkInterfaceId: string;
    InstanceId: string;
    DeviceIndex: number;
  };
  declare type EC2$20160401$AttachNetworkInterfaceResult = {
    AttachmentId?: string;
  };
  declare type EC2$20160401$AttachVolumeRequest = {
    DryRun?: boolean;
    VolumeId: string;
    InstanceId: string;
    Device: string;
  };
  declare type EC2$20160401$AttachVpnGatewayRequest = {
    DryRun?: boolean;
    VpnGatewayId: string;
    VpcId: string;
  };
  declare type EC2$20160401$AttachVpnGatewayResult = {
    VpcAttachment?: EC2$20160401$VpcAttachment;
  };
  declare type EC2$20160401$AttachmentStatus = 'attaching' | 'attached' | 'detaching' | 'detached';
  declare type EC2$20160401$AttributeBooleanValue = {
    Value?: boolean;
  };
  declare type EC2$20160401$AttributeValue = {
    Value?: string;
  };
  declare type EC2$20160401$AuthorizeSecurityGroupEgressRequest = {
    DryRun?: boolean;
    GroupId: string;
    SourceSecurityGroupName?: string;
    SourceSecurityGroupOwnerId?: string;
    IpProtocol?: string;
    FromPort?: number;
    ToPort?: number;
    CidrIp?: string;
    IpPermissions?: EC2$20160401$IpPermissionList;
  };
  declare type EC2$20160401$AuthorizeSecurityGroupIngressRequest = {
    DryRun?: boolean;
    GroupName?: string;
    GroupId?: string;
    SourceSecurityGroupName?: string;
    SourceSecurityGroupOwnerId?: string;
    IpProtocol?: string;
    FromPort?: number;
    ToPort?: number;
    CidrIp?: string;
    IpPermissions?: EC2$20160401$IpPermissionList;
  };
  declare type EC2$20160401$AutoPlacement = 'on' | 'off';
  declare type EC2$20160401$AvailabilityZone = {
    ZoneName?: string;
    State?: 'available' | 'information' | 'impaired' | 'unavailable';
    RegionName?: string;
    Messages?: EC2$20160401$AvailabilityZoneMessageList;
  };
  declare type EC2$20160401$AvailabilityZoneList = EC2$20160401$AvailabilityZone[];
  declare type EC2$20160401$AvailabilityZoneMessage = {
    Message?: string;
  };
  declare type EC2$20160401$AvailabilityZoneMessageList = EC2$20160401$AvailabilityZoneMessage[];
  declare type EC2$20160401$AvailabilityZoneState = 'available' | 'information' | 'impaired' | 'unavailable';
  declare type EC2$20160401$AvailableCapacity = {
    AvailableInstanceCapacity?: EC2$20160401$AvailableInstanceCapacityList;
    AvailableVCpus?: number;
  };
  declare type EC2$20160401$AvailableInstanceCapacityList = EC2$20160401$InstanceCapacity[];
  declare type EC2$20160401$BatchState = 'submitted' | 'active' | 'cancelled' | 'failed' | 'cancelled_running' | 'cancelled_terminating' | 'modifying';
  declare type EC2$20160401$Blob = Buffer | $TypedArray | Blob | string;
  declare type EC2$20160401$BlobAttributeValue = {
    Value?: Buffer | $TypedArray | Blob | string;
  };
  declare type EC2$20160401$BlockDeviceMapping = {
    VirtualName?: string;
    DeviceName?: string;
    Ebs?: EC2$20160401$EbsBlockDevice;
    NoDevice?: string;
  };
  declare type EC2$20160401$BlockDeviceMappingList = EC2$20160401$BlockDeviceMapping[];
  declare type EC2$20160401$BlockDeviceMappingRequestList = EC2$20160401$BlockDeviceMapping[];
  declare type EC2$20160401$BundleIdStringList = string[];
  declare type EC2$20160401$BundleInstanceRequest = {
    DryRun?: boolean;
    InstanceId: string;
    Storage: EC2$20160401$Storage;
  };
  declare type EC2$20160401$BundleInstanceResult = {
    BundleTask?: EC2$20160401$BundleTask;
  };
  declare type EC2$20160401$BundleTask = {
    InstanceId?: string;
    BundleId?: string;
    State?: 'pending' | 'waiting-for-shutdown' | 'bundling' | 'storing' | 'cancelling' | 'complete' | 'failed';
    StartTime?: Date;
    UpdateTime?: Date;
    Storage?: EC2$20160401$Storage;
    Progress?: string;
    BundleTaskError?: EC2$20160401$BundleTaskError;
  };
  declare type EC2$20160401$BundleTaskError = {
    Code?: string;
    Message?: string;
  };
  declare type EC2$20160401$BundleTaskList = EC2$20160401$BundleTask[];
  declare type EC2$20160401$BundleTaskState = 'pending' | 'waiting-for-shutdown' | 'bundling' | 'storing' | 'cancelling' | 'complete' | 'failed';
  declare type EC2$20160401$CancelBatchErrorCode = 'fleetRequestIdDoesNotExist' | 'fleetRequestIdMalformed' | 'fleetRequestNotInCancellableState' | 'unexpectedError';
  declare type EC2$20160401$CancelBundleTaskRequest = {
    DryRun?: boolean;
    BundleId: string;
  };
  declare type EC2$20160401$CancelBundleTaskResult = {
    BundleTask?: EC2$20160401$BundleTask;
  };
  declare type EC2$20160401$CancelConversionRequest = {
    DryRun?: boolean;
    ConversionTaskId: string;
    ReasonMessage?: string;
  };
  declare type EC2$20160401$CancelExportTaskRequest = {
    ExportTaskId: string;
  };
  declare type EC2$20160401$CancelImportTaskRequest = {
    DryRun?: boolean;
    ImportTaskId?: string;
    CancelReason?: string;
  };
  declare type EC2$20160401$CancelImportTaskResult = {
    ImportTaskId?: string;
    State?: string;
    PreviousState?: string;
  };
  declare type EC2$20160401$CancelReservedInstancesListingRequest = {
    ReservedInstancesListingId: string;
  };
  declare type EC2$20160401$CancelReservedInstancesListingResult = {
    ReservedInstancesListings?: EC2$20160401$ReservedInstancesListingList;
  };
  declare type EC2$20160401$CancelSpotFleetRequestsError = {
    Code: 'fleetRequestIdDoesNotExist' | 'fleetRequestIdMalformed' | 'fleetRequestNotInCancellableState' | 'unexpectedError';
    Message: string;
  };
  declare type EC2$20160401$CancelSpotFleetRequestsErrorItem = {
    SpotFleetRequestId: string;
    Error: EC2$20160401$CancelSpotFleetRequestsError;
  };
  declare type EC2$20160401$CancelSpotFleetRequestsErrorSet = EC2$20160401$CancelSpotFleetRequestsErrorItem[];
  declare type EC2$20160401$CancelSpotFleetRequestsRequest = {
    DryRun?: boolean;
    SpotFleetRequestIds: EC2$20160401$ValueStringList;
    TerminateInstances: boolean;
  };
  declare type EC2$20160401$CancelSpotFleetRequestsResponse = {
    UnsuccessfulFleetRequests?: EC2$20160401$CancelSpotFleetRequestsErrorSet;
    SuccessfulFleetRequests?: EC2$20160401$CancelSpotFleetRequestsSuccessSet;
  };
  declare type EC2$20160401$CancelSpotFleetRequestsSuccessItem = {
    SpotFleetRequestId: string;
    CurrentSpotFleetRequestState: 'submitted' | 'active' | 'cancelled' | 'failed' | 'cancelled_running' | 'cancelled_terminating' | 'modifying';
    PreviousSpotFleetRequestState: 'submitted' | 'active' | 'cancelled' | 'failed' | 'cancelled_running' | 'cancelled_terminating' | 'modifying';
  };
  declare type EC2$20160401$CancelSpotFleetRequestsSuccessSet = EC2$20160401$CancelSpotFleetRequestsSuccessItem[];
  declare type EC2$20160401$CancelSpotInstanceRequestState = 'active' | 'open' | 'closed' | 'cancelled' | 'completed';
  declare type EC2$20160401$CancelSpotInstanceRequestsRequest = {
    DryRun?: boolean;
    SpotInstanceRequestIds: EC2$20160401$SpotInstanceRequestIdList;
  };
  declare type EC2$20160401$CancelSpotInstanceRequestsResult = {
    CancelledSpotInstanceRequests?: EC2$20160401$CancelledSpotInstanceRequestList;
  };
  declare type EC2$20160401$CancelledSpotInstanceRequest = {
    SpotInstanceRequestId?: string;
    State?: 'active' | 'open' | 'closed' | 'cancelled' | 'completed';
  };
  declare type EC2$20160401$CancelledSpotInstanceRequestList = EC2$20160401$CancelledSpotInstanceRequest[];
  declare type EC2$20160401$ClassicLinkDnsSupport = {
    VpcId?: string;
    ClassicLinkDnsSupported?: boolean;
  };
  declare type EC2$20160401$ClassicLinkDnsSupportList = EC2$20160401$ClassicLinkDnsSupport[];
  declare type EC2$20160401$ClassicLinkInstance = {
    InstanceId?: string;
    VpcId?: string;
    Groups?: EC2$20160401$GroupIdentifierList;
    Tags?: EC2$20160401$TagList;
  };
  declare type EC2$20160401$ClassicLinkInstanceList = EC2$20160401$ClassicLinkInstance[];
  declare type EC2$20160401$ClientData = {
    UploadStart?: Date;
    UploadEnd?: Date;
    UploadSize?: number;
    Comment?: string;
  };
  declare type EC2$20160401$ConfirmProductInstanceRequest = {
    DryRun?: boolean;
    ProductCode: string;
    InstanceId: string;
  };
  declare type EC2$20160401$ConfirmProductInstanceResult = {
    OwnerId?: string;
    Return?: boolean;
  };
  declare type EC2$20160401$ContainerFormat = 'ova';
  declare type EC2$20160401$ConversionIdStringList = string[];
  declare type EC2$20160401$ConversionTask = {
    ConversionTaskId: string;
    ExpirationTime?: string;
    ImportInstance?: EC2$20160401$ImportInstanceTaskDetails;
    ImportVolume?: EC2$20160401$ImportVolumeTaskDetails;
    State: 'active' | 'cancelling' | 'cancelled' | 'completed';
    StatusMessage?: string;
    Tags?: EC2$20160401$TagList;
  };
  declare type EC2$20160401$ConversionTaskState = 'active' | 'cancelling' | 'cancelled' | 'completed';
  declare type EC2$20160401$CopyImageRequest = {
    DryRun?: boolean;
    SourceRegion: string;
    SourceImageId: string;
    Name: string;
    Description?: string;
    ClientToken?: string;
    Encrypted?: boolean;
    KmsKeyId?: string;
  };
  declare type EC2$20160401$CopyImageResult = {
    ImageId?: string;
  };
  declare type EC2$20160401$CopySnapshotRequest = {
    DryRun?: boolean;
    SourceRegion: string;
    SourceSnapshotId: string;
    Description?: string;
    DestinationRegion?: string;
    PresignedUrl?: string;
    Encrypted?: boolean;
    KmsKeyId?: string;
  };
  declare type EC2$20160401$CopySnapshotResult = {
    SnapshotId?: string;
  };
  declare type EC2$20160401$CreateCustomerGatewayRequest = {
    DryRun?: boolean;
    Type: 'ipsec.1';
    PublicIp: string;
    BgpAsn: number;
  };
  declare type EC2$20160401$CreateCustomerGatewayResult = {
    CustomerGateway?: EC2$20160401$CustomerGateway;
  };
  declare type EC2$20160401$CreateDhcpOptionsRequest = {
    DryRun?: boolean;
    DhcpConfigurations: EC2$20160401$NewDhcpConfigurationList;
  };
  declare type EC2$20160401$CreateDhcpOptionsResult = {
    DhcpOptions?: EC2$20160401$DhcpOptions;
  };
  declare type EC2$20160401$CreateFlowLogsRequest = {
    ResourceIds: EC2$20160401$ValueStringList;
    ResourceType: 'VPC' | 'Subnet' | 'NetworkInterface';
    TrafficType: 'ACCEPT' | 'REJECT' | 'ALL';
    LogGroupName: string;
    DeliverLogsPermissionArn: string;
    ClientToken?: string;
  };
  declare type EC2$20160401$CreateFlowLogsResult = {
    FlowLogIds?: EC2$20160401$ValueStringList;
    ClientToken?: string;
    Unsuccessful?: EC2$20160401$UnsuccessfulItemSet;
  };
  declare type EC2$20160401$CreateImageRequest = {
    DryRun?: boolean;
    InstanceId: string;
    Name: string;
    Description?: string;
    NoReboot?: boolean;
    BlockDeviceMappings?: EC2$20160401$BlockDeviceMappingRequestList;
  };
  declare type EC2$20160401$CreateImageResult = {
    ImageId?: string;
  };
  declare type EC2$20160401$CreateInstanceExportTaskRequest = {
    Description?: string;
    InstanceId: string;
    TargetEnvironment?: 'citrix' | 'vmware' | 'microsoft';
    ExportToS3Task?: EC2$20160401$ExportToS3TaskSpecification;
  };
  declare type EC2$20160401$CreateInstanceExportTaskResult = {
    ExportTask?: EC2$20160401$ExportTask;
  };
  declare type EC2$20160401$CreateInternetGatewayRequest = {
    DryRun?: boolean;
  };
  declare type EC2$20160401$CreateInternetGatewayResult = {
    InternetGateway?: EC2$20160401$InternetGateway;
  };
  declare type EC2$20160401$CreateKeyPairRequest = {
    DryRun?: boolean;
    KeyName: string;
  };
  declare type EC2$20160401$CreateNatGatewayRequest = {
    SubnetId: string;
    AllocationId: string;
    ClientToken?: string;
  };
  declare type EC2$20160401$CreateNatGatewayResult = {
    NatGateway?: EC2$20160401$NatGateway;
    ClientToken?: string;
  };
  declare type EC2$20160401$CreateNetworkAclEntryRequest = {
    DryRun?: boolean;
    NetworkAclId: string;
    RuleNumber: number;
    Protocol: string;
    RuleAction: 'allow' | 'deny';
    Egress: boolean;
    CidrBlock: string;
    IcmpTypeCode?: EC2$20160401$IcmpTypeCode;
    PortRange?: EC2$20160401$PortRange;
  };
  declare type EC2$20160401$CreateNetworkAclRequest = {
    DryRun?: boolean;
    VpcId: string;
  };
  declare type EC2$20160401$CreateNetworkAclResult = {
    NetworkAcl?: EC2$20160401$NetworkAcl;
  };
  declare type EC2$20160401$CreateNetworkInterfaceRequest = {
    SubnetId: string;
    Description?: string;
    PrivateIpAddress?: string;
    Groups?: EC2$20160401$SecurityGroupIdStringList;
    PrivateIpAddresses?: EC2$20160401$PrivateIpAddressSpecificationList;
    SecondaryPrivateIpAddressCount?: number;
    DryRun?: boolean;
  };
  declare type EC2$20160401$CreateNetworkInterfaceResult = {
    NetworkInterface?: EC2$20160401$NetworkInterface;
  };
  declare type EC2$20160401$CreatePlacementGroupRequest = {
    DryRun?: boolean;
    GroupName: string;
    Strategy: 'cluster';
  };
  declare type EC2$20160401$CreateReservedInstancesListingRequest = {
    ReservedInstancesId: string;
    InstanceCount: number;
    PriceSchedules: EC2$20160401$PriceScheduleSpecificationList;
    ClientToken: string;
  };
  declare type EC2$20160401$CreateReservedInstancesListingResult = {
    ReservedInstancesListings?: EC2$20160401$ReservedInstancesListingList;
  };
  declare type EC2$20160401$CreateRouteRequest = {
    DryRun?: boolean;
    RouteTableId: string;
    DestinationCidrBlock: string;
    GatewayId?: string;
    InstanceId?: string;
    NetworkInterfaceId?: string;
    VpcPeeringConnectionId?: string;
    NatGatewayId?: string;
  };
  declare type EC2$20160401$CreateRouteResult = {
    Return?: boolean;
  };
  declare type EC2$20160401$CreateRouteTableRequest = {
    DryRun?: boolean;
    VpcId: string;
  };
  declare type EC2$20160401$CreateRouteTableResult = {
    RouteTable?: EC2$20160401$RouteTable;
  };
  declare type EC2$20160401$CreateSecurityGroupRequest = {
    DryRun?: boolean;
    GroupName: string;
    Description: string;
    VpcId?: string;
  };
  declare type EC2$20160401$CreateSecurityGroupResult = {
    GroupId?: string;
  };
  declare type EC2$20160401$CreateSnapshotRequest = {
    DryRun?: boolean;
    VolumeId: string;
    Description?: string;
  };
  declare type EC2$20160401$CreateSpotDatafeedSubscriptionRequest = {
    DryRun?: boolean;
    Bucket: string;
    Prefix?: string;
  };
  declare type EC2$20160401$CreateSpotDatafeedSubscriptionResult = {
    SpotDatafeedSubscription?: EC2$20160401$SpotDatafeedSubscription;
  };
  declare type EC2$20160401$CreateSubnetRequest = {
    DryRun?: boolean;
    VpcId: string;
    CidrBlock: string;
    AvailabilityZone?: string;
  };
  declare type EC2$20160401$CreateSubnetResult = {
    Subnet?: EC2$20160401$Subnet;
  };
  declare type EC2$20160401$CreateTagsRequest = {
    DryRun?: boolean;
    Resources: EC2$20160401$ResourceIdList;
    Tags: EC2$20160401$TagList;
  };
  declare type EC2$20160401$CreateVolumePermission = {
    UserId?: string;
    Group?: 'all';
  };
  declare type EC2$20160401$CreateVolumePermissionList = EC2$20160401$CreateVolumePermission[];
  declare type EC2$20160401$CreateVolumePermissionModifications = {
    Add?: EC2$20160401$CreateVolumePermissionList;
    Remove?: EC2$20160401$CreateVolumePermissionList;
  };
  declare type EC2$20160401$CreateVolumeRequest = {
    DryRun?: boolean;
    Size?: number;
    SnapshotId?: string;
    AvailabilityZone: string;
    VolumeType?: 'standard' | 'io1' | 'gp2' | 'sc1' | 'st1';
    Iops?: number;
    Encrypted?: boolean;
    KmsKeyId?: string;
  };
  declare type EC2$20160401$CreateVpcEndpointRequest = {
    DryRun?: boolean;
    VpcId: string;
    ServiceName: string;
    PolicyDocument?: string;
    RouteTableIds?: EC2$20160401$ValueStringList;
    ClientToken?: string;
  };
  declare type EC2$20160401$CreateVpcEndpointResult = {
    VpcEndpoint?: EC2$20160401$VpcEndpoint;
    ClientToken?: string;
  };
  declare type EC2$20160401$CreateVpcPeeringConnectionRequest = {
    DryRun?: boolean;
    VpcId?: string;
    PeerVpcId?: string;
    PeerOwnerId?: string;
  };
  declare type EC2$20160401$CreateVpcPeeringConnectionResult = {
    VpcPeeringConnection?: EC2$20160401$VpcPeeringConnection;
  };
  declare type EC2$20160401$CreateVpcRequest = {
    DryRun?: boolean;
    CidrBlock: string;
    InstanceTenancy?: 'default' | 'dedicated' | 'host';
  };
  declare type EC2$20160401$CreateVpcResult = {
    Vpc?: EC2$20160401$Vpc;
  };
  declare type EC2$20160401$CreateVpnConnectionRequest = {
    DryRun?: boolean;
    Type: string;
    CustomerGatewayId: string;
    VpnGatewayId: string;
    Options?: EC2$20160401$VpnConnectionOptionsSpecification;
  };
  declare type EC2$20160401$CreateVpnConnectionResult = {
    VpnConnection?: EC2$20160401$VpnConnection;
  };
  declare type EC2$20160401$CreateVpnConnectionRouteRequest = {
    VpnConnectionId: string;
    DestinationCidrBlock: string;
  };
  declare type EC2$20160401$CreateVpnGatewayRequest = {
    DryRun?: boolean;
    Type: 'ipsec.1';
    AvailabilityZone?: string;
  };
  declare type EC2$20160401$CreateVpnGatewayResult = {
    VpnGateway?: EC2$20160401$VpnGateway;
  };
  declare type EC2$20160401$CurrencyCodeValues = 'USD';
  declare type EC2$20160401$CustomerGateway = {
    CustomerGatewayId?: string;
    State?: string;
    Type?: string;
    IpAddress?: string;
    BgpAsn?: string;
    Tags?: EC2$20160401$TagList;
  };
  declare type EC2$20160401$CustomerGatewayIdStringList = string[];
  declare type EC2$20160401$CustomerGatewayList = EC2$20160401$CustomerGateway[];
  declare type EC2$20160401$DatafeedSubscriptionState = 'Active' | 'Inactive';
  declare type EC2$20160401$DateTime = Date;
  declare type EC2$20160401$DeleteCustomerGatewayRequest = {
    DryRun?: boolean;
    CustomerGatewayId: string;
  };
  declare type EC2$20160401$DeleteDhcpOptionsRequest = {
    DryRun?: boolean;
    DhcpOptionsId: string;
  };
  declare type EC2$20160401$DeleteFlowLogsRequest = {
    FlowLogIds: EC2$20160401$ValueStringList;
  };
  declare type EC2$20160401$DeleteFlowLogsResult = {
    Unsuccessful?: EC2$20160401$UnsuccessfulItemSet;
  };
  declare type EC2$20160401$DeleteInternetGatewayRequest = {
    DryRun?: boolean;
    InternetGatewayId: string;
  };
  declare type EC2$20160401$DeleteKeyPairRequest = {
    DryRun?: boolean;
    KeyName: string;
  };
  declare type EC2$20160401$DeleteNatGatewayRequest = {
    NatGatewayId: string;
  };
  declare type EC2$20160401$DeleteNatGatewayResult = {
    NatGatewayId?: string;
  };
  declare type EC2$20160401$DeleteNetworkAclEntryRequest = {
    DryRun?: boolean;
    NetworkAclId: string;
    RuleNumber: number;
    Egress: boolean;
  };
  declare type EC2$20160401$DeleteNetworkAclRequest = {
    DryRun?: boolean;
    NetworkAclId: string;
  };
  declare type EC2$20160401$DeleteNetworkInterfaceRequest = {
    DryRun?: boolean;
    NetworkInterfaceId: string;
  };
  declare type EC2$20160401$DeletePlacementGroupRequest = {
    DryRun?: boolean;
    GroupName: string;
  };
  declare type EC2$20160401$DeleteRouteRequest = {
    DryRun?: boolean;
    RouteTableId: string;
    DestinationCidrBlock: string;
  };
  declare type EC2$20160401$DeleteRouteTableRequest = {
    DryRun?: boolean;
    RouteTableId: string;
  };
  declare type EC2$20160401$DeleteSecurityGroupRequest = {
    DryRun?: boolean;
    GroupName?: string;
    GroupId?: string;
  };
  declare type EC2$20160401$DeleteSnapshotRequest = {
    DryRun?: boolean;
    SnapshotId: string;
  };
  declare type EC2$20160401$DeleteSpotDatafeedSubscriptionRequest = {
    DryRun?: boolean;
  };
  declare type EC2$20160401$DeleteSubnetRequest = {
    DryRun?: boolean;
    SubnetId: string;
  };
  declare type EC2$20160401$DeleteTagsRequest = {
    DryRun?: boolean;
    Resources: EC2$20160401$ResourceIdList;
    Tags?: EC2$20160401$TagList;
  };
  declare type EC2$20160401$DeleteVolumeRequest = {
    DryRun?: boolean;
    VolumeId: string;
  };
  declare type EC2$20160401$DeleteVpcEndpointsRequest = {
    DryRun?: boolean;
    VpcEndpointIds: EC2$20160401$ValueStringList;
  };
  declare type EC2$20160401$DeleteVpcEndpointsResult = {
    Unsuccessful?: EC2$20160401$UnsuccessfulItemSet;
  };
  declare type EC2$20160401$DeleteVpcPeeringConnectionRequest = {
    DryRun?: boolean;
    VpcPeeringConnectionId: string;
  };
  declare type EC2$20160401$DeleteVpcPeeringConnectionResult = {
    Return?: boolean;
  };
  declare type EC2$20160401$DeleteVpcRequest = {
    DryRun?: boolean;
    VpcId: string;
  };
  declare type EC2$20160401$DeleteVpnConnectionRequest = {
    DryRun?: boolean;
    VpnConnectionId: string;
  };
  declare type EC2$20160401$DeleteVpnConnectionRouteRequest = {
    VpnConnectionId: string;
    DestinationCidrBlock: string;
  };
  declare type EC2$20160401$DeleteVpnGatewayRequest = {
    DryRun?: boolean;
    VpnGatewayId: string;
  };
  declare type EC2$20160401$DeregisterImageRequest = {
    DryRun?: boolean;
    ImageId: string;
  };
  declare type EC2$20160401$DescribeAccountAttributesRequest = {
    DryRun?: boolean;
    AttributeNames?: EC2$20160401$AccountAttributeNameStringList;
  };
  declare type EC2$20160401$DescribeAccountAttributesResult = {
    AccountAttributes?: EC2$20160401$AccountAttributeList;
  };
  declare type EC2$20160401$DescribeAddressesRequest = {
    DryRun?: boolean;
    PublicIps?: EC2$20160401$PublicIpStringList;
    Filters?: EC2$20160401$FilterList;
    AllocationIds?: EC2$20160401$AllocationIdList;
  };
  declare type EC2$20160401$DescribeAddressesResult = {
    Addresses?: EC2$20160401$AddressList;
  };
  declare type EC2$20160401$DescribeAvailabilityZonesRequest = {
    DryRun?: boolean;
    ZoneNames?: EC2$20160401$ZoneNameStringList;
    Filters?: EC2$20160401$FilterList;
  };
  declare type EC2$20160401$DescribeAvailabilityZonesResult = {
    AvailabilityZones?: EC2$20160401$AvailabilityZoneList;
  };
  declare type EC2$20160401$DescribeBundleTasksRequest = {
    DryRun?: boolean;
    BundleIds?: EC2$20160401$BundleIdStringList;
    Filters?: EC2$20160401$FilterList;
  };
  declare type EC2$20160401$DescribeBundleTasksResult = {
    BundleTasks?: EC2$20160401$BundleTaskList;
  };
  declare type EC2$20160401$DescribeClassicLinkInstancesRequest = {
    DryRun?: boolean;
    InstanceIds?: EC2$20160401$InstanceIdStringList;
    Filters?: EC2$20160401$FilterList;
    NextToken?: string;
    MaxResults?: number;
  };
  declare type EC2$20160401$DescribeClassicLinkInstancesResult = {
    Instances?: EC2$20160401$ClassicLinkInstanceList;
    NextToken?: string;
  };
  declare type EC2$20160401$DescribeConversionTaskList = EC2$20160401$ConversionTask[];
  declare type EC2$20160401$DescribeConversionTasksRequest = {
    DryRun?: boolean;
    Filters?: EC2$20160401$FilterList;
    ConversionTaskIds?: EC2$20160401$ConversionIdStringList;
  };
  declare type EC2$20160401$DescribeConversionTasksResult = {
    ConversionTasks?: EC2$20160401$DescribeConversionTaskList;
  };
  declare type EC2$20160401$DescribeCustomerGatewaysRequest = {
    DryRun?: boolean;
    CustomerGatewayIds?: EC2$20160401$CustomerGatewayIdStringList;
    Filters?: EC2$20160401$FilterList;
  };
  declare type EC2$20160401$DescribeCustomerGatewaysResult = {
    CustomerGateways?: EC2$20160401$CustomerGatewayList;
  };
  declare type EC2$20160401$DescribeDhcpOptionsRequest = {
    DryRun?: boolean;
    DhcpOptionsIds?: EC2$20160401$DhcpOptionsIdStringList;
    Filters?: EC2$20160401$FilterList;
  };
  declare type EC2$20160401$DescribeDhcpOptionsResult = {
    DhcpOptions?: EC2$20160401$DhcpOptionsList;
  };
  declare type EC2$20160401$DescribeExportTasksRequest = {
    ExportTaskIds?: EC2$20160401$ExportTaskIdStringList;
  };
  declare type EC2$20160401$DescribeExportTasksResult = {
    ExportTasks?: EC2$20160401$ExportTaskList;
  };
  declare type EC2$20160401$DescribeFlowLogsRequest = {
    FlowLogIds?: EC2$20160401$ValueStringList;
    Filter?: EC2$20160401$FilterList;
    NextToken?: string;
    MaxResults?: number;
  };
  declare type EC2$20160401$DescribeFlowLogsResult = {
    FlowLogs?: EC2$20160401$FlowLogSet;
    NextToken?: string;
  };
  declare type EC2$20160401$DescribeHostsRequest = {
    HostIds?: EC2$20160401$RequestHostIdList;
    NextToken?: string;
    MaxResults?: number;
    Filter?: EC2$20160401$FilterList;
  };
  declare type EC2$20160401$DescribeHostsResult = {
    Hosts?: EC2$20160401$HostList;
    NextToken?: string;
  };
  declare type EC2$20160401$DescribeIdFormatRequest = {
    Resource?: string;
  };
  declare type EC2$20160401$DescribeIdFormatResult = {
    Statuses?: EC2$20160401$IdFormatList;
  };
  declare type EC2$20160401$DescribeIdentityIdFormatRequest = {
    Resource?: string;
    PrincipalArn: string;
  };
  declare type EC2$20160401$DescribeIdentityIdFormatResult = {
    Statuses?: EC2$20160401$IdFormatList;
  };
  declare type EC2$20160401$DescribeImageAttributeRequest = {
    DryRun?: boolean;
    ImageId: string;
    Attribute: 'description' | 'kernel' | 'ramdisk' | 'launchPermission' | 'productCodes' | 'blockDeviceMapping' | 'sriovNetSupport';
  };
  declare type EC2$20160401$DescribeImagesRequest = {
    DryRun?: boolean;
    ImageIds?: EC2$20160401$ImageIdStringList;
    Owners?: EC2$20160401$OwnerStringList;
    ExecutableUsers?: EC2$20160401$ExecutableByStringList;
    Filters?: EC2$20160401$FilterList;
  };
  declare type EC2$20160401$DescribeImagesResult = {
    Images?: EC2$20160401$ImageList;
  };
  declare type EC2$20160401$DescribeImportImageTasksRequest = {
    DryRun?: boolean;
    ImportTaskIds?: EC2$20160401$ImportTaskIdList;
    NextToken?: string;
    MaxResults?: number;
    Filters?: EC2$20160401$FilterList;
  };
  declare type EC2$20160401$DescribeImportImageTasksResult = {
    ImportImageTasks?: EC2$20160401$ImportImageTaskList;
    NextToken?: string;
  };
  declare type EC2$20160401$DescribeImportSnapshotTasksRequest = {
    DryRun?: boolean;
    ImportTaskIds?: EC2$20160401$ImportTaskIdList;
    NextToken?: string;
    MaxResults?: number;
    Filters?: EC2$20160401$FilterList;
  };
  declare type EC2$20160401$DescribeImportSnapshotTasksResult = {
    ImportSnapshotTasks?: EC2$20160401$ImportSnapshotTaskList;
    NextToken?: string;
  };
  declare type EC2$20160401$DescribeInstanceAttributeRequest = {
    DryRun?: boolean;
    InstanceId: string;
    Attribute: 'instanceType' | 'kernel' | 'ramdisk' | 'userData' | 'disableApiTermination' | 'instanceInitiatedShutdownBehavior' | 'rootDeviceName' | 'blockDeviceMapping' | 'productCodes' | 'sourceDestCheck' | 'groupSet' | 'ebsOptimized' | 'sriovNetSupport' | 'enaSupport';
  };
  declare type EC2$20160401$DescribeInstanceStatusRequest = {
    DryRun?: boolean;
    InstanceIds?: EC2$20160401$InstanceIdStringList;
    Filters?: EC2$20160401$FilterList;
    NextToken?: string;
    MaxResults?: number;
    IncludeAllInstances?: boolean;
  };
  declare type EC2$20160401$DescribeInstanceStatusResult = {
    InstanceStatuses?: EC2$20160401$InstanceStatusList;
    NextToken?: string;
  };
  declare type EC2$20160401$DescribeInstancesRequest = {
    DryRun?: boolean;
    InstanceIds?: EC2$20160401$InstanceIdStringList;
    Filters?: EC2$20160401$FilterList;
    NextToken?: string;
    MaxResults?: number;
  };
  declare type EC2$20160401$DescribeInstancesResult = {
    Reservations?: EC2$20160401$ReservationList;
    NextToken?: string;
  };
  declare type EC2$20160401$DescribeInternetGatewaysRequest = {
    DryRun?: boolean;
    InternetGatewayIds?: EC2$20160401$ValueStringList;
    Filters?: EC2$20160401$FilterList;
  };
  declare type EC2$20160401$DescribeInternetGatewaysResult = {
    InternetGateways?: EC2$20160401$InternetGatewayList;
  };
  declare type EC2$20160401$DescribeKeyPairsRequest = {
    DryRun?: boolean;
    KeyNames?: EC2$20160401$KeyNameStringList;
    Filters?: EC2$20160401$FilterList;
  };
  declare type EC2$20160401$DescribeKeyPairsResult = {
    KeyPairs?: EC2$20160401$KeyPairList;
  };
  declare type EC2$20160401$DescribeMovingAddressesRequest = {
    DryRun?: boolean;
    PublicIps?: EC2$20160401$ValueStringList;
    NextToken?: string;
    Filters?: EC2$20160401$FilterList;
    MaxResults?: number;
  };
  declare type EC2$20160401$DescribeMovingAddressesResult = {
    MovingAddressStatuses?: EC2$20160401$MovingAddressStatusSet;
    NextToken?: string;
  };
  declare type EC2$20160401$DescribeNatGatewaysRequest = {
    NatGatewayIds?: EC2$20160401$ValueStringList;
    Filter?: EC2$20160401$FilterList;
    MaxResults?: number;
    NextToken?: string;
  };
  declare type EC2$20160401$DescribeNatGatewaysResult = {
    NatGateways?: EC2$20160401$NatGatewayList;
    NextToken?: string;
  };
  declare type EC2$20160401$DescribeNetworkAclsRequest = {
    DryRun?: boolean;
    NetworkAclIds?: EC2$20160401$ValueStringList;
    Filters?: EC2$20160401$FilterList;
  };
  declare type EC2$20160401$DescribeNetworkAclsResult = {
    NetworkAcls?: EC2$20160401$NetworkAclList;
  };
  declare type EC2$20160401$DescribeNetworkInterfaceAttributeRequest = {
    DryRun?: boolean;
    NetworkInterfaceId: string;
    Attribute?: 'description' | 'groupSet' | 'sourceDestCheck' | 'attachment';
  };
  declare type EC2$20160401$DescribeNetworkInterfaceAttributeResult = {
    NetworkInterfaceId?: string;
    Description?: EC2$20160401$AttributeValue;
    SourceDestCheck?: EC2$20160401$AttributeBooleanValue;
    Groups?: EC2$20160401$GroupIdentifierList;
    Attachment?: EC2$20160401$NetworkInterfaceAttachment;
  };
  declare type EC2$20160401$DescribeNetworkInterfacesRequest = {
    DryRun?: boolean;
    NetworkInterfaceIds?: EC2$20160401$NetworkInterfaceIdList;
    Filters?: EC2$20160401$FilterList;
  };
  declare type EC2$20160401$DescribeNetworkInterfacesResult = {
    NetworkInterfaces?: EC2$20160401$NetworkInterfaceList;
  };
  declare type EC2$20160401$DescribePlacementGroupsRequest = {
    DryRun?: boolean;
    GroupNames?: EC2$20160401$PlacementGroupStringList;
    Filters?: EC2$20160401$FilterList;
  };
  declare type EC2$20160401$DescribePlacementGroupsResult = {
    PlacementGroups?: EC2$20160401$PlacementGroupList;
  };
  declare type EC2$20160401$DescribePrefixListsRequest = {
    DryRun?: boolean;
    PrefixListIds?: EC2$20160401$ValueStringList;
    Filters?: EC2$20160401$FilterList;
    MaxResults?: number;
    NextToken?: string;
  };
  declare type EC2$20160401$DescribePrefixListsResult = {
    PrefixLists?: EC2$20160401$PrefixListSet;
    NextToken?: string;
  };
  declare type EC2$20160401$DescribeRegionsRequest = {
    DryRun?: boolean;
    RegionNames?: EC2$20160401$RegionNameStringList;
    Filters?: EC2$20160401$FilterList;
  };
  declare type EC2$20160401$DescribeRegionsResult = {
    Regions?: EC2$20160401$RegionList;
  };
  declare type EC2$20160401$DescribeReservedInstancesListingsRequest = {
    ReservedInstancesId?: string;
    ReservedInstancesListingId?: string;
    Filters?: EC2$20160401$FilterList;
  };
  declare type EC2$20160401$DescribeReservedInstancesListingsResult = {
    ReservedInstancesListings?: EC2$20160401$ReservedInstancesListingList;
  };
  declare type EC2$20160401$DescribeReservedInstancesModificationsRequest = {
    ReservedInstancesModificationIds?: EC2$20160401$ReservedInstancesModificationIdStringList;
    NextToken?: string;
    Filters?: EC2$20160401$FilterList;
  };
  declare type EC2$20160401$DescribeReservedInstancesModificationsResult = {
    ReservedInstancesModifications?: EC2$20160401$ReservedInstancesModificationList;
    NextToken?: string;
  };
  declare type EC2$20160401$DescribeReservedInstancesOfferingsRequest = {
    DryRun?: boolean;
    ReservedInstancesOfferingIds?: EC2$20160401$ReservedInstancesOfferingIdStringList;
    InstanceType?: 't1.micro' | 't2.nano' | 't2.micro' | 't2.small' | 't2.medium' | 't2.large' | 'm1.small' | 'm1.medium' | 'm1.large' | 'm1.xlarge' | 'm3.medium' | 'm3.large' | 'm3.xlarge' | 'm3.2xlarge' | 'm4.large' | 'm4.xlarge' | 'm4.2xlarge' | 'm4.4xlarge' | 'm4.10xlarge' | 'm2.xlarge' | 'm2.2xlarge' | 'm2.4xlarge' | 'cr1.8xlarge' | 'r3.large' | 'r3.xlarge' | 'r3.2xlarge' | 'r3.4xlarge' | 'r3.8xlarge' | 'x1.4xlarge' | 'x1.8xlarge' | 'x1.16xlarge' | 'x1.32xlarge' | 'i2.xlarge' | 'i2.2xlarge' | 'i2.4xlarge' | 'i2.8xlarge' | 'hi1.4xlarge' | 'hs1.8xlarge' | 'c1.medium' | 'c1.xlarge' | 'c3.large' | 'c3.xlarge' | 'c3.2xlarge' | 'c3.4xlarge' | 'c3.8xlarge' | 'c4.large' | 'c4.xlarge' | 'c4.2xlarge' | 'c4.4xlarge' | 'c4.8xlarge' | 'cc1.4xlarge' | 'cc2.8xlarge' | 'g2.2xlarge' | 'g2.8xlarge' | 'cg1.4xlarge' | 'd2.xlarge' | 'd2.2xlarge' | 'd2.4xlarge' | 'd2.8xlarge';
    AvailabilityZone?: string;
    ProductDescription?: 'Linux/UNIX' | 'Linux/UNIX (Amazon VPC)' | 'Windows' | 'Windows (Amazon VPC)';
    Filters?: EC2$20160401$FilterList;
    InstanceTenancy?: 'default' | 'dedicated' | 'host';
    OfferingType?: 'Heavy Utilization' | 'Medium Utilization' | 'Light Utilization' | 'No Upfront' | 'Partial Upfront' | 'All Upfront';
    NextToken?: string;
    MaxResults?: number;
    IncludeMarketplace?: boolean;
    MinDuration?: number;
    MaxDuration?: number;
    MaxInstanceCount?: number;
  };
  declare type EC2$20160401$DescribeReservedInstancesOfferingsResult = {
    ReservedInstancesOfferings?: EC2$20160401$ReservedInstancesOfferingList;
    NextToken?: string;
  };
  declare type EC2$20160401$DescribeReservedInstancesRequest = {
    DryRun?: boolean;
    ReservedInstancesIds?: EC2$20160401$ReservedInstancesIdStringList;
    Filters?: EC2$20160401$FilterList;
    OfferingType?: 'Heavy Utilization' | 'Medium Utilization' | 'Light Utilization' | 'No Upfront' | 'Partial Upfront' | 'All Upfront';
  };
  declare type EC2$20160401$DescribeReservedInstancesResult = {
    ReservedInstances?: EC2$20160401$ReservedInstancesList;
  };
  declare type EC2$20160401$DescribeRouteTablesRequest = {
    DryRun?: boolean;
    RouteTableIds?: EC2$20160401$ValueStringList;
    Filters?: EC2$20160401$FilterList;
  };
  declare type EC2$20160401$DescribeRouteTablesResult = {
    RouteTables?: EC2$20160401$RouteTableList;
  };
  declare type EC2$20160401$DescribeScheduledInstanceAvailabilityRequest = {
    DryRun?: boolean;
    Recurrence: EC2$20160401$ScheduledInstanceRecurrenceRequest;
    FirstSlotStartTimeRange: EC2$20160401$SlotDateTimeRangeRequest;
    MinSlotDurationInHours?: number;
    MaxSlotDurationInHours?: number;
    NextToken?: string;
    MaxResults?: number;
    Filters?: EC2$20160401$FilterList;
  };
  declare type EC2$20160401$DescribeScheduledInstanceAvailabilityResult = {
    NextToken?: string;
    ScheduledInstanceAvailabilitySet?: EC2$20160401$ScheduledInstanceAvailabilitySet;
  };
  declare type EC2$20160401$DescribeScheduledInstancesRequest = {
    DryRun?: boolean;
    ScheduledInstanceIds?: EC2$20160401$ScheduledInstanceIdRequestSet;
    SlotStartTimeRange?: EC2$20160401$SlotStartTimeRangeRequest;
    NextToken?: string;
    MaxResults?: number;
    Filters?: EC2$20160401$FilterList;
  };
  declare type EC2$20160401$DescribeScheduledInstancesResult = {
    NextToken?: string;
    ScheduledInstanceSet?: EC2$20160401$ScheduledInstanceSet;
  };
  declare type EC2$20160401$DescribeSecurityGroupReferencesRequest = {
    DryRun?: boolean;
    GroupId: EC2$20160401$GroupIds;
  };
  declare type EC2$20160401$DescribeSecurityGroupReferencesResult = {
    SecurityGroupReferenceSet?: EC2$20160401$SecurityGroupReferences;
  };
  declare type EC2$20160401$DescribeSecurityGroupsRequest = {
    DryRun?: boolean;
    GroupNames?: EC2$20160401$GroupNameStringList;
    GroupIds?: EC2$20160401$GroupIdStringList;
    Filters?: EC2$20160401$FilterList;
  };
  declare type EC2$20160401$DescribeSecurityGroupsResult = {
    SecurityGroups?: EC2$20160401$SecurityGroupList;
  };
  declare type EC2$20160401$DescribeSnapshotAttributeRequest = {
    DryRun?: boolean;
    SnapshotId: string;
    Attribute: 'productCodes' | 'createVolumePermission';
  };
  declare type EC2$20160401$DescribeSnapshotAttributeResult = {
    SnapshotId?: string;
    CreateVolumePermissions?: EC2$20160401$CreateVolumePermissionList;
    ProductCodes?: EC2$20160401$ProductCodeList;
  };
  declare type EC2$20160401$DescribeSnapshotsRequest = {
    DryRun?: boolean;
    SnapshotIds?: EC2$20160401$SnapshotIdStringList;
    OwnerIds?: EC2$20160401$OwnerStringList;
    RestorableByUserIds?: EC2$20160401$RestorableByStringList;
    Filters?: EC2$20160401$FilterList;
    NextToken?: string;
    MaxResults?: number;
  };
  declare type EC2$20160401$DescribeSnapshotsResult = {
    Snapshots?: EC2$20160401$SnapshotList;
    NextToken?: string;
  };
  declare type EC2$20160401$DescribeSpotDatafeedSubscriptionRequest = {
    DryRun?: boolean;
  };
  declare type EC2$20160401$DescribeSpotDatafeedSubscriptionResult = {
    SpotDatafeedSubscription?: EC2$20160401$SpotDatafeedSubscription;
  };
  declare type EC2$20160401$DescribeSpotFleetInstancesRequest = {
    DryRun?: boolean;
    SpotFleetRequestId: string;
    NextToken?: string;
    MaxResults?: number;
  };
  declare type EC2$20160401$DescribeSpotFleetInstancesResponse = {
    SpotFleetRequestId: string;
    ActiveInstances: EC2$20160401$ActiveInstanceSet;
    NextToken?: string;
  };
  declare type EC2$20160401$DescribeSpotFleetRequestHistoryRequest = {
    DryRun?: boolean;
    SpotFleetRequestId: string;
    EventType?: 'instanceChange' | 'fleetRequestChange' | 'error';
    StartTime: Date;
    NextToken?: string;
    MaxResults?: number;
  };
  declare type EC2$20160401$DescribeSpotFleetRequestHistoryResponse = {
    SpotFleetRequestId: string;
    StartTime: Date;
    LastEvaluatedTime: Date;
    HistoryRecords: EC2$20160401$HistoryRecords;
    NextToken?: string;
  };
  declare type EC2$20160401$DescribeSpotFleetRequestsRequest = {
    DryRun?: boolean;
    SpotFleetRequestIds?: EC2$20160401$ValueStringList;
    NextToken?: string;
    MaxResults?: number;
  };
  declare type EC2$20160401$DescribeSpotFleetRequestsResponse = {
    SpotFleetRequestConfigs: EC2$20160401$SpotFleetRequestConfigSet;
    NextToken?: string;
  };
  declare type EC2$20160401$DescribeSpotInstanceRequestsRequest = {
    DryRun?: boolean;
    SpotInstanceRequestIds?: EC2$20160401$SpotInstanceRequestIdList;
    Filters?: EC2$20160401$FilterList;
  };
  declare type EC2$20160401$DescribeSpotInstanceRequestsResult = {
    SpotInstanceRequests?: EC2$20160401$SpotInstanceRequestList;
  };
  declare type EC2$20160401$DescribeSpotPriceHistoryRequest = {
    DryRun?: boolean;
    StartTime?: Date;
    EndTime?: Date;
    InstanceTypes?: EC2$20160401$InstanceTypeList;
    ProductDescriptions?: EC2$20160401$ProductDescriptionList;
    Filters?: EC2$20160401$FilterList;
    AvailabilityZone?: string;
    MaxResults?: number;
    NextToken?: string;
  };
  declare type EC2$20160401$DescribeSpotPriceHistoryResult = {
    SpotPriceHistory?: EC2$20160401$SpotPriceHistoryList;
    NextToken?: string;
  };
  declare type EC2$20160401$DescribeStaleSecurityGroupsRequest = {
    DryRun?: boolean;
    VpcId: string;
    MaxResults?: number;
    NextToken?: string;
  };
  declare type EC2$20160401$DescribeStaleSecurityGroupsResult = {
    StaleSecurityGroupSet?: EC2$20160401$StaleSecurityGroupSet;
    NextToken?: string;
  };
  declare type EC2$20160401$DescribeSubnetsRequest = {
    DryRun?: boolean;
    SubnetIds?: EC2$20160401$SubnetIdStringList;
    Filters?: EC2$20160401$FilterList;
  };
  declare type EC2$20160401$DescribeSubnetsResult = {
    Subnets?: EC2$20160401$SubnetList;
  };
  declare type EC2$20160401$DescribeTagsRequest = {
    DryRun?: boolean;
    Filters?: EC2$20160401$FilterList;
    MaxResults?: number;
    NextToken?: string;
  };
  declare type EC2$20160401$DescribeTagsResult = {
    Tags?: EC2$20160401$TagDescriptionList;
    NextToken?: string;
  };
  declare type EC2$20160401$DescribeVolumeAttributeRequest = {
    DryRun?: boolean;
    VolumeId: string;
    Attribute?: 'autoEnableIO' | 'productCodes';
  };
  declare type EC2$20160401$DescribeVolumeAttributeResult = {
    VolumeId?: string;
    AutoEnableIO?: EC2$20160401$AttributeBooleanValue;
    ProductCodes?: EC2$20160401$ProductCodeList;
  };
  declare type EC2$20160401$DescribeVolumeStatusRequest = {
    DryRun?: boolean;
    VolumeIds?: EC2$20160401$VolumeIdStringList;
    Filters?: EC2$20160401$FilterList;
    NextToken?: string;
    MaxResults?: number;
  };
  declare type EC2$20160401$DescribeVolumeStatusResult = {
    VolumeStatuses?: EC2$20160401$VolumeStatusList;
    NextToken?: string;
  };
  declare type EC2$20160401$DescribeVolumesRequest = {
    DryRun?: boolean;
    VolumeIds?: EC2$20160401$VolumeIdStringList;
    Filters?: EC2$20160401$FilterList;
    NextToken?: string;
    MaxResults?: number;
  };
  declare type EC2$20160401$DescribeVolumesResult = {
    Volumes?: EC2$20160401$VolumeList;
    NextToken?: string;
  };
  declare type EC2$20160401$DescribeVpcAttributeRequest = {
    DryRun?: boolean;
    VpcId: string;
    Attribute: 'enableDnsSupport' | 'enableDnsHostnames';
  };
  declare type EC2$20160401$DescribeVpcAttributeResult = {
    VpcId?: string;
    EnableDnsSupport?: EC2$20160401$AttributeBooleanValue;
    EnableDnsHostnames?: EC2$20160401$AttributeBooleanValue;
  };
  declare type EC2$20160401$DescribeVpcClassicLinkDnsSupportRequest = {
    VpcIds?: EC2$20160401$VpcClassicLinkIdList;
    MaxResults?: number;
    NextToken?: string;
  };
  declare type EC2$20160401$DescribeVpcClassicLinkDnsSupportResult = {
    Vpcs?: EC2$20160401$ClassicLinkDnsSupportList;
    NextToken?: string;
  };
  declare type EC2$20160401$DescribeVpcClassicLinkRequest = {
    DryRun?: boolean;
    VpcIds?: EC2$20160401$VpcClassicLinkIdList;
    Filters?: EC2$20160401$FilterList;
  };
  declare type EC2$20160401$DescribeVpcClassicLinkResult = {
    Vpcs?: EC2$20160401$VpcClassicLinkList;
  };
  declare type EC2$20160401$DescribeVpcEndpointServicesRequest = {
    DryRun?: boolean;
    MaxResults?: number;
    NextToken?: string;
  };
  declare type EC2$20160401$DescribeVpcEndpointServicesResult = {
    ServiceNames?: EC2$20160401$ValueStringList;
    NextToken?: string;
  };
  declare type EC2$20160401$DescribeVpcEndpointsRequest = {
    DryRun?: boolean;
    VpcEndpointIds?: EC2$20160401$ValueStringList;
    Filters?: EC2$20160401$FilterList;
    MaxResults?: number;
    NextToken?: string;
  };
  declare type EC2$20160401$DescribeVpcEndpointsResult = {
    VpcEndpoints?: EC2$20160401$VpcEndpointSet;
    NextToken?: string;
  };
  declare type EC2$20160401$DescribeVpcPeeringConnectionsRequest = {
    DryRun?: boolean;
    VpcPeeringConnectionIds?: EC2$20160401$ValueStringList;
    Filters?: EC2$20160401$FilterList;
  };
  declare type EC2$20160401$DescribeVpcPeeringConnectionsResult = {
    VpcPeeringConnections?: EC2$20160401$VpcPeeringConnectionList;
  };
  declare type EC2$20160401$DescribeVpcsRequest = {
    DryRun?: boolean;
    VpcIds?: EC2$20160401$VpcIdStringList;
    Filters?: EC2$20160401$FilterList;
  };
  declare type EC2$20160401$DescribeVpcsResult = {
    Vpcs?: EC2$20160401$VpcList;
  };
  declare type EC2$20160401$DescribeVpnConnectionsRequest = {
    DryRun?: boolean;
    VpnConnectionIds?: EC2$20160401$VpnConnectionIdStringList;
    Filters?: EC2$20160401$FilterList;
  };
  declare type EC2$20160401$DescribeVpnConnectionsResult = {
    VpnConnections?: EC2$20160401$VpnConnectionList;
  };
  declare type EC2$20160401$DescribeVpnGatewaysRequest = {
    DryRun?: boolean;
    VpnGatewayIds?: EC2$20160401$VpnGatewayIdStringList;
    Filters?: EC2$20160401$FilterList;
  };
  declare type EC2$20160401$DescribeVpnGatewaysResult = {
    VpnGateways?: EC2$20160401$VpnGatewayList;
  };
  declare type EC2$20160401$DetachClassicLinkVpcRequest = {
    DryRun?: boolean;
    InstanceId: string;
    VpcId: string;
  };
  declare type EC2$20160401$DetachClassicLinkVpcResult = {
    Return?: boolean;
  };
  declare type EC2$20160401$DetachInternetGatewayRequest = {
    DryRun?: boolean;
    InternetGatewayId: string;
    VpcId: string;
  };
  declare type EC2$20160401$DetachNetworkInterfaceRequest = {
    DryRun?: boolean;
    AttachmentId: string;
    Force?: boolean;
  };
  declare type EC2$20160401$DetachVolumeRequest = {
    DryRun?: boolean;
    VolumeId: string;
    InstanceId?: string;
    Device?: string;
    Force?: boolean;
  };
  declare type EC2$20160401$DetachVpnGatewayRequest = {
    DryRun?: boolean;
    VpnGatewayId: string;
    VpcId: string;
  };
  declare type EC2$20160401$DeviceType = 'ebs' | 'instance-store';
  declare type EC2$20160401$DhcpConfiguration = {
    Key?: string;
    Values?: EC2$20160401$DhcpConfigurationValueList;
  };
  declare type EC2$20160401$DhcpConfigurationList = EC2$20160401$DhcpConfiguration[];
  declare type EC2$20160401$DhcpConfigurationValueList = EC2$20160401$AttributeValue[];
  declare type EC2$20160401$DhcpOptions = {
    DhcpOptionsId?: string;
    DhcpConfigurations?: EC2$20160401$DhcpConfigurationList;
    Tags?: EC2$20160401$TagList;
  };
  declare type EC2$20160401$DhcpOptionsIdStringList = string[];
  declare type EC2$20160401$DhcpOptionsList = EC2$20160401$DhcpOptions[];
  declare type EC2$20160401$DisableVgwRoutePropagationRequest = {
    RouteTableId: string;
    GatewayId: string;
  };
  declare type EC2$20160401$DisableVpcClassicLinkDnsSupportRequest = {
    VpcId?: string;
  };
  declare type EC2$20160401$DisableVpcClassicLinkDnsSupportResult = {
    Return?: boolean;
  };
  declare type EC2$20160401$DisableVpcClassicLinkRequest = {
    DryRun?: boolean;
    VpcId: string;
  };
  declare type EC2$20160401$DisableVpcClassicLinkResult = {
    Return?: boolean;
  };
  declare type EC2$20160401$DisassociateAddressRequest = {
    DryRun?: boolean;
    PublicIp?: string;
    AssociationId?: string;
  };
  declare type EC2$20160401$DisassociateRouteTableRequest = {
    DryRun?: boolean;
    AssociationId: string;
  };
  declare type EC2$20160401$DiskImage = {
    Image?: EC2$20160401$DiskImageDetail;
    Description?: string;
    Volume?: EC2$20160401$VolumeDetail;
  };
  declare type EC2$20160401$DiskImageDescription = {
    Format: 'VMDK' | 'RAW' | 'VHD';
    Size: number;
    ImportManifestUrl: string;
    Checksum?: string;
  };
  declare type EC2$20160401$DiskImageDetail = {
    Format: 'VMDK' | 'RAW' | 'VHD';
    Bytes: number;
    ImportManifestUrl: string;
  };
  declare type EC2$20160401$DiskImageFormat = 'VMDK' | 'RAW' | 'VHD';
  declare type EC2$20160401$DiskImageList = EC2$20160401$DiskImage[];
  declare type EC2$20160401$DiskImageVolumeDescription = {
    Size?: number;
    Id: string;
  };
  declare type EC2$20160401$DomainType = 'vpc' | 'standard';
  declare type EC2$20160401$EbsBlockDevice = {
    SnapshotId?: string;
    VolumeSize?: number;
    DeleteOnTermination?: boolean;
    VolumeType?: 'standard' | 'io1' | 'gp2' | 'sc1' | 'st1';
    Iops?: number;
    Encrypted?: boolean;
  };
  declare type EC2$20160401$EbsInstanceBlockDevice = {
    VolumeId?: string;
    Status?: 'attaching' | 'attached' | 'detaching' | 'detached';
    AttachTime?: Date;
    DeleteOnTermination?: boolean;
  };
  declare type EC2$20160401$EbsInstanceBlockDeviceSpecification = {
    VolumeId?: string;
    DeleteOnTermination?: boolean;
  };
  declare type EC2$20160401$EnableVgwRoutePropagationRequest = {
    RouteTableId: string;
    GatewayId: string;
  };
  declare type EC2$20160401$EnableVolumeIORequest = {
    DryRun?: boolean;
    VolumeId: string;
  };
  declare type EC2$20160401$EnableVpcClassicLinkDnsSupportRequest = {
    VpcId?: string;
  };
  declare type EC2$20160401$EnableVpcClassicLinkDnsSupportResult = {
    Return?: boolean;
  };
  declare type EC2$20160401$EnableVpcClassicLinkRequest = {
    DryRun?: boolean;
    VpcId: string;
  };
  declare type EC2$20160401$EnableVpcClassicLinkResult = {
    Return?: boolean;
  };
  declare type EC2$20160401$EventCode = 'instance-reboot' | 'system-reboot' | 'system-maintenance' | 'instance-retirement' | 'instance-stop';
  declare type EC2$20160401$EventInformation = {
    InstanceId?: string;
    EventSubType?: string;
    EventDescription?: string;
  };
  declare type EC2$20160401$EventType = 'instanceChange' | 'fleetRequestChange' | 'error';
  declare type EC2$20160401$ExcessCapacityTerminationPolicy = 'noTermination' | 'default';
  declare type EC2$20160401$ExecutableByStringList = string[];
  declare type EC2$20160401$ExportEnvironment = 'citrix' | 'vmware' | 'microsoft';
  declare type EC2$20160401$ExportTask = {
    ExportTaskId?: string;
    Description?: string;
    State?: 'active' | 'cancelling' | 'cancelled' | 'completed';
    StatusMessage?: string;
    InstanceExportDetails?: EC2$20160401$InstanceExportDetails;
    ExportToS3Task?: EC2$20160401$ExportToS3Task;
  };
  declare type EC2$20160401$ExportTaskIdStringList = string[];
  declare type EC2$20160401$ExportTaskList = EC2$20160401$ExportTask[];
  declare type EC2$20160401$ExportTaskState = 'active' | 'cancelling' | 'cancelled' | 'completed';
  declare type EC2$20160401$ExportToS3Task = {
    DiskImageFormat?: 'VMDK' | 'RAW' | 'VHD';
    ContainerFormat?: 'ova';
    S3Bucket?: string;
    S3Key?: string;
  };
  declare type EC2$20160401$ExportToS3TaskSpecification = {
    DiskImageFormat?: 'VMDK' | 'RAW' | 'VHD';
    ContainerFormat?: 'ova';
    S3Bucket?: string;
    S3Prefix?: string;
  };
  declare type EC2$20160401$Filter = {
    Name?: string;
    Values?: EC2$20160401$ValueStringList;
  };
  declare type EC2$20160401$FilterList = EC2$20160401$Filter[];
  declare type EC2$20160401$FleetType = 'request' | 'maintain';
  declare type EC2$20160401$FlowLog = {
    CreationTime?: Date;
    FlowLogId?: string;
    FlowLogStatus?: string;
    ResourceId?: string;
    TrafficType?: 'ACCEPT' | 'REJECT' | 'ALL';
    LogGroupName?: string;
    DeliverLogsStatus?: string;
    DeliverLogsErrorMessage?: string;
    DeliverLogsPermissionArn?: string;
  };
  declare type EC2$20160401$FlowLogSet = EC2$20160401$FlowLog[];
  declare type EC2$20160401$FlowLogsResourceType = 'VPC' | 'Subnet' | 'NetworkInterface';
  declare type EC2$20160401$GatewayType = 'ipsec.1';
  declare type EC2$20160401$GetConsoleOutputRequest = {
    DryRun?: boolean;
    InstanceId: string;
  };
  declare type EC2$20160401$GetConsoleOutputResult = {
    InstanceId?: string;
    Timestamp?: Date;
    Output?: string;
  };
  declare type EC2$20160401$GetConsoleScreenshotRequest = {
    DryRun?: boolean;
    InstanceId: string;
    WakeUp?: boolean;
  };
  declare type EC2$20160401$GetConsoleScreenshotResult = {
    InstanceId?: string;
    ImageData?: string;
  };
  declare type EC2$20160401$GetPasswordDataRequest = {
    DryRun?: boolean;
    InstanceId: string;
  };
  declare type EC2$20160401$GetPasswordDataResult = {
    InstanceId?: string;
    Timestamp?: Date;
    PasswordData?: string;
  };
  declare type EC2$20160401$GroupIdStringList = string[];
  declare type EC2$20160401$GroupIdentifier = {
    GroupName?: string;
    GroupId?: string;
  };
  declare type EC2$20160401$GroupIdentifierList = EC2$20160401$GroupIdentifier[];
  declare type EC2$20160401$GroupIds = string[];
  declare type EC2$20160401$GroupNameStringList = string[];
  declare type EC2$20160401$HistoryRecord = {
    Timestamp: Date;
    EventType: 'instanceChange' | 'fleetRequestChange' | 'error';
    EventInformation: EC2$20160401$EventInformation;
  };
  declare type EC2$20160401$HistoryRecords = EC2$20160401$HistoryRecord[];
  declare type EC2$20160401$Host = {
    HostId?: string;
    AutoPlacement?: 'on' | 'off';
    HostReservationId?: string;
    ClientToken?: string;
    HostProperties?: EC2$20160401$HostProperties;
    State?: 'available' | 'under-assessment' | 'permanent-failure' | 'released' | 'released-permanent-failure';
    AvailabilityZone?: string;
    Instances?: EC2$20160401$HostInstanceList;
    AvailableCapacity?: EC2$20160401$AvailableCapacity;
  };
  declare type EC2$20160401$HostInstance = {
    InstanceId?: string;
    InstanceType?: string;
  };
  declare type EC2$20160401$HostInstanceList = EC2$20160401$HostInstance[];
  declare type EC2$20160401$HostList = EC2$20160401$Host[];
  declare type EC2$20160401$HostProperties = {
    Sockets?: number;
    Cores?: number;
    TotalVCpus?: number;
    InstanceType?: string;
  };
  declare type EC2$20160401$HostTenancy = 'dedicated' | 'host';
  declare type EC2$20160401$HypervisorType = 'ovm' | 'xen';
  declare type EC2$20160401$IamInstanceProfile = {
    Arn?: string;
    Id?: string;
  };
  declare type EC2$20160401$IamInstanceProfileSpecification = {
    Arn?: string;
    Name?: string;
  };
  declare type EC2$20160401$IcmpTypeCode = {
    Type?: number;
    Code?: number;
  };
  declare type EC2$20160401$IdFormat = {
    Resource?: string;
    UseLongIds?: boolean;
    Deadline?: Date;
  };
  declare type EC2$20160401$IdFormatList = EC2$20160401$IdFormat[];
  declare type EC2$20160401$Image = {
    ImageId?: string;
    ImageLocation?: string;
    State?: 'pending' | 'available' | 'invalid' | 'deregistered' | 'transient' | 'failed' | 'error';
    OwnerId?: string;
    CreationDate?: string;
    Public?: boolean;
    ProductCodes?: EC2$20160401$ProductCodeList;
    Architecture?: 'i386' | 'x86_64';
    ImageType?: 'machine' | 'kernel' | 'ramdisk';
    KernelId?: string;
    RamdiskId?: string;
    Platform?: 'Windows';
    SriovNetSupport?: string;
    EnaSupport?: boolean;
    StateReason?: EC2$20160401$StateReason;
    ImageOwnerAlias?: string;
    Name?: string;
    Description?: string;
    RootDeviceType?: 'ebs' | 'instance-store';
    RootDeviceName?: string;
    BlockDeviceMappings?: EC2$20160401$BlockDeviceMappingList;
    VirtualizationType?: 'hvm' | 'paravirtual';
    Tags?: EC2$20160401$TagList;
    Hypervisor?: 'ovm' | 'xen';
  };
  declare type EC2$20160401$ImageAttribute = {
    ImageId?: string;
    LaunchPermissions?: EC2$20160401$LaunchPermissionList;
    ProductCodes?: EC2$20160401$ProductCodeList;
    KernelId?: EC2$20160401$AttributeValue;
    RamdiskId?: EC2$20160401$AttributeValue;
    Description?: EC2$20160401$AttributeValue;
    SriovNetSupport?: EC2$20160401$AttributeValue;
    BlockDeviceMappings?: EC2$20160401$BlockDeviceMappingList;
  };
  declare type EC2$20160401$ImageAttributeName = 'description' | 'kernel' | 'ramdisk' | 'launchPermission' | 'productCodes' | 'blockDeviceMapping' | 'sriovNetSupport';
  declare type EC2$20160401$ImageDiskContainer = {
    Description?: string;
    Format?: string;
    Url?: string;
    UserBucket?: EC2$20160401$UserBucket;
    DeviceName?: string;
    SnapshotId?: string;
  };
  declare type EC2$20160401$ImageDiskContainerList = EC2$20160401$ImageDiskContainer[];
  declare type EC2$20160401$ImageIdStringList = string[];
  declare type EC2$20160401$ImageList = EC2$20160401$Image[];
  declare type EC2$20160401$ImageState = 'pending' | 'available' | 'invalid' | 'deregistered' | 'transient' | 'failed' | 'error';
  declare type EC2$20160401$ImageTypeValues = 'machine' | 'kernel' | 'ramdisk';
  declare type EC2$20160401$ImportImageRequest = {
    DryRun?: boolean;
    Description?: string;
    DiskContainers?: EC2$20160401$ImageDiskContainerList;
    LicenseType?: string;
    Hypervisor?: string;
    Architecture?: string;
    Platform?: string;
    ClientData?: EC2$20160401$ClientData;
    ClientToken?: string;
    RoleName?: string;
  };
  declare type EC2$20160401$ImportImageResult = {
    ImportTaskId?: string;
    Architecture?: string;
    LicenseType?: string;
    Platform?: string;
    Hypervisor?: string;
    Description?: string;
    SnapshotDetails?: EC2$20160401$SnapshotDetailList;
    ImageId?: string;
    Progress?: string;
    StatusMessage?: string;
    Status?: string;
  };
  declare type EC2$20160401$ImportImageTask = {
    ImportTaskId?: string;
    Architecture?: string;
    LicenseType?: string;
    Platform?: string;
    Hypervisor?: string;
    Description?: string;
    SnapshotDetails?: EC2$20160401$SnapshotDetailList;
    ImageId?: string;
    Progress?: string;
    StatusMessage?: string;
    Status?: string;
  };
  declare type EC2$20160401$ImportImageTaskList = EC2$20160401$ImportImageTask[];
  declare type EC2$20160401$ImportInstanceLaunchSpecification = {
    Architecture?: 'i386' | 'x86_64';
    GroupNames?: EC2$20160401$SecurityGroupStringList;
    GroupIds?: EC2$20160401$SecurityGroupIdStringList;
    AdditionalInfo?: string;
    UserData?: EC2$20160401$UserData;
    InstanceType?: 't1.micro' | 't2.nano' | 't2.micro' | 't2.small' | 't2.medium' | 't2.large' | 'm1.small' | 'm1.medium' | 'm1.large' | 'm1.xlarge' | 'm3.medium' | 'm3.large' | 'm3.xlarge' | 'm3.2xlarge' | 'm4.large' | 'm4.xlarge' | 'm4.2xlarge' | 'm4.4xlarge' | 'm4.10xlarge' | 'm2.xlarge' | 'm2.2xlarge' | 'm2.4xlarge' | 'cr1.8xlarge' | 'r3.large' | 'r3.xlarge' | 'r3.2xlarge' | 'r3.4xlarge' | 'r3.8xlarge' | 'x1.4xlarge' | 'x1.8xlarge' | 'x1.16xlarge' | 'x1.32xlarge' | 'i2.xlarge' | 'i2.2xlarge' | 'i2.4xlarge' | 'i2.8xlarge' | 'hi1.4xlarge' | 'hs1.8xlarge' | 'c1.medium' | 'c1.xlarge' | 'c3.large' | 'c3.xlarge' | 'c3.2xlarge' | 'c3.4xlarge' | 'c3.8xlarge' | 'c4.large' | 'c4.xlarge' | 'c4.2xlarge' | 'c4.4xlarge' | 'c4.8xlarge' | 'cc1.4xlarge' | 'cc2.8xlarge' | 'g2.2xlarge' | 'g2.8xlarge' | 'cg1.4xlarge' | 'd2.xlarge' | 'd2.2xlarge' | 'd2.4xlarge' | 'd2.8xlarge';
    Placement?: EC2$20160401$Placement;
    Monitoring?: boolean;
    SubnetId?: string;
    InstanceInitiatedShutdownBehavior?: 'stop' | 'terminate';
    PrivateIpAddress?: string;
  };
  declare type EC2$20160401$ImportInstanceRequest = {
    DryRun?: boolean;
    Description?: string;
    LaunchSpecification?: EC2$20160401$ImportInstanceLaunchSpecification;
    DiskImages?: EC2$20160401$DiskImageList;
    Platform: 'Windows';
  };
  declare type EC2$20160401$ImportInstanceResult = {
    ConversionTask?: EC2$20160401$ConversionTask;
  };
  declare type EC2$20160401$ImportInstanceTaskDetails = {
    Volumes: EC2$20160401$ImportInstanceVolumeDetailSet;
    InstanceId?: string;
    Platform?: 'Windows';
    Description?: string;
  };
  declare type EC2$20160401$ImportInstanceVolumeDetailItem = {
    BytesConverted: number;
    AvailabilityZone: string;
    Image: EC2$20160401$DiskImageDescription;
    Volume: EC2$20160401$DiskImageVolumeDescription;
    Status: string;
    StatusMessage?: string;
    Description?: string;
  };
  declare type EC2$20160401$ImportInstanceVolumeDetailSet = EC2$20160401$ImportInstanceVolumeDetailItem[];
  declare type EC2$20160401$ImportKeyPairRequest = {
    DryRun?: boolean;
    KeyName: string;
    PublicKeyMaterial: Buffer | $TypedArray | Blob | string;
  };
  declare type EC2$20160401$ImportKeyPairResult = {
    KeyName?: string;
    KeyFingerprint?: string;
  };
  declare type EC2$20160401$ImportSnapshotRequest = {
    DryRun?: boolean;
    Description?: string;
    DiskContainer?: EC2$20160401$SnapshotDiskContainer;
    ClientData?: EC2$20160401$ClientData;
    ClientToken?: string;
    RoleName?: string;
  };
  declare type EC2$20160401$ImportSnapshotResult = {
    ImportTaskId?: string;
    SnapshotTaskDetail?: EC2$20160401$SnapshotTaskDetail;
    Description?: string;
  };
  declare type EC2$20160401$ImportSnapshotTask = {
    ImportTaskId?: string;
    SnapshotTaskDetail?: EC2$20160401$SnapshotTaskDetail;
    Description?: string;
  };
  declare type EC2$20160401$ImportSnapshotTaskList = EC2$20160401$ImportSnapshotTask[];
  declare type EC2$20160401$ImportTaskIdList = string[];
  declare type EC2$20160401$ImportVolumeRequest = {
    DryRun?: boolean;
    AvailabilityZone: string;
    Image: EC2$20160401$DiskImageDetail;
    Description?: string;
    Volume: EC2$20160401$VolumeDetail;
  };
  declare type EC2$20160401$ImportVolumeResult = {
    ConversionTask?: EC2$20160401$ConversionTask;
  };
  declare type EC2$20160401$ImportVolumeTaskDetails = {
    BytesConverted: number;
    AvailabilityZone: string;
    Description?: string;
    Image: EC2$20160401$DiskImageDescription;
    Volume: EC2$20160401$DiskImageVolumeDescription;
  };
  declare type EC2$20160401$Instance = {
    InstanceId?: string;
    ImageId?: string;
    State?: EC2$20160401$InstanceState;
    PrivateDnsName?: string;
    PublicDnsName?: string;
    StateTransitionReason?: string;
    KeyName?: string;
    AmiLaunchIndex?: number;
    ProductCodes?: EC2$20160401$ProductCodeList;
    InstanceType?: 't1.micro' | 't2.nano' | 't2.micro' | 't2.small' | 't2.medium' | 't2.large' | 'm1.small' | 'm1.medium' | 'm1.large' | 'm1.xlarge' | 'm3.medium' | 'm3.large' | 'm3.xlarge' | 'm3.2xlarge' | 'm4.large' | 'm4.xlarge' | 'm4.2xlarge' | 'm4.4xlarge' | 'm4.10xlarge' | 'm2.xlarge' | 'm2.2xlarge' | 'm2.4xlarge' | 'cr1.8xlarge' | 'r3.large' | 'r3.xlarge' | 'r3.2xlarge' | 'r3.4xlarge' | 'r3.8xlarge' | 'x1.4xlarge' | 'x1.8xlarge' | 'x1.16xlarge' | 'x1.32xlarge' | 'i2.xlarge' | 'i2.2xlarge' | 'i2.4xlarge' | 'i2.8xlarge' | 'hi1.4xlarge' | 'hs1.8xlarge' | 'c1.medium' | 'c1.xlarge' | 'c3.large' | 'c3.xlarge' | 'c3.2xlarge' | 'c3.4xlarge' | 'c3.8xlarge' | 'c4.large' | 'c4.xlarge' | 'c4.2xlarge' | 'c4.4xlarge' | 'c4.8xlarge' | 'cc1.4xlarge' | 'cc2.8xlarge' | 'g2.2xlarge' | 'g2.8xlarge' | 'cg1.4xlarge' | 'd2.xlarge' | 'd2.2xlarge' | 'd2.4xlarge' | 'd2.8xlarge';
    LaunchTime?: Date;
    Placement?: EC2$20160401$Placement;
    KernelId?: string;
    RamdiskId?: string;
    Platform?: 'Windows';
    Monitoring?: EC2$20160401$Monitoring;
    SubnetId?: string;
    VpcId?: string;
    PrivateIpAddress?: string;
    PublicIpAddress?: string;
    StateReason?: EC2$20160401$StateReason;
    Architecture?: 'i386' | 'x86_64';
    RootDeviceType?: 'ebs' | 'instance-store';
    RootDeviceName?: string;
    BlockDeviceMappings?: EC2$20160401$InstanceBlockDeviceMappingList;
    VirtualizationType?: 'hvm' | 'paravirtual';
    InstanceLifecycle?: 'spot' | 'scheduled';
    SpotInstanceRequestId?: string;
    ClientToken?: string;
    Tags?: EC2$20160401$TagList;
    SecurityGroups?: EC2$20160401$GroupIdentifierList;
    SourceDestCheck?: boolean;
    Hypervisor?: 'ovm' | 'xen';
    NetworkInterfaces?: EC2$20160401$InstanceNetworkInterfaceList;
    IamInstanceProfile?: EC2$20160401$IamInstanceProfile;
    EbsOptimized?: boolean;
    SriovNetSupport?: string;
    EnaSupport?: boolean;
  };
  declare type EC2$20160401$InstanceAttribute = {
    InstanceId?: string;
    InstanceType?: EC2$20160401$AttributeValue;
    KernelId?: EC2$20160401$AttributeValue;
    RamdiskId?: EC2$20160401$AttributeValue;
    UserData?: EC2$20160401$AttributeValue;
    DisableApiTermination?: EC2$20160401$AttributeBooleanValue;
    InstanceInitiatedShutdownBehavior?: EC2$20160401$AttributeValue;
    RootDeviceName?: EC2$20160401$AttributeValue;
    BlockDeviceMappings?: EC2$20160401$InstanceBlockDeviceMappingList;
    ProductCodes?: EC2$20160401$ProductCodeList;
    EbsOptimized?: EC2$20160401$AttributeBooleanValue;
    SriovNetSupport?: EC2$20160401$AttributeValue;
    EnaSupport?: EC2$20160401$AttributeBooleanValue;
    SourceDestCheck?: EC2$20160401$AttributeBooleanValue;
    Groups?: EC2$20160401$GroupIdentifierList;
  };
  declare type EC2$20160401$InstanceAttributeName = 'instanceType' | 'kernel' | 'ramdisk' | 'userData' | 'disableApiTermination' | 'instanceInitiatedShutdownBehavior' | 'rootDeviceName' | 'blockDeviceMapping' | 'productCodes' | 'sourceDestCheck' | 'groupSet' | 'ebsOptimized' | 'sriovNetSupport' | 'enaSupport';
  declare type EC2$20160401$InstanceBlockDeviceMapping = {
    DeviceName?: string;
    Ebs?: EC2$20160401$EbsInstanceBlockDevice;
  };
  declare type EC2$20160401$InstanceBlockDeviceMappingList = EC2$20160401$InstanceBlockDeviceMapping[];
  declare type EC2$20160401$InstanceBlockDeviceMappingSpecification = {
    DeviceName?: string;
    Ebs?: EC2$20160401$EbsInstanceBlockDeviceSpecification;
    VirtualName?: string;
    NoDevice?: string;
  };
  declare type EC2$20160401$InstanceBlockDeviceMappingSpecificationList = EC2$20160401$InstanceBlockDeviceMappingSpecification[];
  declare type EC2$20160401$InstanceCapacity = {
    InstanceType?: string;
    AvailableCapacity?: number;
    TotalCapacity?: number;
  };
  declare type EC2$20160401$InstanceCount = {
    State?: 'available' | 'sold' | 'cancelled' | 'pending';
    InstanceCount?: number;
  };
  declare type EC2$20160401$InstanceCountList = EC2$20160401$InstanceCount[];
  declare type EC2$20160401$InstanceExportDetails = {
    InstanceId?: string;
    TargetEnvironment?: 'citrix' | 'vmware' | 'microsoft';
  };
  declare type EC2$20160401$InstanceIdSet = string[];
  declare type EC2$20160401$InstanceIdStringList = string[];
  declare type EC2$20160401$InstanceLifecycleType = 'spot' | 'scheduled';
  declare type EC2$20160401$InstanceList = EC2$20160401$Instance[];
  declare type EC2$20160401$InstanceMonitoring = {
    InstanceId?: string;
    Monitoring?: EC2$20160401$Monitoring;
  };
  declare type EC2$20160401$InstanceMonitoringList = EC2$20160401$InstanceMonitoring[];
  declare type EC2$20160401$InstanceNetworkInterface = {
    NetworkInterfaceId?: string;
    SubnetId?: string;
    VpcId?: string;
    Description?: string;
    OwnerId?: string;
    Status?: 'available' | 'attaching' | 'in-use' | 'detaching';
    MacAddress?: string;
    PrivateIpAddress?: string;
    PrivateDnsName?: string;
    SourceDestCheck?: boolean;
    Groups?: EC2$20160401$GroupIdentifierList;
    Attachment?: EC2$20160401$InstanceNetworkInterfaceAttachment;
    Association?: EC2$20160401$InstanceNetworkInterfaceAssociation;
    PrivateIpAddresses?: EC2$20160401$InstancePrivateIpAddressList;
  };
  declare type EC2$20160401$InstanceNetworkInterfaceAssociation = {
    PublicIp?: string;
    PublicDnsName?: string;
    IpOwnerId?: string;
  };
  declare type EC2$20160401$InstanceNetworkInterfaceAttachment = {
    AttachmentId?: string;
    DeviceIndex?: number;
    Status?: 'attaching' | 'attached' | 'detaching' | 'detached';
    AttachTime?: Date;
    DeleteOnTermination?: boolean;
  };
  declare type EC2$20160401$InstanceNetworkInterfaceList = EC2$20160401$InstanceNetworkInterface[];
  declare type EC2$20160401$InstanceNetworkInterfaceSpecification = {
    NetworkInterfaceId?: string;
    DeviceIndex?: number;
    SubnetId?: string;
    Description?: string;
    PrivateIpAddress?: string;
    Groups?: EC2$20160401$SecurityGroupIdStringList;
    DeleteOnTermination?: boolean;
    PrivateIpAddresses?: EC2$20160401$PrivateIpAddressSpecificationList;
    SecondaryPrivateIpAddressCount?: number;
    AssociatePublicIpAddress?: boolean;
  };
  declare type EC2$20160401$InstanceNetworkInterfaceSpecificationList = EC2$20160401$InstanceNetworkInterfaceSpecification[];
  declare type EC2$20160401$InstancePrivateIpAddress = {
    PrivateIpAddress?: string;
    PrivateDnsName?: string;
    Primary?: boolean;
    Association?: EC2$20160401$InstanceNetworkInterfaceAssociation;
  };
  declare type EC2$20160401$InstancePrivateIpAddressList = EC2$20160401$InstancePrivateIpAddress[];
  declare type EC2$20160401$InstanceState = {
    Code?: number;
    Name?: 'pending' | 'running' | 'shutting-down' | 'terminated' | 'stopping' | 'stopped';
  };
  declare type EC2$20160401$InstanceStateChange = {
    InstanceId?: string;
    CurrentState?: EC2$20160401$InstanceState;
    PreviousState?: EC2$20160401$InstanceState;
  };
  declare type EC2$20160401$InstanceStateChangeList = EC2$20160401$InstanceStateChange[];
  declare type EC2$20160401$InstanceStateName = 'pending' | 'running' | 'shutting-down' | 'terminated' | 'stopping' | 'stopped';
  declare type EC2$20160401$InstanceStatus = {
    InstanceId?: string;
    AvailabilityZone?: string;
    Events?: EC2$20160401$InstanceStatusEventList;
    InstanceState?: EC2$20160401$InstanceState;
    SystemStatus?: EC2$20160401$InstanceStatusSummary;
    InstanceStatus?: EC2$20160401$InstanceStatusSummary;
  };
  declare type EC2$20160401$InstanceStatusDetails = {
    Name?: 'reachability';
    Status?: 'passed' | 'failed' | 'insufficient-data' | 'initializing';
    ImpairedSince?: Date;
  };
  declare type EC2$20160401$InstanceStatusDetailsList = EC2$20160401$InstanceStatusDetails[];
  declare type EC2$20160401$InstanceStatusEvent = {
    Code?: 'instance-reboot' | 'system-reboot' | 'system-maintenance' | 'instance-retirement' | 'instance-stop';
    Description?: string;
    NotBefore?: Date;
    NotAfter?: Date;
  };
  declare type EC2$20160401$InstanceStatusEventList = EC2$20160401$InstanceStatusEvent[];
  declare type EC2$20160401$InstanceStatusList = EC2$20160401$InstanceStatus[];
  declare type EC2$20160401$InstanceStatusSummary = {
    Status?: 'ok' | 'impaired' | 'insufficient-data' | 'not-applicable' | 'initializing';
    Details?: EC2$20160401$InstanceStatusDetailsList;
  };
  declare type EC2$20160401$InstanceType = 't1.micro' | 't2.nano' | 't2.micro' | 't2.small' | 't2.medium' | 't2.large' | 'm1.small' | 'm1.medium' | 'm1.large' | 'm1.xlarge' | 'm3.medium' | 'm3.large' | 'm3.xlarge' | 'm3.2xlarge' | 'm4.large' | 'm4.xlarge' | 'm4.2xlarge' | 'm4.4xlarge' | 'm4.10xlarge' | 'm2.xlarge' | 'm2.2xlarge' | 'm2.4xlarge' | 'cr1.8xlarge' | 'r3.large' | 'r3.xlarge' | 'r3.2xlarge' | 'r3.4xlarge' | 'r3.8xlarge' | 'x1.4xlarge' | 'x1.8xlarge' | 'x1.16xlarge' | 'x1.32xlarge' | 'i2.xlarge' | 'i2.2xlarge' | 'i2.4xlarge' | 'i2.8xlarge' | 'hi1.4xlarge' | 'hs1.8xlarge' | 'c1.medium' | 'c1.xlarge' | 'c3.large' | 'c3.xlarge' | 'c3.2xlarge' | 'c3.4xlarge' | 'c3.8xlarge' | 'c4.large' | 'c4.xlarge' | 'c4.2xlarge' | 'c4.4xlarge' | 'c4.8xlarge' | 'cc1.4xlarge' | 'cc2.8xlarge' | 'g2.2xlarge' | 'g2.8xlarge' | 'cg1.4xlarge' | 'd2.xlarge' | 'd2.2xlarge' | 'd2.4xlarge' | 'd2.8xlarge';
  declare type EC2$20160401$InstanceTypeList = ('t1.micro' | 't2.nano' | 't2.micro' | 't2.small' | 't2.medium' | 't2.large' | 'm1.small' | 'm1.medium' | 'm1.large' | 'm1.xlarge' | 'm3.medium' | 'm3.large' | 'm3.xlarge' | 'm3.2xlarge' | 'm4.large' | 'm4.xlarge' | 'm4.2xlarge' | 'm4.4xlarge' | 'm4.10xlarge' | 'm2.xlarge' | 'm2.2xlarge' | 'm2.4xlarge' | 'cr1.8xlarge' | 'r3.large' | 'r3.xlarge' | 'r3.2xlarge' | 'r3.4xlarge' | 'r3.8xlarge' | 'x1.4xlarge' | 'x1.8xlarge' | 'x1.16xlarge' | 'x1.32xlarge' | 'i2.xlarge' | 'i2.2xlarge' | 'i2.4xlarge' | 'i2.8xlarge' | 'hi1.4xlarge' | 'hs1.8xlarge' | 'c1.medium' | 'c1.xlarge' | 'c3.large' | 'c3.xlarge' | 'c3.2xlarge' | 'c3.4xlarge' | 'c3.8xlarge' | 'c4.large' | 'c4.xlarge' | 'c4.2xlarge' | 'c4.4xlarge' | 'c4.8xlarge' | 'cc1.4xlarge' | 'cc2.8xlarge' | 'g2.2xlarge' | 'g2.8xlarge' | 'cg1.4xlarge' | 'd2.xlarge' | 'd2.2xlarge' | 'd2.4xlarge' | 'd2.8xlarge')[];
  declare type EC2$20160401$InternetGateway = {
    InternetGatewayId?: string;
    Attachments?: EC2$20160401$InternetGatewayAttachmentList;
    Tags?: EC2$20160401$TagList;
  };
  declare type EC2$20160401$InternetGatewayAttachment = {
    VpcId?: string;
    State?: 'attaching' | 'attached' | 'detaching' | 'detached';
  };
  declare type EC2$20160401$InternetGatewayAttachmentList = EC2$20160401$InternetGatewayAttachment[];
  declare type EC2$20160401$InternetGatewayList = EC2$20160401$InternetGateway[];
  declare type EC2$20160401$IpPermission = {
    IpProtocol?: string;
    FromPort?: number;
    ToPort?: number;
    UserIdGroupPairs?: EC2$20160401$UserIdGroupPairList;
    IpRanges?: EC2$20160401$IpRangeList;
    PrefixListIds?: EC2$20160401$PrefixListIdList;
  };
  declare type EC2$20160401$IpPermissionList = EC2$20160401$IpPermission[];
  declare type EC2$20160401$IpRange = {
    CidrIp?: string;
  };
  declare type EC2$20160401$IpRangeList = EC2$20160401$IpRange[];
  declare type EC2$20160401$IpRanges = string[];
  declare type EC2$20160401$KeyNameStringList = string[];
  declare type EC2$20160401$KeyPair = {
    KeyName?: string;
    KeyFingerprint?: string;
    KeyMaterial?: string;
  };
  declare type EC2$20160401$KeyPairInfo = {
    KeyName?: string;
    KeyFingerprint?: string;
  };
  declare type EC2$20160401$KeyPairList = EC2$20160401$KeyPairInfo[];
  declare type EC2$20160401$LaunchPermission = {
    UserId?: string;
    Group?: 'all';
  };
  declare type EC2$20160401$LaunchPermissionList = EC2$20160401$LaunchPermission[];
  declare type EC2$20160401$LaunchPermissionModifications = {
    Add?: EC2$20160401$LaunchPermissionList;
    Remove?: EC2$20160401$LaunchPermissionList;
  };
  declare type EC2$20160401$LaunchSpecification = {
    ImageId?: string;
    KeyName?: string;
    SecurityGroups?: EC2$20160401$GroupIdentifierList;
    UserData?: string;
    AddressingType?: string;
    InstanceType?: 't1.micro' | 't2.nano' | 't2.micro' | 't2.small' | 't2.medium' | 't2.large' | 'm1.small' | 'm1.medium' | 'm1.large' | 'm1.xlarge' | 'm3.medium' | 'm3.large' | 'm3.xlarge' | 'm3.2xlarge' | 'm4.large' | 'm4.xlarge' | 'm4.2xlarge' | 'm4.4xlarge' | 'm4.10xlarge' | 'm2.xlarge' | 'm2.2xlarge' | 'm2.4xlarge' | 'cr1.8xlarge' | 'r3.large' | 'r3.xlarge' | 'r3.2xlarge' | 'r3.4xlarge' | 'r3.8xlarge' | 'x1.4xlarge' | 'x1.8xlarge' | 'x1.16xlarge' | 'x1.32xlarge' | 'i2.xlarge' | 'i2.2xlarge' | 'i2.4xlarge' | 'i2.8xlarge' | 'hi1.4xlarge' | 'hs1.8xlarge' | 'c1.medium' | 'c1.xlarge' | 'c3.large' | 'c3.xlarge' | 'c3.2xlarge' | 'c3.4xlarge' | 'c3.8xlarge' | 'c4.large' | 'c4.xlarge' | 'c4.2xlarge' | 'c4.4xlarge' | 'c4.8xlarge' | 'cc1.4xlarge' | 'cc2.8xlarge' | 'g2.2xlarge' | 'g2.8xlarge' | 'cg1.4xlarge' | 'd2.xlarge' | 'd2.2xlarge' | 'd2.4xlarge' | 'd2.8xlarge';
    Placement?: EC2$20160401$SpotPlacement;
    KernelId?: string;
    RamdiskId?: string;
    BlockDeviceMappings?: EC2$20160401$BlockDeviceMappingList;
    SubnetId?: string;
    NetworkInterfaces?: EC2$20160401$InstanceNetworkInterfaceSpecificationList;
    IamInstanceProfile?: EC2$20160401$IamInstanceProfileSpecification;
    EbsOptimized?: boolean;
    Monitoring?: EC2$20160401$RunInstancesMonitoringEnabled;
  };
  declare type EC2$20160401$LaunchSpecsList = EC2$20160401$SpotFleetLaunchSpecification[];
  declare type EC2$20160401$ListingState = 'available' | 'sold' | 'cancelled' | 'pending';
  declare type EC2$20160401$ListingStatus = 'active' | 'pending' | 'cancelled' | 'closed';
  declare type EC2$20160401$ModifyHostsRequest = {
    HostIds: EC2$20160401$RequestHostIdList;
    AutoPlacement: 'on' | 'off';
  };
  declare type EC2$20160401$ModifyHostsResult = {
    Successful?: EC2$20160401$ResponseHostIdList;
    Unsuccessful?: EC2$20160401$UnsuccessfulItemList;
  };
  declare type EC2$20160401$ModifyIdFormatRequest = {
    Resource: string;
    UseLongIds: boolean;
  };
  declare type EC2$20160401$ModifyIdentityIdFormatRequest = {
    Resource: string;
    UseLongIds: boolean;
    PrincipalArn: string;
  };
  declare type EC2$20160401$ModifyImageAttributeRequest = {
    DryRun?: boolean;
    ImageId: string;
    Attribute?: string;
    OperationType?: 'add' | 'remove';
    UserIds?: EC2$20160401$UserIdStringList;
    UserGroups?: EC2$20160401$UserGroupStringList;
    ProductCodes?: EC2$20160401$ProductCodeStringList;
    Value?: string;
    LaunchPermission?: EC2$20160401$LaunchPermissionModifications;
    Description?: EC2$20160401$AttributeValue;
  };
  declare type EC2$20160401$ModifyInstanceAttributeRequest = {
    DryRun?: boolean;
    InstanceId: string;
    Attribute?: 'instanceType' | 'kernel' | 'ramdisk' | 'userData' | 'disableApiTermination' | 'instanceInitiatedShutdownBehavior' | 'rootDeviceName' | 'blockDeviceMapping' | 'productCodes' | 'sourceDestCheck' | 'groupSet' | 'ebsOptimized' | 'sriovNetSupport' | 'enaSupport';
    Value?: string;
    BlockDeviceMappings?: EC2$20160401$InstanceBlockDeviceMappingSpecificationList;
    SourceDestCheck?: EC2$20160401$AttributeBooleanValue;
    DisableApiTermination?: EC2$20160401$AttributeBooleanValue;
    InstanceType?: EC2$20160401$AttributeValue;
    Kernel?: EC2$20160401$AttributeValue;
    Ramdisk?: EC2$20160401$AttributeValue;
    UserData?: EC2$20160401$BlobAttributeValue;
    InstanceInitiatedShutdownBehavior?: EC2$20160401$AttributeValue;
    Groups?: EC2$20160401$GroupIdStringList;
    EbsOptimized?: EC2$20160401$AttributeBooleanValue;
    SriovNetSupport?: EC2$20160401$AttributeValue;
    EnaSupport?: EC2$20160401$AttributeBooleanValue;
  };
  declare type EC2$20160401$ModifyInstancePlacementRequest = {
    InstanceId: string;
    Tenancy?: 'dedicated' | 'host';
    Affinity?: 'default' | 'host';
    HostId?: string;
  };
  declare type EC2$20160401$ModifyInstancePlacementResult = {
    Return?: boolean;
  };
  declare type EC2$20160401$ModifyNetworkInterfaceAttributeRequest = {
    DryRun?: boolean;
    NetworkInterfaceId: string;
    Description?: EC2$20160401$AttributeValue;
    SourceDestCheck?: EC2$20160401$AttributeBooleanValue;
    Groups?: EC2$20160401$SecurityGroupIdStringList;
    Attachment?: EC2$20160401$NetworkInterfaceAttachmentChanges;
  };
  declare type EC2$20160401$ModifyReservedInstancesRequest = {
    ClientToken?: string;
    ReservedInstancesIds: EC2$20160401$ReservedInstancesIdStringList;
    TargetConfigurations: EC2$20160401$ReservedInstancesConfigurationList;
  };
  declare type EC2$20160401$ModifyReservedInstancesResult = {
    ReservedInstancesModificationId?: string;
  };
  declare type EC2$20160401$ModifySnapshotAttributeRequest = {
    DryRun?: boolean;
    SnapshotId: string;
    Attribute?: 'productCodes' | 'createVolumePermission';
    OperationType?: 'add' | 'remove';
    UserIds?: EC2$20160401$UserIdStringList;
    GroupNames?: EC2$20160401$GroupNameStringList;
    CreateVolumePermission?: EC2$20160401$CreateVolumePermissionModifications;
  };
  declare type EC2$20160401$ModifySpotFleetRequestRequest = {
    SpotFleetRequestId: string;
    TargetCapacity?: number;
    ExcessCapacityTerminationPolicy?: 'noTermination' | 'default';
  };
  declare type EC2$20160401$ModifySpotFleetRequestResponse = {
    Return?: boolean;
  };
  declare type EC2$20160401$ModifySubnetAttributeRequest = {
    SubnetId: string;
    MapPublicIpOnLaunch?: EC2$20160401$AttributeBooleanValue;
  };
  declare type EC2$20160401$ModifyVolumeAttributeRequest = {
    DryRun?: boolean;
    VolumeId: string;
    AutoEnableIO?: EC2$20160401$AttributeBooleanValue;
  };
  declare type EC2$20160401$ModifyVpcAttributeRequest = {
    VpcId: string;
    EnableDnsSupport?: EC2$20160401$AttributeBooleanValue;
    EnableDnsHostnames?: EC2$20160401$AttributeBooleanValue;
  };
  declare type EC2$20160401$ModifyVpcEndpointRequest = {
    DryRun?: boolean;
    VpcEndpointId: string;
    ResetPolicy?: boolean;
    PolicyDocument?: string;
    AddRouteTableIds?: EC2$20160401$ValueStringList;
    RemoveRouteTableIds?: EC2$20160401$ValueStringList;
  };
  declare type EC2$20160401$ModifyVpcEndpointResult = {
    Return?: boolean;
  };
  declare type EC2$20160401$ModifyVpcPeeringConnectionOptionsRequest = {
    DryRun?: boolean;
    VpcPeeringConnectionId: string;
    RequesterPeeringConnectionOptions?: EC2$20160401$PeeringConnectionOptionsRequest;
    AccepterPeeringConnectionOptions?: EC2$20160401$PeeringConnectionOptionsRequest;
  };
  declare type EC2$20160401$ModifyVpcPeeringConnectionOptionsResult = {
    RequesterPeeringConnectionOptions?: EC2$20160401$PeeringConnectionOptions;
    AccepterPeeringConnectionOptions?: EC2$20160401$PeeringConnectionOptions;
  };
  declare type EC2$20160401$MonitorInstancesRequest = {
    DryRun?: boolean;
    InstanceIds: EC2$20160401$InstanceIdStringList;
  };
  declare type EC2$20160401$MonitorInstancesResult = {
    InstanceMonitorings?: EC2$20160401$InstanceMonitoringList;
  };
  declare type EC2$20160401$Monitoring = {
    State?: 'disabled' | 'disabling' | 'enabled' | 'pending';
  };
  declare type EC2$20160401$MonitoringState = 'disabled' | 'disabling' | 'enabled' | 'pending';
  declare type EC2$20160401$MoveAddressToVpcRequest = {
    DryRun?: boolean;
    PublicIp: string;
  };
  declare type EC2$20160401$MoveAddressToVpcResult = {
    AllocationId?: string;
    Status?: 'MoveInProgress' | 'InVpc' | 'InClassic';
  };
  declare type EC2$20160401$MoveStatus = 'movingToVpc' | 'restoringToClassic';
  declare type EC2$20160401$MovingAddressStatus = {
    PublicIp?: string;
    MoveStatus?: 'movingToVpc' | 'restoringToClassic';
  };
  declare type EC2$20160401$MovingAddressStatusSet = EC2$20160401$MovingAddressStatus[];
  declare type EC2$20160401$NatGateway = {
    VpcId?: string;
    SubnetId?: string;
    NatGatewayId?: string;
    CreateTime?: Date;
    DeleteTime?: Date;
    NatGatewayAddresses?: EC2$20160401$NatGatewayAddressList;
    State?: 'pending' | 'failed' | 'available' | 'deleting' | 'deleted';
    FailureCode?: string;
    FailureMessage?: string;
    ProvisionedBandwidth?: EC2$20160401$ProvisionedBandwidth;
  };
  declare type EC2$20160401$NatGatewayAddress = {
    PublicIp?: string;
    AllocationId?: string;
    PrivateIp?: string;
    NetworkInterfaceId?: string;
  };
  declare type EC2$20160401$NatGatewayAddressList = EC2$20160401$NatGatewayAddress[];
  declare type EC2$20160401$NatGatewayList = EC2$20160401$NatGateway[];
  declare type EC2$20160401$NatGatewayState = 'pending' | 'failed' | 'available' | 'deleting' | 'deleted';
  declare type EC2$20160401$NetworkAcl = {
    NetworkAclId?: string;
    VpcId?: string;
    IsDefault?: boolean;
    Entries?: EC2$20160401$NetworkAclEntryList;
    Associations?: EC2$20160401$NetworkAclAssociationList;
    Tags?: EC2$20160401$TagList;
  };
  declare type EC2$20160401$NetworkAclAssociation = {
    NetworkAclAssociationId?: string;
    NetworkAclId?: string;
    SubnetId?: string;
  };
  declare type EC2$20160401$NetworkAclAssociationList = EC2$20160401$NetworkAclAssociation[];
  declare type EC2$20160401$NetworkAclEntry = {
    RuleNumber?: number;
    Protocol?: string;
    RuleAction?: 'allow' | 'deny';
    Egress?: boolean;
    CidrBlock?: string;
    IcmpTypeCode?: EC2$20160401$IcmpTypeCode;
    PortRange?: EC2$20160401$PortRange;
  };
  declare type EC2$20160401$NetworkAclEntryList = EC2$20160401$NetworkAclEntry[];
  declare type EC2$20160401$NetworkAclList = EC2$20160401$NetworkAcl[];
  declare type EC2$20160401$NetworkInterface = {
    NetworkInterfaceId?: string;
    SubnetId?: string;
    VpcId?: string;
    AvailabilityZone?: string;
    Description?: string;
    OwnerId?: string;
    RequesterId?: string;
    RequesterManaged?: boolean;
    Status?: 'available' | 'attaching' | 'in-use' | 'detaching';
    MacAddress?: string;
    PrivateIpAddress?: string;
    PrivateDnsName?: string;
    SourceDestCheck?: boolean;
    Groups?: EC2$20160401$GroupIdentifierList;
    Attachment?: EC2$20160401$NetworkInterfaceAttachment;
    Association?: EC2$20160401$NetworkInterfaceAssociation;
    TagSet?: EC2$20160401$TagList;
    PrivateIpAddresses?: EC2$20160401$NetworkInterfacePrivateIpAddressList;
    InterfaceType?: 'interface' | 'natGateway';
  };
  declare type EC2$20160401$NetworkInterfaceAssociation = {
    PublicIp?: string;
    PublicDnsName?: string;
    IpOwnerId?: string;
    AllocationId?: string;
    AssociationId?: string;
  };
  declare type EC2$20160401$NetworkInterfaceAttachment = {
    AttachmentId?: string;
    InstanceId?: string;
    InstanceOwnerId?: string;
    DeviceIndex?: number;
    Status?: 'attaching' | 'attached' | 'detaching' | 'detached';
    AttachTime?: Date;
    DeleteOnTermination?: boolean;
  };
  declare type EC2$20160401$NetworkInterfaceAttachmentChanges = {
    AttachmentId?: string;
    DeleteOnTermination?: boolean;
  };
  declare type EC2$20160401$NetworkInterfaceAttribute = 'description' | 'groupSet' | 'sourceDestCheck' | 'attachment';
  declare type EC2$20160401$NetworkInterfaceIdList = string[];
  declare type EC2$20160401$NetworkInterfaceList = EC2$20160401$NetworkInterface[];
  declare type EC2$20160401$NetworkInterfacePrivateIpAddress = {
    PrivateIpAddress?: string;
    PrivateDnsName?: string;
    Primary?: boolean;
    Association?: EC2$20160401$NetworkInterfaceAssociation;
  };
  declare type EC2$20160401$NetworkInterfacePrivateIpAddressList = EC2$20160401$NetworkInterfacePrivateIpAddress[];
  declare type EC2$20160401$NetworkInterfaceStatus = 'available' | 'attaching' | 'in-use' | 'detaching';
  declare type EC2$20160401$NetworkInterfaceType = 'interface' | 'natGateway';
  declare type EC2$20160401$NewDhcpConfiguration = {
    Key?: string;
    Values?: EC2$20160401$ValueStringList;
  };
  declare type EC2$20160401$NewDhcpConfigurationList = EC2$20160401$NewDhcpConfiguration[];
  declare type EC2$20160401$OccurrenceDayRequestSet = number[];
  declare type EC2$20160401$OccurrenceDaySet = number[];
  declare type EC2$20160401$OfferingTypeValues = 'Heavy Utilization' | 'Medium Utilization' | 'Light Utilization' | 'No Upfront' | 'Partial Upfront' | 'All Upfront';
  declare type EC2$20160401$OperationType = 'add' | 'remove';
  declare type EC2$20160401$OwnerStringList = string[];
  declare type EC2$20160401$PeeringConnectionOptions = {
    AllowEgressFromLocalClassicLinkToRemoteVpc?: boolean;
    AllowEgressFromLocalVpcToRemoteClassicLink?: boolean;
    AllowDnsResolutionFromRemoteVpc?: boolean;
  };
  declare type EC2$20160401$PeeringConnectionOptionsRequest = {
    AllowEgressFromLocalClassicLinkToRemoteVpc?: boolean;
    AllowEgressFromLocalVpcToRemoteClassicLink?: boolean;
    AllowDnsResolutionFromRemoteVpc?: boolean;
  };
  declare type EC2$20160401$PermissionGroup = 'all';
  declare type EC2$20160401$Placement = {
    AvailabilityZone?: string;
    GroupName?: string;
    Tenancy?: 'default' | 'dedicated' | 'host';
    HostId?: string;
    Affinity?: string;
  };
  declare type EC2$20160401$PlacementGroup = {
    GroupName?: string;
    Strategy?: 'cluster';
    State?: 'pending' | 'available' | 'deleting' | 'deleted';
  };
  declare type EC2$20160401$PlacementGroupList = EC2$20160401$PlacementGroup[];
  declare type EC2$20160401$PlacementGroupState = 'pending' | 'available' | 'deleting' | 'deleted';
  declare type EC2$20160401$PlacementGroupStringList = string[];
  declare type EC2$20160401$PlacementStrategy = 'cluster';
  declare type EC2$20160401$PlatformValues = 'Windows';
  declare type EC2$20160401$PortRange = {
    From?: number;
    To?: number;
  };
  declare type EC2$20160401$PrefixList = {
    PrefixListId?: string;
    PrefixListName?: string;
    Cidrs?: EC2$20160401$ValueStringList;
  };
  declare type EC2$20160401$PrefixListId = {
    PrefixListId?: string;
  };
  declare type EC2$20160401$PrefixListIdList = EC2$20160401$PrefixListId[];
  declare type EC2$20160401$PrefixListIdSet = string[];
  declare type EC2$20160401$PrefixListSet = EC2$20160401$PrefixList[];
  declare type EC2$20160401$PriceSchedule = {
    Term?: number;
    Price?: number;
    CurrencyCode?: 'USD';
    Active?: boolean;
  };
  declare type EC2$20160401$PriceScheduleList = EC2$20160401$PriceSchedule[];
  declare type EC2$20160401$PriceScheduleSpecification = {
    Term?: number;
    Price?: number;
    CurrencyCode?: 'USD';
  };
  declare type EC2$20160401$PriceScheduleSpecificationList = EC2$20160401$PriceScheduleSpecification[];
  declare type EC2$20160401$PricingDetail = {
    Price?: number;
    Count?: number;
  };
  declare type EC2$20160401$PricingDetailsList = EC2$20160401$PricingDetail[];
  declare type EC2$20160401$PrivateIpAddressConfigSet = EC2$20160401$ScheduledInstancesPrivateIpAddressConfig[];
  declare type EC2$20160401$PrivateIpAddressSpecification = {
    PrivateIpAddress: string;
    Primary?: boolean;
  };
  declare type EC2$20160401$PrivateIpAddressSpecificationList = EC2$20160401$PrivateIpAddressSpecification[];
  declare type EC2$20160401$PrivateIpAddressStringList = string[];
  declare type EC2$20160401$ProductCode = {
    ProductCodeId?: string;
    ProductCodeType?: 'devpay' | 'marketplace';
  };
  declare type EC2$20160401$ProductCodeList = EC2$20160401$ProductCode[];
  declare type EC2$20160401$ProductCodeStringList = string[];
  declare type EC2$20160401$ProductCodeValues = 'devpay' | 'marketplace';
  declare type EC2$20160401$ProductDescriptionList = string[];
  declare type EC2$20160401$PropagatingVgw = {
    GatewayId?: string;
  };
  declare type EC2$20160401$PropagatingVgwList = EC2$20160401$PropagatingVgw[];
  declare type EC2$20160401$ProvisionedBandwidth = {
    Provisioned?: string;
    Requested?: string;
    RequestTime?: Date;
    ProvisionTime?: Date;
    Status?: string;
  };
  declare type EC2$20160401$PublicIpStringList = string[];
  declare type EC2$20160401$PurchaseRequest = {
    PurchaseToken: string;
    InstanceCount: number;
  };
  declare type EC2$20160401$PurchaseRequestSet = EC2$20160401$PurchaseRequest[];
  declare type EC2$20160401$PurchaseReservedInstancesOfferingRequest = {
    DryRun?: boolean;
    ReservedInstancesOfferingId: string;
    InstanceCount: number;
    LimitPrice?: EC2$20160401$ReservedInstanceLimitPrice;
  };
  declare type EC2$20160401$PurchaseReservedInstancesOfferingResult = {
    ReservedInstancesId?: string;
  };
  declare type EC2$20160401$PurchaseScheduledInstancesRequest = {
    DryRun?: boolean;
    ClientToken?: string;
    PurchaseRequests: EC2$20160401$PurchaseRequestSet;
  };
  declare type EC2$20160401$PurchaseScheduledInstancesResult = {
    ScheduledInstanceSet?: EC2$20160401$PurchasedScheduledInstanceSet;
  };
  declare type EC2$20160401$PurchasedScheduledInstanceSet = EC2$20160401$ScheduledInstance[];
  declare type EC2$20160401$RIProductDescription = 'Linux/UNIX' | 'Linux/UNIX (Amazon VPC)' | 'Windows' | 'Windows (Amazon VPC)';
  declare type EC2$20160401$ReasonCodesList = ('instance-stuck-in-state' | 'unresponsive' | 'not-accepting-credentials' | 'password-not-available' | 'performance-network' | 'performance-instance-store' | 'performance-ebs-volume' | 'performance-other' | 'other')[];
  declare type EC2$20160401$RebootInstancesRequest = {
    DryRun?: boolean;
    InstanceIds: EC2$20160401$InstanceIdStringList;
  };
  declare type EC2$20160401$RecurringCharge = {
    Frequency?: 'Hourly';
    Amount?: number;
  };
  declare type EC2$20160401$RecurringChargeFrequency = 'Hourly';
  declare type EC2$20160401$RecurringChargesList = EC2$20160401$RecurringCharge[];
  declare type EC2$20160401$Region = {
    RegionName?: string;
    Endpoint?: string;
  };
  declare type EC2$20160401$RegionList = EC2$20160401$Region[];
  declare type EC2$20160401$RegionNameStringList = string[];
  declare type EC2$20160401$RegisterImageRequest = {
    DryRun?: boolean;
    ImageLocation?: string;
    Name: string;
    Description?: string;
    Architecture?: 'i386' | 'x86_64';
    KernelId?: string;
    RamdiskId?: string;
    RootDeviceName?: string;
    BlockDeviceMappings?: EC2$20160401$BlockDeviceMappingRequestList;
    VirtualizationType?: string;
    SriovNetSupport?: string;
    EnaSupport?: boolean;
  };
  declare type EC2$20160401$RegisterImageResult = {
    ImageId?: string;
  };
  declare type EC2$20160401$RejectVpcPeeringConnectionRequest = {
    DryRun?: boolean;
    VpcPeeringConnectionId: string;
  };
  declare type EC2$20160401$RejectVpcPeeringConnectionResult = {
    Return?: boolean;
  };
  declare type EC2$20160401$ReleaseAddressRequest = {
    DryRun?: boolean;
    PublicIp?: string;
    AllocationId?: string;
  };
  declare type EC2$20160401$ReleaseHostsRequest = {
    HostIds: EC2$20160401$RequestHostIdList;
  };
  declare type EC2$20160401$ReleaseHostsResult = {
    Successful?: EC2$20160401$ResponseHostIdList;
    Unsuccessful?: EC2$20160401$UnsuccessfulItemList;
  };
  declare type EC2$20160401$ReplaceNetworkAclAssociationRequest = {
    DryRun?: boolean;
    AssociationId: string;
    NetworkAclId: string;
  };
  declare type EC2$20160401$ReplaceNetworkAclAssociationResult = {
    NewAssociationId?: string;
  };
  declare type EC2$20160401$ReplaceNetworkAclEntryRequest = {
    DryRun?: boolean;
    NetworkAclId: string;
    RuleNumber: number;
    Protocol: string;
    RuleAction: 'allow' | 'deny';
    Egress: boolean;
    CidrBlock: string;
    IcmpTypeCode?: EC2$20160401$IcmpTypeCode;
    PortRange?: EC2$20160401$PortRange;
  };
  declare type EC2$20160401$ReplaceRouteRequest = {
    DryRun?: boolean;
    RouteTableId: string;
    DestinationCidrBlock: string;
    GatewayId?: string;
    InstanceId?: string;
    NetworkInterfaceId?: string;
    VpcPeeringConnectionId?: string;
    NatGatewayId?: string;
  };
  declare type EC2$20160401$ReplaceRouteTableAssociationRequest = {
    DryRun?: boolean;
    AssociationId: string;
    RouteTableId: string;
  };
  declare type EC2$20160401$ReplaceRouteTableAssociationResult = {
    NewAssociationId?: string;
  };
  declare type EC2$20160401$ReportInstanceReasonCodes = 'instance-stuck-in-state' | 'unresponsive' | 'not-accepting-credentials' | 'password-not-available' | 'performance-network' | 'performance-instance-store' | 'performance-ebs-volume' | 'performance-other' | 'other';
  declare type EC2$20160401$ReportInstanceStatusRequest = {
    DryRun?: boolean;
    Instances: EC2$20160401$InstanceIdStringList;
    Status: 'ok' | 'impaired';
    StartTime?: Date;
    EndTime?: Date;
    ReasonCodes: EC2$20160401$ReasonCodesList;
    Description?: string;
  };
  declare type EC2$20160401$ReportStatusType = 'ok' | 'impaired';
  declare type EC2$20160401$RequestHostIdList = string[];
  declare type EC2$20160401$RequestSpotFleetRequest = {
    DryRun?: boolean;
    SpotFleetRequestConfig: EC2$20160401$SpotFleetRequestConfigData;
  };
  declare type EC2$20160401$RequestSpotFleetResponse = {
    SpotFleetRequestId: string;
  };
  declare type EC2$20160401$RequestSpotInstancesRequest = {
    DryRun?: boolean;
    SpotPrice: string;
    ClientToken?: string;
    InstanceCount?: number;
    Type?: 'one-time' | 'persistent';
    ValidFrom?: Date;
    ValidUntil?: Date;
    LaunchGroup?: string;
    AvailabilityZoneGroup?: string;
    BlockDurationMinutes?: number;
    LaunchSpecification?: EC2$20160401$RequestSpotLaunchSpecification;
  };
  declare type EC2$20160401$RequestSpotInstancesResult = {
    SpotInstanceRequests?: EC2$20160401$SpotInstanceRequestList;
  };
  declare type EC2$20160401$RequestSpotLaunchSpecification = {
    ImageId?: string;
    KeyName?: string;
    SecurityGroups?: EC2$20160401$ValueStringList;
    UserData?: string;
    AddressingType?: string;
    InstanceType?: 't1.micro' | 't2.nano' | 't2.micro' | 't2.small' | 't2.medium' | 't2.large' | 'm1.small' | 'm1.medium' | 'm1.large' | 'm1.xlarge' | 'm3.medium' | 'm3.large' | 'm3.xlarge' | 'm3.2xlarge' | 'm4.large' | 'm4.xlarge' | 'm4.2xlarge' | 'm4.4xlarge' | 'm4.10xlarge' | 'm2.xlarge' | 'm2.2xlarge' | 'm2.4xlarge' | 'cr1.8xlarge' | 'r3.large' | 'r3.xlarge' | 'r3.2xlarge' | 'r3.4xlarge' | 'r3.8xlarge' | 'x1.4xlarge' | 'x1.8xlarge' | 'x1.16xlarge' | 'x1.32xlarge' | 'i2.xlarge' | 'i2.2xlarge' | 'i2.4xlarge' | 'i2.8xlarge' | 'hi1.4xlarge' | 'hs1.8xlarge' | 'c1.medium' | 'c1.xlarge' | 'c3.large' | 'c3.xlarge' | 'c3.2xlarge' | 'c3.4xlarge' | 'c3.8xlarge' | 'c4.large' | 'c4.xlarge' | 'c4.2xlarge' | 'c4.4xlarge' | 'c4.8xlarge' | 'cc1.4xlarge' | 'cc2.8xlarge' | 'g2.2xlarge' | 'g2.8xlarge' | 'cg1.4xlarge' | 'd2.xlarge' | 'd2.2xlarge' | 'd2.4xlarge' | 'd2.8xlarge';
    Placement?: EC2$20160401$SpotPlacement;
    KernelId?: string;
    RamdiskId?: string;
    BlockDeviceMappings?: EC2$20160401$BlockDeviceMappingList;
    SubnetId?: string;
    NetworkInterfaces?: EC2$20160401$InstanceNetworkInterfaceSpecificationList;
    IamInstanceProfile?: EC2$20160401$IamInstanceProfileSpecification;
    EbsOptimized?: boolean;
    Monitoring?: EC2$20160401$RunInstancesMonitoringEnabled;
    SecurityGroupIds?: EC2$20160401$ValueStringList;
  };
  declare type EC2$20160401$Reservation = {
    ReservationId?: string;
    OwnerId?: string;
    RequesterId?: string;
    Groups?: EC2$20160401$GroupIdentifierList;
    Instances?: EC2$20160401$InstanceList;
  };
  declare type EC2$20160401$ReservationList = EC2$20160401$Reservation[];
  declare type EC2$20160401$ReservedInstanceLimitPrice = {
    Amount?: number;
    CurrencyCode?: 'USD';
  };
  declare type EC2$20160401$ReservedInstanceState = 'payment-pending' | 'active' | 'payment-failed' | 'retired';
  declare type EC2$20160401$ReservedInstances = {
    ReservedInstancesId?: string;
    InstanceType?: 't1.micro' | 't2.nano' | 't2.micro' | 't2.small' | 't2.medium' | 't2.large' | 'm1.small' | 'm1.medium' | 'm1.large' | 'm1.xlarge' | 'm3.medium' | 'm3.large' | 'm3.xlarge' | 'm3.2xlarge' | 'm4.large' | 'm4.xlarge' | 'm4.2xlarge' | 'm4.4xlarge' | 'm4.10xlarge' | 'm2.xlarge' | 'm2.2xlarge' | 'm2.4xlarge' | 'cr1.8xlarge' | 'r3.large' | 'r3.xlarge' | 'r3.2xlarge' | 'r3.4xlarge' | 'r3.8xlarge' | 'x1.4xlarge' | 'x1.8xlarge' | 'x1.16xlarge' | 'x1.32xlarge' | 'i2.xlarge' | 'i2.2xlarge' | 'i2.4xlarge' | 'i2.8xlarge' | 'hi1.4xlarge' | 'hs1.8xlarge' | 'c1.medium' | 'c1.xlarge' | 'c3.large' | 'c3.xlarge' | 'c3.2xlarge' | 'c3.4xlarge' | 'c3.8xlarge' | 'c4.large' | 'c4.xlarge' | 'c4.2xlarge' | 'c4.4xlarge' | 'c4.8xlarge' | 'cc1.4xlarge' | 'cc2.8xlarge' | 'g2.2xlarge' | 'g2.8xlarge' | 'cg1.4xlarge' | 'd2.xlarge' | 'd2.2xlarge' | 'd2.4xlarge' | 'd2.8xlarge';
    AvailabilityZone?: string;
    Start?: Date;
    End?: Date;
    Duration?: number;
    UsagePrice?: number;
    FixedPrice?: number;
    InstanceCount?: number;
    ProductDescription?: 'Linux/UNIX' | 'Linux/UNIX (Amazon VPC)' | 'Windows' | 'Windows (Amazon VPC)';
    State?: 'payment-pending' | 'active' | 'payment-failed' | 'retired';
    Tags?: EC2$20160401$TagList;
    InstanceTenancy?: 'default' | 'dedicated' | 'host';
    CurrencyCode?: 'USD';
    OfferingType?: 'Heavy Utilization' | 'Medium Utilization' | 'Light Utilization' | 'No Upfront' | 'Partial Upfront' | 'All Upfront';
    RecurringCharges?: EC2$20160401$RecurringChargesList;
  };
  declare type EC2$20160401$ReservedInstancesConfiguration = {
    AvailabilityZone?: string;
    Platform?: string;
    InstanceCount?: number;
    InstanceType?: 't1.micro' | 't2.nano' | 't2.micro' | 't2.small' | 't2.medium' | 't2.large' | 'm1.small' | 'm1.medium' | 'm1.large' | 'm1.xlarge' | 'm3.medium' | 'm3.large' | 'm3.xlarge' | 'm3.2xlarge' | 'm4.large' | 'm4.xlarge' | 'm4.2xlarge' | 'm4.4xlarge' | 'm4.10xlarge' | 'm2.xlarge' | 'm2.2xlarge' | 'm2.4xlarge' | 'cr1.8xlarge' | 'r3.large' | 'r3.xlarge' | 'r3.2xlarge' | 'r3.4xlarge' | 'r3.8xlarge' | 'x1.4xlarge' | 'x1.8xlarge' | 'x1.16xlarge' | 'x1.32xlarge' | 'i2.xlarge' | 'i2.2xlarge' | 'i2.4xlarge' | 'i2.8xlarge' | 'hi1.4xlarge' | 'hs1.8xlarge' | 'c1.medium' | 'c1.xlarge' | 'c3.large' | 'c3.xlarge' | 'c3.2xlarge' | 'c3.4xlarge' | 'c3.8xlarge' | 'c4.large' | 'c4.xlarge' | 'c4.2xlarge' | 'c4.4xlarge' | 'c4.8xlarge' | 'cc1.4xlarge' | 'cc2.8xlarge' | 'g2.2xlarge' | 'g2.8xlarge' | 'cg1.4xlarge' | 'd2.xlarge' | 'd2.2xlarge' | 'd2.4xlarge' | 'd2.8xlarge';
  };
  declare type EC2$20160401$ReservedInstancesConfigurationList = EC2$20160401$ReservedInstancesConfiguration[];
  declare type EC2$20160401$ReservedInstancesId = {
    ReservedInstancesId?: string;
  };
  declare type EC2$20160401$ReservedInstancesIdStringList = string[];
  declare type EC2$20160401$ReservedInstancesList = EC2$20160401$ReservedInstances[];
  declare type EC2$20160401$ReservedInstancesListing = {
    ReservedInstancesListingId?: string;
    ReservedInstancesId?: string;
    CreateDate?: Date;
    UpdateDate?: Date;
    Status?: 'active' | 'pending' | 'cancelled' | 'closed';
    StatusMessage?: string;
    InstanceCounts?: EC2$20160401$InstanceCountList;
    PriceSchedules?: EC2$20160401$PriceScheduleList;
    Tags?: EC2$20160401$TagList;
    ClientToken?: string;
  };
  declare type EC2$20160401$ReservedInstancesListingList = EC2$20160401$ReservedInstancesListing[];
  declare type EC2$20160401$ReservedInstancesModification = {
    ReservedInstancesModificationId?: string;
    ReservedInstancesIds?: EC2$20160401$ReservedIntancesIds;
    ModificationResults?: EC2$20160401$ReservedInstancesModificationResultList;
    CreateDate?: Date;
    UpdateDate?: Date;
    EffectiveDate?: Date;
    Status?: string;
    StatusMessage?: string;
    ClientToken?: string;
  };
  declare type EC2$20160401$ReservedInstancesModificationIdStringList = string[];
  declare type EC2$20160401$ReservedInstancesModificationList = EC2$20160401$ReservedInstancesModification[];
  declare type EC2$20160401$ReservedInstancesModificationResult = {
    ReservedInstancesId?: string;
    TargetConfiguration?: EC2$20160401$ReservedInstancesConfiguration;
  };
  declare type EC2$20160401$ReservedInstancesModificationResultList = EC2$20160401$ReservedInstancesModificationResult[];
  declare type EC2$20160401$ReservedInstancesOffering = {
    ReservedInstancesOfferingId?: string;
    InstanceType?: 't1.micro' | 't2.nano' | 't2.micro' | 't2.small' | 't2.medium' | 't2.large' | 'm1.small' | 'm1.medium' | 'm1.large' | 'm1.xlarge' | 'm3.medium' | 'm3.large' | 'm3.xlarge' | 'm3.2xlarge' | 'm4.large' | 'm4.xlarge' | 'm4.2xlarge' | 'm4.4xlarge' | 'm4.10xlarge' | 'm2.xlarge' | 'm2.2xlarge' | 'm2.4xlarge' | 'cr1.8xlarge' | 'r3.large' | 'r3.xlarge' | 'r3.2xlarge' | 'r3.4xlarge' | 'r3.8xlarge' | 'x1.4xlarge' | 'x1.8xlarge' | 'x1.16xlarge' | 'x1.32xlarge' | 'i2.xlarge' | 'i2.2xlarge' | 'i2.4xlarge' | 'i2.8xlarge' | 'hi1.4xlarge' | 'hs1.8xlarge' | 'c1.medium' | 'c1.xlarge' | 'c3.large' | 'c3.xlarge' | 'c3.2xlarge' | 'c3.4xlarge' | 'c3.8xlarge' | 'c4.large' | 'c4.xlarge' | 'c4.2xlarge' | 'c4.4xlarge' | 'c4.8xlarge' | 'cc1.4xlarge' | 'cc2.8xlarge' | 'g2.2xlarge' | 'g2.8xlarge' | 'cg1.4xlarge' | 'd2.xlarge' | 'd2.2xlarge' | 'd2.4xlarge' | 'd2.8xlarge';
    AvailabilityZone?: string;
    Duration?: number;
    UsagePrice?: number;
    FixedPrice?: number;
    ProductDescription?: 'Linux/UNIX' | 'Linux/UNIX (Amazon VPC)' | 'Windows' | 'Windows (Amazon VPC)';
    InstanceTenancy?: 'default' | 'dedicated' | 'host';
    CurrencyCode?: 'USD';
    OfferingType?: 'Heavy Utilization' | 'Medium Utilization' | 'Light Utilization' | 'No Upfront' | 'Partial Upfront' | 'All Upfront';
    RecurringCharges?: EC2$20160401$RecurringChargesList;
    Marketplace?: boolean;
    PricingDetails?: EC2$20160401$PricingDetailsList;
  };
  declare type EC2$20160401$ReservedInstancesOfferingIdStringList = string[];
  declare type EC2$20160401$ReservedInstancesOfferingList = EC2$20160401$ReservedInstancesOffering[];
  declare type EC2$20160401$ReservedIntancesIds = EC2$20160401$ReservedInstancesId[];
  declare type EC2$20160401$ResetImageAttributeName = 'launchPermission';
  declare type EC2$20160401$ResetImageAttributeRequest = {
    DryRun?: boolean;
    ImageId: string;
    Attribute: 'launchPermission';
  };
  declare type EC2$20160401$ResetInstanceAttributeRequest = {
    DryRun?: boolean;
    InstanceId: string;
    Attribute: 'instanceType' | 'kernel' | 'ramdisk' | 'userData' | 'disableApiTermination' | 'instanceInitiatedShutdownBehavior' | 'rootDeviceName' | 'blockDeviceMapping' | 'productCodes' | 'sourceDestCheck' | 'groupSet' | 'ebsOptimized' | 'sriovNetSupport' | 'enaSupport';
  };
  declare type EC2$20160401$ResetNetworkInterfaceAttributeRequest = {
    DryRun?: boolean;
    NetworkInterfaceId: string;
    SourceDestCheck?: string;
  };
  declare type EC2$20160401$ResetSnapshotAttributeRequest = {
    DryRun?: boolean;
    SnapshotId: string;
    Attribute: 'productCodes' | 'createVolumePermission';
  };
  declare type EC2$20160401$ResourceIdList = string[];
  declare type EC2$20160401$ResourceType = 'customer-gateway' | 'dhcp-options' | 'image' | 'instance' | 'internet-gateway' | 'network-acl' | 'network-interface' | 'reserved-instances' | 'route-table' | 'snapshot' | 'spot-instances-request' | 'subnet' | 'security-group' | 'volume' | 'vpc' | 'vpn-connection' | 'vpn-gateway';
  declare type EC2$20160401$ResponseHostIdList = string[];
  declare type EC2$20160401$RestorableByStringList = string[];
  declare type EC2$20160401$RestoreAddressToClassicRequest = {
    DryRun?: boolean;
    PublicIp: string;
  };
  declare type EC2$20160401$RestoreAddressToClassicResult = {
    Status?: 'MoveInProgress' | 'InVpc' | 'InClassic';
    PublicIp?: string;
  };
  declare type EC2$20160401$RevokeSecurityGroupEgressRequest = {
    DryRun?: boolean;
    GroupId: string;
    SourceSecurityGroupName?: string;
    SourceSecurityGroupOwnerId?: string;
    IpProtocol?: string;
    FromPort?: number;
    ToPort?: number;
    CidrIp?: string;
    IpPermissions?: EC2$20160401$IpPermissionList;
  };
  declare type EC2$20160401$RevokeSecurityGroupIngressRequest = {
    DryRun?: boolean;
    GroupName?: string;
    GroupId?: string;
    SourceSecurityGroupName?: string;
    SourceSecurityGroupOwnerId?: string;
    IpProtocol?: string;
    FromPort?: number;
    ToPort?: number;
    CidrIp?: string;
    IpPermissions?: EC2$20160401$IpPermissionList;
  };
  declare type EC2$20160401$Route = {
    DestinationCidrBlock?: string;
    DestinationPrefixListId?: string;
    GatewayId?: string;
    InstanceId?: string;
    InstanceOwnerId?: string;
    NetworkInterfaceId?: string;
    VpcPeeringConnectionId?: string;
    NatGatewayId?: string;
    State?: 'active' | 'blackhole';
    Origin?: 'CreateRouteTable' | 'CreateRoute' | 'EnableVgwRoutePropagation';
  };
  declare type EC2$20160401$RouteList = EC2$20160401$Route[];
  declare type EC2$20160401$RouteOrigin = 'CreateRouteTable' | 'CreateRoute' | 'EnableVgwRoutePropagation';
  declare type EC2$20160401$RouteState = 'active' | 'blackhole';
  declare type EC2$20160401$RouteTable = {
    RouteTableId?: string;
    VpcId?: string;
    Routes?: EC2$20160401$RouteList;
    Associations?: EC2$20160401$RouteTableAssociationList;
    Tags?: EC2$20160401$TagList;
    PropagatingVgws?: EC2$20160401$PropagatingVgwList;
  };
  declare type EC2$20160401$RouteTableAssociation = {
    RouteTableAssociationId?: string;
    RouteTableId?: string;
    SubnetId?: string;
    Main?: boolean;
  };
  declare type EC2$20160401$RouteTableAssociationList = EC2$20160401$RouteTableAssociation[];
  declare type EC2$20160401$RouteTableList = EC2$20160401$RouteTable[];
  declare type EC2$20160401$RuleAction = 'allow' | 'deny';
  declare type EC2$20160401$RunInstancesMonitoringEnabled = {
    Enabled: boolean;
  };
  declare type EC2$20160401$RunInstancesRequest = {
    DryRun?: boolean;
    ImageId: string;
    MinCount: number;
    MaxCount: number;
    KeyName?: string;
    SecurityGroups?: EC2$20160401$SecurityGroupStringList;
    SecurityGroupIds?: EC2$20160401$SecurityGroupIdStringList;
    UserData?: string;
    InstanceType?: 't1.micro' | 't2.nano' | 't2.micro' | 't2.small' | 't2.medium' | 't2.large' | 'm1.small' | 'm1.medium' | 'm1.large' | 'm1.xlarge' | 'm3.medium' | 'm3.large' | 'm3.xlarge' | 'm3.2xlarge' | 'm4.large' | 'm4.xlarge' | 'm4.2xlarge' | 'm4.4xlarge' | 'm4.10xlarge' | 'm2.xlarge' | 'm2.2xlarge' | 'm2.4xlarge' | 'cr1.8xlarge' | 'r3.large' | 'r3.xlarge' | 'r3.2xlarge' | 'r3.4xlarge' | 'r3.8xlarge' | 'x1.4xlarge' | 'x1.8xlarge' | 'x1.16xlarge' | 'x1.32xlarge' | 'i2.xlarge' | 'i2.2xlarge' | 'i2.4xlarge' | 'i2.8xlarge' | 'hi1.4xlarge' | 'hs1.8xlarge' | 'c1.medium' | 'c1.xlarge' | 'c3.large' | 'c3.xlarge' | 'c3.2xlarge' | 'c3.4xlarge' | 'c3.8xlarge' | 'c4.large' | 'c4.xlarge' | 'c4.2xlarge' | 'c4.4xlarge' | 'c4.8xlarge' | 'cc1.4xlarge' | 'cc2.8xlarge' | 'g2.2xlarge' | 'g2.8xlarge' | 'cg1.4xlarge' | 'd2.xlarge' | 'd2.2xlarge' | 'd2.4xlarge' | 'd2.8xlarge';
    Placement?: EC2$20160401$Placement;
    KernelId?: string;
    RamdiskId?: string;
    BlockDeviceMappings?: EC2$20160401$BlockDeviceMappingRequestList;
    Monitoring?: EC2$20160401$RunInstancesMonitoringEnabled;
    SubnetId?: string;
    DisableApiTermination?: boolean;
    InstanceInitiatedShutdownBehavior?: 'stop' | 'terminate';
    PrivateIpAddress?: string;
    ClientToken?: string;
    AdditionalInfo?: string;
    NetworkInterfaces?: EC2$20160401$InstanceNetworkInterfaceSpecificationList;
    IamInstanceProfile?: EC2$20160401$IamInstanceProfileSpecification;
    EbsOptimized?: boolean;
  };
  declare type EC2$20160401$RunScheduledInstancesRequest = {
    DryRun?: boolean;
    ClientToken?: string;
    InstanceCount?: number;
    ScheduledInstanceId: string;
    LaunchSpecification: EC2$20160401$ScheduledInstancesLaunchSpecification;
  };
  declare type EC2$20160401$RunScheduledInstancesResult = {
    InstanceIdSet?: EC2$20160401$InstanceIdSet;
  };
  declare type EC2$20160401$S3Storage = {
    Bucket?: string;
    Prefix?: string;
    AWSAccessKeyId?: string;
    UploadPolicy?: Buffer | $TypedArray | Blob | string;
    UploadPolicySignature?: string;
  };
  declare type EC2$20160401$ScheduledInstance = {
    ScheduledInstanceId?: string;
    InstanceType?: string;
    Platform?: string;
    NetworkPlatform?: string;
    AvailabilityZone?: string;
    SlotDurationInHours?: number;
    Recurrence?: EC2$20160401$ScheduledInstanceRecurrence;
    PreviousSlotEndTime?: Date;
    NextSlotStartTime?: Date;
    HourlyPrice?: string;
    TotalScheduledInstanceHours?: number;
    InstanceCount?: number;
    TermStartDate?: Date;
    TermEndDate?: Date;
    CreateDate?: Date;
  };
  declare type EC2$20160401$ScheduledInstanceAvailability = {
    InstanceType?: string;
    Platform?: string;
    NetworkPlatform?: string;
    AvailabilityZone?: string;
    PurchaseToken?: string;
    SlotDurationInHours?: number;
    Recurrence?: EC2$20160401$ScheduledInstanceRecurrence;
    FirstSlotStartTime?: Date;
    HourlyPrice?: string;
    TotalScheduledInstanceHours?: number;
    AvailableInstanceCount?: number;
    MinTermDurationInDays?: number;
    MaxTermDurationInDays?: number;
  };
  declare type EC2$20160401$ScheduledInstanceAvailabilitySet = EC2$20160401$ScheduledInstanceAvailability[];
  declare type EC2$20160401$ScheduledInstanceIdRequestSet = string[];
  declare type EC2$20160401$ScheduledInstanceRecurrence = {
    Frequency?: string;
    Interval?: number;
    OccurrenceDaySet?: EC2$20160401$OccurrenceDaySet;
    OccurrenceRelativeToEnd?: boolean;
    OccurrenceUnit?: string;
  };
  declare type EC2$20160401$ScheduledInstanceRecurrenceRequest = {
    Frequency?: string;
    Interval?: number;
    OccurrenceDays?: EC2$20160401$OccurrenceDayRequestSet;
    OccurrenceRelativeToEnd?: boolean;
    OccurrenceUnit?: string;
  };
  declare type EC2$20160401$ScheduledInstanceSet = EC2$20160401$ScheduledInstance[];
  declare type EC2$20160401$ScheduledInstancesBlockDeviceMapping = {
    DeviceName?: string;
    NoDevice?: string;
    VirtualName?: string;
    Ebs?: EC2$20160401$ScheduledInstancesEbs;
  };
  declare type EC2$20160401$ScheduledInstancesBlockDeviceMappingSet = EC2$20160401$ScheduledInstancesBlockDeviceMapping[];
  declare type EC2$20160401$ScheduledInstancesEbs = {
    SnapshotId?: string;
    VolumeSize?: number;
    DeleteOnTermination?: boolean;
    VolumeType?: string;
    Iops?: number;
    Encrypted?: boolean;
  };
  declare type EC2$20160401$ScheduledInstancesIamInstanceProfile = {
    Arn?: string;
    Name?: string;
  };
  declare type EC2$20160401$ScheduledInstancesLaunchSpecification = {
    ImageId: string;
    KeyName?: string;
    SecurityGroupIds?: EC2$20160401$ScheduledInstancesSecurityGroupIdSet;
    UserData?: string;
    Placement?: EC2$20160401$ScheduledInstancesPlacement;
    KernelId?: string;
    InstanceType?: string;
    RamdiskId?: string;
    BlockDeviceMappings?: EC2$20160401$ScheduledInstancesBlockDeviceMappingSet;
    Monitoring?: EC2$20160401$ScheduledInstancesMonitoring;
    SubnetId?: string;
    NetworkInterfaces?: EC2$20160401$ScheduledInstancesNetworkInterfaceSet;
    IamInstanceProfile?: EC2$20160401$ScheduledInstancesIamInstanceProfile;
    EbsOptimized?: boolean;
  };
  declare type EC2$20160401$ScheduledInstancesMonitoring = {
    Enabled?: boolean;
  };
  declare type EC2$20160401$ScheduledInstancesNetworkInterface = {
    NetworkInterfaceId?: string;
    DeviceIndex?: number;
    SubnetId?: string;
    Description?: string;
    PrivateIpAddress?: string;
    PrivateIpAddressConfigs?: EC2$20160401$PrivateIpAddressConfigSet;
    SecondaryPrivateIpAddressCount?: number;
    AssociatePublicIpAddress?: boolean;
    Groups?: EC2$20160401$ScheduledInstancesSecurityGroupIdSet;
    DeleteOnTermination?: boolean;
  };
  declare type EC2$20160401$ScheduledInstancesNetworkInterfaceSet = EC2$20160401$ScheduledInstancesNetworkInterface[];
  declare type EC2$20160401$ScheduledInstancesPlacement = {
    AvailabilityZone?: string;
    GroupName?: string;
  };
  declare type EC2$20160401$ScheduledInstancesPrivateIpAddressConfig = {
    PrivateIpAddress?: string;
    Primary?: boolean;
  };
  declare type EC2$20160401$ScheduledInstancesSecurityGroupIdSet = string[];
  declare type EC2$20160401$SecurityGroup = {
    OwnerId?: string;
    GroupName?: string;
    GroupId?: string;
    Description?: string;
    IpPermissions?: EC2$20160401$IpPermissionList;
    IpPermissionsEgress?: EC2$20160401$IpPermissionList;
    VpcId?: string;
    Tags?: EC2$20160401$TagList;
  };
  declare type EC2$20160401$SecurityGroupIdStringList = string[];
  declare type EC2$20160401$SecurityGroupList = EC2$20160401$SecurityGroup[];
  declare type EC2$20160401$SecurityGroupReference = {
    GroupId: string;
    ReferencingVpcId: string;
    VpcPeeringConnectionId?: string;
  };
  declare type EC2$20160401$SecurityGroupReferences = EC2$20160401$SecurityGroupReference[];
  declare type EC2$20160401$SecurityGroupStringList = string[];
  declare type EC2$20160401$ShutdownBehavior = 'stop' | 'terminate';
  declare type EC2$20160401$SlotDateTimeRangeRequest = {
    EarliestTime: Date;
    LatestTime: Date;
  };
  declare type EC2$20160401$SlotStartTimeRangeRequest = {
    EarliestTime?: Date;
    LatestTime?: Date;
  };
  declare type EC2$20160401$Snapshot = {
    SnapshotId?: string;
    VolumeId?: string;
    State?: 'pending' | 'completed' | 'error';
    StateMessage?: string;
    StartTime?: Date;
    Progress?: string;
    OwnerId?: string;
    Description?: string;
    VolumeSize?: number;
    OwnerAlias?: string;
    Tags?: EC2$20160401$TagList;
    Encrypted?: boolean;
    KmsKeyId?: string;
    DataEncryptionKeyId?: string;
  };
  declare type EC2$20160401$SnapshotAttributeName = 'productCodes' | 'createVolumePermission';
  declare type EC2$20160401$SnapshotDetail = {
    DiskImageSize?: number;
    Description?: string;
    Format?: string;
    Url?: string;
    UserBucket?: EC2$20160401$UserBucketDetails;
    DeviceName?: string;
    SnapshotId?: string;
    Progress?: string;
    StatusMessage?: string;
    Status?: string;
  };
  declare type EC2$20160401$SnapshotDetailList = EC2$20160401$SnapshotDetail[];
  declare type EC2$20160401$SnapshotDiskContainer = {
    Description?: string;
    Format?: string;
    Url?: string;
    UserBucket?: EC2$20160401$UserBucket;
  };
  declare type EC2$20160401$SnapshotIdStringList = string[];
  declare type EC2$20160401$SnapshotList = EC2$20160401$Snapshot[];
  declare type EC2$20160401$SnapshotState = 'pending' | 'completed' | 'error';
  declare type EC2$20160401$SnapshotTaskDetail = {
    DiskImageSize?: number;
    Description?: string;
    Format?: string;
    Url?: string;
    UserBucket?: EC2$20160401$UserBucketDetails;
    SnapshotId?: string;
    Progress?: string;
    StatusMessage?: string;
    Status?: string;
  };
  declare type EC2$20160401$SpotDatafeedSubscription = {
    OwnerId?: string;
    Bucket?: string;
    Prefix?: string;
    State?: 'Active' | 'Inactive';
    Fault?: EC2$20160401$SpotInstanceStateFault;
  };
  declare type EC2$20160401$SpotFleetLaunchSpecification = {
    ImageId?: string;
    KeyName?: string;
    SecurityGroups?: EC2$20160401$GroupIdentifierList;
    UserData?: string;
    AddressingType?: string;
    InstanceType?: 't1.micro' | 't2.nano' | 't2.micro' | 't2.small' | 't2.medium' | 't2.large' | 'm1.small' | 'm1.medium' | 'm1.large' | 'm1.xlarge' | 'm3.medium' | 'm3.large' | 'm3.xlarge' | 'm3.2xlarge' | 'm4.large' | 'm4.xlarge' | 'm4.2xlarge' | 'm4.4xlarge' | 'm4.10xlarge' | 'm2.xlarge' | 'm2.2xlarge' | 'm2.4xlarge' | 'cr1.8xlarge' | 'r3.large' | 'r3.xlarge' | 'r3.2xlarge' | 'r3.4xlarge' | 'r3.8xlarge' | 'x1.4xlarge' | 'x1.8xlarge' | 'x1.16xlarge' | 'x1.32xlarge' | 'i2.xlarge' | 'i2.2xlarge' | 'i2.4xlarge' | 'i2.8xlarge' | 'hi1.4xlarge' | 'hs1.8xlarge' | 'c1.medium' | 'c1.xlarge' | 'c3.large' | 'c3.xlarge' | 'c3.2xlarge' | 'c3.4xlarge' | 'c3.8xlarge' | 'c4.large' | 'c4.xlarge' | 'c4.2xlarge' | 'c4.4xlarge' | 'c4.8xlarge' | 'cc1.4xlarge' | 'cc2.8xlarge' | 'g2.2xlarge' | 'g2.8xlarge' | 'cg1.4xlarge' | 'd2.xlarge' | 'd2.2xlarge' | 'd2.4xlarge' | 'd2.8xlarge';
    Placement?: EC2$20160401$SpotPlacement;
    KernelId?: string;
    RamdiskId?: string;
    BlockDeviceMappings?: EC2$20160401$BlockDeviceMappingList;
    Monitoring?: EC2$20160401$SpotFleetMonitoring;
    SubnetId?: string;
    NetworkInterfaces?: EC2$20160401$InstanceNetworkInterfaceSpecificationList;
    IamInstanceProfile?: EC2$20160401$IamInstanceProfileSpecification;
    EbsOptimized?: boolean;
    WeightedCapacity?: number;
    SpotPrice?: string;
  };
  declare type EC2$20160401$SpotFleetMonitoring = {
    Enabled?: boolean;
  };
  declare type EC2$20160401$SpotFleetRequestConfig = {
    SpotFleetRequestId: string;
    SpotFleetRequestState: 'submitted' | 'active' | 'cancelled' | 'failed' | 'cancelled_running' | 'cancelled_terminating' | 'modifying';
    SpotFleetRequestConfig: EC2$20160401$SpotFleetRequestConfigData;
    CreateTime: Date;
  };
  declare type EC2$20160401$SpotFleetRequestConfigData = {
    ClientToken?: string;
    SpotPrice: string;
    TargetCapacity: number;
    ValidFrom?: Date;
    ValidUntil?: Date;
    TerminateInstancesWithExpiration?: boolean;
    IamFleetRole: string;
    LaunchSpecifications: EC2$20160401$LaunchSpecsList;
    ExcessCapacityTerminationPolicy?: 'noTermination' | 'default';
    AllocationStrategy?: 'lowestPrice' | 'diversified';
    FulfilledCapacity?: number;
    Type?: 'request' | 'maintain';
  };
  declare type EC2$20160401$SpotFleetRequestConfigSet = EC2$20160401$SpotFleetRequestConfig[];
  declare type EC2$20160401$SpotInstanceRequest = {
    SpotInstanceRequestId?: string;
    SpotPrice?: string;
    Type?: 'one-time' | 'persistent';
    State?: 'open' | 'active' | 'closed' | 'cancelled' | 'failed';
    Fault?: EC2$20160401$SpotInstanceStateFault;
    Status?: EC2$20160401$SpotInstanceStatus;
    ValidFrom?: Date;
    ValidUntil?: Date;
    LaunchGroup?: string;
    AvailabilityZoneGroup?: string;
    LaunchSpecification?: EC2$20160401$LaunchSpecification;
    InstanceId?: string;
    CreateTime?: Date;
    ProductDescription?: 'Linux/UNIX' | 'Linux/UNIX (Amazon VPC)' | 'Windows' | 'Windows (Amazon VPC)';
    BlockDurationMinutes?: number;
    ActualBlockHourlyPrice?: string;
    Tags?: EC2$20160401$TagList;
    LaunchedAvailabilityZone?: string;
  };
  declare type EC2$20160401$SpotInstanceRequestIdList = string[];
  declare type EC2$20160401$SpotInstanceRequestList = EC2$20160401$SpotInstanceRequest[];
  declare type EC2$20160401$SpotInstanceState = 'open' | 'active' | 'closed' | 'cancelled' | 'failed';
  declare type EC2$20160401$SpotInstanceStateFault = {
    Code?: string;
    Message?: string;
  };
  declare type EC2$20160401$SpotInstanceStatus = {
    Code?: string;
    UpdateTime?: Date;
    Message?: string;
  };
  declare type EC2$20160401$SpotInstanceType = 'one-time' | 'persistent';
  declare type EC2$20160401$SpotPlacement = {
    AvailabilityZone?: string;
    GroupName?: string;
  };
  declare type EC2$20160401$SpotPrice = {
    InstanceType?: 't1.micro' | 't2.nano' | 't2.micro' | 't2.small' | 't2.medium' | 't2.large' | 'm1.small' | 'm1.medium' | 'm1.large' | 'm1.xlarge' | 'm3.medium' | 'm3.large' | 'm3.xlarge' | 'm3.2xlarge' | 'm4.large' | 'm4.xlarge' | 'm4.2xlarge' | 'm4.4xlarge' | 'm4.10xlarge' | 'm2.xlarge' | 'm2.2xlarge' | 'm2.4xlarge' | 'cr1.8xlarge' | 'r3.large' | 'r3.xlarge' | 'r3.2xlarge' | 'r3.4xlarge' | 'r3.8xlarge' | 'x1.4xlarge' | 'x1.8xlarge' | 'x1.16xlarge' | 'x1.32xlarge' | 'i2.xlarge' | 'i2.2xlarge' | 'i2.4xlarge' | 'i2.8xlarge' | 'hi1.4xlarge' | 'hs1.8xlarge' | 'c1.medium' | 'c1.xlarge' | 'c3.large' | 'c3.xlarge' | 'c3.2xlarge' | 'c3.4xlarge' | 'c3.8xlarge' | 'c4.large' | 'c4.xlarge' | 'c4.2xlarge' | 'c4.4xlarge' | 'c4.8xlarge' | 'cc1.4xlarge' | 'cc2.8xlarge' | 'g2.2xlarge' | 'g2.8xlarge' | 'cg1.4xlarge' | 'd2.xlarge' | 'd2.2xlarge' | 'd2.4xlarge' | 'd2.8xlarge';
    ProductDescription?: 'Linux/UNIX' | 'Linux/UNIX (Amazon VPC)' | 'Windows' | 'Windows (Amazon VPC)';
    SpotPrice?: string;
    Timestamp?: Date;
    AvailabilityZone?: string;
  };
  declare type EC2$20160401$SpotPriceHistoryList = EC2$20160401$SpotPrice[];
  declare type EC2$20160401$StaleIpPermission = {
    FromPort?: number;
    IpProtocol?: string;
    IpRanges?: EC2$20160401$IpRanges;
    PrefixListIds?: EC2$20160401$PrefixListIdSet;
    ToPort?: number;
    UserIdGroupPairs?: EC2$20160401$UserIdGroupPairSet;
  };
  declare type EC2$20160401$StaleIpPermissionSet = EC2$20160401$StaleIpPermission[];
  declare type EC2$20160401$StaleSecurityGroup = {
    GroupId: string;
    GroupName?: string;
    Description?: string;
    VpcId?: string;
    StaleIpPermissions?: EC2$20160401$StaleIpPermissionSet;
    StaleIpPermissionsEgress?: EC2$20160401$StaleIpPermissionSet;
  };
  declare type EC2$20160401$StaleSecurityGroupSet = EC2$20160401$StaleSecurityGroup[];
  declare type EC2$20160401$StartInstancesRequest = {
    InstanceIds: EC2$20160401$InstanceIdStringList;
    AdditionalInfo?: string;
    DryRun?: boolean;
  };
  declare type EC2$20160401$StartInstancesResult = {
    StartingInstances?: EC2$20160401$InstanceStateChangeList;
  };
  declare type EC2$20160401$State = 'Pending' | 'Available' | 'Deleting' | 'Deleted';
  declare type EC2$20160401$StateReason = {
    Code?: string;
    Message?: string;
  };
  declare type EC2$20160401$Status = 'MoveInProgress' | 'InVpc' | 'InClassic';
  declare type EC2$20160401$StatusName = 'reachability';
  declare type EC2$20160401$StatusType = 'passed' | 'failed' | 'insufficient-data' | 'initializing';
  declare type EC2$20160401$StopInstancesRequest = {
    DryRun?: boolean;
    InstanceIds: EC2$20160401$InstanceIdStringList;
    Force?: boolean;
  };
  declare type EC2$20160401$StopInstancesResult = {
    StoppingInstances?: EC2$20160401$InstanceStateChangeList;
  };
  declare type EC2$20160401$Storage = {
    S3?: EC2$20160401$S3Storage;
  };
  declare type EC2$20160401$Subnet = {
    SubnetId?: string;
    State?: 'pending' | 'available';
    VpcId?: string;
    CidrBlock?: string;
    AvailableIpAddressCount?: number;
    AvailabilityZone?: string;
    DefaultForAz?: boolean;
    MapPublicIpOnLaunch?: boolean;
    Tags?: EC2$20160401$TagList;
  };
  declare type EC2$20160401$SubnetIdStringList = string[];
  declare type EC2$20160401$SubnetList = EC2$20160401$Subnet[];
  declare type EC2$20160401$SubnetState = 'pending' | 'available';
  declare type EC2$20160401$SummaryStatus = 'ok' | 'impaired' | 'insufficient-data' | 'not-applicable' | 'initializing';
  declare type EC2$20160401$Tag = {
    Key?: string;
    Value?: string;
  };
  declare type EC2$20160401$TagDescription = {
    ResourceId?: string;
    ResourceType?: 'customer-gateway' | 'dhcp-options' | 'image' | 'instance' | 'internet-gateway' | 'network-acl' | 'network-interface' | 'reserved-instances' | 'route-table' | 'snapshot' | 'spot-instances-request' | 'subnet' | 'security-group' | 'volume' | 'vpc' | 'vpn-connection' | 'vpn-gateway';
    Key?: string;
    Value?: string;
  };
  declare type EC2$20160401$TagDescriptionList = EC2$20160401$TagDescription[];
  declare type EC2$20160401$TagList = EC2$20160401$Tag[];
  declare type EC2$20160401$TelemetryStatus = 'UP' | 'DOWN';
  declare type EC2$20160401$Tenancy = 'default' | 'dedicated' | 'host';
  declare type EC2$20160401$TerminateInstancesRequest = {
    DryRun?: boolean;
    InstanceIds: EC2$20160401$InstanceIdStringList;
  };
  declare type EC2$20160401$TerminateInstancesResult = {
    TerminatingInstances?: EC2$20160401$InstanceStateChangeList;
  };
  declare type EC2$20160401$TrafficType = 'ACCEPT' | 'REJECT' | 'ALL';
  declare type EC2$20160401$UnassignPrivateIpAddressesRequest = {
    NetworkInterfaceId: string;
    PrivateIpAddresses: EC2$20160401$PrivateIpAddressStringList;
  };
  declare type EC2$20160401$UnmonitorInstancesRequest = {
    DryRun?: boolean;
    InstanceIds: EC2$20160401$InstanceIdStringList;
  };
  declare type EC2$20160401$UnmonitorInstancesResult = {
    InstanceMonitorings?: EC2$20160401$InstanceMonitoringList;
  };
  declare type EC2$20160401$UnsuccessfulItem = {
    ResourceId?: string;
    Error: EC2$20160401$UnsuccessfulItemError;
  };
  declare type EC2$20160401$UnsuccessfulItemError = {
    Code: string;
    Message: string;
  };
  declare type EC2$20160401$UnsuccessfulItemList = EC2$20160401$UnsuccessfulItem[];
  declare type EC2$20160401$UnsuccessfulItemSet = EC2$20160401$UnsuccessfulItem[];
  declare type EC2$20160401$UserBucket = {
    S3Bucket?: string;
    S3Key?: string;
  };
  declare type EC2$20160401$UserBucketDetails = {
    S3Bucket?: string;
    S3Key?: string;
  };
  declare type EC2$20160401$UserData = {
    Data?: string;
  };
  declare type EC2$20160401$UserGroupStringList = string[];
  declare type EC2$20160401$UserIdGroupPair = {
    UserId?: string;
    GroupName?: string;
    GroupId?: string;
    VpcId?: string;
    VpcPeeringConnectionId?: string;
    PeeringStatus?: string;
  };
  declare type EC2$20160401$UserIdGroupPairList = EC2$20160401$UserIdGroupPair[];
  declare type EC2$20160401$UserIdGroupPairSet = EC2$20160401$UserIdGroupPair[];
  declare type EC2$20160401$UserIdStringList = string[];
  declare type EC2$20160401$ValueStringList = string[];
  declare type EC2$20160401$VgwTelemetry = {
    OutsideIpAddress?: string;
    Status?: 'UP' | 'DOWN';
    LastStatusChange?: Date;
    StatusMessage?: string;
    AcceptedRouteCount?: number;
  };
  declare type EC2$20160401$VgwTelemetryList = EC2$20160401$VgwTelemetry[];
  declare type EC2$20160401$VirtualizationType = 'hvm' | 'paravirtual';
  declare type EC2$20160401$Volume = {
    VolumeId?: string;
    Size?: number;
    SnapshotId?: string;
    AvailabilityZone?: string;
    State?: 'creating' | 'available' | 'in-use' | 'deleting' | 'deleted' | 'error';
    CreateTime?: Date;
    Attachments?: EC2$20160401$VolumeAttachmentList;
    Tags?: EC2$20160401$TagList;
    VolumeType?: 'standard' | 'io1' | 'gp2' | 'sc1' | 'st1';
    Iops?: number;
    Encrypted?: boolean;
    KmsKeyId?: string;
  };
  declare type EC2$20160401$VolumeAttachment = {
    VolumeId?: string;
    InstanceId?: string;
    Device?: string;
    State?: 'attaching' | 'attached' | 'detaching' | 'detached';
    AttachTime?: Date;
    DeleteOnTermination?: boolean;
  };
  declare type EC2$20160401$VolumeAttachmentList = EC2$20160401$VolumeAttachment[];
  declare type EC2$20160401$VolumeAttachmentState = 'attaching' | 'attached' | 'detaching' | 'detached';
  declare type EC2$20160401$VolumeAttributeName = 'autoEnableIO' | 'productCodes';
  declare type EC2$20160401$VolumeDetail = {
    Size: number;
  };
  declare type EC2$20160401$VolumeIdStringList = string[];
  declare type EC2$20160401$VolumeList = EC2$20160401$Volume[];
  declare type EC2$20160401$VolumeState = 'creating' | 'available' | 'in-use' | 'deleting' | 'deleted' | 'error';
  declare type EC2$20160401$VolumeStatusAction = {
    Code?: string;
    Description?: string;
    EventType?: string;
    EventId?: string;
  };
  declare type EC2$20160401$VolumeStatusActionsList = EC2$20160401$VolumeStatusAction[];
  declare type EC2$20160401$VolumeStatusDetails = {
    Name?: 'io-enabled' | 'io-performance';
    Status?: string;
  };
  declare type EC2$20160401$VolumeStatusDetailsList = EC2$20160401$VolumeStatusDetails[];
  declare type EC2$20160401$VolumeStatusEvent = {
    EventType?: string;
    Description?: string;
    NotBefore?: Date;
    NotAfter?: Date;
    EventId?: string;
  };
  declare type EC2$20160401$VolumeStatusEventsList = EC2$20160401$VolumeStatusEvent[];
  declare type EC2$20160401$VolumeStatusInfo = {
    Status?: 'ok' | 'impaired' | 'insufficient-data';
    Details?: EC2$20160401$VolumeStatusDetailsList;
  };
  declare type EC2$20160401$VolumeStatusInfoStatus = 'ok' | 'impaired' | 'insufficient-data';
  declare type EC2$20160401$VolumeStatusItem = {
    VolumeId?: string;
    AvailabilityZone?: string;
    VolumeStatus?: EC2$20160401$VolumeStatusInfo;
    Events?: EC2$20160401$VolumeStatusEventsList;
    Actions?: EC2$20160401$VolumeStatusActionsList;
  };
  declare type EC2$20160401$VolumeStatusList = EC2$20160401$VolumeStatusItem[];
  declare type EC2$20160401$VolumeStatusName = 'io-enabled' | 'io-performance';
  declare type EC2$20160401$VolumeType = 'standard' | 'io1' | 'gp2' | 'sc1' | 'st1';
  declare type EC2$20160401$Vpc = {
    VpcId?: string;
    State?: 'pending' | 'available';
    CidrBlock?: string;
    DhcpOptionsId?: string;
    Tags?: EC2$20160401$TagList;
    InstanceTenancy?: 'default' | 'dedicated' | 'host';
    IsDefault?: boolean;
  };
  declare type EC2$20160401$VpcAttachment = {
    VpcId?: string;
    State?: 'attaching' | 'attached' | 'detaching' | 'detached';
  };
  declare type EC2$20160401$VpcAttachmentList = EC2$20160401$VpcAttachment[];
  declare type EC2$20160401$VpcAttributeName = 'enableDnsSupport' | 'enableDnsHostnames';
  declare type EC2$20160401$VpcClassicLink = {
    VpcId?: string;
    ClassicLinkEnabled?: boolean;
    Tags?: EC2$20160401$TagList;
  };
  declare type EC2$20160401$VpcClassicLinkIdList = string[];
  declare type EC2$20160401$VpcClassicLinkList = EC2$20160401$VpcClassicLink[];
  declare type EC2$20160401$VpcEndpoint = {
    VpcEndpointId?: string;
    VpcId?: string;
    ServiceName?: string;
    State?: 'Pending' | 'Available' | 'Deleting' | 'Deleted';
    PolicyDocument?: string;
    RouteTableIds?: EC2$20160401$ValueStringList;
    CreationTimestamp?: Date;
  };
  declare type EC2$20160401$VpcEndpointSet = EC2$20160401$VpcEndpoint[];
  declare type EC2$20160401$VpcIdStringList = string[];
  declare type EC2$20160401$VpcList = EC2$20160401$Vpc[];
  declare type EC2$20160401$VpcPeeringConnection = {
    AccepterVpcInfo?: EC2$20160401$VpcPeeringConnectionVpcInfo;
    ExpirationTime?: Date;
    RequesterVpcInfo?: EC2$20160401$VpcPeeringConnectionVpcInfo;
    Status?: EC2$20160401$VpcPeeringConnectionStateReason;
    Tags?: EC2$20160401$TagList;
    VpcPeeringConnectionId?: string;
  };
  declare type EC2$20160401$VpcPeeringConnectionList = EC2$20160401$VpcPeeringConnection[];
  declare type EC2$20160401$VpcPeeringConnectionOptionsDescription = {
    AllowEgressFromLocalClassicLinkToRemoteVpc?: boolean;
    AllowEgressFromLocalVpcToRemoteClassicLink?: boolean;
    AllowDnsResolutionFromRemoteVpc?: boolean;
  };
  declare type EC2$20160401$VpcPeeringConnectionStateReason = {
    Code?: 'initiating-request' | 'pending-acceptance' | 'active' | 'deleted' | 'rejected' | 'failed' | 'expired' | 'provisioning' | 'deleting';
    Message?: string;
  };
  declare type EC2$20160401$VpcPeeringConnectionStateReasonCode = 'initiating-request' | 'pending-acceptance' | 'active' | 'deleted' | 'rejected' | 'failed' | 'expired' | 'provisioning' | 'deleting';
  declare type EC2$20160401$VpcPeeringConnectionVpcInfo = {
    CidrBlock?: string;
    OwnerId?: string;
    VpcId?: string;
    PeeringOptions?: EC2$20160401$VpcPeeringConnectionOptionsDescription;
  };
  declare type EC2$20160401$VpcState = 'pending' | 'available';
  declare type EC2$20160401$VpnConnection = {
    VpnConnectionId?: string;
    State?: 'pending' | 'available' | 'deleting' | 'deleted';
    CustomerGatewayConfiguration?: string;
    Type?: 'ipsec.1';
    CustomerGatewayId?: string;
    VpnGatewayId?: string;
    Tags?: EC2$20160401$TagList;
    VgwTelemetry?: EC2$20160401$VgwTelemetryList;
    Options?: EC2$20160401$VpnConnectionOptions;
    Routes?: EC2$20160401$VpnStaticRouteList;
  };
  declare type EC2$20160401$VpnConnectionIdStringList = string[];
  declare type EC2$20160401$VpnConnectionList = EC2$20160401$VpnConnection[];
  declare type EC2$20160401$VpnConnectionOptions = {
    StaticRoutesOnly?: boolean;
  };
  declare type EC2$20160401$VpnConnectionOptionsSpecification = {
    StaticRoutesOnly?: boolean;
  };
  declare type EC2$20160401$VpnGateway = {
    VpnGatewayId?: string;
    State?: 'pending' | 'available' | 'deleting' | 'deleted';
    Type?: 'ipsec.1';
    AvailabilityZone?: string;
    VpcAttachments?: EC2$20160401$VpcAttachmentList;
    Tags?: EC2$20160401$TagList;
  };
  declare type EC2$20160401$VpnGatewayIdStringList = string[];
  declare type EC2$20160401$VpnGatewayList = EC2$20160401$VpnGateway[];
  declare type EC2$20160401$VpnState = 'pending' | 'available' | 'deleting' | 'deleted';
  declare type EC2$20160401$VpnStaticRoute = {
    DestinationCidrBlock?: string;
    Source?: 'Static';
    State?: 'pending' | 'available' | 'deleting' | 'deleted';
  };
  declare type EC2$20160401$VpnStaticRouteList = EC2$20160401$VpnStaticRoute[];
  declare type EC2$20160401$VpnStaticRouteSource = 'Static';
  declare type EC2$20160401$ZoneNameStringList = string[];
  declare type ECR$20150921$AuthorizationData = {
    authorizationToken?: string;
    expiresAt?: Date;
    proxyEndpoint?: string;
  };
  declare type ECR$20150921$AuthorizationDataList = ECR$20150921$AuthorizationData[];
  declare type ECR$20150921$BatchCheckLayerAvailabilityRequest = {
    registryId?: string;
    repositoryName: string;
    layerDigests: ECR$20150921$BatchedOperationLayerDigestList;
  };
  declare type ECR$20150921$BatchCheckLayerAvailabilityResponse = {
    layers?: ECR$20150921$LayerList;
    failures?: ECR$20150921$LayerFailureList;
  };
  declare type ECR$20150921$BatchDeleteImageRequest = {
    registryId?: string;
    repositoryName: string;
    imageIds: ECR$20150921$ImageIdentifierList;
  };
  declare type ECR$20150921$BatchDeleteImageResponse = {
    imageIds?: ECR$20150921$ImageIdentifierList;
    failures?: ECR$20150921$ImageFailureList;
  };
  declare type ECR$20150921$BatchGetImageRequest = {
    registryId?: string;
    repositoryName: string;
    imageIds: ECR$20150921$ImageIdentifierList;
  };
  declare type ECR$20150921$BatchGetImageResponse = {
    images?: ECR$20150921$ImageList;
    failures?: ECR$20150921$ImageFailureList;
  };
  declare type ECR$20150921$BatchedOperationLayerDigestList = string[];
  declare type ECR$20150921$CompleteLayerUploadRequest = {
    registryId?: string;
    repositoryName: string;
    uploadId: string;
    layerDigests: ECR$20150921$LayerDigestList;
  };
  declare type ECR$20150921$CompleteLayerUploadResponse = {
    registryId?: string;
    repositoryName?: string;
    uploadId?: string;
    layerDigest?: string;
  };
  declare type ECR$20150921$CreateRepositoryRequest = {
    repositoryName: string;
  };
  declare type ECR$20150921$CreateRepositoryResponse = {
    repository?: ECR$20150921$Repository;
  };
  declare type ECR$20150921$DeleteRepositoryPolicyRequest = {
    registryId?: string;
    repositoryName: string;
  };
  declare type ECR$20150921$DeleteRepositoryPolicyResponse = {
    registryId?: string;
    repositoryName?: string;
    policyText?: string;
  };
  declare type ECR$20150921$DeleteRepositoryRequest = {
    registryId?: string;
    repositoryName: string;
    force?: boolean;
  };
  declare type ECR$20150921$DeleteRepositoryResponse = {
    repository?: ECR$20150921$Repository;
  };
  declare type ECR$20150921$DescribeRepositoriesRequest = {
    registryId?: string;
    repositoryNames?: ECR$20150921$RepositoryNameList;
    nextToken?: string;
    maxResults?: number;
  };
  declare type ECR$20150921$DescribeRepositoriesResponse = {
    repositories?: ECR$20150921$RepositoryList;
    nextToken?: string;
  };
  declare type ECR$20150921$EmptyUploadException = {
    message?: string;
  };
  declare type ECR$20150921$ExpirationTimestamp = Date;
  declare type ECR$20150921$GetAuthorizationTokenRegistryIdList = string[];
  declare type ECR$20150921$GetAuthorizationTokenRequest = {
    registryIds?: ECR$20150921$GetAuthorizationTokenRegistryIdList;
  };
  declare type ECR$20150921$GetAuthorizationTokenResponse = {
    authorizationData?: ECR$20150921$AuthorizationDataList;
  };
  declare type ECR$20150921$GetDownloadUrlForLayerRequest = {
    registryId?: string;
    repositoryName: string;
    layerDigest: string;
  };
  declare type ECR$20150921$GetDownloadUrlForLayerResponse = {
    downloadUrl?: string;
    layerDigest?: string;
  };
  declare type ECR$20150921$GetRepositoryPolicyRequest = {
    registryId?: string;
    repositoryName: string;
  };
  declare type ECR$20150921$GetRepositoryPolicyResponse = {
    registryId?: string;
    repositoryName?: string;
    policyText?: string;
  };
  declare type ECR$20150921$Image = {
    registryId?: string;
    repositoryName?: string;
    imageId?: ECR$20150921$ImageIdentifier;
    imageManifest?: string;
  };
  declare type ECR$20150921$ImageAlreadyExistsException = {
    message?: string;
  };
  declare type ECR$20150921$ImageFailure = {
    imageId?: ECR$20150921$ImageIdentifier;
    failureCode?: 'InvalidImageDigest' | 'InvalidImageTag' | 'ImageTagDoesNotMatchDigest' | 'ImageNotFound' | 'MissingDigestAndTag';
    failureReason?: string;
  };
  declare type ECR$20150921$ImageFailureCode = 'InvalidImageDigest' | 'InvalidImageTag' | 'ImageTagDoesNotMatchDigest' | 'ImageNotFound' | 'MissingDigestAndTag';
  declare type ECR$20150921$ImageFailureList = ECR$20150921$ImageFailure[];
  declare type ECR$20150921$ImageIdentifier = {
    imageDigest?: string;
    imageTag?: string;
  };
  declare type ECR$20150921$ImageIdentifierList = ECR$20150921$ImageIdentifier[];
  declare type ECR$20150921$ImageList = ECR$20150921$Image[];
  declare type ECR$20150921$InitiateLayerUploadRequest = {
    registryId?: string;
    repositoryName: string;
  };
  declare type ECR$20150921$InitiateLayerUploadResponse = {
    uploadId?: string;
    partSize?: number;
  };
  declare type ECR$20150921$InvalidLayerException = {
    message?: string;
  };
  declare type ECR$20150921$InvalidLayerPartException = {
    registryId?: string;
    repositoryName?: string;
    uploadId?: string;
    lastValidByteReceived?: number;
    message?: string;
  };
  declare type ECR$20150921$InvalidParameterException = {
    message?: string;
  };
  declare type ECR$20150921$Layer = {
    layerDigest?: string;
    layerAvailability?: 'AVAILABLE' | 'UNAVAILABLE';
    layerSize?: number;
  };
  declare type ECR$20150921$LayerAlreadyExistsException = {
    message?: string;
  };
  declare type ECR$20150921$LayerAvailability = 'AVAILABLE' | 'UNAVAILABLE';
  declare type ECR$20150921$LayerDigestList = string[];
  declare type ECR$20150921$LayerFailure = {
    layerDigest?: string;
    failureCode?: 'InvalidLayerDigest' | 'MissingLayerDigest';
    failureReason?: string;
  };
  declare type ECR$20150921$LayerFailureCode = 'InvalidLayerDigest' | 'MissingLayerDigest';
  declare type ECR$20150921$LayerFailureList = ECR$20150921$LayerFailure[];
  declare type ECR$20150921$LayerInaccessibleException = {
    message?: string;
  };
  declare type ECR$20150921$LayerList = ECR$20150921$Layer[];
  declare type ECR$20150921$LayerPartBlob = Buffer | $TypedArray | Blob | string;
  declare type ECR$20150921$LayerPartTooSmallException = {
    message?: string;
  };
  declare type ECR$20150921$LayersNotFoundException = {
    message?: string;
  };
  declare type ECR$20150921$LimitExceededException = {
    message?: string;
  };
  declare type ECR$20150921$ListImagesFilter = {
    tagStatus?: 'TAGGED' | 'UNTAGGED';
  };
  declare type ECR$20150921$ListImagesRequest = {
    registryId?: string;
    repositoryName: string;
    nextToken?: string;
    maxResults?: number;
    filter?: ECR$20150921$ListImagesFilter;
  };
  declare type ECR$20150921$ListImagesResponse = {
    imageIds?: ECR$20150921$ImageIdentifierList;
    nextToken?: string;
  };
  declare type ECR$20150921$PutImageRequest = {
    registryId?: string;
    repositoryName: string;
    imageManifest: string;
  };
  declare type ECR$20150921$PutImageResponse = {
    image?: ECR$20150921$Image;
  };
  declare type ECR$20150921$Repository = {
    repositoryArn?: string;
    registryId?: string;
    repositoryName?: string;
    repositoryUri?: string;
  };
  declare type ECR$20150921$RepositoryAlreadyExistsException = {
    message?: string;
  };
  declare type ECR$20150921$RepositoryList = ECR$20150921$Repository[];
  declare type ECR$20150921$RepositoryNameList = string[];
  declare type ECR$20150921$RepositoryNotEmptyException = {
    message?: string;
  };
  declare type ECR$20150921$RepositoryNotFoundException = {
    message?: string;
  };
  declare type ECR$20150921$RepositoryPolicyNotFoundException = {
    message?: string;
  };
  declare type ECR$20150921$ServerException = {
    message?: string;
  };
  declare type ECR$20150921$SetRepositoryPolicyRequest = {
    registryId?: string;
    repositoryName: string;
    policyText: string;
    force?: boolean;
  };
  declare type ECR$20150921$SetRepositoryPolicyResponse = {
    registryId?: string;
    repositoryName?: string;
    policyText?: string;
  };
  declare type ECR$20150921$TagStatus = 'TAGGED' | 'UNTAGGED';
  declare type ECR$20150921$UploadLayerPartRequest = {
    registryId?: string;
    repositoryName: string;
    uploadId: string;
    partFirstByte: number;
    partLastByte: number;
    layerPartBlob: Buffer | $TypedArray | Blob | string;
  };
  declare type ECR$20150921$UploadLayerPartResponse = {
    registryId?: string;
    repositoryName?: string;
    uploadId?: string;
    lastByteReceived?: number;
  };
  declare type ECR$20150921$UploadNotFoundException = {
    message?: string;
  };
  declare type ECS$20141113$AgentUpdateStatus = 'PENDING' | 'STAGING' | 'STAGED' | 'UPDATING' | 'UPDATED' | 'FAILED';
  declare type ECS$20141113$Attribute = {
    name: string;
    value?: string;
  };
  declare type ECS$20141113$Attributes = ECS$20141113$Attribute[];
  declare type ECS$20141113$ClientException = {
    message?: string;
  };
  declare type ECS$20141113$Cluster = {
    clusterArn?: string;
    clusterName?: string;
    status?: string;
    registeredContainerInstancesCount?: number;
    runningTasksCount?: number;
    pendingTasksCount?: number;
    activeServicesCount?: number;
  };
  declare type ECS$20141113$ClusterContainsContainerInstancesException = {};
  declare type ECS$20141113$ClusterContainsServicesException = {};
  declare type ECS$20141113$ClusterNotFoundException = {};
  declare type ECS$20141113$Clusters = ECS$20141113$Cluster[];
  declare type ECS$20141113$Container = {
    containerArn?: string;
    taskArn?: string;
    name?: string;
    lastStatus?: string;
    exitCode?: number;
    reason?: string;
    networkBindings?: ECS$20141113$NetworkBindings;
  };
  declare type ECS$20141113$ContainerDefinition = {
    name?: string;
    image?: string;
    cpu?: number;
    memory?: number;
    links?: ECS$20141113$StringList;
    portMappings?: ECS$20141113$PortMappingList;
    essential?: boolean;
    entryPoint?: ECS$20141113$StringList;
    command?: ECS$20141113$StringList;
    environment?: ECS$20141113$EnvironmentVariables;
    mountPoints?: ECS$20141113$MountPointList;
    volumesFrom?: ECS$20141113$VolumeFromList;
    hostname?: string;
    user?: string;
    workingDirectory?: string;
    disableNetworking?: boolean;
    privileged?: boolean;
    readonlyRootFilesystem?: boolean;
    dnsServers?: ECS$20141113$StringList;
    dnsSearchDomains?: ECS$20141113$StringList;
    extraHosts?: ECS$20141113$HostEntryList;
    dockerSecurityOptions?: ECS$20141113$StringList;
    dockerLabels?: {
      [key: string]: string;
    };
    ulimits?: ECS$20141113$UlimitList;
    logConfiguration?: ECS$20141113$LogConfiguration;
  };
  declare type ECS$20141113$ContainerDefinitions = ECS$20141113$ContainerDefinition[];
  declare type ECS$20141113$ContainerInstance = {
    containerInstanceArn?: string;
    ec2InstanceId?: string;
    versionInfo?: ECS$20141113$VersionInfo;
    remainingResources?: ECS$20141113$Resources;
    registeredResources?: ECS$20141113$Resources;
    status?: string;
    agentConnected?: boolean;
    runningTasksCount?: number;
    pendingTasksCount?: number;
    agentUpdateStatus?: 'PENDING' | 'STAGING' | 'STAGED' | 'UPDATING' | 'UPDATED' | 'FAILED';
    attributes?: ECS$20141113$Attributes;
  };
  declare type ECS$20141113$ContainerInstances = ECS$20141113$ContainerInstance[];
  declare type ECS$20141113$ContainerOverride = {
    name?: string;
    command?: ECS$20141113$StringList;
    environment?: ECS$20141113$EnvironmentVariables;
  };
  declare type ECS$20141113$ContainerOverrides = ECS$20141113$ContainerOverride[];
  declare type ECS$20141113$Containers = ECS$20141113$Container[];
  declare type ECS$20141113$CreateClusterRequest = {
    clusterName?: string;
  };
  declare type ECS$20141113$CreateClusterResponse = {
    cluster?: ECS$20141113$Cluster;
  };
  declare type ECS$20141113$CreateServiceRequest = {
    cluster?: string;
    serviceName: string;
    taskDefinition: string;
    loadBalancers?: ECS$20141113$LoadBalancers;
    desiredCount: number;
    clientToken?: string;
    role?: string;
    deploymentConfiguration?: ECS$20141113$DeploymentConfiguration;
  };
  declare type ECS$20141113$CreateServiceResponse = {
    service?: ECS$20141113$Service;
  };
  declare type ECS$20141113$DeleteClusterRequest = {
    cluster: string;
  };
  declare type ECS$20141113$DeleteClusterResponse = {
    cluster?: ECS$20141113$Cluster;
  };
  declare type ECS$20141113$DeleteServiceRequest = {
    cluster?: string;
    service: string;
  };
  declare type ECS$20141113$DeleteServiceResponse = {
    service?: ECS$20141113$Service;
  };
  declare type ECS$20141113$Deployment = {
    id?: string;
    status?: string;
    taskDefinition?: string;
    desiredCount?: number;
    pendingCount?: number;
    runningCount?: number;
    createdAt?: Date;
    updatedAt?: Date;
  };
  declare type ECS$20141113$DeploymentConfiguration = {
    maximumPercent?: number;
    minimumHealthyPercent?: number;
  };
  declare type ECS$20141113$Deployments = ECS$20141113$Deployment[];
  declare type ECS$20141113$DeregisterContainerInstanceRequest = {
    cluster?: string;
    containerInstance: string;
    force?: boolean;
  };
  declare type ECS$20141113$DeregisterContainerInstanceResponse = {
    containerInstance?: ECS$20141113$ContainerInstance;
  };
  declare type ECS$20141113$DeregisterTaskDefinitionRequest = {
    taskDefinition: string;
  };
  declare type ECS$20141113$DeregisterTaskDefinitionResponse = {
    taskDefinition?: ECS$20141113$TaskDefinition;
  };
  declare type ECS$20141113$DescribeClustersRequest = {
    clusters?: ECS$20141113$StringList;
  };
  declare type ECS$20141113$DescribeClustersResponse = {
    clusters?: ECS$20141113$Clusters;
    failures?: ECS$20141113$Failures;
  };
  declare type ECS$20141113$DescribeContainerInstancesRequest = {
    cluster?: string;
    containerInstances: ECS$20141113$StringList;
  };
  declare type ECS$20141113$DescribeContainerInstancesResponse = {
    containerInstances?: ECS$20141113$ContainerInstances;
    failures?: ECS$20141113$Failures;
  };
  declare type ECS$20141113$DescribeServicesRequest = {
    cluster?: string;
    services: ECS$20141113$StringList;
  };
  declare type ECS$20141113$DescribeServicesResponse = {
    services?: ECS$20141113$Services;
    failures?: ECS$20141113$Failures;
  };
  declare type ECS$20141113$DescribeTaskDefinitionRequest = {
    taskDefinition: string;
  };
  declare type ECS$20141113$DescribeTaskDefinitionResponse = {
    taskDefinition?: ECS$20141113$TaskDefinition;
  };
  declare type ECS$20141113$DescribeTasksRequest = {
    cluster?: string;
    tasks: ECS$20141113$StringList;
  };
  declare type ECS$20141113$DescribeTasksResponse = {
    tasks?: ECS$20141113$Tasks;
    failures?: ECS$20141113$Failures;
  };
  declare type ECS$20141113$DesiredStatus = 'RUNNING' | 'PENDING' | 'STOPPED';
  declare type ECS$20141113$DiscoverPollEndpointRequest = {
    containerInstance?: string;
    cluster?: string;
  };
  declare type ECS$20141113$DiscoverPollEndpointResponse = {
    endpoint?: string;
    telemetryEndpoint?: string;
  };
  declare type ECS$20141113$DockerLabelsMap = {
    [key: string]: string;
  };
  declare type ECS$20141113$EnvironmentVariables = ECS$20141113$KeyValuePair[];
  declare type ECS$20141113$Failure = {
    arn?: string;
    reason?: string;
  };
  declare type ECS$20141113$Failures = ECS$20141113$Failure[];
  declare type ECS$20141113$HostEntry = {
    hostname: string;
    ipAddress: string;
  };
  declare type ECS$20141113$HostEntryList = ECS$20141113$HostEntry[];
  declare type ECS$20141113$HostVolumeProperties = {
    sourcePath?: string;
  };
  declare type ECS$20141113$InvalidParameterException = {};
  declare type ECS$20141113$KeyValuePair = {
    name?: string;
    value?: string;
  };
  declare type ECS$20141113$ListClustersRequest = {
    nextToken?: string;
    maxResults?: number;
  };
  declare type ECS$20141113$ListClustersResponse = {
    clusterArns?: ECS$20141113$StringList;
    nextToken?: string;
  };
  declare type ECS$20141113$ListContainerInstancesRequest = {
    cluster?: string;
    nextToken?: string;
    maxResults?: number;
  };
  declare type ECS$20141113$ListContainerInstancesResponse = {
    containerInstanceArns?: ECS$20141113$StringList;
    nextToken?: string;
  };
  declare type ECS$20141113$ListServicesRequest = {
    cluster?: string;
    nextToken?: string;
    maxResults?: number;
  };
  declare type ECS$20141113$ListServicesResponse = {
    serviceArns?: ECS$20141113$StringList;
    nextToken?: string;
  };
  declare type ECS$20141113$ListTaskDefinitionFamiliesRequest = {
    familyPrefix?: string;
    status?: 'ACTIVE' | 'INACTIVE' | 'ALL';
    nextToken?: string;
    maxResults?: number;
  };
  declare type ECS$20141113$ListTaskDefinitionFamiliesResponse = {
    families?: ECS$20141113$StringList;
    nextToken?: string;
  };
  declare type ECS$20141113$ListTaskDefinitionsRequest = {
    familyPrefix?: string;
    status?: 'ACTIVE' | 'INACTIVE';
    sort?: 'ASC' | 'DESC';
    nextToken?: string;
    maxResults?: number;
  };
  declare type ECS$20141113$ListTaskDefinitionsResponse = {
    taskDefinitionArns?: ECS$20141113$StringList;
    nextToken?: string;
  };
  declare type ECS$20141113$ListTasksRequest = {
    cluster?: string;
    containerInstance?: string;
    family?: string;
    nextToken?: string;
    maxResults?: number;
    startedBy?: string;
    serviceName?: string;
    desiredStatus?: 'RUNNING' | 'PENDING' | 'STOPPED';
  };
  declare type ECS$20141113$ListTasksResponse = {
    taskArns?: ECS$20141113$StringList;
    nextToken?: string;
  };
  declare type ECS$20141113$LoadBalancer = {
    targetGroupArn?: string;
    loadBalancerName?: string;
    containerName?: string;
    containerPort?: number;
  };
  declare type ECS$20141113$LoadBalancers = ECS$20141113$LoadBalancer[];
  declare type ECS$20141113$LogConfiguration = {
    logDriver: 'json-file' | 'syslog' | 'journald' | 'gelf' | 'fluentd' | 'awslogs';
    options?: {
      [key: string]: string;
    };
  };
  declare type ECS$20141113$LogConfigurationOptionsMap = {
    [key: string]: string;
  };
  declare type ECS$20141113$LogDriver = 'json-file' | 'syslog' | 'journald' | 'gelf' | 'fluentd' | 'awslogs';
  declare type ECS$20141113$MissingVersionException = {};
  declare type ECS$20141113$MountPoint = {
    sourceVolume?: string;
    containerPath?: string;
    readOnly?: boolean;
  };
  declare type ECS$20141113$MountPointList = ECS$20141113$MountPoint[];
  declare type ECS$20141113$NetworkBinding = {
    bindIP?: string;
    containerPort?: number;
    hostPort?: number;
    protocol?: 'tcp' | 'udp';
  };
  declare type ECS$20141113$NetworkBindings = ECS$20141113$NetworkBinding[];
  declare type ECS$20141113$NoUpdateAvailableException = {};
  declare type ECS$20141113$PortMapping = {
    containerPort?: number;
    hostPort?: number;
    protocol?: 'tcp' | 'udp';
  };
  declare type ECS$20141113$PortMappingList = ECS$20141113$PortMapping[];
  declare type ECS$20141113$RegisterContainerInstanceRequest = {
    cluster?: string;
    instanceIdentityDocument?: string;
    instanceIdentityDocumentSignature?: string;
    totalResources?: ECS$20141113$Resources;
    versionInfo?: ECS$20141113$VersionInfo;
    containerInstanceArn?: string;
    attributes?: ECS$20141113$Attributes;
  };
  declare type ECS$20141113$RegisterContainerInstanceResponse = {
    containerInstance?: ECS$20141113$ContainerInstance;
  };
  declare type ECS$20141113$RegisterTaskDefinitionRequest = {
    family: string;
    taskRoleArn?: string;
    containerDefinitions: ECS$20141113$ContainerDefinitions;
    volumes?: ECS$20141113$VolumeList;
  };
  declare type ECS$20141113$RegisterTaskDefinitionResponse = {
    taskDefinition?: ECS$20141113$TaskDefinition;
  };
  declare type ECS$20141113$RequiresAttributes = ECS$20141113$Attribute[];
  declare type ECS$20141113$Resource = {
    name?: string;
    type?: string;
    doubleValue?: number;
    longValue?: number;
    integerValue?: number;
    stringSetValue?: ECS$20141113$StringList;
  };
  declare type ECS$20141113$Resources = ECS$20141113$Resource[];
  declare type ECS$20141113$RunTaskRequest = {
    cluster?: string;
    taskDefinition: string;
    overrides?: ECS$20141113$TaskOverride;
    count?: number;
    startedBy?: string;
  };
  declare type ECS$20141113$RunTaskResponse = {
    tasks?: ECS$20141113$Tasks;
    failures?: ECS$20141113$Failures;
  };
  declare type ECS$20141113$ServerException = {
    message?: string;
  };
  declare type ECS$20141113$Service = {
    serviceArn?: string;
    serviceName?: string;
    clusterArn?: string;
    loadBalancers?: ECS$20141113$LoadBalancers;
    status?: string;
    desiredCount?: number;
    runningCount?: number;
    pendingCount?: number;
    taskDefinition?: string;
    deploymentConfiguration?: ECS$20141113$DeploymentConfiguration;
    deployments?: ECS$20141113$Deployments;
    roleArn?: string;
    events?: ECS$20141113$ServiceEvents;
    createdAt?: Date;
  };
  declare type ECS$20141113$ServiceEvent = {
    id?: string;
    createdAt?: Date;
    message?: string;
  };
  declare type ECS$20141113$ServiceEvents = ECS$20141113$ServiceEvent[];
  declare type ECS$20141113$ServiceNotActiveException = {};
  declare type ECS$20141113$ServiceNotFoundException = {};
  declare type ECS$20141113$Services = ECS$20141113$Service[];
  declare type ECS$20141113$SortOrder = 'ASC' | 'DESC';
  declare type ECS$20141113$StartTaskRequest = {
    cluster?: string;
    taskDefinition: string;
    overrides?: ECS$20141113$TaskOverride;
    containerInstances: ECS$20141113$StringList;
    startedBy?: string;
  };
  declare type ECS$20141113$StartTaskResponse = {
    tasks?: ECS$20141113$Tasks;
    failures?: ECS$20141113$Failures;
  };
  declare type ECS$20141113$StopTaskRequest = {
    cluster?: string;
    task: string;
    reason?: string;
  };
  declare type ECS$20141113$StopTaskResponse = {
    task?: ECS$20141113$Task;
  };
  declare type ECS$20141113$StringList = string[];
  declare type ECS$20141113$SubmitContainerStateChangeRequest = {
    cluster?: string;
    task?: string;
    containerName?: string;
    status?: string;
    exitCode?: number;
    reason?: string;
    networkBindings?: ECS$20141113$NetworkBindings;
  };
  declare type ECS$20141113$SubmitContainerStateChangeResponse = {
    acknowledgment?: string;
  };
  declare type ECS$20141113$SubmitTaskStateChangeRequest = {
    cluster?: string;
    task?: string;
    status?: string;
    reason?: string;
  };
  declare type ECS$20141113$SubmitTaskStateChangeResponse = {
    acknowledgment?: string;
  };
  declare type ECS$20141113$Task = {
    taskArn?: string;
    clusterArn?: string;
    taskDefinitionArn?: string;
    containerInstanceArn?: string;
    overrides?: ECS$20141113$TaskOverride;
    lastStatus?: string;
    desiredStatus?: string;
    containers?: ECS$20141113$Containers;
    startedBy?: string;
    stoppedReason?: string;
    createdAt?: Date;
    startedAt?: Date;
    stoppedAt?: Date;
  };
  declare type ECS$20141113$TaskDefinition = {
    taskDefinitionArn?: string;
    containerDefinitions?: ECS$20141113$ContainerDefinitions;
    family?: string;
    taskRoleArn?: string;
    revision?: number;
    volumes?: ECS$20141113$VolumeList;
    status?: 'ACTIVE' | 'INACTIVE';
    requiresAttributes?: ECS$20141113$RequiresAttributes;
  };
  declare type ECS$20141113$TaskDefinitionFamilyStatus = 'ACTIVE' | 'INACTIVE' | 'ALL';
  declare type ECS$20141113$TaskDefinitionStatus = 'ACTIVE' | 'INACTIVE';
  declare type ECS$20141113$TaskOverride = {
    containerOverrides?: ECS$20141113$ContainerOverrides;
    taskRoleArn?: string;
  };
  declare type ECS$20141113$Tasks = ECS$20141113$Task[];
  declare type ECS$20141113$Timestamp = Date;
  declare type ECS$20141113$TransportProtocol = 'tcp' | 'udp';
  declare type ECS$20141113$Ulimit = {
    name: 'core' | 'cpu' | 'data' | 'fsize' | 'locks' | 'memlock' | 'msgqueue' | 'nice' | 'nofile' | 'nproc' | 'rss' | 'rtprio' | 'rttime' | 'sigpending' | 'stack';
    softLimit: number;
    hardLimit: number;
  };
  declare type ECS$20141113$UlimitList = ECS$20141113$Ulimit[];
  declare type ECS$20141113$UlimitName = 'core' | 'cpu' | 'data' | 'fsize' | 'locks' | 'memlock' | 'msgqueue' | 'nice' | 'nofile' | 'nproc' | 'rss' | 'rtprio' | 'rttime' | 'sigpending' | 'stack';
  declare type ECS$20141113$UpdateContainerAgentRequest = {
    cluster?: string;
    containerInstance: string;
  };
  declare type ECS$20141113$UpdateContainerAgentResponse = {
    containerInstance?: ECS$20141113$ContainerInstance;
  };
  declare type ECS$20141113$UpdateInProgressException = {};
  declare type ECS$20141113$UpdateServiceRequest = {
    cluster?: string;
    service: string;
    desiredCount?: number;
    taskDefinition?: string;
    deploymentConfiguration?: ECS$20141113$DeploymentConfiguration;
  };
  declare type ECS$20141113$UpdateServiceResponse = {
    service?: ECS$20141113$Service;
  };
  declare type ECS$20141113$VersionInfo = {
    agentVersion?: string;
    agentHash?: string;
    dockerVersion?: string;
  };
  declare type ECS$20141113$Volume = {
    name?: string;
    host?: ECS$20141113$HostVolumeProperties;
  };
  declare type ECS$20141113$VolumeFrom = {
    sourceContainer?: string;
    readOnly?: boolean;
  };
  declare type ECS$20141113$VolumeFromList = ECS$20141113$VolumeFrom[];
  declare type ECS$20141113$VolumeList = ECS$20141113$Volume[];
  declare type EFS$20150201$BadRequest = {
    ErrorCode: string;
    Message?: string;
  };
  declare type EFS$20150201$CreateFileSystemRequest = {
    CreationToken: string;
    PerformanceMode?: 'generalPurpose' | 'maxIO';
  };
  declare type EFS$20150201$CreateMountTargetRequest = {
    FileSystemId: string;
    SubnetId: string;
    IpAddress?: string;
    SecurityGroups?: EFS$20150201$SecurityGroups;
  };
  declare type EFS$20150201$CreateTagsRequest = {
    FileSystemId: string;
    Tags: EFS$20150201$Tags;
  };
  declare type EFS$20150201$DeleteFileSystemRequest = {
    FileSystemId: string;
  };
  declare type EFS$20150201$DeleteMountTargetRequest = {
    MountTargetId: string;
  };
  declare type EFS$20150201$DeleteTagsRequest = {
    FileSystemId: string;
    TagKeys: EFS$20150201$TagKeys;
  };
  declare type EFS$20150201$DependencyTimeout = {
    ErrorCode: string;
    Message?: string;
  };
  declare type EFS$20150201$DescribeFileSystemsRequest = {
    MaxItems?: number;
    Marker?: string;
    CreationToken?: string;
    FileSystemId?: string;
  };
  declare type EFS$20150201$DescribeFileSystemsResponse = {
    Marker?: string;
    FileSystems?: EFS$20150201$FileSystemDescriptions;
    NextMarker?: string;
  };
  declare type EFS$20150201$DescribeMountTargetSecurityGroupsRequest = {
    MountTargetId: string;
  };
  declare type EFS$20150201$DescribeMountTargetSecurityGroupsResponse = {
    SecurityGroups: EFS$20150201$SecurityGroups;
  };
  declare type EFS$20150201$DescribeMountTargetsRequest = {
    MaxItems?: number;
    Marker?: string;
    FileSystemId?: string;
    MountTargetId?: string;
  };
  declare type EFS$20150201$DescribeMountTargetsResponse = {
    Marker?: string;
    MountTargets?: EFS$20150201$MountTargetDescriptions;
    NextMarker?: string;
  };
  declare type EFS$20150201$DescribeTagsRequest = {
    MaxItems?: number;
    Marker?: string;
    FileSystemId: string;
  };
  declare type EFS$20150201$DescribeTagsResponse = {
    Marker?: string;
    Tags: EFS$20150201$Tags;
    NextMarker?: string;
  };
  declare type EFS$20150201$FileSystemAlreadyExists = {
    ErrorCode: string;
    Message?: string;
    FileSystemId: string;
  };
  declare type EFS$20150201$FileSystemDescription = {
    OwnerId: string;
    CreationToken: string;
    FileSystemId: string;
    CreationTime: Date;
    LifeCycleState: 'creating' | 'available' | 'deleting' | 'deleted';
    Name?: string;
    NumberOfMountTargets: number;
    SizeInBytes: EFS$20150201$FileSystemSize;
    PerformanceMode: 'generalPurpose' | 'maxIO';
  };
  declare type EFS$20150201$FileSystemDescriptions = EFS$20150201$FileSystemDescription[];
  declare type EFS$20150201$FileSystemInUse = {
    ErrorCode: string;
    Message?: string;
  };
  declare type EFS$20150201$FileSystemLimitExceeded = {
    ErrorCode: string;
    Message?: string;
  };
  declare type EFS$20150201$FileSystemNotFound = {
    ErrorCode: string;
    Message?: string;
  };
  declare type EFS$20150201$FileSystemSize = {
    Value: number;
    Timestamp?: Date;
  };
  declare type EFS$20150201$IncorrectFileSystemLifeCycleState = {
    ErrorCode: string;
    Message?: string;
  };
  declare type EFS$20150201$IncorrectMountTargetState = {
    ErrorCode: string;
    Message?: string;
  };
  declare type EFS$20150201$InternalServerError = {
    ErrorCode: string;
    Message?: string;
  };
  declare type EFS$20150201$IpAddressInUse = {
    ErrorCode: string;
    Message?: string;
  };
  declare type EFS$20150201$LifeCycleState = 'creating' | 'available' | 'deleting' | 'deleted';
  declare type EFS$20150201$ModifyMountTargetSecurityGroupsRequest = {
    MountTargetId: string;
    SecurityGroups?: EFS$20150201$SecurityGroups;
  };
  declare type EFS$20150201$MountTargetConflict = {
    ErrorCode: string;
    Message?: string;
  };
  declare type EFS$20150201$MountTargetDescription = {
    OwnerId?: string;
    MountTargetId: string;
    FileSystemId: string;
    SubnetId: string;
    LifeCycleState: 'creating' | 'available' | 'deleting' | 'deleted';
    IpAddress?: string;
    NetworkInterfaceId?: string;
  };
  declare type EFS$20150201$MountTargetDescriptions = EFS$20150201$MountTargetDescription[];
  declare type EFS$20150201$MountTargetNotFound = {
    ErrorCode: string;
    Message?: string;
  };
  declare type EFS$20150201$NetworkInterfaceLimitExceeded = {
    ErrorCode: string;
    Message?: string;
  };
  declare type EFS$20150201$NoFreeAddressesInSubnet = {
    ErrorCode: string;
    Message?: string;
  };
  declare type EFS$20150201$PerformanceMode = 'generalPurpose' | 'maxIO';
  declare type EFS$20150201$SecurityGroupLimitExceeded = {
    ErrorCode: string;
    Message?: string;
  };
  declare type EFS$20150201$SecurityGroupNotFound = {
    ErrorCode: string;
    Message?: string;
  };
  declare type EFS$20150201$SecurityGroups = string[];
  declare type EFS$20150201$SubnetNotFound = {
    ErrorCode: string;
    Message?: string;
  };
  declare type EFS$20150201$Tag = {
    Key: string;
    Value: string;
  };
  declare type EFS$20150201$TagKeys = string[];
  declare type EFS$20150201$Tags = EFS$20150201$Tag[];
  declare type EFS$20150201$Timestamp = Date;
  declare type EFS$20150201$UnsupportedAvailabilityZone = {
    ErrorCode: string;
    Message?: string;
  };
  declare type ElastiCache$20150202$AZMode = 'single-az' | 'cross-az';
  declare type ElastiCache$20150202$AddTagsToResourceMessage = {
    ResourceName: string;
    Tags: ElastiCache$20150202$TagList;
  };
  declare type ElastiCache$20150202$AllowedNodeTypeModificationsMessage = {
    ScaleUpModifications?: ElastiCache$20150202$NodeTypeList;
  };
  declare type ElastiCache$20150202$AuthorizationAlreadyExistsFault = {};
  declare type ElastiCache$20150202$AuthorizationNotFoundFault = {};
  declare type ElastiCache$20150202$AuthorizeCacheSecurityGroupIngressMessage = {
    CacheSecurityGroupName: string;
    EC2SecurityGroupName: string;
    EC2SecurityGroupOwnerId: string;
  };
  declare type ElastiCache$20150202$AuthorizeCacheSecurityGroupIngressResult = {
    CacheSecurityGroup?: ElastiCache$20150202$CacheSecurityGroup;
  };
  declare type ElastiCache$20150202$AutomaticFailoverStatus = 'enabled' | 'disabled' | 'enabling' | 'disabling';
  declare type ElastiCache$20150202$AvailabilityZone = {
    Name?: string;
  };
  declare type ElastiCache$20150202$AvailabilityZonesList = string[];
  declare type ElastiCache$20150202$CacheCluster = {
    CacheClusterId?: string;
    ConfigurationEndpoint?: ElastiCache$20150202$Endpoint;
    ClientDownloadLandingPage?: string;
    CacheNodeType?: string;
    Engine?: string;
    EngineVersion?: string;
    CacheClusterStatus?: string;
    NumCacheNodes?: number;
    PreferredAvailabilityZone?: string;
    CacheClusterCreateTime?: Date;
    PreferredMaintenanceWindow?: string;
    PendingModifiedValues?: ElastiCache$20150202$PendingModifiedValues;
    NotificationConfiguration?: ElastiCache$20150202$NotificationConfiguration;
    CacheSecurityGroups?: ElastiCache$20150202$CacheSecurityGroupMembershipList;
    CacheParameterGroup?: ElastiCache$20150202$CacheParameterGroupStatus;
    CacheSubnetGroupName?: string;
    CacheNodes?: ElastiCache$20150202$CacheNodeList;
    AutoMinorVersionUpgrade?: boolean;
    SecurityGroups?: ElastiCache$20150202$SecurityGroupMembershipList;
    ReplicationGroupId?: string;
    SnapshotRetentionLimit?: number;
    SnapshotWindow?: string;
  };
  declare type ElastiCache$20150202$CacheClusterAlreadyExistsFault = {};
  declare type ElastiCache$20150202$CacheClusterList = ElastiCache$20150202$CacheCluster[];
  declare type ElastiCache$20150202$CacheClusterMessage = {
    Marker?: string;
    CacheClusters?: ElastiCache$20150202$CacheClusterList;
  };
  declare type ElastiCache$20150202$CacheClusterNotFoundFault = {};
  declare type ElastiCache$20150202$CacheEngineVersion = {
    Engine?: string;
    EngineVersion?: string;
    CacheParameterGroupFamily?: string;
    CacheEngineDescription?: string;
    CacheEngineVersionDescription?: string;
  };
  declare type ElastiCache$20150202$CacheEngineVersionList = ElastiCache$20150202$CacheEngineVersion[];
  declare type ElastiCache$20150202$CacheEngineVersionMessage = {
    Marker?: string;
    CacheEngineVersions?: ElastiCache$20150202$CacheEngineVersionList;
  };
  declare type ElastiCache$20150202$CacheNode = {
    CacheNodeId?: string;
    CacheNodeStatus?: string;
    CacheNodeCreateTime?: Date;
    Endpoint?: ElastiCache$20150202$Endpoint;
    ParameterGroupStatus?: string;
    SourceCacheNodeId?: string;
    CustomerAvailabilityZone?: string;
  };
  declare type ElastiCache$20150202$CacheNodeIdsList = string[];
  declare type ElastiCache$20150202$CacheNodeList = ElastiCache$20150202$CacheNode[];
  declare type ElastiCache$20150202$CacheNodeTypeSpecificParameter = {
    ParameterName?: string;
    Description?: string;
    Source?: string;
    DataType?: string;
    AllowedValues?: string;
    IsModifiable?: boolean;
    MinimumEngineVersion?: string;
    CacheNodeTypeSpecificValues?: ElastiCache$20150202$CacheNodeTypeSpecificValueList;
    ChangeType?: 'immediate' | 'requires-reboot';
  };
  declare type ElastiCache$20150202$CacheNodeTypeSpecificParametersList = ElastiCache$20150202$CacheNodeTypeSpecificParameter[];
  declare type ElastiCache$20150202$CacheNodeTypeSpecificValue = {
    CacheNodeType?: string;
    Value?: string;
  };
  declare type ElastiCache$20150202$CacheNodeTypeSpecificValueList = ElastiCache$20150202$CacheNodeTypeSpecificValue[];
  declare type ElastiCache$20150202$CacheParameterGroup = {
    CacheParameterGroupName?: string;
    CacheParameterGroupFamily?: string;
    Description?: string;
  };
  declare type ElastiCache$20150202$CacheParameterGroupAlreadyExistsFault = {};
  declare type ElastiCache$20150202$CacheParameterGroupDetails = {
    Marker?: string;
    Parameters?: ElastiCache$20150202$ParametersList;
    CacheNodeTypeSpecificParameters?: ElastiCache$20150202$CacheNodeTypeSpecificParametersList;
  };
  declare type ElastiCache$20150202$CacheParameterGroupList = ElastiCache$20150202$CacheParameterGroup[];
  declare type ElastiCache$20150202$CacheParameterGroupNameMessage = {
    CacheParameterGroupName?: string;
  };
  declare type ElastiCache$20150202$CacheParameterGroupNotFoundFault = {};
  declare type ElastiCache$20150202$CacheParameterGroupQuotaExceededFault = {};
  declare type ElastiCache$20150202$CacheParameterGroupStatus = {
    CacheParameterGroupName?: string;
    ParameterApplyStatus?: string;
    CacheNodeIdsToReboot?: ElastiCache$20150202$CacheNodeIdsList;
  };
  declare type ElastiCache$20150202$CacheParameterGroupsMessage = {
    Marker?: string;
    CacheParameterGroups?: ElastiCache$20150202$CacheParameterGroupList;
  };
  declare type ElastiCache$20150202$CacheSecurityGroup = {
    OwnerId?: string;
    CacheSecurityGroupName?: string;
    Description?: string;
    EC2SecurityGroups?: ElastiCache$20150202$EC2SecurityGroupList;
  };
  declare type ElastiCache$20150202$CacheSecurityGroupAlreadyExistsFault = {};
  declare type ElastiCache$20150202$CacheSecurityGroupMembership = {
    CacheSecurityGroupName?: string;
    Status?: string;
  };
  declare type ElastiCache$20150202$CacheSecurityGroupMembershipList = ElastiCache$20150202$CacheSecurityGroupMembership[];
  declare type ElastiCache$20150202$CacheSecurityGroupMessage = {
    Marker?: string;
    CacheSecurityGroups?: ElastiCache$20150202$CacheSecurityGroups;
  };
  declare type ElastiCache$20150202$CacheSecurityGroupNameList = string[];
  declare type ElastiCache$20150202$CacheSecurityGroupNotFoundFault = {};
  declare type ElastiCache$20150202$CacheSecurityGroupQuotaExceededFault = {};
  declare type ElastiCache$20150202$CacheSecurityGroups = ElastiCache$20150202$CacheSecurityGroup[];
  declare type ElastiCache$20150202$CacheSubnetGroup = {
    CacheSubnetGroupName?: string;
    CacheSubnetGroupDescription?: string;
    VpcId?: string;
    Subnets?: ElastiCache$20150202$SubnetList;
  };
  declare type ElastiCache$20150202$CacheSubnetGroupAlreadyExistsFault = {};
  declare type ElastiCache$20150202$CacheSubnetGroupInUse = {};
  declare type ElastiCache$20150202$CacheSubnetGroupMessage = {
    Marker?: string;
    CacheSubnetGroups?: ElastiCache$20150202$CacheSubnetGroups;
  };
  declare type ElastiCache$20150202$CacheSubnetGroupNotFoundFault = {};
  declare type ElastiCache$20150202$CacheSubnetGroupQuotaExceededFault = {};
  declare type ElastiCache$20150202$CacheSubnetGroups = ElastiCache$20150202$CacheSubnetGroup[];
  declare type ElastiCache$20150202$CacheSubnetQuotaExceededFault = {};
  declare type ElastiCache$20150202$ChangeType = 'immediate' | 'requires-reboot';
  declare type ElastiCache$20150202$ClusterIdList = string[];
  declare type ElastiCache$20150202$ClusterQuotaForCustomerExceededFault = {};
  declare type ElastiCache$20150202$CopySnapshotMessage = {
    SourceSnapshotName: string;
    TargetSnapshotName: string;
    TargetBucket?: string;
  };
  declare type ElastiCache$20150202$CopySnapshotResult = {
    Snapshot?: ElastiCache$20150202$Snapshot;
  };
  declare type ElastiCache$20150202$CreateCacheClusterMessage = {
    CacheClusterId: string;
    ReplicationGroupId?: string;
    AZMode?: 'single-az' | 'cross-az';
    PreferredAvailabilityZone?: string;
    PreferredAvailabilityZones?: ElastiCache$20150202$PreferredAvailabilityZoneList;
    NumCacheNodes?: number;
    CacheNodeType?: string;
    Engine?: string;
    EngineVersion?: string;
    CacheParameterGroupName?: string;
    CacheSubnetGroupName?: string;
    CacheSecurityGroupNames?: ElastiCache$20150202$CacheSecurityGroupNameList;
    SecurityGroupIds?: ElastiCache$20150202$SecurityGroupIdsList;
    Tags?: ElastiCache$20150202$TagList;
    SnapshotArns?: ElastiCache$20150202$SnapshotArnsList;
    SnapshotName?: string;
    PreferredMaintenanceWindow?: string;
    Port?: number;
    NotificationTopicArn?: string;
    AutoMinorVersionUpgrade?: boolean;
    SnapshotRetentionLimit?: number;
    SnapshotWindow?: string;
  };
  declare type ElastiCache$20150202$CreateCacheClusterResult = {
    CacheCluster?: ElastiCache$20150202$CacheCluster;
  };
  declare type ElastiCache$20150202$CreateCacheParameterGroupMessage = {
    CacheParameterGroupName: string;
    CacheParameterGroupFamily: string;
    Description: string;
  };
  declare type ElastiCache$20150202$CreateCacheParameterGroupResult = {
    CacheParameterGroup?: ElastiCache$20150202$CacheParameterGroup;
  };
  declare type ElastiCache$20150202$CreateCacheSecurityGroupMessage = {
    CacheSecurityGroupName: string;
    Description: string;
  };
  declare type ElastiCache$20150202$CreateCacheSecurityGroupResult = {
    CacheSecurityGroup?: ElastiCache$20150202$CacheSecurityGroup;
  };
  declare type ElastiCache$20150202$CreateCacheSubnetGroupMessage = {
    CacheSubnetGroupName: string;
    CacheSubnetGroupDescription: string;
    SubnetIds: ElastiCache$20150202$SubnetIdentifierList;
  };
  declare type ElastiCache$20150202$CreateCacheSubnetGroupResult = {
    CacheSubnetGroup?: ElastiCache$20150202$CacheSubnetGroup;
  };
  declare type ElastiCache$20150202$CreateReplicationGroupMessage = {
    ReplicationGroupId: string;
    ReplicationGroupDescription: string;
    PrimaryClusterId?: string;
    AutomaticFailoverEnabled?: boolean;
    NumCacheClusters?: number;
    PreferredCacheClusterAZs?: ElastiCache$20150202$AvailabilityZonesList;
    CacheNodeType?: string;
    Engine?: string;
    EngineVersion?: string;
    CacheParameterGroupName?: string;
    CacheSubnetGroupName?: string;
    CacheSecurityGroupNames?: ElastiCache$20150202$CacheSecurityGroupNameList;
    SecurityGroupIds?: ElastiCache$20150202$SecurityGroupIdsList;
    Tags?: ElastiCache$20150202$TagList;
    SnapshotArns?: ElastiCache$20150202$SnapshotArnsList;
    SnapshotName?: string;
    PreferredMaintenanceWindow?: string;
    Port?: number;
    NotificationTopicArn?: string;
    AutoMinorVersionUpgrade?: boolean;
    SnapshotRetentionLimit?: number;
    SnapshotWindow?: string;
  };
  declare type ElastiCache$20150202$CreateReplicationGroupResult = {
    ReplicationGroup?: ElastiCache$20150202$ReplicationGroup;
  };
  declare type ElastiCache$20150202$CreateSnapshotMessage = {
    CacheClusterId: string;
    SnapshotName: string;
  };
  declare type ElastiCache$20150202$CreateSnapshotResult = {
    Snapshot?: ElastiCache$20150202$Snapshot;
  };
  declare type ElastiCache$20150202$DeleteCacheClusterMessage = {
    CacheClusterId: string;
    FinalSnapshotIdentifier?: string;
  };
  declare type ElastiCache$20150202$DeleteCacheClusterResult = {
    CacheCluster?: ElastiCache$20150202$CacheCluster;
  };
  declare type ElastiCache$20150202$DeleteCacheParameterGroupMessage = {
    CacheParameterGroupName: string;
  };
  declare type ElastiCache$20150202$DeleteCacheSecurityGroupMessage = {
    CacheSecurityGroupName: string;
  };
  declare type ElastiCache$20150202$DeleteCacheSubnetGroupMessage = {
    CacheSubnetGroupName: string;
  };
  declare type ElastiCache$20150202$DeleteReplicationGroupMessage = {
    ReplicationGroupId: string;
    RetainPrimaryCluster?: boolean;
    FinalSnapshotIdentifier?: string;
  };
  declare type ElastiCache$20150202$DeleteReplicationGroupResult = {
    ReplicationGroup?: ElastiCache$20150202$ReplicationGroup;
  };
  declare type ElastiCache$20150202$DeleteSnapshotMessage = {
    SnapshotName: string;
  };
  declare type ElastiCache$20150202$DeleteSnapshotResult = {
    Snapshot?: ElastiCache$20150202$Snapshot;
  };
  declare type ElastiCache$20150202$DescribeCacheClustersMessage = {
    CacheClusterId?: string;
    MaxRecords?: number;
    Marker?: string;
    ShowCacheNodeInfo?: boolean;
  };
  declare type ElastiCache$20150202$DescribeCacheEngineVersionsMessage = {
    Engine?: string;
    EngineVersion?: string;
    CacheParameterGroupFamily?: string;
    MaxRecords?: number;
    Marker?: string;
    DefaultOnly?: boolean;
  };
  declare type ElastiCache$20150202$DescribeCacheParameterGroupsMessage = {
    CacheParameterGroupName?: string;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type ElastiCache$20150202$DescribeCacheParametersMessage = {
    CacheParameterGroupName: string;
    Source?: string;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type ElastiCache$20150202$DescribeCacheSecurityGroupsMessage = {
    CacheSecurityGroupName?: string;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type ElastiCache$20150202$DescribeCacheSubnetGroupsMessage = {
    CacheSubnetGroupName?: string;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type ElastiCache$20150202$DescribeEngineDefaultParametersMessage = {
    CacheParameterGroupFamily: string;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type ElastiCache$20150202$DescribeEngineDefaultParametersResult = {
    EngineDefaults?: ElastiCache$20150202$EngineDefaults;
  };
  declare type ElastiCache$20150202$DescribeEventsMessage = {
    SourceIdentifier?: string;
    SourceType?: 'cache-cluster' | 'cache-parameter-group' | 'cache-security-group' | 'cache-subnet-group';
    StartTime?: Date;
    EndTime?: Date;
    Duration?: number;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type ElastiCache$20150202$DescribeReplicationGroupsMessage = {
    ReplicationGroupId?: string;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type ElastiCache$20150202$DescribeReservedCacheNodesMessage = {
    ReservedCacheNodeId?: string;
    ReservedCacheNodesOfferingId?: string;
    CacheNodeType?: string;
    Duration?: string;
    ProductDescription?: string;
    OfferingType?: string;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type ElastiCache$20150202$DescribeReservedCacheNodesOfferingsMessage = {
    ReservedCacheNodesOfferingId?: string;
    CacheNodeType?: string;
    Duration?: string;
    ProductDescription?: string;
    OfferingType?: string;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type ElastiCache$20150202$DescribeSnapshotsListMessage = {
    Marker?: string;
    Snapshots?: ElastiCache$20150202$SnapshotList;
  };
  declare type ElastiCache$20150202$DescribeSnapshotsMessage = {
    CacheClusterId?: string;
    SnapshotName?: string;
    SnapshotSource?: string;
    Marker?: string;
    MaxRecords?: number;
  };
  declare type ElastiCache$20150202$EC2SecurityGroup = {
    Status?: string;
    EC2SecurityGroupName?: string;
    EC2SecurityGroupOwnerId?: string;
  };
  declare type ElastiCache$20150202$EC2SecurityGroupList = ElastiCache$20150202$EC2SecurityGroup[];
  declare type ElastiCache$20150202$Endpoint = {
    Address?: string;
    Port?: number;
  };
  declare type ElastiCache$20150202$EngineDefaults = {
    CacheParameterGroupFamily?: string;
    Marker?: string;
    Parameters?: ElastiCache$20150202$ParametersList;
    CacheNodeTypeSpecificParameters?: ElastiCache$20150202$CacheNodeTypeSpecificParametersList;
  };
  declare type ElastiCache$20150202$Event = {
    SourceIdentifier?: string;
    SourceType?: 'cache-cluster' | 'cache-parameter-group' | 'cache-security-group' | 'cache-subnet-group';
    Message?: string;
    Date?: Date;
  };
  declare type ElastiCache$20150202$EventList = ElastiCache$20150202$Event[];
  declare type ElastiCache$20150202$EventsMessage = {
    Marker?: string;
    Events?: ElastiCache$20150202$EventList;
  };
  declare type ElastiCache$20150202$InsufficientCacheClusterCapacityFault = {};
  declare type ElastiCache$20150202$InvalidARNFault = {};
  declare type ElastiCache$20150202$InvalidCacheClusterStateFault = {};
  declare type ElastiCache$20150202$InvalidCacheParameterGroupStateFault = {};
  declare type ElastiCache$20150202$InvalidCacheSecurityGroupStateFault = {};
  declare type ElastiCache$20150202$InvalidParameterCombinationException = {
    message?: string;
  };
  declare type ElastiCache$20150202$InvalidParameterValueException = {
    message?: string;
  };
  declare type ElastiCache$20150202$InvalidReplicationGroupStateFault = {};
  declare type ElastiCache$20150202$InvalidSnapshotStateFault = {};
  declare type ElastiCache$20150202$InvalidSubnet = {};
  declare type ElastiCache$20150202$InvalidVPCNetworkStateFault = {};
  declare type ElastiCache$20150202$KeyList = string[];
  declare type ElastiCache$20150202$ListAllowedNodeTypeModificationsMessage = {
    CacheClusterId?: string;
    ReplicationGroupId?: string;
  };
  declare type ElastiCache$20150202$ListTagsForResourceMessage = {
    ResourceName: string;
  };
  declare type ElastiCache$20150202$ModifyCacheClusterMessage = {
    CacheClusterId: string;
    NumCacheNodes?: number;
    CacheNodeIdsToRemove?: ElastiCache$20150202$CacheNodeIdsList;
    AZMode?: 'single-az' | 'cross-az';
    NewAvailabilityZones?: ElastiCache$20150202$PreferredAvailabilityZoneList;
    CacheSecurityGroupNames?: ElastiCache$20150202$CacheSecurityGroupNameList;
    SecurityGroupIds?: ElastiCache$20150202$SecurityGroupIdsList;
    PreferredMaintenanceWindow?: string;
    NotificationTopicArn?: string;
    CacheParameterGroupName?: string;
    NotificationTopicStatus?: string;
    ApplyImmediately?: boolean;
    EngineVersion?: string;
    AutoMinorVersionUpgrade?: boolean;
    SnapshotRetentionLimit?: number;
    SnapshotWindow?: string;
    CacheNodeType?: string;
  };
  declare type ElastiCache$20150202$ModifyCacheClusterResult = {
    CacheCluster?: ElastiCache$20150202$CacheCluster;
  };
  declare type ElastiCache$20150202$ModifyCacheParameterGroupMessage = {
    CacheParameterGroupName: string;
    ParameterNameValues: ElastiCache$20150202$ParameterNameValueList;
  };
  declare type ElastiCache$20150202$ModifyCacheSubnetGroupMessage = {
    CacheSubnetGroupName: string;
    CacheSubnetGroupDescription?: string;
    SubnetIds?: ElastiCache$20150202$SubnetIdentifierList;
  };
  declare type ElastiCache$20150202$ModifyCacheSubnetGroupResult = {
    CacheSubnetGroup?: ElastiCache$20150202$CacheSubnetGroup;
  };
  declare type ElastiCache$20150202$ModifyReplicationGroupMessage = {
    ReplicationGroupId: string;
    ReplicationGroupDescription?: string;
    PrimaryClusterId?: string;
    SnapshottingClusterId?: string;
    AutomaticFailoverEnabled?: boolean;
    CacheSecurityGroupNames?: ElastiCache$20150202$CacheSecurityGroupNameList;
    SecurityGroupIds?: ElastiCache$20150202$SecurityGroupIdsList;
    PreferredMaintenanceWindow?: string;
    NotificationTopicArn?: string;
    CacheParameterGroupName?: string;
    NotificationTopicStatus?: string;
    ApplyImmediately?: boolean;
    EngineVersion?: string;
    AutoMinorVersionUpgrade?: boolean;
    SnapshotRetentionLimit?: number;
    SnapshotWindow?: string;
    CacheNodeType?: string;
  };
  declare type ElastiCache$20150202$ModifyReplicationGroupResult = {
    ReplicationGroup?: ElastiCache$20150202$ReplicationGroup;
  };
  declare type ElastiCache$20150202$NodeGroup = {
    NodeGroupId?: string;
    Status?: string;
    PrimaryEndpoint?: ElastiCache$20150202$Endpoint;
    NodeGroupMembers?: ElastiCache$20150202$NodeGroupMemberList;
  };
  declare type ElastiCache$20150202$NodeGroupList = ElastiCache$20150202$NodeGroup[];
  declare type ElastiCache$20150202$NodeGroupMember = {
    CacheClusterId?: string;
    CacheNodeId?: string;
    ReadEndpoint?: ElastiCache$20150202$Endpoint;
    PreferredAvailabilityZone?: string;
    CurrentRole?: string;
  };
  declare type ElastiCache$20150202$NodeGroupMemberList = ElastiCache$20150202$NodeGroupMember[];
  declare type ElastiCache$20150202$NodeQuotaForClusterExceededFault = {};
  declare type ElastiCache$20150202$NodeQuotaForCustomerExceededFault = {};
  declare type ElastiCache$20150202$NodeSnapshot = {
    CacheNodeId?: string;
    CacheSize?: string;
    CacheNodeCreateTime?: Date;
    SnapshotCreateTime?: Date;
  };
  declare type ElastiCache$20150202$NodeSnapshotList = ElastiCache$20150202$NodeSnapshot[];
  declare type ElastiCache$20150202$NodeTypeList = string[];
  declare type ElastiCache$20150202$NotificationConfiguration = {
    TopicArn?: string;
    TopicStatus?: string;
  };
  declare type ElastiCache$20150202$Parameter = {
    ParameterName?: string;
    ParameterValue?: string;
    Description?: string;
    Source?: string;
    DataType?: string;
    AllowedValues?: string;
    IsModifiable?: boolean;
    MinimumEngineVersion?: string;
    ChangeType?: 'immediate' | 'requires-reboot';
  };
  declare type ElastiCache$20150202$ParameterNameValue = {
    ParameterName?: string;
    ParameterValue?: string;
  };
  declare type ElastiCache$20150202$ParameterNameValueList = ElastiCache$20150202$ParameterNameValue[];
  declare type ElastiCache$20150202$ParametersList = ElastiCache$20150202$Parameter[];
  declare type ElastiCache$20150202$PendingAutomaticFailoverStatus = 'enabled' | 'disabled';
  declare type ElastiCache$20150202$PendingModifiedValues = {
    NumCacheNodes?: number;
    CacheNodeIdsToRemove?: ElastiCache$20150202$CacheNodeIdsList;
    EngineVersion?: string;
    CacheNodeType?: string;
  };
  declare type ElastiCache$20150202$PreferredAvailabilityZoneList = string[];
  declare type ElastiCache$20150202$PurchaseReservedCacheNodesOfferingMessage = {
    ReservedCacheNodesOfferingId: string;
    ReservedCacheNodeId?: string;
    CacheNodeCount?: number;
  };
  declare type ElastiCache$20150202$PurchaseReservedCacheNodesOfferingResult = {
    ReservedCacheNode?: ElastiCache$20150202$ReservedCacheNode;
  };
  declare type ElastiCache$20150202$RebootCacheClusterMessage = {
    CacheClusterId: string;
    CacheNodeIdsToReboot: ElastiCache$20150202$CacheNodeIdsList;
  };
  declare type ElastiCache$20150202$RebootCacheClusterResult = {
    CacheCluster?: ElastiCache$20150202$CacheCluster;
  };
  declare type ElastiCache$20150202$RecurringCharge = {
    RecurringChargeAmount?: number;
    RecurringChargeFrequency?: string;
  };
  declare type ElastiCache$20150202$RecurringChargeList = ElastiCache$20150202$RecurringCharge[];
  declare type ElastiCache$20150202$RemoveTagsFromResourceMessage = {
    ResourceName: string;
    TagKeys: ElastiCache$20150202$KeyList;
  };
  declare type ElastiCache$20150202$ReplicationGroup = {
    ReplicationGroupId?: string;
    Description?: string;
    Status?: string;
    PendingModifiedValues?: ElastiCache$20150202$ReplicationGroupPendingModifiedValues;
    MemberClusters?: ElastiCache$20150202$ClusterIdList;
    NodeGroups?: ElastiCache$20150202$NodeGroupList;
    SnapshottingClusterId?: string;
    AutomaticFailover?: 'enabled' | 'disabled' | 'enabling' | 'disabling';
  };
  declare type ElastiCache$20150202$ReplicationGroupAlreadyExistsFault = {};
  declare type ElastiCache$20150202$ReplicationGroupList = ElastiCache$20150202$ReplicationGroup[];
  declare type ElastiCache$20150202$ReplicationGroupMessage = {
    Marker?: string;
    ReplicationGroups?: ElastiCache$20150202$ReplicationGroupList;
  };
  declare type ElastiCache$20150202$ReplicationGroupNotFoundFault = {};
  declare type ElastiCache$20150202$ReplicationGroupPendingModifiedValues = {
    PrimaryClusterId?: string;
    AutomaticFailoverStatus?: 'enabled' | 'disabled';
  };
  declare type ElastiCache$20150202$ReservedCacheNode = {
    ReservedCacheNodeId?: string;
    ReservedCacheNodesOfferingId?: string;
    CacheNodeType?: string;
    StartTime?: Date;
    Duration?: number;
    FixedPrice?: number;
    UsagePrice?: number;
    CacheNodeCount?: number;
    ProductDescription?: string;
    OfferingType?: string;
    State?: string;
    RecurringCharges?: ElastiCache$20150202$RecurringChargeList;
  };
  declare type ElastiCache$20150202$ReservedCacheNodeAlreadyExistsFault = {};
  declare type ElastiCache$20150202$ReservedCacheNodeList = ElastiCache$20150202$ReservedCacheNode[];
  declare type ElastiCache$20150202$ReservedCacheNodeMessage = {
    Marker?: string;
    ReservedCacheNodes?: ElastiCache$20150202$ReservedCacheNodeList;
  };
  declare type ElastiCache$20150202$ReservedCacheNodeNotFoundFault = {};
  declare type ElastiCache$20150202$ReservedCacheNodeQuotaExceededFault = {};
  declare type ElastiCache$20150202$ReservedCacheNodesOffering = {
    ReservedCacheNodesOfferingId?: string;
    CacheNodeType?: string;
    Duration?: number;
    FixedPrice?: number;
    UsagePrice?: number;
    ProductDescription?: string;
    OfferingType?: string;
    RecurringCharges?: ElastiCache$20150202$RecurringChargeList;
  };
  declare type ElastiCache$20150202$ReservedCacheNodesOfferingList = ElastiCache$20150202$ReservedCacheNodesOffering[];
  declare type ElastiCache$20150202$ReservedCacheNodesOfferingMessage = {
    Marker?: string;
    ReservedCacheNodesOfferings?: ElastiCache$20150202$ReservedCacheNodesOfferingList;
  };
  declare type ElastiCache$20150202$ReservedCacheNodesOfferingNotFoundFault = {};
  declare type ElastiCache$20150202$ResetCacheParameterGroupMessage = {
    CacheParameterGroupName: string;
    ResetAllParameters?: boolean;
    ParameterNameValues?: ElastiCache$20150202$ParameterNameValueList;
  };
  declare type ElastiCache$20150202$RevokeCacheSecurityGroupIngressMessage = {
    CacheSecurityGroupName: string;
    EC2SecurityGroupName: string;
    EC2SecurityGroupOwnerId: string;
  };
  declare type ElastiCache$20150202$RevokeCacheSecurityGroupIngressResult = {
    CacheSecurityGroup?: ElastiCache$20150202$CacheSecurityGroup;
  };
  declare type ElastiCache$20150202$SecurityGroupIdsList = string[];
  declare type ElastiCache$20150202$SecurityGroupMembership = {
    SecurityGroupId?: string;
    Status?: string;
  };
  declare type ElastiCache$20150202$SecurityGroupMembershipList = ElastiCache$20150202$SecurityGroupMembership[];
  declare type ElastiCache$20150202$Snapshot = {
    SnapshotName?: string;
    CacheClusterId?: string;
    SnapshotStatus?: string;
    SnapshotSource?: string;
    CacheNodeType?: string;
    Engine?: string;
    EngineVersion?: string;
    NumCacheNodes?: number;
    PreferredAvailabilityZone?: string;
    CacheClusterCreateTime?: Date;
    PreferredMaintenanceWindow?: string;
    TopicArn?: string;
    Port?: number;
    CacheParameterGroupName?: string;
    CacheSubnetGroupName?: string;
    VpcId?: string;
    AutoMinorVersionUpgrade?: boolean;
    SnapshotRetentionLimit?: number;
    SnapshotWindow?: string;
    NodeSnapshots?: ElastiCache$20150202$NodeSnapshotList;
  };
  declare type ElastiCache$20150202$SnapshotAlreadyExistsFault = {};
  declare type ElastiCache$20150202$SnapshotArnsList = string[];
  declare type ElastiCache$20150202$SnapshotFeatureNotSupportedFault = {};
  declare type ElastiCache$20150202$SnapshotList = ElastiCache$20150202$Snapshot[];
  declare type ElastiCache$20150202$SnapshotNotFoundFault = {};
  declare type ElastiCache$20150202$SnapshotQuotaExceededFault = {};
  declare type ElastiCache$20150202$SourceType = 'cache-cluster' | 'cache-parameter-group' | 'cache-security-group' | 'cache-subnet-group';
  declare type ElastiCache$20150202$Subnet = {
    SubnetIdentifier?: string;
    SubnetAvailabilityZone?: ElastiCache$20150202$AvailabilityZone;
  };
  declare type ElastiCache$20150202$SubnetIdentifierList = string[];
  declare type ElastiCache$20150202$SubnetInUse = {};
  declare type ElastiCache$20150202$SubnetList = ElastiCache$20150202$Subnet[];
  declare type ElastiCache$20150202$TStamp = Date;
  declare type ElastiCache$20150202$Tag = {
    Key?: string;
    Value?: string;
  };
  declare type ElastiCache$20150202$TagList = ElastiCache$20150202$Tag[];
  declare type ElastiCache$20150202$TagListMessage = {
    TagList?: ElastiCache$20150202$TagList;
  };
  declare type ElastiCache$20150202$TagNotFoundFault = {};
  declare type ElastiCache$20150202$TagQuotaPerResourceExceeded = {};
  declare type ElasticBeanstalk$20101201$AbortEnvironmentUpdateMessage = {
    EnvironmentId?: string;
    EnvironmentName?: string;
  };
  declare type ElasticBeanstalk$20101201$ActionHistoryStatus = 'Completed' | 'Failed' | 'Unknown';
  declare type ElasticBeanstalk$20101201$ActionStatus = 'Scheduled' | 'Pending' | 'Running' | 'Unknown';
  declare type ElasticBeanstalk$20101201$ActionType = 'InstanceRefresh' | 'PlatformUpdate' | 'Unknown';
  declare type ElasticBeanstalk$20101201$ApplicationDescription = {
    ApplicationName?: string;
    Description?: string;
    DateCreated?: Date;
    DateUpdated?: Date;
    Versions?: ElasticBeanstalk$20101201$VersionLabelsList;
    ConfigurationTemplates?: ElasticBeanstalk$20101201$ConfigurationTemplateNamesList;
  };
  declare type ElasticBeanstalk$20101201$ApplicationDescriptionList = ElasticBeanstalk$20101201$ApplicationDescription[];
  declare type ElasticBeanstalk$20101201$ApplicationDescriptionMessage = {
    Application?: ElasticBeanstalk$20101201$ApplicationDescription;
  };
  declare type ElasticBeanstalk$20101201$ApplicationDescriptionsMessage = {
    Applications?: ElasticBeanstalk$20101201$ApplicationDescriptionList;
  };
  declare type ElasticBeanstalk$20101201$ApplicationMetrics = {
    Duration?: number;
    RequestCount?: number;
    StatusCodes?: ElasticBeanstalk$20101201$StatusCodes;
    Latency?: ElasticBeanstalk$20101201$Latency;
  };
  declare type ElasticBeanstalk$20101201$ApplicationNamesList = string[];
  declare type ElasticBeanstalk$20101201$ApplicationVersionDescription = {
    ApplicationName?: string;
    Description?: string;
    VersionLabel?: string;
    SourceBundle?: ElasticBeanstalk$20101201$S3Location;
    DateCreated?: Date;
    DateUpdated?: Date;
    Status?: 'Processed' | 'Unprocessed' | 'Failed' | 'Processing';
  };
  declare type ElasticBeanstalk$20101201$ApplicationVersionDescriptionList = ElasticBeanstalk$20101201$ApplicationVersionDescription[];
  declare type ElasticBeanstalk$20101201$ApplicationVersionDescriptionMessage = {
    ApplicationVersion?: ElasticBeanstalk$20101201$ApplicationVersionDescription;
  };
  declare type ElasticBeanstalk$20101201$ApplicationVersionDescriptionsMessage = {
    ApplicationVersions?: ElasticBeanstalk$20101201$ApplicationVersionDescriptionList;
  };
  declare type ElasticBeanstalk$20101201$ApplicationVersionStatus = 'Processed' | 'Unprocessed' | 'Failed' | 'Processing';
  declare type ElasticBeanstalk$20101201$ApplyEnvironmentManagedActionRequest = {
    EnvironmentName?: string;
    EnvironmentId?: string;
    ActionId: string;
  };
  declare type ElasticBeanstalk$20101201$ApplyEnvironmentManagedActionResult = {
    ActionId?: string;
    ActionDescription?: string;
    ActionType?: 'InstanceRefresh' | 'PlatformUpdate' | 'Unknown';
    Status?: string;
  };
  declare type ElasticBeanstalk$20101201$AutoScalingGroup = {
    Name?: string;
  };
  declare type ElasticBeanstalk$20101201$AutoScalingGroupList = ElasticBeanstalk$20101201$AutoScalingGroup[];
  declare type ElasticBeanstalk$20101201$AvailableSolutionStackDetailsList = ElasticBeanstalk$20101201$SolutionStackDescription[];
  declare type ElasticBeanstalk$20101201$AvailableSolutionStackNamesList = string[];
  declare type ElasticBeanstalk$20101201$CPUUtilization = {
    User?: number;
    Nice?: number;
    System?: number;
    Idle?: number;
    IOWait?: number;
    IRQ?: number;
    SoftIRQ?: number;
  };
  declare type ElasticBeanstalk$20101201$Causes = string[];
  declare type ElasticBeanstalk$20101201$CheckDNSAvailabilityMessage = {
    CNAMEPrefix: string;
  };
  declare type ElasticBeanstalk$20101201$CheckDNSAvailabilityResultMessage = {
    Available?: boolean;
    FullyQualifiedCNAME?: string;
  };
  declare type ElasticBeanstalk$20101201$ComposeEnvironmentsMessage = {
    ApplicationName?: string;
    GroupName?: string;
    VersionLabels?: ElasticBeanstalk$20101201$VersionLabels;
  };
  declare type ElasticBeanstalk$20101201$ConfigurationDeploymentStatus = 'deployed' | 'pending' | 'failed';
  declare type ElasticBeanstalk$20101201$ConfigurationOptionDescription = {
    Namespace?: string;
    Name?: string;
    DefaultValue?: string;
    ChangeSeverity?: string;
    UserDefined?: boolean;
    ValueType?: 'Scalar' | 'List';
    ValueOptions?: ElasticBeanstalk$20101201$ConfigurationOptionPossibleValues;
    MinValue?: number;
    MaxValue?: number;
    MaxLength?: number;
    Regex?: ElasticBeanstalk$20101201$OptionRestrictionRegex;
  };
  declare type ElasticBeanstalk$20101201$ConfigurationOptionDescriptionsList = ElasticBeanstalk$20101201$ConfigurationOptionDescription[];
  declare type ElasticBeanstalk$20101201$ConfigurationOptionPossibleValues = string[];
  declare type ElasticBeanstalk$20101201$ConfigurationOptionSetting = {
    ResourceName?: string;
    Namespace?: string;
    OptionName?: string;
    Value?: string;
  };
  declare type ElasticBeanstalk$20101201$ConfigurationOptionSettingsList = ElasticBeanstalk$20101201$ConfigurationOptionSetting[];
  declare type ElasticBeanstalk$20101201$ConfigurationOptionValueType = 'Scalar' | 'List';
  declare type ElasticBeanstalk$20101201$ConfigurationOptionsDescription = {
    SolutionStackName?: string;
    Options?: ElasticBeanstalk$20101201$ConfigurationOptionDescriptionsList;
  };
  declare type ElasticBeanstalk$20101201$ConfigurationSettingsDescription = {
    SolutionStackName?: string;
    ApplicationName?: string;
    TemplateName?: string;
    Description?: string;
    EnvironmentName?: string;
    DeploymentStatus?: 'deployed' | 'pending' | 'failed';
    DateCreated?: Date;
    DateUpdated?: Date;
    OptionSettings?: ElasticBeanstalk$20101201$ConfigurationOptionSettingsList;
  };
  declare type ElasticBeanstalk$20101201$ConfigurationSettingsDescriptionList = ElasticBeanstalk$20101201$ConfigurationSettingsDescription[];
  declare type ElasticBeanstalk$20101201$ConfigurationSettingsDescriptions = {
    ConfigurationSettings?: ElasticBeanstalk$20101201$ConfigurationSettingsDescriptionList;
  };
  declare type ElasticBeanstalk$20101201$ConfigurationSettingsValidationMessages = {
    Messages?: ElasticBeanstalk$20101201$ValidationMessagesList;
  };
  declare type ElasticBeanstalk$20101201$ConfigurationTemplateNamesList = string[];
  declare type ElasticBeanstalk$20101201$CreateApplicationMessage = {
    ApplicationName: string;
    Description?: string;
  };
  declare type ElasticBeanstalk$20101201$CreateApplicationVersionMessage = {
    ApplicationName: string;
    VersionLabel: string;
    Description?: string;
    SourceBundle?: ElasticBeanstalk$20101201$S3Location;
    AutoCreateApplication?: boolean;
    Process?: boolean;
  };
  declare type ElasticBeanstalk$20101201$CreateConfigurationTemplateMessage = {
    ApplicationName: string;
    TemplateName: string;
    SolutionStackName?: string;
    SourceConfiguration?: ElasticBeanstalk$20101201$SourceConfiguration;
    EnvironmentId?: string;
    Description?: string;
    OptionSettings?: ElasticBeanstalk$20101201$ConfigurationOptionSettingsList;
  };
  declare type ElasticBeanstalk$20101201$CreateEnvironmentMessage = {
    ApplicationName: string;
    EnvironmentName?: string;
    GroupName?: string;
    Description?: string;
    CNAMEPrefix?: string;
    Tier?: ElasticBeanstalk$20101201$EnvironmentTier;
    Tags?: ElasticBeanstalk$20101201$Tags;
    VersionLabel?: string;
    TemplateName?: string;
    SolutionStackName?: string;
    OptionSettings?: ElasticBeanstalk$20101201$ConfigurationOptionSettingsList;
    OptionsToRemove?: ElasticBeanstalk$20101201$OptionsSpecifierList;
  };
  declare type ElasticBeanstalk$20101201$CreateStorageLocationResultMessage = {
    S3Bucket?: string;
  };
  declare type ElasticBeanstalk$20101201$CreationDate = Date;
  declare type ElasticBeanstalk$20101201$DeleteApplicationMessage = {
    ApplicationName: string;
    TerminateEnvByForce?: boolean;
  };
  declare type ElasticBeanstalk$20101201$DeleteApplicationVersionMessage = {
    ApplicationName: string;
    VersionLabel: string;
    DeleteSourceBundle?: boolean;
  };
  declare type ElasticBeanstalk$20101201$DeleteConfigurationTemplateMessage = {
    ApplicationName: string;
    TemplateName: string;
  };
  declare type ElasticBeanstalk$20101201$DeleteEnvironmentConfigurationMessage = {
    ApplicationName: string;
    EnvironmentName: string;
  };
  declare type ElasticBeanstalk$20101201$Deployment = {
    VersionLabel?: string;
    DeploymentId?: number;
    Status?: string;
    DeploymentTime?: Date;
  };
  declare type ElasticBeanstalk$20101201$DeploymentTimestamp = Date;
  declare type ElasticBeanstalk$20101201$DescribeApplicationVersionsMessage = {
    ApplicationName?: string;
    VersionLabels?: ElasticBeanstalk$20101201$VersionLabelsList;
  };
  declare type ElasticBeanstalk$20101201$DescribeApplicationsMessage = {
    ApplicationNames?: ElasticBeanstalk$20101201$ApplicationNamesList;
  };
  declare type ElasticBeanstalk$20101201$DescribeConfigurationOptionsMessage = {
    ApplicationName?: string;
    TemplateName?: string;
    EnvironmentName?: string;
    SolutionStackName?: string;
    Options?: ElasticBeanstalk$20101201$OptionsSpecifierList;
  };
  declare type ElasticBeanstalk$20101201$DescribeConfigurationSettingsMessage = {
    ApplicationName: string;
    TemplateName?: string;
    EnvironmentName?: string;
  };
  declare type ElasticBeanstalk$20101201$DescribeEnvironmentHealthRequest = {
    EnvironmentName?: string;
    EnvironmentId?: string;
    AttributeNames?: ElasticBeanstalk$20101201$EnvironmentHealthAttributes;
  };
  declare type ElasticBeanstalk$20101201$DescribeEnvironmentHealthResult = {
    EnvironmentName?: string;
    HealthStatus?: string;
    Status?: 'Green' | 'Yellow' | 'Red' | 'Grey';
    Color?: string;
    Causes?: ElasticBeanstalk$20101201$Causes;
    ApplicationMetrics?: ElasticBeanstalk$20101201$ApplicationMetrics;
    InstancesHealth?: ElasticBeanstalk$20101201$InstanceHealthSummary;
    RefreshedAt?: Date;
  };
  declare type ElasticBeanstalk$20101201$DescribeEnvironmentManagedActionHistoryRequest = {
    EnvironmentId?: string;
    EnvironmentName?: string;
    NextToken?: string;
    MaxItems?: number;
  };
  declare type ElasticBeanstalk$20101201$DescribeEnvironmentManagedActionHistoryResult = {
    ManagedActionHistoryItems?: ElasticBeanstalk$20101201$ManagedActionHistoryItems;
    NextToken?: string;
  };
  declare type ElasticBeanstalk$20101201$DescribeEnvironmentManagedActionsRequest = {
    EnvironmentName?: string;
    EnvironmentId?: string;
    Status?: 'Scheduled' | 'Pending' | 'Running' | 'Unknown';
  };
  declare type ElasticBeanstalk$20101201$DescribeEnvironmentManagedActionsResult = {
    ManagedActions?: ElasticBeanstalk$20101201$ManagedActions;
  };
  declare type ElasticBeanstalk$20101201$DescribeEnvironmentResourcesMessage = {
    EnvironmentId?: string;
    EnvironmentName?: string;
  };
  declare type ElasticBeanstalk$20101201$DescribeEnvironmentsMessage = {
    ApplicationName?: string;
    VersionLabel?: string;
    EnvironmentIds?: ElasticBeanstalk$20101201$EnvironmentIdList;
    EnvironmentNames?: ElasticBeanstalk$20101201$EnvironmentNamesList;
    IncludeDeleted?: boolean;
    IncludedDeletedBackTo?: Date;
  };
  declare type ElasticBeanstalk$20101201$DescribeEventsMessage = {
    ApplicationName?: string;
    VersionLabel?: string;
    TemplateName?: string;
    EnvironmentId?: string;
    EnvironmentName?: string;
    RequestId?: string;
    Severity?: 'TRACE' | 'DEBUG' | 'INFO' | 'WARN' | 'ERROR' | 'FATAL';
    StartTime?: Date;
    EndTime?: Date;
    MaxRecords?: number;
    NextToken?: string;
  };
  declare type ElasticBeanstalk$20101201$DescribeInstancesHealthRequest = {
    EnvironmentName?: string;
    EnvironmentId?: string;
    AttributeNames?: ElasticBeanstalk$20101201$InstancesHealthAttributes;
    NextToken?: string;
  };
  declare type ElasticBeanstalk$20101201$DescribeInstancesHealthResult = {
    InstanceHealthList?: ElasticBeanstalk$20101201$InstanceHealthList;
    RefreshedAt?: Date;
    NextToken?: string;
  };
  declare type ElasticBeanstalk$20101201$ElasticBeanstalkServiceException = {
    message?: string;
  };
  declare type ElasticBeanstalk$20101201$EnvironmentDescription = {
    EnvironmentName?: string;
    EnvironmentId?: string;
    ApplicationName?: string;
    VersionLabel?: string;
    SolutionStackName?: string;
    TemplateName?: string;
    Description?: string;
    EndpointURL?: string;
    CNAME?: string;
    DateCreated?: Date;
    DateUpdated?: Date;
    Status?: 'Launching' | 'Updating' | 'Ready' | 'Terminating' | 'Terminated';
    AbortableOperationInProgress?: boolean;
    Health?: 'Green' | 'Yellow' | 'Red' | 'Grey';
    HealthStatus?: 'NoData' | 'Unknown' | 'Pending' | 'Ok' | 'Info' | 'Warning' | 'Degraded' | 'Severe';
    Resources?: ElasticBeanstalk$20101201$EnvironmentResourcesDescription;
    Tier?: ElasticBeanstalk$20101201$EnvironmentTier;
    EnvironmentLinks?: ElasticBeanstalk$20101201$EnvironmentLinks;
  };
  declare type ElasticBeanstalk$20101201$EnvironmentDescriptionsList = ElasticBeanstalk$20101201$EnvironmentDescription[];
  declare type ElasticBeanstalk$20101201$EnvironmentDescriptionsMessage = {
    Environments?: ElasticBeanstalk$20101201$EnvironmentDescriptionsList;
  };
  declare type ElasticBeanstalk$20101201$EnvironmentHealth = 'Green' | 'Yellow' | 'Red' | 'Grey';
  declare type ElasticBeanstalk$20101201$EnvironmentHealthAttribute = 'Status' | 'Color' | 'Causes' | 'ApplicationMetrics' | 'InstancesHealth' | 'All' | 'HealthStatus' | 'RefreshedAt';
  declare type ElasticBeanstalk$20101201$EnvironmentHealthAttributes = ('Status' | 'Color' | 'Causes' | 'ApplicationMetrics' | 'InstancesHealth' | 'All' | 'HealthStatus' | 'RefreshedAt')[];
  declare type ElasticBeanstalk$20101201$EnvironmentHealthStatus = 'NoData' | 'Unknown' | 'Pending' | 'Ok' | 'Info' | 'Warning' | 'Degraded' | 'Severe';
  declare type ElasticBeanstalk$20101201$EnvironmentIdList = string[];
  declare type ElasticBeanstalk$20101201$EnvironmentInfoDescription = {
    InfoType?: 'tail' | 'bundle';
    Ec2InstanceId?: string;
    SampleTimestamp?: Date;
    Message?: string;
  };
  declare type ElasticBeanstalk$20101201$EnvironmentInfoDescriptionList = ElasticBeanstalk$20101201$EnvironmentInfoDescription[];
  declare type ElasticBeanstalk$20101201$EnvironmentInfoType = 'tail' | 'bundle';
  declare type ElasticBeanstalk$20101201$EnvironmentLink = {
    LinkName?: string;
    EnvironmentName?: string;
  };
  declare type ElasticBeanstalk$20101201$EnvironmentLinks = ElasticBeanstalk$20101201$EnvironmentLink[];
  declare type ElasticBeanstalk$20101201$EnvironmentNamesList = string[];
  declare type ElasticBeanstalk$20101201$EnvironmentResourceDescription = {
    EnvironmentName?: string;
    AutoScalingGroups?: ElasticBeanstalk$20101201$AutoScalingGroupList;
    Instances?: ElasticBeanstalk$20101201$InstanceList;
    LaunchConfigurations?: ElasticBeanstalk$20101201$LaunchConfigurationList;
    LoadBalancers?: ElasticBeanstalk$20101201$LoadBalancerList;
    Triggers?: ElasticBeanstalk$20101201$TriggerList;
    Queues?: ElasticBeanstalk$20101201$QueueList;
  };
  declare type ElasticBeanstalk$20101201$EnvironmentResourceDescriptionsMessage = {
    EnvironmentResources?: ElasticBeanstalk$20101201$EnvironmentResourceDescription;
  };
  declare type ElasticBeanstalk$20101201$EnvironmentResourcesDescription = {
    LoadBalancer?: ElasticBeanstalk$20101201$LoadBalancerDescription;
  };
  declare type ElasticBeanstalk$20101201$EnvironmentStatus = 'Launching' | 'Updating' | 'Ready' | 'Terminating' | 'Terminated';
  declare type ElasticBeanstalk$20101201$EnvironmentTier = {
    Name?: string;
    Type?: string;
    Version?: string;
  };
  declare type ElasticBeanstalk$20101201$EventDate = Date;
  declare type ElasticBeanstalk$20101201$EventDescription = {
    EventDate?: Date;
    Message?: string;
    ApplicationName?: string;
    VersionLabel?: string;
    TemplateName?: string;
    EnvironmentName?: string;
    RequestId?: string;
    Severity?: 'TRACE' | 'DEBUG' | 'INFO' | 'WARN' | 'ERROR' | 'FATAL';
  };
  declare type ElasticBeanstalk$20101201$EventDescriptionList = ElasticBeanstalk$20101201$EventDescription[];
  declare type ElasticBeanstalk$20101201$EventDescriptionsMessage = {
    Events?: ElasticBeanstalk$20101201$EventDescriptionList;
    NextToken?: string;
  };
  declare type ElasticBeanstalk$20101201$EventSeverity = 'TRACE' | 'DEBUG' | 'INFO' | 'WARN' | 'ERROR' | 'FATAL';
  declare type ElasticBeanstalk$20101201$FailureType = 'UpdateCancelled' | 'CancellationFailed' | 'RollbackFailed' | 'RollbackSuccessful' | 'InternalFailure' | 'InvalidEnvironmentState' | 'PermissionsError';
  declare type ElasticBeanstalk$20101201$IncludeDeletedBackTo = Date;
  declare type ElasticBeanstalk$20101201$Instance = {
    Id?: string;
  };
  declare type ElasticBeanstalk$20101201$InstanceHealthList = ElasticBeanstalk$20101201$SingleInstanceHealth[];
  declare type ElasticBeanstalk$20101201$InstanceHealthSummary = {
    NoData?: number;
    Unknown?: number;
    Pending?: number;
    Ok?: number;
    Info?: number;
    Warning?: number;
    Degraded?: number;
    Severe?: number;
  };
  declare type ElasticBeanstalk$20101201$InstanceList = ElasticBeanstalk$20101201$Instance[];
  declare type ElasticBeanstalk$20101201$InstancesHealthAttribute = 'HealthStatus' | 'Color' | 'Causes' | 'ApplicationMetrics' | 'RefreshedAt' | 'LaunchedAt' | 'System' | 'Deployment' | 'AvailabilityZone' | 'InstanceType' | 'All';
  declare type ElasticBeanstalk$20101201$InstancesHealthAttributes = ('HealthStatus' | 'Color' | 'Causes' | 'ApplicationMetrics' | 'RefreshedAt' | 'LaunchedAt' | 'System' | 'Deployment' | 'AvailabilityZone' | 'InstanceType' | 'All')[];
  declare type ElasticBeanstalk$20101201$InsufficientPrivilegesException = {};
  declare type ElasticBeanstalk$20101201$InvalidRequestException = {};
  declare type ElasticBeanstalk$20101201$Latency = {
    P999?: number;
    P99?: number;
    P95?: number;
    P90?: number;
    P85?: number;
    P75?: number;
    P50?: number;
    P10?: number;
  };
  declare type ElasticBeanstalk$20101201$LaunchConfiguration = {
    Name?: string;
  };
  declare type ElasticBeanstalk$20101201$LaunchConfigurationList = ElasticBeanstalk$20101201$LaunchConfiguration[];
  declare type ElasticBeanstalk$20101201$LaunchedAt = Date;
  declare type ElasticBeanstalk$20101201$ListAvailableSolutionStacksResultMessage = {
    SolutionStacks?: ElasticBeanstalk$20101201$AvailableSolutionStackNamesList;
    SolutionStackDetails?: ElasticBeanstalk$20101201$AvailableSolutionStackDetailsList;
  };
  declare type ElasticBeanstalk$20101201$Listener = {
    Protocol?: string;
    Port?: number;
  };
  declare type ElasticBeanstalk$20101201$LoadAverage = number[];
  declare type ElasticBeanstalk$20101201$LoadBalancer = {
    Name?: string;
  };
  declare type ElasticBeanstalk$20101201$LoadBalancerDescription = {
    LoadBalancerName?: string;
    Domain?: string;
    Listeners?: ElasticBeanstalk$20101201$LoadBalancerListenersDescription;
  };
  declare type ElasticBeanstalk$20101201$LoadBalancerList = ElasticBeanstalk$20101201$LoadBalancer[];
  declare type ElasticBeanstalk$20101201$LoadBalancerListenersDescription = ElasticBeanstalk$20101201$Listener[];
  declare type ElasticBeanstalk$20101201$ManagedAction = {
    ActionId?: string;
    ActionDescription?: string;
    ActionType?: 'InstanceRefresh' | 'PlatformUpdate' | 'Unknown';
    Status?: 'Scheduled' | 'Pending' | 'Running' | 'Unknown';
    WindowStartTime?: Date;
  };
  declare type ElasticBeanstalk$20101201$ManagedActionHistoryItem = {
    ActionId?: string;
    ActionType?: 'InstanceRefresh' | 'PlatformUpdate' | 'Unknown';
    ActionDescription?: string;
    FailureType?: 'UpdateCancelled' | 'CancellationFailed' | 'RollbackFailed' | 'RollbackSuccessful' | 'InternalFailure' | 'InvalidEnvironmentState' | 'PermissionsError';
    Status?: 'Completed' | 'Failed' | 'Unknown';
    FailureDescription?: string;
    ExecutedTime?: Date;
    FinishedTime?: Date;
  };
  declare type ElasticBeanstalk$20101201$ManagedActionHistoryItems = ElasticBeanstalk$20101201$ManagedActionHistoryItem[];
  declare type ElasticBeanstalk$20101201$ManagedActionInvalidStateException = {};
  declare type ElasticBeanstalk$20101201$ManagedActions = ElasticBeanstalk$20101201$ManagedAction[];
  declare type ElasticBeanstalk$20101201$OperationInProgressException = {};
  declare type ElasticBeanstalk$20101201$OptionRestrictionRegex = {
    Pattern?: string;
    Label?: string;
  };
  declare type ElasticBeanstalk$20101201$OptionSpecification = {
    ResourceName?: string;
    Namespace?: string;
    OptionName?: string;
  };
  declare type ElasticBeanstalk$20101201$OptionsSpecifierList = ElasticBeanstalk$20101201$OptionSpecification[];
  declare type ElasticBeanstalk$20101201$Queue = {
    Name?: string;
    URL?: string;
  };
  declare type ElasticBeanstalk$20101201$QueueList = ElasticBeanstalk$20101201$Queue[];
  declare type ElasticBeanstalk$20101201$RebuildEnvironmentMessage = {
    EnvironmentId?: string;
    EnvironmentName?: string;
  };
  declare type ElasticBeanstalk$20101201$RefreshedAt = Date;
  declare type ElasticBeanstalk$20101201$RequestEnvironmentInfoMessage = {
    EnvironmentId?: string;
    EnvironmentName?: string;
    InfoType: 'tail' | 'bundle';
  };
  declare type ElasticBeanstalk$20101201$RestartAppServerMessage = {
    EnvironmentId?: string;
    EnvironmentName?: string;
  };
  declare type ElasticBeanstalk$20101201$RetrieveEnvironmentInfoMessage = {
    EnvironmentId?: string;
    EnvironmentName?: string;
    InfoType: 'tail' | 'bundle';
  };
  declare type ElasticBeanstalk$20101201$RetrieveEnvironmentInfoResultMessage = {
    EnvironmentInfo?: ElasticBeanstalk$20101201$EnvironmentInfoDescriptionList;
  };
  declare type ElasticBeanstalk$20101201$S3Location = {
    S3Bucket?: string;
    S3Key?: string;
  };
  declare type ElasticBeanstalk$20101201$S3LocationNotInServiceRegionException = {};
  declare type ElasticBeanstalk$20101201$S3SubscriptionRequiredException = {};
  declare type ElasticBeanstalk$20101201$SampleTimestamp = Date;
  declare type ElasticBeanstalk$20101201$SingleInstanceHealth = {
    InstanceId?: string;
    HealthStatus?: string;
    Color?: string;
    Causes?: ElasticBeanstalk$20101201$Causes;
    LaunchedAt?: Date;
    ApplicationMetrics?: ElasticBeanstalk$20101201$ApplicationMetrics;
    System?: ElasticBeanstalk$20101201$SystemStatus;
    Deployment?: ElasticBeanstalk$20101201$Deployment;
    AvailabilityZone?: string;
    InstanceType?: string;
  };
  declare type ElasticBeanstalk$20101201$SolutionStackDescription = {
    SolutionStackName?: string;
    PermittedFileTypes?: ElasticBeanstalk$20101201$SolutionStackFileTypeList;
  };
  declare type ElasticBeanstalk$20101201$SolutionStackFileTypeList = string[];
  declare type ElasticBeanstalk$20101201$SourceBundleDeletionException = {};
  declare type ElasticBeanstalk$20101201$SourceConfiguration = {
    ApplicationName?: string;
    TemplateName?: string;
  };
  declare type ElasticBeanstalk$20101201$StatusCodes = {
    Status2xx?: number;
    Status3xx?: number;
    Status4xx?: number;
    Status5xx?: number;
  };
  declare type ElasticBeanstalk$20101201$SwapEnvironmentCNAMEsMessage = {
    SourceEnvironmentId?: string;
    SourceEnvironmentName?: string;
    DestinationEnvironmentId?: string;
    DestinationEnvironmentName?: string;
  };
  declare type ElasticBeanstalk$20101201$SystemStatus = {
    CPUUtilization?: ElasticBeanstalk$20101201$CPUUtilization;
    LoadAverage?: ElasticBeanstalk$20101201$LoadAverage;
  };
  declare type ElasticBeanstalk$20101201$Tag = {
    Key?: string;
    Value?: string;
  };
  declare type ElasticBeanstalk$20101201$Tags = ElasticBeanstalk$20101201$Tag[];
  declare type ElasticBeanstalk$20101201$TerminateEnvironmentMessage = {
    EnvironmentId?: string;
    EnvironmentName?: string;
    TerminateResources?: boolean;
    ForceTerminate?: boolean;
  };
  declare type ElasticBeanstalk$20101201$TimeFilterEnd = Date;
  declare type ElasticBeanstalk$20101201$TimeFilterStart = Date;
  declare type ElasticBeanstalk$20101201$Timestamp = Date;
  declare type ElasticBeanstalk$20101201$TooManyApplicationVersionsException = {};
  declare type ElasticBeanstalk$20101201$TooManyApplicationsException = {};
  declare type ElasticBeanstalk$20101201$TooManyBucketsException = {};
  declare type ElasticBeanstalk$20101201$TooManyConfigurationTemplatesException = {};
  declare type ElasticBeanstalk$20101201$TooManyEnvironmentsException = {};
  declare type ElasticBeanstalk$20101201$Trigger = {
    Name?: string;
  };
  declare type ElasticBeanstalk$20101201$TriggerList = ElasticBeanstalk$20101201$Trigger[];
  declare type ElasticBeanstalk$20101201$UpdateApplicationMessage = {
    ApplicationName: string;
    Description?: string;
  };
  declare type ElasticBeanstalk$20101201$UpdateApplicationVersionMessage = {
    ApplicationName: string;
    VersionLabel: string;
    Description?: string;
  };
  declare type ElasticBeanstalk$20101201$UpdateConfigurationTemplateMessage = {
    ApplicationName: string;
    TemplateName: string;
    Description?: string;
    OptionSettings?: ElasticBeanstalk$20101201$ConfigurationOptionSettingsList;
    OptionsToRemove?: ElasticBeanstalk$20101201$OptionsSpecifierList;
  };
  declare type ElasticBeanstalk$20101201$UpdateDate = Date;
  declare type ElasticBeanstalk$20101201$UpdateEnvironmentMessage = {
    ApplicationName?: string;
    EnvironmentId?: string;
    EnvironmentName?: string;
    GroupName?: string;
    Description?: string;
    Tier?: ElasticBeanstalk$20101201$EnvironmentTier;
    VersionLabel?: string;
    TemplateName?: string;
    SolutionStackName?: string;
    OptionSettings?: ElasticBeanstalk$20101201$ConfigurationOptionSettingsList;
    OptionsToRemove?: ElasticBeanstalk$20101201$OptionsSpecifierList;
  };
  declare type ElasticBeanstalk$20101201$ValidateConfigurationSettingsMessage = {
    ApplicationName: string;
    TemplateName?: string;
    EnvironmentName?: string;
    OptionSettings: ElasticBeanstalk$20101201$ConfigurationOptionSettingsList;
  };
  declare type ElasticBeanstalk$20101201$ValidationMessage = {
    Message?: string;
    Severity?: 'error' | 'warning';
    Namespace?: string;
    OptionName?: string;
  };
  declare type ElasticBeanstalk$20101201$ValidationMessagesList = ElasticBeanstalk$20101201$ValidationMessage[];
  declare type ElasticBeanstalk$20101201$ValidationSeverity = 'error' | 'warning';
  declare type ElasticBeanstalk$20101201$VersionLabels = string[];
  declare type ElasticBeanstalk$20101201$VersionLabelsList = string[];
  declare type ELB$20120601$AccessLog = {
    Enabled: boolean;
    S3BucketName?: string;
    EmitInterval?: number;
    S3BucketPrefix?: string;
  };
  declare type ELB$20120601$AccessPointNotFoundException = {};
  declare type ELB$20120601$AddAvailabilityZonesInput = {
    LoadBalancerName: string;
    AvailabilityZones: ELB$20120601$AvailabilityZones;
  };
  declare type ELB$20120601$AddAvailabilityZonesOutput = {
    AvailabilityZones?: ELB$20120601$AvailabilityZones;
  };
  declare type ELB$20120601$AddTagsInput = {
    LoadBalancerNames: ELB$20120601$LoadBalancerNames;
    Tags: ELB$20120601$TagList;
  };
  declare type ELB$20120601$AddTagsOutput = {};
  declare type ELB$20120601$AdditionalAttribute = {
    Key?: string;
    Value?: string;
  };
  declare type ELB$20120601$AdditionalAttributes = ELB$20120601$AdditionalAttribute[];
  declare type ELB$20120601$AppCookieStickinessPolicies = ELB$20120601$AppCookieStickinessPolicy[];
  declare type ELB$20120601$AppCookieStickinessPolicy = {
    PolicyName?: string;
    CookieName?: string;
  };
  declare type ELB$20120601$ApplySecurityGroupsToLoadBalancerInput = {
    LoadBalancerName: string;
    SecurityGroups: ELB$20120601$SecurityGroups;
  };
  declare type ELB$20120601$ApplySecurityGroupsToLoadBalancerOutput = {
    SecurityGroups?: ELB$20120601$SecurityGroups;
  };
  declare type ELB$20120601$AttachLoadBalancerToSubnetsInput = {
    LoadBalancerName: string;
    Subnets: ELB$20120601$Subnets;
  };
  declare type ELB$20120601$AttachLoadBalancerToSubnetsOutput = {
    Subnets?: ELB$20120601$Subnets;
  };
  declare type ELB$20120601$AvailabilityZones = string[];
  declare type ELB$20120601$BackendServerDescription = {
    InstancePort?: number;
    PolicyNames?: ELB$20120601$PolicyNames;
  };
  declare type ELB$20120601$BackendServerDescriptions = ELB$20120601$BackendServerDescription[];
  declare type ELB$20120601$CertificateNotFoundException = {};
  declare type ELB$20120601$ConfigureHealthCheckInput = {
    LoadBalancerName: string;
    HealthCheck: ELB$20120601$HealthCheck;
  };
  declare type ELB$20120601$ConfigureHealthCheckOutput = {
    HealthCheck?: ELB$20120601$HealthCheck;
  };
  declare type ELB$20120601$ConnectionDraining = {
    Enabled: boolean;
    Timeout?: number;
  };
  declare type ELB$20120601$ConnectionSettings = {
    IdleTimeout: number;
  };
  declare type ELB$20120601$CreateAccessPointInput = {
    LoadBalancerName: string;
    Listeners: ELB$20120601$Listeners;
    AvailabilityZones?: ELB$20120601$AvailabilityZones;
    Subnets?: ELB$20120601$Subnets;
    SecurityGroups?: ELB$20120601$SecurityGroups;
    Scheme?: string;
    Tags?: ELB$20120601$TagList;
  };
  declare type ELB$20120601$CreateAccessPointOutput = {
    DNSName?: string;
  };
  declare type ELB$20120601$CreateAppCookieStickinessPolicyInput = {
    LoadBalancerName: string;
    PolicyName: string;
    CookieName: string;
  };
  declare type ELB$20120601$CreateAppCookieStickinessPolicyOutput = {};
  declare type ELB$20120601$CreateLBCookieStickinessPolicyInput = {
    LoadBalancerName: string;
    PolicyName: string;
    CookieExpirationPeriod?: number;
  };
  declare type ELB$20120601$CreateLBCookieStickinessPolicyOutput = {};
  declare type ELB$20120601$CreateLoadBalancerListenerInput = {
    LoadBalancerName: string;
    Listeners: ELB$20120601$Listeners;
  };
  declare type ELB$20120601$CreateLoadBalancerListenerOutput = {};
  declare type ELB$20120601$CreateLoadBalancerPolicyInput = {
    LoadBalancerName: string;
    PolicyName: string;
    PolicyTypeName: string;
    PolicyAttributes?: ELB$20120601$PolicyAttributes;
  };
  declare type ELB$20120601$CreateLoadBalancerPolicyOutput = {};
  declare type ELB$20120601$CreatedTime = Date;
  declare type ELB$20120601$CrossZoneLoadBalancing = {
    Enabled: boolean;
  };
  declare type ELB$20120601$DeleteAccessPointInput = {
    LoadBalancerName: string;
  };
  declare type ELB$20120601$DeleteAccessPointOutput = {};
  declare type ELB$20120601$DeleteLoadBalancerListenerInput = {
    LoadBalancerName: string;
    LoadBalancerPorts: ELB$20120601$Ports;
  };
  declare type ELB$20120601$DeleteLoadBalancerListenerOutput = {};
  declare type ELB$20120601$DeleteLoadBalancerPolicyInput = {
    LoadBalancerName: string;
    PolicyName: string;
  };
  declare type ELB$20120601$DeleteLoadBalancerPolicyOutput = {};
  declare type ELB$20120601$DependencyThrottleException = {};
  declare type ELB$20120601$DeregisterEndPointsInput = {
    LoadBalancerName: string;
    Instances: ELB$20120601$Instances;
  };
  declare type ELB$20120601$DeregisterEndPointsOutput = {
    Instances?: ELB$20120601$Instances;
  };
  declare type ELB$20120601$DescribeAccessPointsInput = {
    LoadBalancerNames?: ELB$20120601$LoadBalancerNames;
    Marker?: string;
    PageSize?: number;
  };
  declare type ELB$20120601$DescribeAccessPointsOutput = {
    LoadBalancerDescriptions?: ELB$20120601$LoadBalancerDescriptions;
    NextMarker?: string;
  };
  declare type ELB$20120601$DescribeEndPointStateInput = {
    LoadBalancerName: string;
    Instances?: ELB$20120601$Instances;
  };
  declare type ELB$20120601$DescribeEndPointStateOutput = {
    InstanceStates?: ELB$20120601$InstanceStates;
  };
  declare type ELB$20120601$DescribeLoadBalancerAttributesInput = {
    LoadBalancerName: string;
  };
  declare type ELB$20120601$DescribeLoadBalancerAttributesOutput = {
    LoadBalancerAttributes?: ELB$20120601$LoadBalancerAttributes;
  };
  declare type ELB$20120601$DescribeLoadBalancerPoliciesInput = {
    LoadBalancerName?: string;
    PolicyNames?: ELB$20120601$PolicyNames;
  };
  declare type ELB$20120601$DescribeLoadBalancerPoliciesOutput = {
    PolicyDescriptions?: ELB$20120601$PolicyDescriptions;
  };
  declare type ELB$20120601$DescribeLoadBalancerPolicyTypesInput = {
    PolicyTypeNames?: ELB$20120601$PolicyTypeNames;
  };
  declare type ELB$20120601$DescribeLoadBalancerPolicyTypesOutput = {
    PolicyTypeDescriptions?: ELB$20120601$PolicyTypeDescriptions;
  };
  declare type ELB$20120601$DescribeTagsInput = {
    LoadBalancerNames: ELB$20120601$LoadBalancerNamesMax20;
  };
  declare type ELB$20120601$DescribeTagsOutput = {
    TagDescriptions?: ELB$20120601$TagDescriptions;
  };
  declare type ELB$20120601$DetachLoadBalancerFromSubnetsInput = {
    LoadBalancerName: string;
    Subnets: ELB$20120601$Subnets;
  };
  declare type ELB$20120601$DetachLoadBalancerFromSubnetsOutput = {
    Subnets?: ELB$20120601$Subnets;
  };
  declare type ELB$20120601$DuplicateAccessPointNameException = {};
  declare type ELB$20120601$DuplicateListenerException = {};
  declare type ELB$20120601$DuplicatePolicyNameException = {};
  declare type ELB$20120601$DuplicateTagKeysException = {};
  declare type ELB$20120601$HealthCheck = {
    Target: string;
    Interval: number;
    Timeout: number;
    UnhealthyThreshold: number;
    HealthyThreshold: number;
  };
  declare type ELB$20120601$Instance = {
    InstanceId?: string;
  };
  declare type ELB$20120601$InstanceState = {
    InstanceId?: string;
    State?: string;
    ReasonCode?: string;
    Description?: string;
  };
  declare type ELB$20120601$InstanceStates = ELB$20120601$InstanceState[];
  declare type ELB$20120601$Instances = ELB$20120601$Instance[];
  declare type ELB$20120601$InvalidConfigurationRequestException = {};
  declare type ELB$20120601$InvalidEndPointException = {};
  declare type ELB$20120601$InvalidSchemeException = {};
  declare type ELB$20120601$InvalidSecurityGroupException = {};
  declare type ELB$20120601$InvalidSubnetException = {};
  declare type ELB$20120601$LBCookieStickinessPolicies = ELB$20120601$LBCookieStickinessPolicy[];
  declare type ELB$20120601$LBCookieStickinessPolicy = {
    PolicyName?: string;
    CookieExpirationPeriod?: number;
  };
  declare type ELB$20120601$Listener = {
    Protocol: string;
    LoadBalancerPort: number;
    InstanceProtocol?: string;
    InstancePort: number;
    SSLCertificateId?: string;
  };
  declare type ELB$20120601$ListenerDescription = {
    Listener?: ELB$20120601$Listener;
    PolicyNames?: ELB$20120601$PolicyNames;
  };
  declare type ELB$20120601$ListenerDescriptions = ELB$20120601$ListenerDescription[];
  declare type ELB$20120601$ListenerNotFoundException = {};
  declare type ELB$20120601$Listeners = ELB$20120601$Listener[];
  declare type ELB$20120601$LoadBalancerAttributeNotFoundException = {};
  declare type ELB$20120601$LoadBalancerAttributes = {
    CrossZoneLoadBalancing?: ELB$20120601$CrossZoneLoadBalancing;
    AccessLog?: ELB$20120601$AccessLog;
    ConnectionDraining?: ELB$20120601$ConnectionDraining;
    ConnectionSettings?: ELB$20120601$ConnectionSettings;
    AdditionalAttributes?: ELB$20120601$AdditionalAttributes;
  };
  declare type ELB$20120601$LoadBalancerDescription = {
    LoadBalancerName?: string;
    DNSName?: string;
    CanonicalHostedZoneName?: string;
    CanonicalHostedZoneNameID?: string;
    ListenerDescriptions?: ELB$20120601$ListenerDescriptions;
    Policies?: ELB$20120601$Policies;
    BackendServerDescriptions?: ELB$20120601$BackendServerDescriptions;
    AvailabilityZones?: ELB$20120601$AvailabilityZones;
    Subnets?: ELB$20120601$Subnets;
    VPCId?: string;
    Instances?: ELB$20120601$Instances;
    HealthCheck?: ELB$20120601$HealthCheck;
    SourceSecurityGroup?: ELB$20120601$SourceSecurityGroup;
    SecurityGroups?: ELB$20120601$SecurityGroups;
    CreatedTime?: Date;
    Scheme?: string;
  };
  declare type ELB$20120601$LoadBalancerDescriptions = ELB$20120601$LoadBalancerDescription[];
  declare type ELB$20120601$LoadBalancerNames = string[];
  declare type ELB$20120601$LoadBalancerNamesMax20 = string[];
  declare type ELB$20120601$ModifyLoadBalancerAttributesInput = {
    LoadBalancerName: string;
    LoadBalancerAttributes: ELB$20120601$LoadBalancerAttributes;
  };
  declare type ELB$20120601$ModifyLoadBalancerAttributesOutput = {
    LoadBalancerName?: string;
    LoadBalancerAttributes?: ELB$20120601$LoadBalancerAttributes;
  };
  declare type ELB$20120601$Policies = {
    AppCookieStickinessPolicies?: ELB$20120601$AppCookieStickinessPolicies;
    LBCookieStickinessPolicies?: ELB$20120601$LBCookieStickinessPolicies;
    OtherPolicies?: ELB$20120601$PolicyNames;
  };
  declare type ELB$20120601$PolicyAttribute = {
    AttributeName?: string;
    AttributeValue?: string;
  };
  declare type ELB$20120601$PolicyAttributeDescription = {
    AttributeName?: string;
    AttributeValue?: string;
  };
  declare type ELB$20120601$PolicyAttributeDescriptions = ELB$20120601$PolicyAttributeDescription[];
  declare type ELB$20120601$PolicyAttributeTypeDescription = {
    AttributeName?: string;
    AttributeType?: string;
    Description?: string;
    DefaultValue?: string;
    Cardinality?: string;
  };
  declare type ELB$20120601$PolicyAttributeTypeDescriptions = ELB$20120601$PolicyAttributeTypeDescription[];
  declare type ELB$20120601$PolicyAttributes = ELB$20120601$PolicyAttribute[];
  declare type ELB$20120601$PolicyDescription = {
    PolicyName?: string;
    PolicyTypeName?: string;
    PolicyAttributeDescriptions?: ELB$20120601$PolicyAttributeDescriptions;
  };
  declare type ELB$20120601$PolicyDescriptions = ELB$20120601$PolicyDescription[];
  declare type ELB$20120601$PolicyNames = string[];
  declare type ELB$20120601$PolicyNotFoundException = {};
  declare type ELB$20120601$PolicyTypeDescription = {
    PolicyTypeName?: string;
    Description?: string;
    PolicyAttributeTypeDescriptions?: ELB$20120601$PolicyAttributeTypeDescriptions;
  };
  declare type ELB$20120601$PolicyTypeDescriptions = ELB$20120601$PolicyTypeDescription[];
  declare type ELB$20120601$PolicyTypeNames = string[];
  declare type ELB$20120601$PolicyTypeNotFoundException = {};
  declare type ELB$20120601$Ports = number[];
  declare type ELB$20120601$RegisterEndPointsInput = {
    LoadBalancerName: string;
    Instances: ELB$20120601$Instances;
  };
  declare type ELB$20120601$RegisterEndPointsOutput = {
    Instances?: ELB$20120601$Instances;
  };
  declare type ELB$20120601$RemoveAvailabilityZonesInput = {
    LoadBalancerName: string;
    AvailabilityZones: ELB$20120601$AvailabilityZones;
  };
  declare type ELB$20120601$RemoveAvailabilityZonesOutput = {
    AvailabilityZones?: ELB$20120601$AvailabilityZones;
  };
  declare type ELB$20120601$RemoveTagsInput = {
    LoadBalancerNames: ELB$20120601$LoadBalancerNames;
    Tags: ELB$20120601$TagKeyList;
  };
  declare type ELB$20120601$RemoveTagsOutput = {};
  declare type ELB$20120601$SecurityGroups = string[];
  declare type ELB$20120601$SetLoadBalancerListenerSSLCertificateInput = {
    LoadBalancerName: string;
    LoadBalancerPort: number;
    SSLCertificateId: string;
  };
  declare type ELB$20120601$SetLoadBalancerListenerSSLCertificateOutput = {};
  declare type ELB$20120601$SetLoadBalancerPoliciesForBackendServerInput = {
    LoadBalancerName: string;
    InstancePort: number;
    PolicyNames: ELB$20120601$PolicyNames;
  };
  declare type ELB$20120601$SetLoadBalancerPoliciesForBackendServerOutput = {};
  declare type ELB$20120601$SetLoadBalancerPoliciesOfListenerInput = {
    LoadBalancerName: string;
    LoadBalancerPort: number;
    PolicyNames: ELB$20120601$PolicyNames;
  };
  declare type ELB$20120601$SetLoadBalancerPoliciesOfListenerOutput = {};
  declare type ELB$20120601$SourceSecurityGroup = {
    OwnerAlias?: string;
    GroupName?: string;
  };
  declare type ELB$20120601$SubnetNotFoundException = {};
  declare type ELB$20120601$Subnets = string[];
  declare type ELB$20120601$Tag = {
    Key: string;
    Value?: string;
  };
  declare type ELB$20120601$TagDescription = {
    LoadBalancerName?: string;
    Tags?: ELB$20120601$TagList;
  };
  declare type ELB$20120601$TagDescriptions = ELB$20120601$TagDescription[];
  declare type ELB$20120601$TagKeyList = ELB$20120601$TagKeyOnly[];
  declare type ELB$20120601$TagKeyOnly = {
    Key?: string;
  };
  declare type ELB$20120601$TagList = ELB$20120601$Tag[];
  declare type ELB$20120601$TooManyAccessPointsException = {};
  declare type ELB$20120601$TooManyPoliciesException = {};
  declare type ELB$20120601$TooManyTagsException = {};
  declare type ELB$20120601$UnsupportedProtocolException = {};
  declare type ELBv2$20151201$Action = {
    Type: 'forward';
    TargetGroupArn: string;
  };
  declare type ELBv2$20151201$ActionTypeEnum = 'forward';
  declare type ELBv2$20151201$Actions = ELBv2$20151201$Action[];
  declare type ELBv2$20151201$AddTagsInput = {
    ResourceArns: ELBv2$20151201$ResourceArns;
    Tags: ELBv2$20151201$TagList;
  };
  declare type ELBv2$20151201$AddTagsOutput = {};
  declare type ELBv2$20151201$AvailabilityZone = {
    ZoneName?: string;
    SubnetId?: string;
  };
  declare type ELBv2$20151201$AvailabilityZones = ELBv2$20151201$AvailabilityZone[];
  declare type ELBv2$20151201$Certificate = {
    CertificateArn?: string;
  };
  declare type ELBv2$20151201$CertificateList = ELBv2$20151201$Certificate[];
  declare type ELBv2$20151201$CertificateNotFoundException = {};
  declare type ELBv2$20151201$Cipher = {
    Name?: string;
    Priority?: number;
  };
  declare type ELBv2$20151201$Ciphers = ELBv2$20151201$Cipher[];
  declare type ELBv2$20151201$CreateListenerInput = {
    LoadBalancerArn: string;
    Protocol: 'HTTP' | 'HTTPS';
    Port: number;
    SslPolicy?: string;
    Certificates?: ELBv2$20151201$CertificateList;
    DefaultActions: ELBv2$20151201$Actions;
  };
  declare type ELBv2$20151201$CreateListenerOutput = {
    Listeners?: ELBv2$20151201$Listeners;
  };
  declare type ELBv2$20151201$CreateLoadBalancerInput = {
    Name: string;
    Subnets: ELBv2$20151201$Subnets;
    SecurityGroups?: ELBv2$20151201$SecurityGroups;
    Scheme?: 'internet-facing' | 'internal';
    Tags?: ELBv2$20151201$TagList;
  };
  declare type ELBv2$20151201$CreateLoadBalancerOutput = {
    LoadBalancers?: ELBv2$20151201$LoadBalancers;
  };
  declare type ELBv2$20151201$CreateRuleInput = {
    ListenerArn: string;
    Conditions: ELBv2$20151201$RuleConditionList;
    Priority: number;
    Actions: ELBv2$20151201$Actions;
  };
  declare type ELBv2$20151201$CreateRuleOutput = {
    Rules?: ELBv2$20151201$Rules;
  };
  declare type ELBv2$20151201$CreateTargetGroupInput = {
    Name: string;
    Protocol: 'HTTP' | 'HTTPS';
    Port: number;
    VpcId: string;
    HealthCheckProtocol?: 'HTTP' | 'HTTPS';
    HealthCheckPort?: string;
    HealthCheckPath?: string;
    HealthCheckIntervalSeconds?: number;
    HealthCheckTimeoutSeconds?: number;
    HealthyThresholdCount?: number;
    UnhealthyThresholdCount?: number;
    Matcher?: ELBv2$20151201$Matcher;
  };
  declare type ELBv2$20151201$CreateTargetGroupOutput = {
    TargetGroups?: ELBv2$20151201$TargetGroups;
  };
  declare type ELBv2$20151201$CreatedTime = Date;
  declare type ELBv2$20151201$DeleteListenerInput = {
    ListenerArn: string;
  };
  declare type ELBv2$20151201$DeleteListenerOutput = {};
  declare type ELBv2$20151201$DeleteLoadBalancerInput = {
    LoadBalancerArn: string;
  };
  declare type ELBv2$20151201$DeleteLoadBalancerOutput = {};
  declare type ELBv2$20151201$DeleteRuleInput = {
    RuleArn: string;
  };
  declare type ELBv2$20151201$DeleteRuleOutput = {};
  declare type ELBv2$20151201$DeleteTargetGroupInput = {
    TargetGroupArn: string;
  };
  declare type ELBv2$20151201$DeleteTargetGroupOutput = {};
  declare type ELBv2$20151201$DeregisterTargetsInput = {
    TargetGroupArn: string;
    Targets: ELBv2$20151201$TargetDescriptions;
  };
  declare type ELBv2$20151201$DeregisterTargetsOutput = {};
  declare type ELBv2$20151201$DescribeListenersInput = {
    LoadBalancerArn?: string;
    ListenerArns?: ELBv2$20151201$ListenerArns;
    Marker?: string;
    PageSize?: number;
  };
  declare type ELBv2$20151201$DescribeListenersOutput = {
    Listeners?: ELBv2$20151201$Listeners;
    NextMarker?: string;
  };
  declare type ELBv2$20151201$DescribeLoadBalancerAttributesInput = {
    LoadBalancerArn: string;
  };
  declare type ELBv2$20151201$DescribeLoadBalancerAttributesOutput = {
    Attributes?: ELBv2$20151201$LoadBalancerAttributes;
  };
  declare type ELBv2$20151201$DescribeLoadBalancersInput = {
    LoadBalancerArns?: ELBv2$20151201$LoadBalancerArns;
    Names?: ELBv2$20151201$LoadBalancerNames;
    Marker?: string;
    PageSize?: number;
  };
  declare type ELBv2$20151201$DescribeLoadBalancersOutput = {
    LoadBalancers?: ELBv2$20151201$LoadBalancers;
    NextMarker?: string;
  };
  declare type ELBv2$20151201$DescribeRulesInput = {
    ListenerArn?: string;
    RuleArns?: ELBv2$20151201$RuleArns;
  };
  declare type ELBv2$20151201$DescribeRulesOutput = {
    Rules?: ELBv2$20151201$Rules;
  };
  declare type ELBv2$20151201$DescribeSSLPoliciesInput = {
    Names?: ELBv2$20151201$SslPolicyNames;
    Marker?: string;
    PageSize?: number;
  };
  declare type ELBv2$20151201$DescribeSSLPoliciesOutput = {
    SslPolicies?: ELBv2$20151201$SslPolicies;
    NextMarker?: string;
  };
  declare type ELBv2$20151201$DescribeTagsInput = {
    ResourceArns: ELBv2$20151201$ResourceArns;
  };
  declare type ELBv2$20151201$DescribeTagsOutput = {
    TagDescriptions?: ELBv2$20151201$TagDescriptions;
  };
  declare type ELBv2$20151201$DescribeTargetGroupAttributesInput = {
    TargetGroupArn: string;
  };
  declare type ELBv2$20151201$DescribeTargetGroupAttributesOutput = {
    Attributes?: ELBv2$20151201$TargetGroupAttributes;
  };
  declare type ELBv2$20151201$DescribeTargetGroupsInput = {
    LoadBalancerArn?: string;
    TargetGroupArns?: ELBv2$20151201$TargetGroupArns;
    Names?: ELBv2$20151201$TargetGroupNames;
    Marker?: string;
    PageSize?: number;
  };
  declare type ELBv2$20151201$DescribeTargetGroupsOutput = {
    TargetGroups?: ELBv2$20151201$TargetGroups;
    NextMarker?: string;
  };
  declare type ELBv2$20151201$DescribeTargetHealthInput = {
    TargetGroupArn: string;
    Targets?: ELBv2$20151201$TargetDescriptions;
  };
  declare type ELBv2$20151201$DescribeTargetHealthOutput = {
    TargetHealthDescriptions?: ELBv2$20151201$TargetHealthDescriptions;
  };
  declare type ELBv2$20151201$DuplicateListenerException = {};
  declare type ELBv2$20151201$DuplicateLoadBalancerNameException = {};
  declare type ELBv2$20151201$DuplicateTagKeysException = {};
  declare type ELBv2$20151201$DuplicateTargetGroupNameException = {};
  declare type ELBv2$20151201$HealthUnavailableException = {};
  declare type ELBv2$20151201$IncompatibleProtocolsException = {};
  declare type ELBv2$20151201$InvalidConfigurationRequestException = {};
  declare type ELBv2$20151201$InvalidSchemeException = {};
  declare type ELBv2$20151201$InvalidSecurityGroupException = {};
  declare type ELBv2$20151201$InvalidSubnetException = {};
  declare type ELBv2$20151201$InvalidTargetException = {};
  declare type ELBv2$20151201$ListOfString = string[];
  declare type ELBv2$20151201$Listener = {
    ListenerArn?: string;
    LoadBalancerArn?: string;
    Port?: number;
    Protocol?: 'HTTP' | 'HTTPS';
    Certificates?: ELBv2$20151201$CertificateList;
    SslPolicy?: string;
    DefaultActions?: ELBv2$20151201$Actions;
  };
  declare type ELBv2$20151201$ListenerArns = string[];
  declare type ELBv2$20151201$ListenerNotFoundException = {};
  declare type ELBv2$20151201$Listeners = ELBv2$20151201$Listener[];
  declare type ELBv2$20151201$LoadBalancer = {
    LoadBalancerArn?: string;
    DNSName?: string;
    CanonicalHostedZoneId?: string;
    CreatedTime?: Date;
    LoadBalancerName?: string;
    Scheme?: 'internet-facing' | 'internal';
    VpcId?: string;
    State?: ELBv2$20151201$LoadBalancerState;
    Type?: 'application';
    AvailabilityZones?: ELBv2$20151201$AvailabilityZones;
    SecurityGroups?: ELBv2$20151201$SecurityGroups;
  };
  declare type ELBv2$20151201$LoadBalancerArns = string[];
  declare type ELBv2$20151201$LoadBalancerAttribute = {
    Key?: string;
    Value?: string;
  };
  declare type ELBv2$20151201$LoadBalancerAttributes = ELBv2$20151201$LoadBalancerAttribute[];
  declare type ELBv2$20151201$LoadBalancerNames = string[];
  declare type ELBv2$20151201$LoadBalancerNotFoundException = {};
  declare type ELBv2$20151201$LoadBalancerSchemeEnum = 'internet-facing' | 'internal';
  declare type ELBv2$20151201$LoadBalancerState = {
    Code?: 'active' | 'provisioning' | 'failed';
    Reason?: string;
  };
  declare type ELBv2$20151201$LoadBalancerStateEnum = 'active' | 'provisioning' | 'failed';
  declare type ELBv2$20151201$LoadBalancerTypeEnum = 'application';
  declare type ELBv2$20151201$LoadBalancers = ELBv2$20151201$LoadBalancer[];
  declare type ELBv2$20151201$Matcher = {
    HttpCode: string;
  };
  declare type ELBv2$20151201$ModifyListenerInput = {
    ListenerArn: string;
    Port?: number;
    Protocol?: 'HTTP' | 'HTTPS';
    SslPolicy?: string;
    Certificates?: ELBv2$20151201$CertificateList;
    DefaultActions?: ELBv2$20151201$Actions;
  };
  declare type ELBv2$20151201$ModifyListenerOutput = {
    Listeners?: ELBv2$20151201$Listeners;
  };
  declare type ELBv2$20151201$ModifyLoadBalancerAttributesInput = {
    LoadBalancerArn: string;
    Attributes: ELBv2$20151201$LoadBalancerAttributes;
  };
  declare type ELBv2$20151201$ModifyLoadBalancerAttributesOutput = {
    Attributes?: ELBv2$20151201$LoadBalancerAttributes;
  };
  declare type ELBv2$20151201$ModifyRuleInput = {
    RuleArn: string;
    Conditions?: ELBv2$20151201$RuleConditionList;
    Actions?: ELBv2$20151201$Actions;
  };
  declare type ELBv2$20151201$ModifyRuleOutput = {
    Rules?: ELBv2$20151201$Rules;
  };
  declare type ELBv2$20151201$ModifyTargetGroupAttributesInput = {
    TargetGroupArn: string;
    Attributes: ELBv2$20151201$TargetGroupAttributes;
  };
  declare type ELBv2$20151201$ModifyTargetGroupAttributesOutput = {
    Attributes?: ELBv2$20151201$TargetGroupAttributes;
  };
  declare type ELBv2$20151201$ModifyTargetGroupInput = {
    TargetGroupArn: string;
    HealthCheckProtocol?: 'HTTP' | 'HTTPS';
    HealthCheckPort?: string;
    HealthCheckPath?: string;
    HealthCheckIntervalSeconds?: number;
    HealthCheckTimeoutSeconds?: number;
    HealthyThresholdCount?: number;
    UnhealthyThresholdCount?: number;
    Matcher?: ELBv2$20151201$Matcher;
  };
  declare type ELBv2$20151201$ModifyTargetGroupOutput = {
    TargetGroups?: ELBv2$20151201$TargetGroups;
  };
  declare type ELBv2$20151201$OperationNotPermittedException = {};
  declare type ELBv2$20151201$PriorityInUseException = {};
  declare type ELBv2$20151201$ProtocolEnum = 'HTTP' | 'HTTPS';
  declare type ELBv2$20151201$RegisterTargetsInput = {
    TargetGroupArn: string;
    Targets: ELBv2$20151201$TargetDescriptions;
  };
  declare type ELBv2$20151201$RegisterTargetsOutput = {};
  declare type ELBv2$20151201$RemoveTagsInput = {
    ResourceArns: ELBv2$20151201$ResourceArns;
    TagKeys: ELBv2$20151201$TagKeys;
  };
  declare type ELBv2$20151201$RemoveTagsOutput = {};
  declare type ELBv2$20151201$ResourceArns = string[];
  declare type ELBv2$20151201$ResourceInUseException = {};
  declare type ELBv2$20151201$Rule = {
    RuleArn?: string;
    Priority?: string;
    Conditions?: ELBv2$20151201$RuleConditionList;
    Actions?: ELBv2$20151201$Actions;
    IsDefault?: boolean;
  };
  declare type ELBv2$20151201$RuleArns = string[];
  declare type ELBv2$20151201$RuleCondition = {
    Field?: string;
    Values?: ELBv2$20151201$ListOfString;
  };
  declare type ELBv2$20151201$RuleConditionList = ELBv2$20151201$RuleCondition[];
  declare type ELBv2$20151201$RuleNotFoundException = {};
  declare type ELBv2$20151201$RulePriorityList = ELBv2$20151201$RulePriorityPair[];
  declare type ELBv2$20151201$RulePriorityPair = {
    RuleArn?: string;
    Priority?: number;
  };
  declare type ELBv2$20151201$Rules = ELBv2$20151201$Rule[];
  declare type ELBv2$20151201$SSLPolicyNotFoundException = {};
  declare type ELBv2$20151201$SecurityGroups = string[];
  declare type ELBv2$20151201$SetRulePrioritiesInput = {
    RulePriorities: ELBv2$20151201$RulePriorityList;
  };
  declare type ELBv2$20151201$SetRulePrioritiesOutput = {
    Rules?: ELBv2$20151201$Rules;
  };
  declare type ELBv2$20151201$SetSecurityGroupsInput = {
    LoadBalancerArn: string;
    SecurityGroups: ELBv2$20151201$SecurityGroups;
  };
  declare type ELBv2$20151201$SetSecurityGroupsOutput = {
    SecurityGroupIds?: ELBv2$20151201$SecurityGroups;
  };
  declare type ELBv2$20151201$SetSubnetsInput = {
    LoadBalancerArn: string;
    Subnets: ELBv2$20151201$Subnets;
  };
  declare type ELBv2$20151201$SetSubnetsOutput = {
    AvailabilityZones?: ELBv2$20151201$AvailabilityZones;
  };
  declare type ELBv2$20151201$SslPolicies = ELBv2$20151201$SslPolicy[];
  declare type ELBv2$20151201$SslPolicy = {
    SslProtocols?: ELBv2$20151201$SslProtocols;
    Ciphers?: ELBv2$20151201$Ciphers;
    Name?: string;
  };
  declare type ELBv2$20151201$SslPolicyNames = string[];
  declare type ELBv2$20151201$SslProtocols = string[];
  declare type ELBv2$20151201$SubnetNotFoundException = {};
  declare type ELBv2$20151201$Subnets = string[];
  declare type ELBv2$20151201$Tag = {
    Key: string;
    Value?: string;
  };
  declare type ELBv2$20151201$TagDescription = {
    ResourceArn?: string;
    Tags?: ELBv2$20151201$TagList;
  };
  declare type ELBv2$20151201$TagDescriptions = ELBv2$20151201$TagDescription[];
  declare type ELBv2$20151201$TagKeys = string[];
  declare type ELBv2$20151201$TagList = ELBv2$20151201$Tag[];
  declare type ELBv2$20151201$TargetDescription = {
    Id: string;
    Port?: number;
  };
  declare type ELBv2$20151201$TargetDescriptions = ELBv2$20151201$TargetDescription[];
  declare type ELBv2$20151201$TargetGroup = {
    TargetGroupArn?: string;
    TargetGroupName?: string;
    Protocol?: 'HTTP' | 'HTTPS';
    Port?: number;
    VpcId?: string;
    HealthCheckProtocol?: 'HTTP' | 'HTTPS';
    HealthCheckPort?: string;
    HealthCheckIntervalSeconds?: number;
    HealthCheckTimeoutSeconds?: number;
    HealthyThresholdCount?: number;
    UnhealthyThresholdCount?: number;
    HealthCheckPath?: string;
    Matcher?: ELBv2$20151201$Matcher;
    LoadBalancerArns?: ELBv2$20151201$LoadBalancerArns;
  };
  declare type ELBv2$20151201$TargetGroupArns = string[];
  declare type ELBv2$20151201$TargetGroupAssociationLimitException = {};
  declare type ELBv2$20151201$TargetGroupAttribute = {
    Key?: string;
    Value?: string;
  };
  declare type ELBv2$20151201$TargetGroupAttributes = ELBv2$20151201$TargetGroupAttribute[];
  declare type ELBv2$20151201$TargetGroupNames = string[];
  declare type ELBv2$20151201$TargetGroupNotFoundException = {};
  declare type ELBv2$20151201$TargetGroups = ELBv2$20151201$TargetGroup[];
  declare type ELBv2$20151201$TargetHealth = {
    State?: 'initial' | 'healthy' | 'unhealthy' | 'unused' | 'draining';
    Reason?: 'Elb.RegistrationInProgress' | 'Elb.InitialHealthChecking' | 'Target.ResponseCodeMismatch' | 'Target.Timeout' | 'Target.FailedHealthChecks' | 'Target.NotRegistered' | 'Target.NotInUse' | 'Target.DeregistrationInProgress' | 'Target.InvalidState' | 'Elb.InternalError';
    Description?: string;
  };
  declare type ELBv2$20151201$TargetHealthDescription = {
    Target?: ELBv2$20151201$TargetDescription;
    HealthCheckPort?: string;
    TargetHealth?: ELBv2$20151201$TargetHealth;
  };
  declare type ELBv2$20151201$TargetHealthDescriptions = ELBv2$20151201$TargetHealthDescription[];
  declare type ELBv2$20151201$TargetHealthReasonEnum = 'Elb.RegistrationInProgress' | 'Elb.InitialHealthChecking' | 'Target.ResponseCodeMismatch' | 'Target.Timeout' | 'Target.FailedHealthChecks' | 'Target.NotRegistered' | 'Target.NotInUse' | 'Target.DeregistrationInProgress' | 'Target.InvalidState' | 'Elb.InternalError';
  declare type ELBv2$20151201$TargetHealthStateEnum = 'initial' | 'healthy' | 'unhealthy' | 'unused' | 'draining';
  declare type ELBv2$20151201$TooManyCertificatesException = {};
  declare type ELBv2$20151201$TooManyListenersException = {};
  declare type ELBv2$20151201$TooManyLoadBalancersException = {};
  declare type ELBv2$20151201$TooManyRegistrationsForTargetIdException = {};
  declare type ELBv2$20151201$TooManyRulesException = {};
  declare type ELBv2$20151201$TooManyTagsException = {};
  declare type ELBv2$20151201$TooManyTargetGroupsException = {};
  declare type ELBv2$20151201$TooManyTargetsException = {};
  declare type ELBv2$20151201$UnsupportedProtocolException = {};
  declare type EMR$20090331$ActionOnFailure = 'TERMINATE_JOB_FLOW' | 'TERMINATE_CLUSTER' | 'CANCEL_AND_WAIT' | 'CONTINUE';
  declare type EMR$20090331$AddInstanceGroupsInput = {
    InstanceGroups: EMR$20090331$InstanceGroupConfigList;
    JobFlowId: string;
  };
  declare type EMR$20090331$AddInstanceGroupsOutput = {
    JobFlowId?: string;
    InstanceGroupIds?: EMR$20090331$InstanceGroupIdsList;
  };
  declare type EMR$20090331$AddJobFlowStepsInput = {
    JobFlowId: string;
    Steps: EMR$20090331$StepConfigList;
  };
  declare type EMR$20090331$AddJobFlowStepsOutput = {
    StepIds?: EMR$20090331$StepIdsList;
  };
  declare type EMR$20090331$AddTagsInput = {
    ResourceId: string;
    Tags: EMR$20090331$TagList;
  };
  declare type EMR$20090331$AddTagsOutput = {};
  declare type EMR$20090331$Application = {
    Name?: string;
    Version?: string;
    Args?: EMR$20090331$StringList;
    AdditionalInfo?: {
      [key: string]: string;
    };
  };
  declare type EMR$20090331$ApplicationList = EMR$20090331$Application[];
  declare type EMR$20090331$BootstrapActionConfig = {
    Name: string;
    ScriptBootstrapAction: EMR$20090331$ScriptBootstrapActionConfig;
  };
  declare type EMR$20090331$BootstrapActionConfigList = EMR$20090331$BootstrapActionConfig[];
  declare type EMR$20090331$BootstrapActionDetail = {
    BootstrapActionConfig?: EMR$20090331$BootstrapActionConfig;
  };
  declare type EMR$20090331$BootstrapActionDetailList = EMR$20090331$BootstrapActionDetail[];
  declare type EMR$20090331$Cluster = {
    Id?: string;
    Name?: string;
    Status?: EMR$20090331$ClusterStatus;
    Ec2InstanceAttributes?: EMR$20090331$Ec2InstanceAttributes;
    LogUri?: string;
    RequestedAmiVersion?: string;
    RunningAmiVersion?: string;
    ReleaseLabel?: string;
    AutoTerminate?: boolean;
    TerminationProtected?: boolean;
    VisibleToAllUsers?: boolean;
    Applications?: EMR$20090331$ApplicationList;
    Tags?: EMR$20090331$TagList;
    ServiceRole?: string;
    NormalizedInstanceHours?: number;
    MasterPublicDnsName?: string;
    Configurations?: EMR$20090331$ConfigurationList;
  };
  declare type EMR$20090331$ClusterState = 'STARTING' | 'BOOTSTRAPPING' | 'RUNNING' | 'WAITING' | 'TERMINATING' | 'TERMINATED' | 'TERMINATED_WITH_ERRORS';
  declare type EMR$20090331$ClusterStateChangeReason = {
    Code?: 'INTERNAL_ERROR' | 'VALIDATION_ERROR' | 'INSTANCE_FAILURE' | 'BOOTSTRAP_FAILURE' | 'USER_REQUEST' | 'STEP_FAILURE' | 'ALL_STEPS_COMPLETED';
    Message?: string;
  };
  declare type EMR$20090331$ClusterStateChangeReasonCode = 'INTERNAL_ERROR' | 'VALIDATION_ERROR' | 'INSTANCE_FAILURE' | 'BOOTSTRAP_FAILURE' | 'USER_REQUEST' | 'STEP_FAILURE' | 'ALL_STEPS_COMPLETED';
  declare type EMR$20090331$ClusterStateList = ('STARTING' | 'BOOTSTRAPPING' | 'RUNNING' | 'WAITING' | 'TERMINATING' | 'TERMINATED' | 'TERMINATED_WITH_ERRORS')[];
  declare type EMR$20090331$ClusterStatus = {
    State?: 'STARTING' | 'BOOTSTRAPPING' | 'RUNNING' | 'WAITING' | 'TERMINATING' | 'TERMINATED' | 'TERMINATED_WITH_ERRORS';
    StateChangeReason?: EMR$20090331$ClusterStateChangeReason;
    Timeline?: EMR$20090331$ClusterTimeline;
  };
  declare type EMR$20090331$ClusterSummary = {
    Id?: string;
    Name?: string;
    Status?: EMR$20090331$ClusterStatus;
    NormalizedInstanceHours?: number;
  };
  declare type EMR$20090331$ClusterSummaryList = EMR$20090331$ClusterSummary[];
  declare type EMR$20090331$ClusterTimeline = {
    CreationDateTime?: Date;
    ReadyDateTime?: Date;
    EndDateTime?: Date;
  };
  declare type EMR$20090331$Command = {
    Name?: string;
    ScriptPath?: string;
    Args?: EMR$20090331$StringList;
  };
  declare type EMR$20090331$CommandList = EMR$20090331$Command[];
  declare type EMR$20090331$Configuration = {
    Classification?: string;
    Configurations?: EMR$20090331$ConfigurationList;
    Properties?: {
      [key: string]: string;
    };
  };
  declare type EMR$20090331$ConfigurationList = EMR$20090331$Configuration[];
  declare type EMR$20090331$Date = Date;
  declare type EMR$20090331$DescribeClusterInput = {
    ClusterId: string;
  };
  declare type EMR$20090331$DescribeClusterOutput = {
    Cluster?: EMR$20090331$Cluster;
  };
  declare type EMR$20090331$DescribeJobFlowsInput = {
    CreatedAfter?: Date;
    CreatedBefore?: Date;
    JobFlowIds?: EMR$20090331$XmlStringList;
    JobFlowStates?: EMR$20090331$JobFlowExecutionStateList;
  };
  declare type EMR$20090331$DescribeJobFlowsOutput = {
    JobFlows?: EMR$20090331$JobFlowDetailList;
  };
  declare type EMR$20090331$DescribeStepInput = {
    ClusterId: string;
    StepId: string;
  };
  declare type EMR$20090331$DescribeStepOutput = {
    Step?: EMR$20090331$Step;
  };
  declare type EMR$20090331$EC2InstanceIdsList = string[];
  declare type EMR$20090331$EC2InstanceIdsToTerminateList = string[];
  declare type EMR$20090331$EbsBlockDevice = {
    VolumeSpecification?: EMR$20090331$VolumeSpecification;
    Device?: string;
  };
  declare type EMR$20090331$EbsBlockDeviceConfig = {
    VolumeSpecification: EMR$20090331$VolumeSpecification;
    VolumesPerInstance?: number;
  };
  declare type EMR$20090331$EbsBlockDeviceConfigList = EMR$20090331$EbsBlockDeviceConfig[];
  declare type EMR$20090331$EbsBlockDeviceList = EMR$20090331$EbsBlockDevice[];
  declare type EMR$20090331$EbsConfiguration = {
    EbsBlockDeviceConfigs?: EMR$20090331$EbsBlockDeviceConfigList;
    EbsOptimized?: boolean;
  };
  declare type EMR$20090331$EbsVolume = {
    Device?: string;
    VolumeId?: string;
  };
  declare type EMR$20090331$EbsVolumeList = EMR$20090331$EbsVolume[];
  declare type EMR$20090331$Ec2InstanceAttributes = {
    Ec2KeyName?: string;
    Ec2SubnetId?: string;
    Ec2AvailabilityZone?: string;
    IamInstanceProfile?: string;
    EmrManagedMasterSecurityGroup?: string;
    EmrManagedSlaveSecurityGroup?: string;
    ServiceAccessSecurityGroup?: string;
    AdditionalMasterSecurityGroups?: EMR$20090331$StringList;
    AdditionalSlaveSecurityGroups?: EMR$20090331$StringList;
  };
  declare type EMR$20090331$FailureDetails = {
    Reason?: string;
    Message?: string;
    LogFile?: string;
  };
  declare type EMR$20090331$HadoopJarStepConfig = {
    Properties?: EMR$20090331$KeyValueList;
    Jar: string;
    MainClass?: string;
    Args?: EMR$20090331$XmlStringList;
  };
  declare type EMR$20090331$HadoopStepConfig = {
    Jar?: string;
    Properties?: {
      [key: string]: string;
    };
    MainClass?: string;
    Args?: EMR$20090331$StringList;
  };
  declare type EMR$20090331$Instance = {
    Id?: string;
    Ec2InstanceId?: string;
    PublicDnsName?: string;
    PublicIpAddress?: string;
    PrivateDnsName?: string;
    PrivateIpAddress?: string;
    Status?: EMR$20090331$InstanceStatus;
    InstanceGroupId?: string;
    EbsVolumes?: EMR$20090331$EbsVolumeList;
  };
  declare type EMR$20090331$InstanceGroup = {
    Id?: string;
    Name?: string;
    Market?: 'ON_DEMAND' | 'SPOT';
    InstanceGroupType?: 'MASTER' | 'CORE' | 'TASK';
    BidPrice?: string;
    InstanceType?: string;
    RequestedInstanceCount?: number;
    RunningInstanceCount?: number;
    Status?: EMR$20090331$InstanceGroupStatus;
    Configurations?: EMR$20090331$ConfigurationList;
    EbsBlockDevices?: EMR$20090331$EbsBlockDeviceList;
    EbsOptimized?: boolean;
    ShrinkPolicy?: EMR$20090331$ShrinkPolicy;
  };
  declare type EMR$20090331$InstanceGroupConfig = {
    Name?: string;
    Market?: 'ON_DEMAND' | 'SPOT';
    InstanceRole: 'MASTER' | 'CORE' | 'TASK';
    BidPrice?: string;
    InstanceType: string;
    InstanceCount: number;
    Configurations?: EMR$20090331$ConfigurationList;
    EbsConfiguration?: EMR$20090331$EbsConfiguration;
  };
  declare type EMR$20090331$InstanceGroupConfigList = EMR$20090331$InstanceGroupConfig[];
  declare type EMR$20090331$InstanceGroupDetail = {
    InstanceGroupId?: string;
    Name?: string;
    Market: 'ON_DEMAND' | 'SPOT';
    InstanceRole: 'MASTER' | 'CORE' | 'TASK';
    BidPrice?: string;
    InstanceType: string;
    InstanceRequestCount: number;
    InstanceRunningCount: number;
    State: 'PROVISIONING' | 'BOOTSTRAPPING' | 'RUNNING' | 'RESIZING' | 'SUSPENDED' | 'TERMINATING' | 'TERMINATED' | 'ARRESTED' | 'SHUTTING_DOWN' | 'ENDED';
    LastStateChangeReason?: string;
    CreationDateTime: Date;
    StartDateTime?: Date;
    ReadyDateTime?: Date;
    EndDateTime?: Date;
  };
  declare type EMR$20090331$InstanceGroupDetailList = EMR$20090331$InstanceGroupDetail[];
  declare type EMR$20090331$InstanceGroupIdsList = string[];
  declare type EMR$20090331$InstanceGroupList = EMR$20090331$InstanceGroup[];
  declare type EMR$20090331$InstanceGroupModifyConfig = {
    InstanceGroupId: string;
    InstanceCount?: number;
    EC2InstanceIdsToTerminate?: EMR$20090331$EC2InstanceIdsToTerminateList;
    ShrinkPolicy?: EMR$20090331$ShrinkPolicy;
  };
  declare type EMR$20090331$InstanceGroupModifyConfigList = EMR$20090331$InstanceGroupModifyConfig[];
  declare type EMR$20090331$InstanceGroupState = 'PROVISIONING' | 'BOOTSTRAPPING' | 'RUNNING' | 'RESIZING' | 'SUSPENDED' | 'TERMINATING' | 'TERMINATED' | 'ARRESTED' | 'SHUTTING_DOWN' | 'ENDED';
  declare type EMR$20090331$InstanceGroupStateChangeReason = {
    Code?: 'INTERNAL_ERROR' | 'VALIDATION_ERROR' | 'INSTANCE_FAILURE' | 'CLUSTER_TERMINATED';
    Message?: string;
  };
  declare type EMR$20090331$InstanceGroupStateChangeReasonCode = 'INTERNAL_ERROR' | 'VALIDATION_ERROR' | 'INSTANCE_FAILURE' | 'CLUSTER_TERMINATED';
  declare type EMR$20090331$InstanceGroupStatus = {
    State?: 'PROVISIONING' | 'BOOTSTRAPPING' | 'RUNNING' | 'RESIZING' | 'SUSPENDED' | 'TERMINATING' | 'TERMINATED' | 'ARRESTED' | 'SHUTTING_DOWN' | 'ENDED';
    StateChangeReason?: EMR$20090331$InstanceGroupStateChangeReason;
    Timeline?: EMR$20090331$InstanceGroupTimeline;
  };
  declare type EMR$20090331$InstanceGroupTimeline = {
    CreationDateTime?: Date;
    ReadyDateTime?: Date;
    EndDateTime?: Date;
  };
  declare type EMR$20090331$InstanceGroupType = 'MASTER' | 'CORE' | 'TASK';
  declare type EMR$20090331$InstanceGroupTypeList = ('MASTER' | 'CORE' | 'TASK')[];
  declare type EMR$20090331$InstanceList = EMR$20090331$Instance[];
  declare type EMR$20090331$InstanceResizePolicy = {
    InstancesToTerminate?: EMR$20090331$EC2InstanceIdsList;
    InstancesToProtect?: EMR$20090331$EC2InstanceIdsList;
    InstanceTerminationTimeout?: number;
  };
  declare type EMR$20090331$InstanceRoleType = 'MASTER' | 'CORE' | 'TASK';
  declare type EMR$20090331$InstanceState = 'AWAITING_FULFILLMENT' | 'PROVISIONING' | 'BOOTSTRAPPING' | 'RUNNING' | 'TERMINATED';
  declare type EMR$20090331$InstanceStateChangeReason = {
    Code?: 'INTERNAL_ERROR' | 'VALIDATION_ERROR' | 'INSTANCE_FAILURE' | 'BOOTSTRAP_FAILURE' | 'CLUSTER_TERMINATED';
    Message?: string;
  };
  declare type EMR$20090331$InstanceStateChangeReasonCode = 'INTERNAL_ERROR' | 'VALIDATION_ERROR' | 'INSTANCE_FAILURE' | 'BOOTSTRAP_FAILURE' | 'CLUSTER_TERMINATED';
  declare type EMR$20090331$InstanceStateList = ('AWAITING_FULFILLMENT' | 'PROVISIONING' | 'BOOTSTRAPPING' | 'RUNNING' | 'TERMINATED')[];
  declare type EMR$20090331$InstanceStatus = {
    State?: 'AWAITING_FULFILLMENT' | 'PROVISIONING' | 'BOOTSTRAPPING' | 'RUNNING' | 'TERMINATED';
    StateChangeReason?: EMR$20090331$InstanceStateChangeReason;
    Timeline?: EMR$20090331$InstanceTimeline;
  };
  declare type EMR$20090331$InstanceTimeline = {
    CreationDateTime?: Date;
    ReadyDateTime?: Date;
    EndDateTime?: Date;
  };
  declare type EMR$20090331$InternalServerError = {};
  declare type EMR$20090331$InternalServerException = {
    Message?: string;
  };
  declare type EMR$20090331$InvalidRequestException = {
    ErrorCode?: string;
    Message?: string;
  };
  declare type EMR$20090331$JobFlowDetail = {
    JobFlowId: string;
    Name: string;
    LogUri?: string;
    AmiVersion?: string;
    ExecutionStatusDetail: EMR$20090331$JobFlowExecutionStatusDetail;
    Instances: EMR$20090331$JobFlowInstancesDetail;
    Steps?: EMR$20090331$StepDetailList;
    BootstrapActions?: EMR$20090331$BootstrapActionDetailList;
    SupportedProducts?: EMR$20090331$SupportedProductsList;
    VisibleToAllUsers?: boolean;
    JobFlowRole?: string;
    ServiceRole?: string;
  };
  declare type EMR$20090331$JobFlowDetailList = EMR$20090331$JobFlowDetail[];
  declare type EMR$20090331$JobFlowExecutionState = 'STARTING' | 'BOOTSTRAPPING' | 'RUNNING' | 'WAITING' | 'SHUTTING_DOWN' | 'TERMINATED' | 'COMPLETED' | 'FAILED';
  declare type EMR$20090331$JobFlowExecutionStateList = ('STARTING' | 'BOOTSTRAPPING' | 'RUNNING' | 'WAITING' | 'SHUTTING_DOWN' | 'TERMINATED' | 'COMPLETED' | 'FAILED')[];
  declare type EMR$20090331$JobFlowExecutionStatusDetail = {
    State: 'STARTING' | 'BOOTSTRAPPING' | 'RUNNING' | 'WAITING' | 'SHUTTING_DOWN' | 'TERMINATED' | 'COMPLETED' | 'FAILED';
    CreationDateTime: Date;
    StartDateTime?: Date;
    ReadyDateTime?: Date;
    EndDateTime?: Date;
    LastStateChangeReason?: string;
  };
  declare type EMR$20090331$JobFlowInstancesConfig = {
    MasterInstanceType?: string;
    SlaveInstanceType?: string;
    InstanceCount?: number;
    InstanceGroups?: EMR$20090331$InstanceGroupConfigList;
    Ec2KeyName?: string;
    Placement?: EMR$20090331$PlacementType;
    KeepJobFlowAliveWhenNoSteps?: boolean;
    TerminationProtected?: boolean;
    HadoopVersion?: string;
    Ec2SubnetId?: string;
    EmrManagedMasterSecurityGroup?: string;
    EmrManagedSlaveSecurityGroup?: string;
    ServiceAccessSecurityGroup?: string;
    AdditionalMasterSecurityGroups?: EMR$20090331$SecurityGroupsList;
    AdditionalSlaveSecurityGroups?: EMR$20090331$SecurityGroupsList;
  };
  declare type EMR$20090331$JobFlowInstancesDetail = {
    MasterInstanceType: string;
    MasterPublicDnsName?: string;
    MasterInstanceId?: string;
    SlaveInstanceType: string;
    InstanceCount: number;
    InstanceGroups?: EMR$20090331$InstanceGroupDetailList;
    NormalizedInstanceHours?: number;
    Ec2KeyName?: string;
    Ec2SubnetId?: string;
    Placement?: EMR$20090331$PlacementType;
    KeepJobFlowAliveWhenNoSteps?: boolean;
    TerminationProtected?: boolean;
    HadoopVersion?: string;
  };
  declare type EMR$20090331$KeyValue = {
    Key?: string;
    Value?: string;
  };
  declare type EMR$20090331$KeyValueList = EMR$20090331$KeyValue[];
  declare type EMR$20090331$ListBootstrapActionsInput = {
    ClusterId: string;
    Marker?: string;
  };
  declare type EMR$20090331$ListBootstrapActionsOutput = {
    BootstrapActions?: EMR$20090331$CommandList;
    Marker?: string;
  };
  declare type EMR$20090331$ListClustersInput = {
    CreatedAfter?: Date;
    CreatedBefore?: Date;
    ClusterStates?: EMR$20090331$ClusterStateList;
    Marker?: string;
  };
  declare type EMR$20090331$ListClustersOutput = {
    Clusters?: EMR$20090331$ClusterSummaryList;
    Marker?: string;
  };
  declare type EMR$20090331$ListInstanceGroupsInput = {
    ClusterId: string;
    Marker?: string;
  };
  declare type EMR$20090331$ListInstanceGroupsOutput = {
    InstanceGroups?: EMR$20090331$InstanceGroupList;
    Marker?: string;
  };
  declare type EMR$20090331$ListInstancesInput = {
    ClusterId: string;
    InstanceGroupId?: string;
    InstanceGroupTypes?: EMR$20090331$InstanceGroupTypeList;
    InstanceStates?: EMR$20090331$InstanceStateList;
    Marker?: string;
  };
  declare type EMR$20090331$ListInstancesOutput = {
    Instances?: EMR$20090331$InstanceList;
    Marker?: string;
  };
  declare type EMR$20090331$ListStepsInput = {
    ClusterId: string;
    StepStates?: EMR$20090331$StepStateList;
    StepIds?: EMR$20090331$XmlStringList;
    Marker?: string;
  };
  declare type EMR$20090331$ListStepsOutput = {
    Steps?: EMR$20090331$StepSummaryList;
    Marker?: string;
  };
  declare type EMR$20090331$MarketType = 'ON_DEMAND' | 'SPOT';
  declare type EMR$20090331$ModifyInstanceGroupsInput = {
    InstanceGroups?: EMR$20090331$InstanceGroupModifyConfigList;
  };
  declare type EMR$20090331$NewSupportedProductsList = EMR$20090331$SupportedProductConfig[];
  declare type EMR$20090331$PlacementType = {
    AvailabilityZone: string;
  };
  declare type EMR$20090331$RemoveTagsInput = {
    ResourceId: string;
    TagKeys: EMR$20090331$StringList;
  };
  declare type EMR$20090331$RemoveTagsOutput = {};
  declare type EMR$20090331$RunJobFlowInput = {
    Name: string;
    LogUri?: string;
    AdditionalInfo?: string;
    AmiVersion?: string;
    ReleaseLabel?: string;
    Instances: EMR$20090331$JobFlowInstancesConfig;
    Steps?: EMR$20090331$StepConfigList;
    BootstrapActions?: EMR$20090331$BootstrapActionConfigList;
    SupportedProducts?: EMR$20090331$SupportedProductsList;
    NewSupportedProducts?: EMR$20090331$NewSupportedProductsList;
    Applications?: EMR$20090331$ApplicationList;
    Configurations?: EMR$20090331$ConfigurationList;
    VisibleToAllUsers?: boolean;
    JobFlowRole?: string;
    ServiceRole?: string;
    Tags?: EMR$20090331$TagList;
  };
  declare type EMR$20090331$RunJobFlowOutput = {
    JobFlowId?: string;
  };
  declare type EMR$20090331$ScriptBootstrapActionConfig = {
    Path: string;
    Args?: EMR$20090331$XmlStringList;
  };
  declare type EMR$20090331$SecurityGroupsList = string[];
  declare type EMR$20090331$SetTerminationProtectionInput = {
    JobFlowIds: EMR$20090331$XmlStringList;
    TerminationProtected: boolean;
  };
  declare type EMR$20090331$SetVisibleToAllUsersInput = {
    JobFlowIds: EMR$20090331$XmlStringList;
    VisibleToAllUsers: boolean;
  };
  declare type EMR$20090331$ShrinkPolicy = {
    DecommissionTimeout?: number;
    InstanceResizePolicy?: EMR$20090331$InstanceResizePolicy;
  };
  declare type EMR$20090331$Step = {
    Id?: string;
    Name?: string;
    Config?: EMR$20090331$HadoopStepConfig;
    ActionOnFailure?: 'TERMINATE_JOB_FLOW' | 'TERMINATE_CLUSTER' | 'CANCEL_AND_WAIT' | 'CONTINUE';
    Status?: EMR$20090331$StepStatus;
  };
  declare type EMR$20090331$StepConfig = {
    Name: string;
    ActionOnFailure?: 'TERMINATE_JOB_FLOW' | 'TERMINATE_CLUSTER' | 'CANCEL_AND_WAIT' | 'CONTINUE';
    HadoopJarStep: EMR$20090331$HadoopJarStepConfig;
  };
  declare type EMR$20090331$StepConfigList = EMR$20090331$StepConfig[];
  declare type EMR$20090331$StepDetail = {
    StepConfig: EMR$20090331$StepConfig;
    ExecutionStatusDetail: EMR$20090331$StepExecutionStatusDetail;
  };
  declare type EMR$20090331$StepDetailList = EMR$20090331$StepDetail[];
  declare type EMR$20090331$StepExecutionState = 'PENDING' | 'RUNNING' | 'CONTINUE' | 'COMPLETED' | 'CANCELLED' | 'FAILED' | 'INTERRUPTED';
  declare type EMR$20090331$StepExecutionStatusDetail = {
    State: 'PENDING' | 'RUNNING' | 'CONTINUE' | 'COMPLETED' | 'CANCELLED' | 'FAILED' | 'INTERRUPTED';
    CreationDateTime: Date;
    StartDateTime?: Date;
    EndDateTime?: Date;
    LastStateChangeReason?: string;
  };
  declare type EMR$20090331$StepIdsList = string[];
  declare type EMR$20090331$StepState = 'PENDING' | 'RUNNING' | 'COMPLETED' | 'CANCELLED' | 'FAILED' | 'INTERRUPTED';
  declare type EMR$20090331$StepStateChangeReason = {
    Code?: 'NONE';
    Message?: string;
  };
  declare type EMR$20090331$StepStateChangeReasonCode = 'NONE';
  declare type EMR$20090331$StepStateList = ('PENDING' | 'RUNNING' | 'COMPLETED' | 'CANCELLED' | 'FAILED' | 'INTERRUPTED')[];
  declare type EMR$20090331$StepStatus = {
    State?: 'PENDING' | 'RUNNING' | 'COMPLETED' | 'CANCELLED' | 'FAILED' | 'INTERRUPTED';
    StateChangeReason?: EMR$20090331$StepStateChangeReason;
    FailureDetails?: EMR$20090331$FailureDetails;
    Timeline?: EMR$20090331$StepTimeline;
  };
  declare type EMR$20090331$StepSummary = {
    Id?: string;
    Name?: string;
    Config?: EMR$20090331$HadoopStepConfig;
    ActionOnFailure?: 'TERMINATE_JOB_FLOW' | 'TERMINATE_CLUSTER' | 'CANCEL_AND_WAIT' | 'CONTINUE';
    Status?: EMR$20090331$StepStatus;
  };
  declare type EMR$20090331$StepSummaryList = EMR$20090331$StepSummary[];
  declare type EMR$20090331$StepTimeline = {
    CreationDateTime?: Date;
    StartDateTime?: Date;
    EndDateTime?: Date;
  };
  declare type EMR$20090331$StringList = string[];
  declare type EMR$20090331$StringMap = {
    [key: string]: string;
  };
  declare type EMR$20090331$SupportedProductConfig = {
    Name?: string;
    Args?: EMR$20090331$XmlStringList;
  };
  declare type EMR$20090331$SupportedProductsList = string[];
  declare type EMR$20090331$Tag = {
    Key?: string;
    Value?: string;
  };
  declare type EMR$20090331$TagList = EMR$20090331$Tag[];
  declare type EMR$20090331$TerminateJobFlowsInput = {
    JobFlowIds: EMR$20090331$XmlStringList;
  };
  declare type EMR$20090331$VolumeSpecification = {
    VolumeType: string;
    Iops?: number;
    SizeInGB: number;
  };
  declare type EMR$20090331$XmlStringList = string[];
  declare type ES$20150101$AccessPoliciesStatus = {
    Options: string;
    Status: ES$20150101$OptionStatus;
  };
  declare type ES$20150101$AddTagsRequest = {
    ARN: string;
    TagList: ES$20150101$TagList;
  };
  declare type ES$20150101$AdvancedOptions = {
    [key: string]: string;
  };
  declare type ES$20150101$AdvancedOptionsStatus = {
    Options: {
      [key: string]: string;
    };
    Status: ES$20150101$OptionStatus;
  };
  declare type ES$20150101$BaseException = {
    message?: string;
  };
  declare type ES$20150101$CreateElasticsearchDomainRequest = {
    DomainName: string;
    ElasticsearchVersion?: string;
    ElasticsearchClusterConfig?: ES$20150101$ElasticsearchClusterConfig;
    EBSOptions?: ES$20150101$EBSOptions;
    AccessPolicies?: string;
    SnapshotOptions?: ES$20150101$SnapshotOptions;
    AdvancedOptions?: {
      [key: string]: string;
    };
  };
  declare type ES$20150101$CreateElasticsearchDomainResponse = {
    DomainStatus?: ES$20150101$ElasticsearchDomainStatus;
  };
  declare type ES$20150101$DeleteElasticsearchDomainRequest = {
    DomainName: string;
  };
  declare type ES$20150101$DeleteElasticsearchDomainResponse = {
    DomainStatus?: ES$20150101$ElasticsearchDomainStatus;
  };
  declare type ES$20150101$DescribeElasticsearchDomainConfigRequest = {
    DomainName: string;
  };
  declare type ES$20150101$DescribeElasticsearchDomainConfigResponse = {
    DomainConfig: ES$20150101$ElasticsearchDomainConfig;
  };
  declare type ES$20150101$DescribeElasticsearchDomainRequest = {
    DomainName: string;
  };
  declare type ES$20150101$DescribeElasticsearchDomainResponse = {
    DomainStatus: ES$20150101$ElasticsearchDomainStatus;
  };
  declare type ES$20150101$DescribeElasticsearchDomainsRequest = {
    DomainNames: ES$20150101$DomainNameList;
  };
  declare type ES$20150101$DescribeElasticsearchDomainsResponse = {
    DomainStatusList: ES$20150101$ElasticsearchDomainStatusList;
  };
  declare type ES$20150101$DisabledOperationException = {};
  declare type ES$20150101$DomainInfo = {
    DomainName?: string;
  };
  declare type ES$20150101$DomainInfoList = ES$20150101$DomainInfo[];
  declare type ES$20150101$DomainNameList = string[];
  declare type ES$20150101$EBSOptions = {
    EBSEnabled?: boolean;
    VolumeType?: 'standard' | 'gp2' | 'io1';
    VolumeSize?: number;
    Iops?: number;
  };
  declare type ES$20150101$EBSOptionsStatus = {
    Options: ES$20150101$EBSOptions;
    Status: ES$20150101$OptionStatus;
  };
  declare type ES$20150101$ESPartitionInstanceType = 'm3.medium.elasticsearch' | 'm3.large.elasticsearch' | 'm3.xlarge.elasticsearch' | 'm3.2xlarge.elasticsearch' | 'm4.large.elasticsearch' | 'm4.xlarge.elasticsearch' | 'm4.2xlarge.elasticsearch' | 'm4.4xlarge.elasticsearch' | 'm4.10xlarge.elasticsearch' | 't2.micro.elasticsearch' | 't2.small.elasticsearch' | 't2.medium.elasticsearch' | 'r3.large.elasticsearch' | 'r3.xlarge.elasticsearch' | 'r3.2xlarge.elasticsearch' | 'r3.4xlarge.elasticsearch' | 'r3.8xlarge.elasticsearch' | 'i2.xlarge.elasticsearch' | 'i2.2xlarge.elasticsearch';
  declare type ES$20150101$ElasticsearchClusterConfig = {
    InstanceType?: 'm3.medium.elasticsearch' | 'm3.large.elasticsearch' | 'm3.xlarge.elasticsearch' | 'm3.2xlarge.elasticsearch' | 'm4.large.elasticsearch' | 'm4.xlarge.elasticsearch' | 'm4.2xlarge.elasticsearch' | 'm4.4xlarge.elasticsearch' | 'm4.10xlarge.elasticsearch' | 't2.micro.elasticsearch' | 't2.small.elasticsearch' | 't2.medium.elasticsearch' | 'r3.large.elasticsearch' | 'r3.xlarge.elasticsearch' | 'r3.2xlarge.elasticsearch' | 'r3.4xlarge.elasticsearch' | 'r3.8xlarge.elasticsearch' | 'i2.xlarge.elasticsearch' | 'i2.2xlarge.elasticsearch';
    InstanceCount?: number;
    DedicatedMasterEnabled?: boolean;
    ZoneAwarenessEnabled?: boolean;
    DedicatedMasterType?: 'm3.medium.elasticsearch' | 'm3.large.elasticsearch' | 'm3.xlarge.elasticsearch' | 'm3.2xlarge.elasticsearch' | 'm4.large.elasticsearch' | 'm4.xlarge.elasticsearch' | 'm4.2xlarge.elasticsearch' | 'm4.4xlarge.elasticsearch' | 'm4.10xlarge.elasticsearch' | 't2.micro.elasticsearch' | 't2.small.elasticsearch' | 't2.medium.elasticsearch' | 'r3.large.elasticsearch' | 'r3.xlarge.elasticsearch' | 'r3.2xlarge.elasticsearch' | 'r3.4xlarge.elasticsearch' | 'r3.8xlarge.elasticsearch' | 'i2.xlarge.elasticsearch' | 'i2.2xlarge.elasticsearch';
    DedicatedMasterCount?: number;
  };
  declare type ES$20150101$ElasticsearchClusterConfigStatus = {
    Options: ES$20150101$ElasticsearchClusterConfig;
    Status: ES$20150101$OptionStatus;
  };
  declare type ES$20150101$ElasticsearchDomainConfig = {
    ElasticsearchVersion?: ES$20150101$ElasticsearchVersionStatus;
    ElasticsearchClusterConfig?: ES$20150101$ElasticsearchClusterConfigStatus;
    EBSOptions?: ES$20150101$EBSOptionsStatus;
    AccessPolicies?: ES$20150101$AccessPoliciesStatus;
    SnapshotOptions?: ES$20150101$SnapshotOptionsStatus;
    AdvancedOptions?: ES$20150101$AdvancedOptionsStatus;
  };
  declare type ES$20150101$ElasticsearchDomainStatus = {
    DomainId: string;
    DomainName: string;
    ARN: string;
    Created?: boolean;
    Deleted?: boolean;
    Endpoint?: string;
    Processing?: boolean;
    ElasticsearchVersion?: string;
    ElasticsearchClusterConfig: ES$20150101$ElasticsearchClusterConfig;
    EBSOptions?: ES$20150101$EBSOptions;
    AccessPolicies?: string;
    SnapshotOptions?: ES$20150101$SnapshotOptions;
    AdvancedOptions?: {
      [key: string]: string;
    };
  };
  declare type ES$20150101$ElasticsearchDomainStatusList = ES$20150101$ElasticsearchDomainStatus[];
  declare type ES$20150101$ElasticsearchVersionStatus = {
    Options: string;
    Status: ES$20150101$OptionStatus;
  };
  declare type ES$20150101$InternalException = {};
  declare type ES$20150101$InvalidTypeException = {};
  declare type ES$20150101$LimitExceededException = {};
  declare type ES$20150101$ListDomainNamesResponse = {
    DomainNames?: ES$20150101$DomainInfoList;
  };
  declare type ES$20150101$ListTagsRequest = {
    ARN: string;
  };
  declare type ES$20150101$ListTagsResponse = {
    TagList?: ES$20150101$TagList;
  };
  declare type ES$20150101$OptionState = 'RequiresIndexDocuments' | 'Processing' | 'Active';
  declare type ES$20150101$OptionStatus = {
    CreationDate: Date;
    UpdateDate: Date;
    UpdateVersion?: number;
    State: 'RequiresIndexDocuments' | 'Processing' | 'Active';
    PendingDeletion?: boolean;
  };
  declare type ES$20150101$RemoveTagsRequest = {
    ARN: string;
    TagKeys: ES$20150101$StringList;
  };
  declare type ES$20150101$ResourceAlreadyExistsException = {};
  declare type ES$20150101$ResourceNotFoundException = {};
  declare type ES$20150101$SnapshotOptions = {
    AutomatedSnapshotStartHour?: number;
  };
  declare type ES$20150101$SnapshotOptionsStatus = {
    Options: ES$20150101$SnapshotOptions;
    Status: ES$20150101$OptionStatus;
  };
  declare type ES$20150101$StringList = string[];
  declare type ES$20150101$Tag = {
    Key: string;
    Value: string;
  };
  declare type ES$20150101$TagList = ES$20150101$Tag[];
  declare type ES$20150101$UpdateElasticsearchDomainConfigRequest = {
    DomainName: string;
    ElasticsearchClusterConfig?: ES$20150101$ElasticsearchClusterConfig;
    EBSOptions?: ES$20150101$EBSOptions;
    SnapshotOptions?: ES$20150101$SnapshotOptions;
    AdvancedOptions?: {
      [key: string]: string;
    };
    AccessPolicies?: string;
  };
  declare type ES$20150101$UpdateElasticsearchDomainConfigResponse = {
    DomainConfig: ES$20150101$ElasticsearchDomainConfig;
  };
  declare type ES$20150101$UpdateTimestamp = Date;
  declare type ES$20150101$ValidationException = {};
  declare type ES$20150101$VolumeType = 'standard' | 'gp2' | 'io1';
  declare type ElasticTranscoder$20120925$AccessControls = string[];
  declare type ElasticTranscoder$20120925$AccessDeniedException = {};
  declare type ElasticTranscoder$20120925$Artwork = {
    InputKey?: string;
    MaxWidth?: string;
    MaxHeight?: string;
    SizingPolicy?: string;
    PaddingPolicy?: string;
    AlbumArtFormat?: string;
    Encryption?: ElasticTranscoder$20120925$Encryption;
  };
  declare type ElasticTranscoder$20120925$Artworks = ElasticTranscoder$20120925$Artwork[];
  declare type ElasticTranscoder$20120925$AudioCodecOptions = {
    Profile?: string;
    BitDepth?: string;
    BitOrder?: string;
    Signed?: string;
  };
  declare type ElasticTranscoder$20120925$AudioParameters = {
    Codec?: string;
    SampleRate?: string;
    BitRate?: string;
    Channels?: string;
    AudioPackingMode?: string;
    CodecOptions?: ElasticTranscoder$20120925$AudioCodecOptions;
  };
  declare type ElasticTranscoder$20120925$CancelJobRequest = {
    Id: string;
  };
  declare type ElasticTranscoder$20120925$CancelJobResponse = {};
  declare type ElasticTranscoder$20120925$CaptionFormat = {
    Format?: string;
    Pattern?: string;
    Encryption?: ElasticTranscoder$20120925$Encryption;
  };
  declare type ElasticTranscoder$20120925$CaptionFormats = ElasticTranscoder$20120925$CaptionFormat[];
  declare type ElasticTranscoder$20120925$CaptionSource = {
    Key?: string;
    Language?: string;
    TimeOffset?: string;
    Label?: string;
    Encryption?: ElasticTranscoder$20120925$Encryption;
  };
  declare type ElasticTranscoder$20120925$CaptionSources = ElasticTranscoder$20120925$CaptionSource[];
  declare type ElasticTranscoder$20120925$Captions = {
    MergePolicy?: string;
    CaptionSources?: ElasticTranscoder$20120925$CaptionSources;
    CaptionFormats?: ElasticTranscoder$20120925$CaptionFormats;
  };
  declare type ElasticTranscoder$20120925$Clip = {
    TimeSpan?: ElasticTranscoder$20120925$TimeSpan;
  };
  declare type ElasticTranscoder$20120925$CodecOptions = {
    [key: string]: string;
  };
  declare type ElasticTranscoder$20120925$Composition = ElasticTranscoder$20120925$Clip[];
  declare type ElasticTranscoder$20120925$CreateJobOutput = {
    Key?: string;
    ThumbnailPattern?: string;
    ThumbnailEncryption?: ElasticTranscoder$20120925$Encryption;
    Rotate?: string;
    PresetId?: string;
    SegmentDuration?: string;
    Watermarks?: ElasticTranscoder$20120925$JobWatermarks;
    AlbumArt?: ElasticTranscoder$20120925$JobAlbumArt;
    Composition?: ElasticTranscoder$20120925$Composition;
    Captions?: ElasticTranscoder$20120925$Captions;
    Encryption?: ElasticTranscoder$20120925$Encryption;
  };
  declare type ElasticTranscoder$20120925$CreateJobOutputs = ElasticTranscoder$20120925$CreateJobOutput[];
  declare type ElasticTranscoder$20120925$CreateJobPlaylist = {
    Name?: string;
    Format?: string;
    OutputKeys?: ElasticTranscoder$20120925$OutputKeys;
    HlsContentProtection?: ElasticTranscoder$20120925$HlsContentProtection;
    PlayReadyDrm?: ElasticTranscoder$20120925$PlayReadyDrm;
  };
  declare type ElasticTranscoder$20120925$CreateJobPlaylists = ElasticTranscoder$20120925$CreateJobPlaylist[];
  declare type ElasticTranscoder$20120925$CreateJobRequest = {
    PipelineId: string;
    Input: ElasticTranscoder$20120925$JobInput;
    Output?: ElasticTranscoder$20120925$CreateJobOutput;
    Outputs?: ElasticTranscoder$20120925$CreateJobOutputs;
    OutputKeyPrefix?: string;
    Playlists?: ElasticTranscoder$20120925$CreateJobPlaylists;
    UserMetadata?: {
      [key: string]: string;
    };
  };
  declare type ElasticTranscoder$20120925$CreateJobResponse = {
    Job?: ElasticTranscoder$20120925$Job;
  };
  declare type ElasticTranscoder$20120925$CreatePipelineRequest = {
    Name: string;
    InputBucket: string;
    OutputBucket?: string;
    Role: string;
    AwsKmsKeyArn?: string;
    Notifications?: ElasticTranscoder$20120925$Notifications;
    ContentConfig?: ElasticTranscoder$20120925$PipelineOutputConfig;
    ThumbnailConfig?: ElasticTranscoder$20120925$PipelineOutputConfig;
  };
  declare type ElasticTranscoder$20120925$CreatePipelineResponse = {
    Pipeline?: ElasticTranscoder$20120925$Pipeline;
    Warnings?: ElasticTranscoder$20120925$Warnings;
  };
  declare type ElasticTranscoder$20120925$CreatePresetRequest = {
    Name: string;
    Description?: string;
    Container: string;
    Video?: ElasticTranscoder$20120925$VideoParameters;
    Audio?: ElasticTranscoder$20120925$AudioParameters;
    Thumbnails?: ElasticTranscoder$20120925$Thumbnails;
  };
  declare type ElasticTranscoder$20120925$CreatePresetResponse = {
    Preset?: ElasticTranscoder$20120925$Preset;
    Warning?: string;
  };
  declare type ElasticTranscoder$20120925$DeletePipelineRequest = {
    Id: string;
  };
  declare type ElasticTranscoder$20120925$DeletePipelineResponse = {};
  declare type ElasticTranscoder$20120925$DeletePresetRequest = {
    Id: string;
  };
  declare type ElasticTranscoder$20120925$DeletePresetResponse = {};
  declare type ElasticTranscoder$20120925$DetectedProperties = {
    Width?: number;
    Height?: number;
    FrameRate?: string;
    FileSize?: number;
    DurationMillis?: number;
  };
  declare type ElasticTranscoder$20120925$Encryption = {
    Mode?: string;
    Key?: string;
    KeyMd5?: string;
    InitializationVector?: string;
  };
  declare type ElasticTranscoder$20120925$ExceptionMessages = string[];
  declare type ElasticTranscoder$20120925$HlsContentProtection = {
    Method?: string;
    Key?: string;
    KeyMd5?: string;
    InitializationVector?: string;
    LicenseAcquisitionUrl?: string;
    KeyStoragePolicy?: string;
  };
  declare type ElasticTranscoder$20120925$IncompatibleVersionException = {};
  declare type ElasticTranscoder$20120925$InternalServiceException = {};
  declare type ElasticTranscoder$20120925$Job = {
    Id?: string;
    Arn?: string;
    PipelineId?: string;
    Input?: ElasticTranscoder$20120925$JobInput;
    Output?: ElasticTranscoder$20120925$JobOutput;
    Outputs?: ElasticTranscoder$20120925$JobOutputs;
    OutputKeyPrefix?: string;
    Playlists?: ElasticTranscoder$20120925$Playlists;
    Status?: string;
    UserMetadata?: {
      [key: string]: string;
    };
    Timing?: ElasticTranscoder$20120925$Timing;
  };
  declare type ElasticTranscoder$20120925$JobAlbumArt = {
    MergePolicy?: string;
    Artwork?: ElasticTranscoder$20120925$Artworks;
  };
  declare type ElasticTranscoder$20120925$JobInput = {
    Key?: string;
    FrameRate?: string;
    Resolution?: string;
    AspectRatio?: string;
    Interlaced?: string;
    Container?: string;
    Encryption?: ElasticTranscoder$20120925$Encryption;
    DetectedProperties?: ElasticTranscoder$20120925$DetectedProperties;
  };
  declare type ElasticTranscoder$20120925$JobOutput = {
    Id?: string;
    Key?: string;
    ThumbnailPattern?: string;
    ThumbnailEncryption?: ElasticTranscoder$20120925$Encryption;
    Rotate?: string;
    PresetId?: string;
    SegmentDuration?: string;
    Status?: string;
    StatusDetail?: string;
    Duration?: number;
    Width?: number;
    Height?: number;
    FrameRate?: string;
    FileSize?: number;
    DurationMillis?: number;
    Watermarks?: ElasticTranscoder$20120925$JobWatermarks;
    AlbumArt?: ElasticTranscoder$20120925$JobAlbumArt;
    Composition?: ElasticTranscoder$20120925$Composition;
    Captions?: ElasticTranscoder$20120925$Captions;
    Encryption?: ElasticTranscoder$20120925$Encryption;
    AppliedColorSpaceConversion?: string;
  };
  declare type ElasticTranscoder$20120925$JobOutputs = ElasticTranscoder$20120925$JobOutput[];
  declare type ElasticTranscoder$20120925$JobWatermark = {
    PresetWatermarkId?: string;
    InputKey?: string;
    Encryption?: ElasticTranscoder$20120925$Encryption;
  };
  declare type ElasticTranscoder$20120925$JobWatermarks = ElasticTranscoder$20120925$JobWatermark[];
  declare type ElasticTranscoder$20120925$Jobs = ElasticTranscoder$20120925$Job[];
  declare type ElasticTranscoder$20120925$LimitExceededException = {};
  declare type ElasticTranscoder$20120925$ListJobsByPipelineRequest = {
    PipelineId: string;
    Ascending?: string;
    PageToken?: string;
  };
  declare type ElasticTranscoder$20120925$ListJobsByPipelineResponse = {
    Jobs?: ElasticTranscoder$20120925$Jobs;
    NextPageToken?: string;
  };
  declare type ElasticTranscoder$20120925$ListJobsByStatusRequest = {
    Status: string;
    Ascending?: string;
    PageToken?: string;
  };
  declare type ElasticTranscoder$20120925$ListJobsByStatusResponse = {
    Jobs?: ElasticTranscoder$20120925$Jobs;
    NextPageToken?: string;
  };
  declare type ElasticTranscoder$20120925$ListPipelinesRequest = {
    Ascending?: string;
    PageToken?: string;
  };
  declare type ElasticTranscoder$20120925$ListPipelinesResponse = {
    Pipelines?: ElasticTranscoder$20120925$Pipelines;
    NextPageToken?: string;
  };
  declare type ElasticTranscoder$20120925$ListPresetsRequest = {
    Ascending?: string;
    PageToken?: string;
  };
  declare type ElasticTranscoder$20120925$ListPresetsResponse = {
    Presets?: ElasticTranscoder$20120925$Presets;
    NextPageToken?: string;
  };
  declare type ElasticTranscoder$20120925$Notifications = {
    Progressing?: string;
    Completed?: string;
    Warning?: string;
    Error?: string;
  };
  declare type ElasticTranscoder$20120925$OutputKeys = string[];
  declare type ElasticTranscoder$20120925$Permission = {
    GranteeType?: string;
    Grantee?: string;
    Access?: ElasticTranscoder$20120925$AccessControls;
  };
  declare type ElasticTranscoder$20120925$Permissions = ElasticTranscoder$20120925$Permission[];
  declare type ElasticTranscoder$20120925$Pipeline = {
    Id?: string;
    Arn?: string;
    Name?: string;
    Status?: string;
    InputBucket?: string;
    OutputBucket?: string;
    Role?: string;
    AwsKmsKeyArn?: string;
    Notifications?: ElasticTranscoder$20120925$Notifications;
    ContentConfig?: ElasticTranscoder$20120925$PipelineOutputConfig;
    ThumbnailConfig?: ElasticTranscoder$20120925$PipelineOutputConfig;
  };
  declare type ElasticTranscoder$20120925$PipelineOutputConfig = {
    Bucket?: string;
    StorageClass?: string;
    Permissions?: ElasticTranscoder$20120925$Permissions;
  };
  declare type ElasticTranscoder$20120925$Pipelines = ElasticTranscoder$20120925$Pipeline[];
  declare type ElasticTranscoder$20120925$PlayReadyDrm = {
    Format?: string;
    Key?: string;
    KeyMd5?: string;
    KeyId?: string;
    InitializationVector?: string;
    LicenseAcquisitionUrl?: string;
  };
  declare type ElasticTranscoder$20120925$Playlist = {
    Name?: string;
    Format?: string;
    OutputKeys?: ElasticTranscoder$20120925$OutputKeys;
    HlsContentProtection?: ElasticTranscoder$20120925$HlsContentProtection;
    PlayReadyDrm?: ElasticTranscoder$20120925$PlayReadyDrm;
    Status?: string;
    StatusDetail?: string;
  };
  declare type ElasticTranscoder$20120925$Playlists = ElasticTranscoder$20120925$Playlist[];
  declare type ElasticTranscoder$20120925$Preset = {
    Id?: string;
    Arn?: string;
    Name?: string;
    Description?: string;
    Container?: string;
    Audio?: ElasticTranscoder$20120925$AudioParameters;
    Video?: ElasticTranscoder$20120925$VideoParameters;
    Thumbnails?: ElasticTranscoder$20120925$Thumbnails;
    Type?: string;
  };
  declare type ElasticTranscoder$20120925$PresetWatermark = {
    Id?: string;
    MaxWidth?: string;
    MaxHeight?: string;
    SizingPolicy?: string;
    HorizontalAlign?: string;
    HorizontalOffset?: string;
    VerticalAlign?: string;
    VerticalOffset?: string;
    Opacity?: string;
    Target?: string;
  };
  declare type ElasticTranscoder$20120925$PresetWatermarks = ElasticTranscoder$20120925$PresetWatermark[];
  declare type ElasticTranscoder$20120925$Presets = ElasticTranscoder$20120925$Preset[];
  declare type ElasticTranscoder$20120925$ReadJobRequest = {
    Id: string;
  };
  declare type ElasticTranscoder$20120925$ReadJobResponse = {
    Job?: ElasticTranscoder$20120925$Job;
  };
  declare type ElasticTranscoder$20120925$ReadPipelineRequest = {
    Id: string;
  };
  declare type ElasticTranscoder$20120925$ReadPipelineResponse = {
    Pipeline?: ElasticTranscoder$20120925$Pipeline;
    Warnings?: ElasticTranscoder$20120925$Warnings;
  };
  declare type ElasticTranscoder$20120925$ReadPresetRequest = {
    Id: string;
  };
  declare type ElasticTranscoder$20120925$ReadPresetResponse = {
    Preset?: ElasticTranscoder$20120925$Preset;
  };
  declare type ElasticTranscoder$20120925$ResourceInUseException = {};
  declare type ElasticTranscoder$20120925$ResourceNotFoundException = {};
  declare type ElasticTranscoder$20120925$SnsTopics = string[];
  declare type ElasticTranscoder$20120925$TestRoleRequest = {
    Role: string;
    InputBucket: string;
    OutputBucket: string;
    Topics: ElasticTranscoder$20120925$SnsTopics;
  };
  declare type ElasticTranscoder$20120925$TestRoleResponse = {
    Success?: string;
    Messages?: ElasticTranscoder$20120925$ExceptionMessages;
  };
  declare type ElasticTranscoder$20120925$Thumbnails = {
    Format?: string;
    Interval?: string;
    Resolution?: string;
    AspectRatio?: string;
    MaxWidth?: string;
    MaxHeight?: string;
    SizingPolicy?: string;
    PaddingPolicy?: string;
  };
  declare type ElasticTranscoder$20120925$TimeSpan = {
    StartTime?: string;
    Duration?: string;
  };
  declare type ElasticTranscoder$20120925$Timing = {
    SubmitTimeMillis?: number;
    StartTimeMillis?: number;
    FinishTimeMillis?: number;
  };
  declare type ElasticTranscoder$20120925$UpdatePipelineNotificationsRequest = {
    Id: string;
    Notifications: ElasticTranscoder$20120925$Notifications;
  };
  declare type ElasticTranscoder$20120925$UpdatePipelineNotificationsResponse = {
    Pipeline?: ElasticTranscoder$20120925$Pipeline;
  };
  declare type ElasticTranscoder$20120925$UpdatePipelineRequest = {
    Id: string;
    Name?: string;
    InputBucket?: string;
    Role?: string;
    AwsKmsKeyArn?: string;
    Notifications?: ElasticTranscoder$20120925$Notifications;
    ContentConfig?: ElasticTranscoder$20120925$PipelineOutputConfig;
    ThumbnailConfig?: ElasticTranscoder$20120925$PipelineOutputConfig;
  };
  declare type ElasticTranscoder$20120925$UpdatePipelineResponse = {
    Pipeline?: ElasticTranscoder$20120925$Pipeline;
    Warnings?: ElasticTranscoder$20120925$Warnings;
  };
  declare type ElasticTranscoder$20120925$UpdatePipelineStatusRequest = {
    Id: string;
    Status: string;
  };
  declare type ElasticTranscoder$20120925$UpdatePipelineStatusResponse = {
    Pipeline?: ElasticTranscoder$20120925$Pipeline;
  };
  declare type ElasticTranscoder$20120925$UserMetadata = {
    [key: string]: string;
  };
  declare type ElasticTranscoder$20120925$ValidationException = {};
  declare type ElasticTranscoder$20120925$VideoParameters = {
    Codec?: string;
    CodecOptions?: {
      [key: string]: string;
    };
    KeyframesMaxDist?: string;
    FixedGOP?: string;
    BitRate?: string;
    FrameRate?: string;
    MaxFrameRate?: string;
    Resolution?: string;
    AspectRatio?: string;
    MaxWidth?: string;
    MaxHeight?: string;
    DisplayAspectRatio?: string;
    SizingPolicy?: string;
    PaddingPolicy?: string;
    Watermarks?: ElasticTranscoder$20120925$PresetWatermarks;
  };
  declare type ElasticTranscoder$20120925$Warning = {
    Code?: string;
    Message?: string;
  };
  declare type ElasticTranscoder$20120925$Warnings = ElasticTranscoder$20120925$Warning[];
  declare type Firehose$20150804$BufferingHints = {
    SizeInMBs?: number;
    IntervalInSeconds?: number;
  };
  declare type Firehose$20150804$CloudWatchLoggingOptions = {
    Enabled?: boolean;
    LogGroupName?: string;
    LogStreamName?: string;
  };
  declare type Firehose$20150804$CompressionFormat = 'UNCOMPRESSED' | 'GZIP' | 'ZIP' | 'Snappy';
  declare type Firehose$20150804$ConcurrentModificationException = {
    message?: string;
  };
  declare type Firehose$20150804$CopyCommand = {
    DataTableName: string;
    DataTableColumns?: string;
    CopyOptions?: string;
  };
  declare type Firehose$20150804$CreateDeliveryStreamInput = {
    DeliveryStreamName: string;
    S3DestinationConfiguration?: Firehose$20150804$S3DestinationConfiguration;
    RedshiftDestinationConfiguration?: Firehose$20150804$RedshiftDestinationConfiguration;
    ElasticsearchDestinationConfiguration?: Firehose$20150804$ElasticsearchDestinationConfiguration;
  };
  declare type Firehose$20150804$CreateDeliveryStreamOutput = {
    DeliveryStreamARN?: string;
  };
  declare type Firehose$20150804$Data = Buffer | $TypedArray | Blob | string;
  declare type Firehose$20150804$DeleteDeliveryStreamInput = {
    DeliveryStreamName: string;
  };
  declare type Firehose$20150804$DeleteDeliveryStreamOutput = {};
  declare type Firehose$20150804$DeliveryStreamDescription = {
    DeliveryStreamName: string;
    DeliveryStreamARN: string;
    DeliveryStreamStatus: 'CREATING' | 'DELETING' | 'ACTIVE';
    VersionId: string;
    CreateTimestamp?: Date;
    LastUpdateTimestamp?: Date;
    Destinations: Firehose$20150804$DestinationDescriptionList;
    HasMoreDestinations: boolean;
  };
  declare type Firehose$20150804$DeliveryStreamNameList = string[];
  declare type Firehose$20150804$DeliveryStreamStatus = 'CREATING' | 'DELETING' | 'ACTIVE';
  declare type Firehose$20150804$DescribeDeliveryStreamInput = {
    DeliveryStreamName: string;
    Limit?: number;
    ExclusiveStartDestinationId?: string;
  };
  declare type Firehose$20150804$DescribeDeliveryStreamOutput = {
    DeliveryStreamDescription: Firehose$20150804$DeliveryStreamDescription;
  };
  declare type Firehose$20150804$DestinationDescription = {
    DestinationId: string;
    S3DestinationDescription?: Firehose$20150804$S3DestinationDescription;
    RedshiftDestinationDescription?: Firehose$20150804$RedshiftDestinationDescription;
    ElasticsearchDestinationDescription?: Firehose$20150804$ElasticsearchDestinationDescription;
  };
  declare type Firehose$20150804$DestinationDescriptionList = Firehose$20150804$DestinationDescription[];
  declare type Firehose$20150804$ElasticsearchBufferingHints = {
    IntervalInSeconds?: number;
    SizeInMBs?: number;
  };
  declare type Firehose$20150804$ElasticsearchDestinationConfiguration = {
    RoleARN: string;
    DomainARN: string;
    IndexName: string;
    TypeName: string;
    IndexRotationPeriod?: 'NoRotation' | 'OneHour' | 'OneDay' | 'OneWeek' | 'OneMonth';
    BufferingHints?: Firehose$20150804$ElasticsearchBufferingHints;
    RetryOptions?: Firehose$20150804$ElasticsearchRetryOptions;
    S3BackupMode?: 'FailedDocumentsOnly' | 'AllDocuments';
    S3Configuration: Firehose$20150804$S3DestinationConfiguration;
    CloudWatchLoggingOptions?: Firehose$20150804$CloudWatchLoggingOptions;
  };
  declare type Firehose$20150804$ElasticsearchDestinationDescription = {
    RoleARN?: string;
    DomainARN?: string;
    IndexName?: string;
    TypeName?: string;
    IndexRotationPeriod?: 'NoRotation' | 'OneHour' | 'OneDay' | 'OneWeek' | 'OneMonth';
    BufferingHints?: Firehose$20150804$ElasticsearchBufferingHints;
    RetryOptions?: Firehose$20150804$ElasticsearchRetryOptions;
    S3BackupMode?: 'FailedDocumentsOnly' | 'AllDocuments';
    S3DestinationDescription?: Firehose$20150804$S3DestinationDescription;
    CloudWatchLoggingOptions?: Firehose$20150804$CloudWatchLoggingOptions;
  };
  declare type Firehose$20150804$ElasticsearchDestinationUpdate = {
    RoleARN?: string;
    DomainARN?: string;
    IndexName?: string;
    TypeName?: string;
    IndexRotationPeriod?: 'NoRotation' | 'OneHour' | 'OneDay' | 'OneWeek' | 'OneMonth';
    BufferingHints?: Firehose$20150804$ElasticsearchBufferingHints;
    RetryOptions?: Firehose$20150804$ElasticsearchRetryOptions;
    S3Update?: Firehose$20150804$S3DestinationUpdate;
    CloudWatchLoggingOptions?: Firehose$20150804$CloudWatchLoggingOptions;
  };
  declare type Firehose$20150804$ElasticsearchIndexRotationPeriod = 'NoRotation' | 'OneHour' | 'OneDay' | 'OneWeek' | 'OneMonth';
  declare type Firehose$20150804$ElasticsearchRetryOptions = {
    DurationInSeconds?: number;
  };
  declare type Firehose$20150804$ElasticsearchS3BackupMode = 'FailedDocumentsOnly' | 'AllDocuments';
  declare type Firehose$20150804$EncryptionConfiguration = {
    NoEncryptionConfig?: 'NoEncryption';
    KMSEncryptionConfig?: Firehose$20150804$KMSEncryptionConfig;
  };
  declare type Firehose$20150804$InvalidArgumentException = {
    message?: string;
  };
  declare type Firehose$20150804$KMSEncryptionConfig = {
    AWSKMSKeyARN: string;
  };
  declare type Firehose$20150804$LimitExceededException = {
    message?: string;
  };
  declare type Firehose$20150804$ListDeliveryStreamsInput = {
    Limit?: number;
    ExclusiveStartDeliveryStreamName?: string;
  };
  declare type Firehose$20150804$ListDeliveryStreamsOutput = {
    DeliveryStreamNames: Firehose$20150804$DeliveryStreamNameList;
    HasMoreDeliveryStreams: boolean;
  };
  declare type Firehose$20150804$NoEncryptionConfig = 'NoEncryption';
  declare type Firehose$20150804$PutRecordBatchInput = {
    DeliveryStreamName: string;
    Records: Firehose$20150804$PutRecordBatchRequestEntryList;
  };
  declare type Firehose$20150804$PutRecordBatchOutput = {
    FailedPutCount: number;
    RequestResponses: Firehose$20150804$PutRecordBatchResponseEntryList;
  };
  declare type Firehose$20150804$PutRecordBatchRequestEntryList = Firehose$20150804$Record[];
  declare type Firehose$20150804$PutRecordBatchResponseEntry = {
    RecordId?: string;
    ErrorCode?: string;
    ErrorMessage?: string;
  };
  declare type Firehose$20150804$PutRecordBatchResponseEntryList = Firehose$20150804$PutRecordBatchResponseEntry[];
  declare type Firehose$20150804$PutRecordInput = {
    DeliveryStreamName: string;
    Record: Firehose$20150804$Record;
  };
  declare type Firehose$20150804$PutRecordOutput = {
    RecordId: string;
  };
  declare type Firehose$20150804$Record = {
    Data: Buffer | $TypedArray | Blob | string;
  };
  declare type Firehose$20150804$RedshiftDestinationConfiguration = {
    RoleARN: string;
    ClusterJDBCURL: string;
    CopyCommand: Firehose$20150804$CopyCommand;
    Username: string;
    Password: string;
    RetryOptions?: Firehose$20150804$RedshiftRetryOptions;
    S3Configuration: Firehose$20150804$S3DestinationConfiguration;
    CloudWatchLoggingOptions?: Firehose$20150804$CloudWatchLoggingOptions;
  };
  declare type Firehose$20150804$RedshiftDestinationDescription = {
    RoleARN: string;
    ClusterJDBCURL: string;
    CopyCommand: Firehose$20150804$CopyCommand;
    Username: string;
    RetryOptions?: Firehose$20150804$RedshiftRetryOptions;
    S3DestinationDescription: Firehose$20150804$S3DestinationDescription;
    CloudWatchLoggingOptions?: Firehose$20150804$CloudWatchLoggingOptions;
  };
  declare type Firehose$20150804$RedshiftDestinationUpdate = {
    RoleARN?: string;
    ClusterJDBCURL?: string;
    CopyCommand?: Firehose$20150804$CopyCommand;
    Username?: string;
    Password?: string;
    RetryOptions?: Firehose$20150804$RedshiftRetryOptions;
    S3Update?: Firehose$20150804$S3DestinationUpdate;
    CloudWatchLoggingOptions?: Firehose$20150804$CloudWatchLoggingOptions;
  };
  declare type Firehose$20150804$RedshiftRetryOptions = {
    DurationInSeconds?: number;
  };
  declare type Firehose$20150804$ResourceInUseException = {
    message?: string;
  };
  declare type Firehose$20150804$ResourceNotFoundException = {
    message?: string;
  };
  declare type Firehose$20150804$S3DestinationConfiguration = {
    RoleARN: string;
    BucketARN: string;
    Prefix?: string;
    BufferingHints?: Firehose$20150804$BufferingHints;
    CompressionFormat?: 'UNCOMPRESSED' | 'GZIP' | 'ZIP' | 'Snappy';
    EncryptionConfiguration?: Firehose$20150804$EncryptionConfiguration;
    CloudWatchLoggingOptions?: Firehose$20150804$CloudWatchLoggingOptions;
  };
  declare type Firehose$20150804$S3DestinationDescription = {
    RoleARN: string;
    BucketARN: string;
    Prefix?: string;
    BufferingHints: Firehose$20150804$BufferingHints;
    CompressionFormat: 'UNCOMPRESSED' | 'GZIP' | 'ZIP' | 'Snappy';
    EncryptionConfiguration: Firehose$20150804$EncryptionConfiguration;
    CloudWatchLoggingOptions?: Firehose$20150804$CloudWatchLoggingOptions;
  };
  declare type Firehose$20150804$S3DestinationUpdate = {
    RoleARN?: string;
    BucketARN?: string;
    Prefix?: string;
    BufferingHints?: Firehose$20150804$BufferingHints;
    CompressionFormat?: 'UNCOMPRESSED' | 'GZIP' | 'ZIP' | 'Snappy';
    EncryptionConfiguration?: Firehose$20150804$EncryptionConfiguration;
    CloudWatchLoggingOptions?: Firehose$20150804$CloudWatchLoggingOptions;
  };
  declare type Firehose$20150804$ServiceUnavailableException = {
    message?: string;
  };
  declare type Firehose$20150804$Timestamp = Date;
  declare type Firehose$20150804$UpdateDestinationInput = {
    DeliveryStreamName: string;
    CurrentDeliveryStreamVersionId: string;
    DestinationId: string;
    S3DestinationUpdate?: Firehose$20150804$S3DestinationUpdate;
    RedshiftDestinationUpdate?: Firehose$20150804$RedshiftDestinationUpdate;
    ElasticsearchDestinationUpdate?: Firehose$20150804$ElasticsearchDestinationUpdate;
  };
  declare type Firehose$20150804$UpdateDestinationOutput = {};
  declare type GameLift$20151001$Alias = {
    AliasId?: string;
    Name?: string;
    Description?: string;
    RoutingStrategy?: GameLift$20151001$RoutingStrategy;
    CreationTime?: Date;
    LastUpdatedTime?: Date;
  };
  declare type GameLift$20151001$AliasList = GameLift$20151001$Alias[];
  declare type GameLift$20151001$AwsCredentials = {
    AccessKeyId?: string;
    SecretAccessKey?: string;
    SessionToken?: string;
  };
  declare type GameLift$20151001$Build = {
    BuildId?: string;
    Name?: string;
    Version?: string;
    Status?: 'INITIALIZED' | 'READY' | 'FAILED';
    SizeOnDisk?: number;
    CreationTime?: Date;
  };
  declare type GameLift$20151001$BuildList = GameLift$20151001$Build[];
  declare type GameLift$20151001$BuildStatus = 'INITIALIZED' | 'READY' | 'FAILED';
  declare type GameLift$20151001$ComparisonOperatorType = 'GreaterThanOrEqualToThreshold' | 'GreaterThanThreshold' | 'LessThanThreshold' | 'LessThanOrEqualToThreshold';
  declare type GameLift$20151001$ConflictException = {
    Message?: string;
  };
  declare type GameLift$20151001$CreateAliasInput = {
    Name: string;
    Description?: string;
    RoutingStrategy: GameLift$20151001$RoutingStrategy;
  };
  declare type GameLift$20151001$CreateAliasOutput = {
    Alias?: GameLift$20151001$Alias;
  };
  declare type GameLift$20151001$CreateBuildInput = {
    Name?: string;
    Version?: string;
    StorageLocation?: GameLift$20151001$S3Location;
  };
  declare type GameLift$20151001$CreateBuildOutput = {
    Build?: GameLift$20151001$Build;
    UploadCredentials?: GameLift$20151001$AwsCredentials;
    StorageLocation?: GameLift$20151001$S3Location;
  };
  declare type GameLift$20151001$CreateFleetInput = {
    Name: string;
    Description?: string;
    BuildId: string;
    ServerLaunchPath?: string;
    ServerLaunchParameters?: string;
    LogPaths?: GameLift$20151001$StringList;
    EC2InstanceType: 't2.micro' | 't2.small' | 't2.medium' | 't2.large' | 'c3.large' | 'c3.xlarge' | 'c3.2xlarge' | 'c3.4xlarge' | 'c3.8xlarge' | 'c4.large' | 'c4.xlarge' | 'c4.2xlarge' | 'c4.4xlarge' | 'c4.8xlarge' | 'r3.large' | 'r3.xlarge' | 'r3.2xlarge' | 'r3.4xlarge' | 'r3.8xlarge' | 'm3.medium' | 'm3.large' | 'm3.xlarge' | 'm3.2xlarge' | 'm4.large' | 'm4.xlarge' | 'm4.2xlarge' | 'm4.4xlarge' | 'm4.10xlarge';
    EC2InboundPermissions?: GameLift$20151001$IpPermissionsList;
    NewGameSessionProtectionPolicy?: 'NoProtection' | 'FullProtection';
    RuntimeConfiguration?: GameLift$20151001$RuntimeConfiguration;
  };
  declare type GameLift$20151001$CreateFleetOutput = {
    FleetAttributes?: GameLift$20151001$FleetAttributes;
  };
  declare type GameLift$20151001$CreateGameSessionInput = {
    FleetId?: string;
    AliasId?: string;
    MaximumPlayerSessionCount: number;
    Name?: string;
    GameProperties?: GameLift$20151001$GamePropertyList;
  };
  declare type GameLift$20151001$CreateGameSessionOutput = {
    GameSession?: GameLift$20151001$GameSession;
  };
  declare type GameLift$20151001$CreatePlayerSessionInput = {
    GameSessionId: string;
    PlayerId: string;
  };
  declare type GameLift$20151001$CreatePlayerSessionOutput = {
    PlayerSession?: GameLift$20151001$PlayerSession;
  };
  declare type GameLift$20151001$CreatePlayerSessionsInput = {
    GameSessionId: string;
    PlayerIds: GameLift$20151001$PlayerIdList;
  };
  declare type GameLift$20151001$CreatePlayerSessionsOutput = {
    PlayerSessions?: GameLift$20151001$PlayerSessionList;
  };
  declare type GameLift$20151001$DeleteAliasInput = {
    AliasId: string;
  };
  declare type GameLift$20151001$DeleteBuildInput = {
    BuildId: string;
  };
  declare type GameLift$20151001$DeleteFleetInput = {
    FleetId: string;
  };
  declare type GameLift$20151001$DeleteScalingPolicyInput = {
    Name: string;
    FleetId: string;
  };
  declare type GameLift$20151001$DescribeAliasInput = {
    AliasId: string;
  };
  declare type GameLift$20151001$DescribeAliasOutput = {
    Alias?: GameLift$20151001$Alias;
  };
  declare type GameLift$20151001$DescribeBuildInput = {
    BuildId: string;
  };
  declare type GameLift$20151001$DescribeBuildOutput = {
    Build?: GameLift$20151001$Build;
  };
  declare type GameLift$20151001$DescribeEC2InstanceLimitsInput = {
    EC2InstanceType?: 't2.micro' | 't2.small' | 't2.medium' | 't2.large' | 'c3.large' | 'c3.xlarge' | 'c3.2xlarge' | 'c3.4xlarge' | 'c3.8xlarge' | 'c4.large' | 'c4.xlarge' | 'c4.2xlarge' | 'c4.4xlarge' | 'c4.8xlarge' | 'r3.large' | 'r3.xlarge' | 'r3.2xlarge' | 'r3.4xlarge' | 'r3.8xlarge' | 'm3.medium' | 'm3.large' | 'm3.xlarge' | 'm3.2xlarge' | 'm4.large' | 'm4.xlarge' | 'm4.2xlarge' | 'm4.4xlarge' | 'm4.10xlarge';
  };
  declare type GameLift$20151001$DescribeEC2InstanceLimitsOutput = {
    EC2InstanceLimits?: GameLift$20151001$EC2InstanceLimitList;
  };
  declare type GameLift$20151001$DescribeFleetAttributesInput = {
    FleetIds?: GameLift$20151001$FleetIdList;
    Limit?: number;
    NextToken?: string;
  };
  declare type GameLift$20151001$DescribeFleetAttributesOutput = {
    FleetAttributes?: GameLift$20151001$FleetAttributesList;
    NextToken?: string;
  };
  declare type GameLift$20151001$DescribeFleetCapacityInput = {
    FleetIds?: GameLift$20151001$FleetIdList;
    Limit?: number;
    NextToken?: string;
  };
  declare type GameLift$20151001$DescribeFleetCapacityOutput = {
    FleetCapacity?: GameLift$20151001$FleetCapacityList;
    NextToken?: string;
  };
  declare type GameLift$20151001$DescribeFleetEventsInput = {
    FleetId: string;
    StartTime?: Date;
    EndTime?: Date;
    Limit?: number;
    NextToken?: string;
  };
  declare type GameLift$20151001$DescribeFleetEventsOutput = {
    Events?: GameLift$20151001$EventList;
    NextToken?: string;
  };
  declare type GameLift$20151001$DescribeFleetPortSettingsInput = {
    FleetId: string;
  };
  declare type GameLift$20151001$DescribeFleetPortSettingsOutput = {
    InboundPermissions?: GameLift$20151001$IpPermissionsList;
  };
  declare type GameLift$20151001$DescribeFleetUtilizationInput = {
    FleetIds?: GameLift$20151001$FleetIdList;
    Limit?: number;
    NextToken?: string;
  };
  declare type GameLift$20151001$DescribeFleetUtilizationOutput = {
    FleetUtilization?: GameLift$20151001$FleetUtilizationList;
    NextToken?: string;
  };
  declare type GameLift$20151001$DescribeGameSessionDetailsInput = {
    FleetId?: string;
    GameSessionId?: string;
    AliasId?: string;
    StatusFilter?: string;
    Limit?: number;
    NextToken?: string;
  };
  declare type GameLift$20151001$DescribeGameSessionDetailsOutput = {
    GameSessionDetails?: GameLift$20151001$GameSessionDetailList;
    NextToken?: string;
  };
  declare type GameLift$20151001$DescribeGameSessionsInput = {
    FleetId?: string;
    GameSessionId?: string;
    AliasId?: string;
    StatusFilter?: string;
    Limit?: number;
    NextToken?: string;
  };
  declare type GameLift$20151001$DescribeGameSessionsOutput = {
    GameSessions?: GameLift$20151001$GameSessionList;
    NextToken?: string;
  };
  declare type GameLift$20151001$DescribePlayerSessionsInput = {
    GameSessionId?: string;
    PlayerId?: string;
    PlayerSessionId?: string;
    PlayerSessionStatusFilter?: string;
    Limit?: number;
    NextToken?: string;
  };
  declare type GameLift$20151001$DescribePlayerSessionsOutput = {
    PlayerSessions?: GameLift$20151001$PlayerSessionList;
    NextToken?: string;
  };
  declare type GameLift$20151001$DescribeRuntimeConfigurationInput = {
    FleetId: string;
  };
  declare type GameLift$20151001$DescribeRuntimeConfigurationOutput = {
    RuntimeConfiguration?: GameLift$20151001$RuntimeConfiguration;
  };
  declare type GameLift$20151001$DescribeScalingPoliciesInput = {
    FleetId: string;
    StatusFilter?: 'ACTIVE' | 'UPDATE_REQUESTED' | 'UPDATING' | 'DELETE_REQUESTED' | 'DELETING' | 'DELETED' | 'ERROR';
    Limit?: number;
    NextToken?: string;
  };
  declare type GameLift$20151001$DescribeScalingPoliciesOutput = {
    ScalingPolicies?: GameLift$20151001$ScalingPolicyList;
    NextToken?: string;
  };
  declare type GameLift$20151001$EC2InstanceCounts = {
    DESIRED?: number;
    MINIMUM?: number;
    MAXIMUM?: number;
    PENDING?: number;
    ACTIVE?: number;
    IDLE?: number;
    TERMINATING?: number;
  };
  declare type GameLift$20151001$EC2InstanceLimit = {
    EC2InstanceType?: 't2.micro' | 't2.small' | 't2.medium' | 't2.large' | 'c3.large' | 'c3.xlarge' | 'c3.2xlarge' | 'c3.4xlarge' | 'c3.8xlarge' | 'c4.large' | 'c4.xlarge' | 'c4.2xlarge' | 'c4.4xlarge' | 'c4.8xlarge' | 'r3.large' | 'r3.xlarge' | 'r3.2xlarge' | 'r3.4xlarge' | 'r3.8xlarge' | 'm3.medium' | 'm3.large' | 'm3.xlarge' | 'm3.2xlarge' | 'm4.large' | 'm4.xlarge' | 'm4.2xlarge' | 'm4.4xlarge' | 'm4.10xlarge';
    CurrentInstances?: number;
    InstanceLimit?: number;
  };
  declare type GameLift$20151001$EC2InstanceLimitList = GameLift$20151001$EC2InstanceLimit[];
  declare type GameLift$20151001$EC2InstanceType = 't2.micro' | 't2.small' | 't2.medium' | 't2.large' | 'c3.large' | 'c3.xlarge' | 'c3.2xlarge' | 'c3.4xlarge' | 'c3.8xlarge' | 'c4.large' | 'c4.xlarge' | 'c4.2xlarge' | 'c4.4xlarge' | 'c4.8xlarge' | 'r3.large' | 'r3.xlarge' | 'r3.2xlarge' | 'r3.4xlarge' | 'r3.8xlarge' | 'm3.medium' | 'm3.large' | 'm3.xlarge' | 'm3.2xlarge' | 'm4.large' | 'm4.xlarge' | 'm4.2xlarge' | 'm4.4xlarge' | 'm4.10xlarge';
  declare type GameLift$20151001$Event = {
    EventId?: string;
    ResourceId?: string;
    EventCode?: 'GENERIC_EVENT' | 'FLEET_CREATED' | 'FLEET_DELETED' | 'FLEET_SCALING_EVENT' | 'FLEET_STATE_DOWNLOADING' | 'FLEET_STATE_VALIDATING' | 'FLEET_STATE_BUILDING' | 'FLEET_STATE_ACTIVATING' | 'FLEET_STATE_ACTIVE' | 'FLEET_STATE_ERROR' | 'FLEET_INITIALIZATION_FAILED' | 'FLEET_BINARY_DOWNLOAD_FAILED' | 'FLEET_VALIDATION_LAUNCH_PATH_NOT_FOUND' | 'FLEET_VALIDATION_EXECUTABLE_RUNTIME_FAILURE' | 'FLEET_VALIDATION_TIMED_OUT' | 'FLEET_ACTIVATION_FAILED' | 'FLEET_ACTIVATION_FAILED_NO_INSTANCES' | 'FLEET_NEW_GAME_SESSION_PROTECTION_POLICY_UPDATED';
    Message?: string;
    EventTime?: Date;
  };
  declare type GameLift$20151001$EventCode = 'GENERIC_EVENT' | 'FLEET_CREATED' | 'FLEET_DELETED' | 'FLEET_SCALING_EVENT' | 'FLEET_STATE_DOWNLOADING' | 'FLEET_STATE_VALIDATING' | 'FLEET_STATE_BUILDING' | 'FLEET_STATE_ACTIVATING' | 'FLEET_STATE_ACTIVE' | 'FLEET_STATE_ERROR' | 'FLEET_INITIALIZATION_FAILED' | 'FLEET_BINARY_DOWNLOAD_FAILED' | 'FLEET_VALIDATION_LAUNCH_PATH_NOT_FOUND' | 'FLEET_VALIDATION_EXECUTABLE_RUNTIME_FAILURE' | 'FLEET_VALIDATION_TIMED_OUT' | 'FLEET_ACTIVATION_FAILED' | 'FLEET_ACTIVATION_FAILED_NO_INSTANCES' | 'FLEET_NEW_GAME_SESSION_PROTECTION_POLICY_UPDATED';
  declare type GameLift$20151001$EventList = GameLift$20151001$Event[];
  declare type GameLift$20151001$FleetAttributes = {
    FleetId?: string;
    Description?: string;
    Name?: string;
    CreationTime?: Date;
    TerminationTime?: Date;
    Status?: 'NEW' | 'DOWNLOADING' | 'VALIDATING' | 'BUILDING' | 'ACTIVATING' | 'ACTIVE' | 'DELETING' | 'ERROR' | 'TERMINATED';
    BuildId?: string;
    ServerLaunchPath?: string;
    ServerLaunchParameters?: string;
    LogPaths?: GameLift$20151001$StringList;
    NewGameSessionProtectionPolicy?: 'NoProtection' | 'FullProtection';
  };
  declare type GameLift$20151001$FleetAttributesList = GameLift$20151001$FleetAttributes[];
  declare type GameLift$20151001$FleetCapacity = {
    FleetId?: string;
    InstanceType?: 't2.micro' | 't2.small' | 't2.medium' | 't2.large' | 'c3.large' | 'c3.xlarge' | 'c3.2xlarge' | 'c3.4xlarge' | 'c3.8xlarge' | 'c4.large' | 'c4.xlarge' | 'c4.2xlarge' | 'c4.4xlarge' | 'c4.8xlarge' | 'r3.large' | 'r3.xlarge' | 'r3.2xlarge' | 'r3.4xlarge' | 'r3.8xlarge' | 'm3.medium' | 'm3.large' | 'm3.xlarge' | 'm3.2xlarge' | 'm4.large' | 'm4.xlarge' | 'm4.2xlarge' | 'm4.4xlarge' | 'm4.10xlarge';
    InstanceCounts?: GameLift$20151001$EC2InstanceCounts;
  };
  declare type GameLift$20151001$FleetCapacityExceededException = {
    Message?: string;
  };
  declare type GameLift$20151001$FleetCapacityList = GameLift$20151001$FleetCapacity[];
  declare type GameLift$20151001$FleetIdList = string[];
  declare type GameLift$20151001$FleetStatus = 'NEW' | 'DOWNLOADING' | 'VALIDATING' | 'BUILDING' | 'ACTIVATING' | 'ACTIVE' | 'DELETING' | 'ERROR' | 'TERMINATED';
  declare type GameLift$20151001$FleetUtilization = {
    FleetId?: string;
    ActiveServerProcessCount?: number;
    ActiveGameSessionCount?: number;
    CurrentPlayerSessionCount?: number;
    MaximumPlayerSessionCount?: number;
  };
  declare type GameLift$20151001$FleetUtilizationList = GameLift$20151001$FleetUtilization[];
  declare type GameLift$20151001$GameProperty = {
    Key: string;
    Value: string;
  };
  declare type GameLift$20151001$GamePropertyList = GameLift$20151001$GameProperty[];
  declare type GameLift$20151001$GameSession = {
    GameSessionId?: string;
    Name?: string;
    FleetId?: string;
    CreationTime?: Date;
    TerminationTime?: Date;
    CurrentPlayerSessionCount?: number;
    MaximumPlayerSessionCount?: number;
    Status?: 'ACTIVE' | 'ACTIVATING' | 'TERMINATED' | 'TERMINATING';
    GameProperties?: GameLift$20151001$GamePropertyList;
    IpAddress?: string;
    Port?: number;
    PlayerSessionCreationPolicy?: 'ACCEPT_ALL' | 'DENY_ALL';
  };
  declare type GameLift$20151001$GameSessionDetail = {
    GameSession?: GameLift$20151001$GameSession;
    ProtectionPolicy?: 'NoProtection' | 'FullProtection';
  };
  declare type GameLift$20151001$GameSessionDetailList = GameLift$20151001$GameSessionDetail[];
  declare type GameLift$20151001$GameSessionFullException = {
    Message?: string;
  };
  declare type GameLift$20151001$GameSessionList = GameLift$20151001$GameSession[];
  declare type GameLift$20151001$GameSessionStatus = 'ACTIVE' | 'ACTIVATING' | 'TERMINATED' | 'TERMINATING';
  declare type GameLift$20151001$GetGameSessionLogUrlInput = {
    GameSessionId: string;
  };
  declare type GameLift$20151001$GetGameSessionLogUrlOutput = {
    PreSignedUrl?: string;
  };
  declare type GameLift$20151001$InternalServiceException = {
    Message?: string;
  };
  declare type GameLift$20151001$InvalidFleetStatusException = {
    Message?: string;
  };
  declare type GameLift$20151001$InvalidGameSessionStatusException = {
    Message?: string;
  };
  declare type GameLift$20151001$InvalidRequestException = {
    Message?: string;
  };
  declare type GameLift$20151001$IpPermission = {
    FromPort: number;
    ToPort: number;
    IpRange: string;
    Protocol: 'TCP' | 'UDP';
  };
  declare type GameLift$20151001$IpPermissionsList = GameLift$20151001$IpPermission[];
  declare type GameLift$20151001$IpProtocol = 'TCP' | 'UDP';
  declare type GameLift$20151001$LimitExceededException = {
    Message?: string;
  };
  declare type GameLift$20151001$ListAliasesInput = {
    RoutingStrategyType?: 'SIMPLE' | 'TERMINAL';
    Name?: string;
    Limit?: number;
    NextToken?: string;
  };
  declare type GameLift$20151001$ListAliasesOutput = {
    Aliases?: GameLift$20151001$AliasList;
    NextToken?: string;
  };
  declare type GameLift$20151001$ListBuildsInput = {
    Status?: 'INITIALIZED' | 'READY' | 'FAILED';
    Limit?: number;
    NextToken?: string;
  };
  declare type GameLift$20151001$ListBuildsOutput = {
    Builds?: GameLift$20151001$BuildList;
    NextToken?: string;
  };
  declare type GameLift$20151001$ListFleetsInput = {
    BuildId?: string;
    Limit?: number;
    NextToken?: string;
  };
  declare type GameLift$20151001$ListFleetsOutput = {
    FleetIds?: GameLift$20151001$FleetIdList;
    NextToken?: string;
  };
  declare type GameLift$20151001$MetricName = 'ActivatingGameSessions' | 'ActiveGameSessions' | 'ActiveInstances' | 'AvailablePlayerSessions' | 'CurrentPlayerSessions' | 'IdleInstances';
  declare type GameLift$20151001$NotFoundException = {
    Message?: string;
  };
  declare type GameLift$20151001$PlayerIdList = string[];
  declare type GameLift$20151001$PlayerSession = {
    PlayerSessionId?: string;
    PlayerId?: string;
    GameSessionId?: string;
    FleetId?: string;
    CreationTime?: Date;
    TerminationTime?: Date;
    Status?: 'RESERVED' | 'ACTIVE' | 'COMPLETED' | 'TIMEDOUT';
    IpAddress?: string;
    Port?: number;
  };
  declare type GameLift$20151001$PlayerSessionCreationPolicy = 'ACCEPT_ALL' | 'DENY_ALL';
  declare type GameLift$20151001$PlayerSessionList = GameLift$20151001$PlayerSession[];
  declare type GameLift$20151001$PlayerSessionStatus = 'RESERVED' | 'ACTIVE' | 'COMPLETED' | 'TIMEDOUT';
  declare type GameLift$20151001$ProtectionPolicy = 'NoProtection' | 'FullProtection';
  declare type GameLift$20151001$PutScalingPolicyInput = {
    Name: string;
    FleetId: string;
    ScalingAdjustment: number;
    ScalingAdjustmentType: 'ChangeInCapacity' | 'ExactCapacity' | 'PercentChangeInCapacity';
    Threshold: number;
    ComparisonOperator: 'GreaterThanOrEqualToThreshold' | 'GreaterThanThreshold' | 'LessThanThreshold' | 'LessThanOrEqualToThreshold';
    EvaluationPeriods: number;
    MetricName: 'ActivatingGameSessions' | 'ActiveGameSessions' | 'ActiveInstances' | 'AvailablePlayerSessions' | 'CurrentPlayerSessions' | 'IdleInstances';
  };
  declare type GameLift$20151001$PutScalingPolicyOutput = {
    Name?: string;
  };
  declare type GameLift$20151001$RequestUploadCredentialsInput = {
    BuildId: string;
  };
  declare type GameLift$20151001$RequestUploadCredentialsOutput = {
    UploadCredentials?: GameLift$20151001$AwsCredentials;
    StorageLocation?: GameLift$20151001$S3Location;
  };
  declare type GameLift$20151001$ResolveAliasInput = {
    AliasId: string;
  };
  declare type GameLift$20151001$ResolveAliasOutput = {
    FleetId?: string;
  };
  declare type GameLift$20151001$RoutingStrategy = {
    Type?: 'SIMPLE' | 'TERMINAL';
    FleetId?: string;
    Message?: string;
  };
  declare type GameLift$20151001$RoutingStrategyType = 'SIMPLE' | 'TERMINAL';
  declare type GameLift$20151001$RuntimeConfiguration = {
    ServerProcesses?: GameLift$20151001$ServerProcessList;
  };
  declare type GameLift$20151001$S3Location = {
    Bucket?: string;
    Key?: string;
    RoleArn?: string;
  };
  declare type GameLift$20151001$ScalingAdjustmentType = 'ChangeInCapacity' | 'ExactCapacity' | 'PercentChangeInCapacity';
  declare type GameLift$20151001$ScalingPolicy = {
    FleetId?: string;
    Name?: string;
    Status?: 'ACTIVE' | 'UPDATE_REQUESTED' | 'UPDATING' | 'DELETE_REQUESTED' | 'DELETING' | 'DELETED' | 'ERROR';
    ScalingAdjustment?: number;
    ScalingAdjustmentType?: 'ChangeInCapacity' | 'ExactCapacity' | 'PercentChangeInCapacity';
    ComparisonOperator?: 'GreaterThanOrEqualToThreshold' | 'GreaterThanThreshold' | 'LessThanThreshold' | 'LessThanOrEqualToThreshold';
    Threshold?: number;
    EvaluationPeriods?: number;
    MetricName?: 'ActivatingGameSessions' | 'ActiveGameSessions' | 'ActiveInstances' | 'AvailablePlayerSessions' | 'CurrentPlayerSessions' | 'IdleInstances';
  };
  declare type GameLift$20151001$ScalingPolicyList = GameLift$20151001$ScalingPolicy[];
  declare type GameLift$20151001$ScalingStatusType = 'ACTIVE' | 'UPDATE_REQUESTED' | 'UPDATING' | 'DELETE_REQUESTED' | 'DELETING' | 'DELETED' | 'ERROR';
  declare type GameLift$20151001$SearchGameSessionsInput = {
    FleetId?: string;
    AliasId?: string;
    FilterExpression?: string;
    SortExpression?: string;
    Limit?: number;
    NextToken?: string;
  };
  declare type GameLift$20151001$SearchGameSessionsOutput = {
    GameSessions?: GameLift$20151001$GameSessionList;
    NextToken?: string;
  };
  declare type GameLift$20151001$ServerProcess = {
    LaunchPath: string;
    Parameters?: string;
    ConcurrentExecutions: number;
  };
  declare type GameLift$20151001$ServerProcessList = GameLift$20151001$ServerProcess[];
  declare type GameLift$20151001$StringList = string[];
  declare type GameLift$20151001$TerminalRoutingStrategyException = {
    Message?: string;
  };
  declare type GameLift$20151001$Timestamp = Date;
  declare type GameLift$20151001$UnauthorizedException = {
    Message?: string;
  };
  declare type GameLift$20151001$UpdateAliasInput = {
    AliasId: string;
    Name?: string;
    Description?: string;
    RoutingStrategy?: GameLift$20151001$RoutingStrategy;
  };
  declare type GameLift$20151001$UpdateAliasOutput = {
    Alias?: GameLift$20151001$Alias;
  };
  declare type GameLift$20151001$UpdateBuildInput = {
    BuildId: string;
    Name?: string;
    Version?: string;
  };
  declare type GameLift$20151001$UpdateBuildOutput = {
    Build?: GameLift$20151001$Build;
  };
  declare type GameLift$20151001$UpdateFleetAttributesInput = {
    FleetId: string;
    Name?: string;
    Description?: string;
    NewGameSessionProtectionPolicy?: 'NoProtection' | 'FullProtection';
  };
  declare type GameLift$20151001$UpdateFleetAttributesOutput = {
    FleetId?: string;
  };
  declare type GameLift$20151001$UpdateFleetCapacityInput = {
    FleetId: string;
    DesiredInstances?: number;
    MinSize?: number;
    MaxSize?: number;
  };
  declare type GameLift$20151001$UpdateFleetCapacityOutput = {
    FleetId?: string;
  };
  declare type GameLift$20151001$UpdateFleetPortSettingsInput = {
    FleetId: string;
    InboundPermissionAuthorizations?: GameLift$20151001$IpPermissionsList;
    InboundPermissionRevocations?: GameLift$20151001$IpPermissionsList;
  };
  declare type GameLift$20151001$UpdateFleetPortSettingsOutput = {
    FleetId?: string;
  };
  declare type GameLift$20151001$UpdateGameSessionInput = {
    GameSessionId: string;
    MaximumPlayerSessionCount?: number;
    Name?: string;
    PlayerSessionCreationPolicy?: 'ACCEPT_ALL' | 'DENY_ALL';
    ProtectionPolicy?: 'NoProtection' | 'FullProtection';
  };
  declare type GameLift$20151001$UpdateGameSessionOutput = {
    GameSession?: GameLift$20151001$GameSession;
  };
  declare type GameLift$20151001$UpdateRuntimeConfigurationInput = {
    FleetId: string;
    RuntimeConfiguration: GameLift$20151001$RuntimeConfiguration;
  };
  declare type GameLift$20151001$UpdateRuntimeConfigurationOutput = {
    RuntimeConfiguration?: GameLift$20151001$RuntimeConfiguration;
  };
  declare type Glacier$20120601$AbortMultipartUploadInput = {
    accountId: string;
    vaultName: string;
    uploadId: string;
  };
  declare type Glacier$20120601$AbortVaultLockInput = {
    accountId: string;
    vaultName: string;
  };
  declare type Glacier$20120601$ActionCode = 'ArchiveRetrieval' | 'InventoryRetrieval';
  declare type Glacier$20120601$AddTagsToVaultInput = {
    accountId: string;
    vaultName: string;
    Tags?: {
      [key: string]: string;
    };
  };
  declare type Glacier$20120601$ArchiveCreationOutput = {
    location?: string;
    checksum?: string;
    archiveId?: string;
  };
  declare type Glacier$20120601$CompleteMultipartUploadInput = {
    accountId: string;
    vaultName: string;
    uploadId: string;
    archiveSize?: string;
    checksum?: string;
  };
  declare type Glacier$20120601$CompleteVaultLockInput = {
    accountId: string;
    vaultName: string;
    lockId: string;
  };
  declare type Glacier$20120601$CreateVaultInput = {
    accountId: string;
    vaultName: string;
  };
  declare type Glacier$20120601$CreateVaultOutput = {
    location?: string;
  };
  declare type Glacier$20120601$DataRetrievalPolicy = {
    Rules?: Glacier$20120601$DataRetrievalRulesList;
  };
  declare type Glacier$20120601$DataRetrievalRule = {
    Strategy?: string;
    BytesPerHour?: number;
  };
  declare type Glacier$20120601$DataRetrievalRulesList = Glacier$20120601$DataRetrievalRule[];
  declare type Glacier$20120601$DeleteArchiveInput = {
    accountId: string;
    vaultName: string;
    archiveId: string;
  };
  declare type Glacier$20120601$DeleteVaultAccessPolicyInput = {
    accountId: string;
    vaultName: string;
  };
  declare type Glacier$20120601$DeleteVaultInput = {
    accountId: string;
    vaultName: string;
  };
  declare type Glacier$20120601$DeleteVaultNotificationsInput = {
    accountId: string;
    vaultName: string;
  };
  declare type Glacier$20120601$DescribeJobInput = {
    accountId: string;
    vaultName: string;
    jobId: string;
  };
  declare type Glacier$20120601$DescribeVaultInput = {
    accountId: string;
    vaultName: string;
  };
  declare type Glacier$20120601$DescribeVaultOutput = {
    VaultARN?: string;
    VaultName?: string;
    CreationDate?: string;
    LastInventoryDate?: string;
    NumberOfArchives?: number;
    SizeInBytes?: number;
  };
  declare type Glacier$20120601$GetDataRetrievalPolicyInput = {
    accountId: string;
  };
  declare type Glacier$20120601$GetDataRetrievalPolicyOutput = {
    Policy?: Glacier$20120601$DataRetrievalPolicy;
  };
  declare type Glacier$20120601$GetJobOutputInput = {
    accountId: string;
    vaultName: string;
    jobId: string;
    range?: string;
  };
  declare type Glacier$20120601$GetJobOutputOutput = {
    body?: Buffer | $TypedArray | Blob | string;
    checksum?: string;
    status?: number;
    contentRange?: string;
    acceptRanges?: string;
    contentType?: string;
    archiveDescription?: string;
  };
  declare type Glacier$20120601$GetVaultAccessPolicyInput = {
    accountId: string;
    vaultName: string;
  };
  declare type Glacier$20120601$GetVaultAccessPolicyOutput = {
    policy?: Glacier$20120601$VaultAccessPolicy;
  };
  declare type Glacier$20120601$GetVaultLockInput = {
    accountId: string;
    vaultName: string;
  };
  declare type Glacier$20120601$GetVaultLockOutput = {
    Policy?: string;
    State?: string;
    ExpirationDate?: string;
    CreationDate?: string;
  };
  declare type Glacier$20120601$GetVaultNotificationsInput = {
    accountId: string;
    vaultName: string;
  };
  declare type Glacier$20120601$GetVaultNotificationsOutput = {
    vaultNotificationConfig?: Glacier$20120601$VaultNotificationConfig;
  };
  declare type Glacier$20120601$GlacierJobDescription = {
    JobId?: string;
    JobDescription?: string;
    Action?: 'ArchiveRetrieval' | 'InventoryRetrieval';
    ArchiveId?: string;
    VaultARN?: string;
    CreationDate?: string;
    Completed?: boolean;
    StatusCode?: 'InProgress' | 'Succeeded' | 'Failed';
    StatusMessage?: string;
    ArchiveSizeInBytes?: number;
    InventorySizeInBytes?: number;
    SNSTopic?: string;
    CompletionDate?: string;
    SHA256TreeHash?: string;
    ArchiveSHA256TreeHash?: string;
    RetrievalByteRange?: string;
    InventoryRetrievalParameters?: Glacier$20120601$InventoryRetrievalJobDescription;
  };
  declare type Glacier$20120601$InitiateJobInput = {
    accountId: string;
    vaultName: string;
    jobParameters?: Glacier$20120601$JobParameters;
  };
  declare type Glacier$20120601$InitiateJobOutput = {
    location?: string;
    jobId?: string;
  };
  declare type Glacier$20120601$InitiateMultipartUploadInput = {
    accountId: string;
    vaultName: string;
    archiveDescription?: string;
    partSize?: string;
  };
  declare type Glacier$20120601$InitiateMultipartUploadOutput = {
    location?: string;
    uploadId?: string;
  };
  declare type Glacier$20120601$InitiateVaultLockInput = {
    accountId: string;
    vaultName: string;
    policy?: Glacier$20120601$VaultLockPolicy;
  };
  declare type Glacier$20120601$InitiateVaultLockOutput = {
    lockId?: string;
  };
  declare type Glacier$20120601$InvalidParameterValueException = {
    type?: string;
    code?: string;
    message?: string;
  };
  declare type Glacier$20120601$InventoryRetrievalJobDescription = {
    Format?: string;
    StartDate?: string;
    EndDate?: string;
    Limit?: string;
    Marker?: string;
  };
  declare type Glacier$20120601$InventoryRetrievalJobInput = {
    StartDate?: string;
    EndDate?: string;
    Limit?: string;
    Marker?: string;
  };
  declare type Glacier$20120601$JobList = Glacier$20120601$GlacierJobDescription[];
  declare type Glacier$20120601$JobParameters = {
    Format?: string;
    Type?: string;
    ArchiveId?: string;
    Description?: string;
    SNSTopic?: string;
    RetrievalByteRange?: string;
    InventoryRetrievalParameters?: Glacier$20120601$InventoryRetrievalJobInput;
  };
  declare type Glacier$20120601$LimitExceededException = {
    type?: string;
    code?: string;
    message?: string;
  };
  declare type Glacier$20120601$ListJobsInput = {
    accountId: string;
    vaultName: string;
    limit?: string;
    marker?: string;
    statuscode?: string;
    completed?: string;
  };
  declare type Glacier$20120601$ListJobsOutput = {
    JobList?: Glacier$20120601$JobList;
    Marker?: string;
  };
  declare type Glacier$20120601$ListMultipartUploadsInput = {
    accountId: string;
    vaultName: string;
    marker?: string;
    limit?: string;
  };
  declare type Glacier$20120601$ListMultipartUploadsOutput = {
    UploadsList?: Glacier$20120601$UploadsList;
    Marker?: string;
  };
  declare type Glacier$20120601$ListPartsInput = {
    accountId: string;
    vaultName: string;
    uploadId: string;
    marker?: string;
    limit?: string;
  };
  declare type Glacier$20120601$ListPartsOutput = {
    MultipartUploadId?: string;
    VaultARN?: string;
    ArchiveDescription?: string;
    PartSizeInBytes?: number;
    CreationDate?: string;
    Parts?: Glacier$20120601$PartList;
    Marker?: string;
  };
  declare type Glacier$20120601$ListTagsForVaultInput = {
    accountId: string;
    vaultName: string;
  };
  declare type Glacier$20120601$ListTagsForVaultOutput = {
    Tags?: {
      [key: string]: string;
    };
  };
  declare type Glacier$20120601$ListVaultsInput = {
    accountId: string;
    marker?: string;
    limit?: string;
  };
  declare type Glacier$20120601$ListVaultsOutput = {
    VaultList?: Glacier$20120601$VaultList;
    Marker?: string;
  };
  declare type Glacier$20120601$MissingParameterValueException = {
    type?: string;
    code?: string;
    message?: string;
  };
  declare type Glacier$20120601$NotificationEventList = string[];
  declare type Glacier$20120601$PartList = Glacier$20120601$PartListElement[];
  declare type Glacier$20120601$PartListElement = {
    RangeInBytes?: string;
    SHA256TreeHash?: string;
  };
  declare type Glacier$20120601$PolicyEnforcedException = {
    type?: string;
    code?: string;
    message?: string;
  };
  declare type Glacier$20120601$RemoveTagsFromVaultInput = {
    accountId: string;
    vaultName: string;
    TagKeys?: Glacier$20120601$TagKeyList;
  };
  declare type Glacier$20120601$RequestTimeoutException = {
    type?: string;
    code?: string;
    message?: string;
  };
  declare type Glacier$20120601$ResourceNotFoundException = {
    type?: string;
    code?: string;
    message?: string;
  };
  declare type Glacier$20120601$ServiceUnavailableException = {
    type?: string;
    code?: string;
    message?: string;
  };
  declare type Glacier$20120601$SetDataRetrievalPolicyInput = {
    accountId: string;
    Policy?: Glacier$20120601$DataRetrievalPolicy;
  };
  declare type Glacier$20120601$SetVaultAccessPolicyInput = {
    accountId: string;
    vaultName: string;
    policy?: Glacier$20120601$VaultAccessPolicy;
  };
  declare type Glacier$20120601$SetVaultNotificationsInput = {
    accountId: string;
    vaultName: string;
    vaultNotificationConfig?: Glacier$20120601$VaultNotificationConfig;
  };
  declare type Glacier$20120601$StatusCode = 'InProgress' | 'Succeeded' | 'Failed';
  declare type Glacier$20120601$Stream = Buffer | $TypedArray | Blob | string;
  declare type Glacier$20120601$TagKeyList = string[];
  declare type Glacier$20120601$TagMap = {
    [key: string]: string;
  };
  declare type Glacier$20120601$UploadArchiveInput = {
    vaultName: string;
    accountId: string;
    archiveDescription?: string;
    checksum?: string;
    body?: Buffer | $TypedArray | Blob | string;
  };
  declare type Glacier$20120601$UploadListElement = {
    MultipartUploadId?: string;
    VaultARN?: string;
    ArchiveDescription?: string;
    PartSizeInBytes?: number;
    CreationDate?: string;
  };
  declare type Glacier$20120601$UploadMultipartPartInput = {
    accountId: string;
    vaultName: string;
    uploadId: string;
    checksum?: string;
    range?: string;
    body?: Buffer | $TypedArray | Blob | string;
  };
  declare type Glacier$20120601$UploadMultipartPartOutput = {
    checksum?: string;
  };
  declare type Glacier$20120601$UploadsList = Glacier$20120601$UploadListElement[];
  declare type Glacier$20120601$VaultAccessPolicy = {
    Policy?: string;
  };
  declare type Glacier$20120601$VaultList = Glacier$20120601$DescribeVaultOutput[];
  declare type Glacier$20120601$VaultLockPolicy = {
    Policy?: string;
  };
  declare type Glacier$20120601$VaultNotificationConfig = {
    SNSTopic?: string;
    Events?: Glacier$20120601$NotificationEventList;
  };
  declare type IAM$20100508$AccessKey = {
    UserName: string;
    AccessKeyId: string;
    Status: 'Active' | 'Inactive';
    SecretAccessKey: string;
    CreateDate?: Date;
  };
  declare type IAM$20100508$AccessKeyLastUsed = {
    LastUsedDate: Date;
    ServiceName: string;
    Region: string;
  };
  declare type IAM$20100508$AccessKeyMetadata = {
    UserName?: string;
    AccessKeyId?: string;
    Status?: 'Active' | 'Inactive';
    CreateDate?: Date;
  };
  declare type IAM$20100508$ActionNameListType = string[];
  declare type IAM$20100508$AddClientIDToOpenIDConnectProviderRequest = {
    OpenIDConnectProviderArn: string;
    ClientID: string;
  };
  declare type IAM$20100508$AddRoleToInstanceProfileRequest = {
    InstanceProfileName: string;
    RoleName: string;
  };
  declare type IAM$20100508$AddUserToGroupRequest = {
    GroupName: string;
    UserName: string;
  };
  declare type IAM$20100508$AttachGroupPolicyRequest = {
    GroupName: string;
    PolicyArn: string;
  };
  declare type IAM$20100508$AttachRolePolicyRequest = {
    RoleName: string;
    PolicyArn: string;
  };
  declare type IAM$20100508$AttachUserPolicyRequest = {
    UserName: string;
    PolicyArn: string;
  };
  declare type IAM$20100508$AttachedPolicy = {
    PolicyName?: string;
    PolicyArn?: string;
  };
  declare type IAM$20100508$BootstrapDatum = Buffer | $TypedArray | Blob | string;
  declare type IAM$20100508$ChangePasswordRequest = {
    OldPassword: string;
    NewPassword: string;
  };
  declare type IAM$20100508$ContextEntry = {
    ContextKeyName?: string;
    ContextKeyValues?: IAM$20100508$ContextKeyValueListType;
    ContextKeyType?: 'string' | 'stringList' | 'numeric' | 'numericList' | 'boolean' | 'booleanList' | 'ip' | 'ipList' | 'binary' | 'binaryList' | 'date' | 'dateList';
  };
  declare type IAM$20100508$ContextEntryListType = IAM$20100508$ContextEntry[];
  declare type IAM$20100508$ContextKeyNamesResultListType = string[];
  declare type IAM$20100508$ContextKeyTypeEnum = 'string' | 'stringList' | 'numeric' | 'numericList' | 'boolean' | 'booleanList' | 'ip' | 'ipList' | 'binary' | 'binaryList' | 'date' | 'dateList';
  declare type IAM$20100508$ContextKeyValueListType = string[];
  declare type IAM$20100508$CreateAccessKeyRequest = {
    UserName?: string;
  };
  declare type IAM$20100508$CreateAccessKeyResponse = {
    AccessKey: IAM$20100508$AccessKey;
  };
  declare type IAM$20100508$CreateAccountAliasRequest = {
    AccountAlias: string;
  };
  declare type IAM$20100508$CreateGroupRequest = {
    Path?: string;
    GroupName: string;
  };
  declare type IAM$20100508$CreateGroupResponse = {
    Group: IAM$20100508$Group;
  };
  declare type IAM$20100508$CreateInstanceProfileRequest = {
    InstanceProfileName: string;
    Path?: string;
  };
  declare type IAM$20100508$CreateInstanceProfileResponse = {
    InstanceProfile: IAM$20100508$InstanceProfile;
  };
  declare type IAM$20100508$CreateLoginProfileRequest = {
    UserName: string;
    Password: string;
    PasswordResetRequired?: boolean;
  };
  declare type IAM$20100508$CreateLoginProfileResponse = {
    LoginProfile: IAM$20100508$LoginProfile;
  };
  declare type IAM$20100508$CreateOpenIDConnectProviderRequest = {
    Url: string;
    ClientIDList?: IAM$20100508$clientIDListType;
    ThumbprintList: IAM$20100508$thumbprintListType;
  };
  declare type IAM$20100508$CreateOpenIDConnectProviderResponse = {
    OpenIDConnectProviderArn?: string;
  };
  declare type IAM$20100508$CreatePolicyRequest = {
    PolicyName: string;
    Path?: string;
    PolicyDocument: string;
    Description?: string;
  };
  declare type IAM$20100508$CreatePolicyResponse = {
    Policy?: IAM$20100508$Policy;
  };
  declare type IAM$20100508$CreatePolicyVersionRequest = {
    PolicyArn: string;
    PolicyDocument: string;
    SetAsDefault?: boolean;
  };
  declare type IAM$20100508$CreatePolicyVersionResponse = {
    PolicyVersion?: IAM$20100508$PolicyVersion;
  };
  declare type IAM$20100508$CreateRoleRequest = {
    Path?: string;
    RoleName: string;
    AssumeRolePolicyDocument: string;
  };
  declare type IAM$20100508$CreateRoleResponse = {
    Role: IAM$20100508$Role;
  };
  declare type IAM$20100508$CreateSAMLProviderRequest = {
    SAMLMetadataDocument: string;
    Name: string;
  };
  declare type IAM$20100508$CreateSAMLProviderResponse = {
    SAMLProviderArn?: string;
  };
  declare type IAM$20100508$CreateUserRequest = {
    Path?: string;
    UserName: string;
  };
  declare type IAM$20100508$CreateUserResponse = {
    User?: IAM$20100508$User;
  };
  declare type IAM$20100508$CreateVirtualMFADeviceRequest = {
    Path?: string;
    VirtualMFADeviceName: string;
  };
  declare type IAM$20100508$CreateVirtualMFADeviceResponse = {
    VirtualMFADevice: IAM$20100508$VirtualMFADevice;
  };
  declare type IAM$20100508$CredentialReportExpiredException = {
    message?: string;
  };
  declare type IAM$20100508$CredentialReportNotPresentException = {
    message?: string;
  };
  declare type IAM$20100508$CredentialReportNotReadyException = {
    message?: string;
  };
  declare type IAM$20100508$DeactivateMFADeviceRequest = {
    UserName: string;
    SerialNumber: string;
  };
  declare type IAM$20100508$DeleteAccessKeyRequest = {
    UserName?: string;
    AccessKeyId: string;
  };
  declare type IAM$20100508$DeleteAccountAliasRequest = {
    AccountAlias: string;
  };
  declare type IAM$20100508$DeleteConflictException = {
    message?: string;
  };
  declare type IAM$20100508$DeleteGroupPolicyRequest = {
    GroupName: string;
    PolicyName: string;
  };
  declare type IAM$20100508$DeleteGroupRequest = {
    GroupName: string;
  };
  declare type IAM$20100508$DeleteInstanceProfileRequest = {
    InstanceProfileName: string;
  };
  declare type IAM$20100508$DeleteLoginProfileRequest = {
    UserName: string;
  };
  declare type IAM$20100508$DeleteOpenIDConnectProviderRequest = {
    OpenIDConnectProviderArn: string;
  };
  declare type IAM$20100508$DeletePolicyRequest = {
    PolicyArn: string;
  };
  declare type IAM$20100508$DeletePolicyVersionRequest = {
    PolicyArn: string;
    VersionId: string;
  };
  declare type IAM$20100508$DeleteRolePolicyRequest = {
    RoleName: string;
    PolicyName: string;
  };
  declare type IAM$20100508$DeleteRoleRequest = {
    RoleName: string;
  };
  declare type IAM$20100508$DeleteSAMLProviderRequest = {
    SAMLProviderArn: string;
  };
  declare type IAM$20100508$DeleteSSHPublicKeyRequest = {
    UserName: string;
    SSHPublicKeyId: string;
  };
  declare type IAM$20100508$DeleteServerCertificateRequest = {
    ServerCertificateName: string;
  };
  declare type IAM$20100508$DeleteSigningCertificateRequest = {
    UserName?: string;
    CertificateId: string;
  };
  declare type IAM$20100508$DeleteUserPolicyRequest = {
    UserName: string;
    PolicyName: string;
  };
  declare type IAM$20100508$DeleteUserRequest = {
    UserName: string;
  };
  declare type IAM$20100508$DeleteVirtualMFADeviceRequest = {
    SerialNumber: string;
  };
  declare type IAM$20100508$DetachGroupPolicyRequest = {
    GroupName: string;
    PolicyArn: string;
  };
  declare type IAM$20100508$DetachRolePolicyRequest = {
    RoleName: string;
    PolicyArn: string;
  };
  declare type IAM$20100508$DetachUserPolicyRequest = {
    UserName: string;
    PolicyArn: string;
  };
  declare type IAM$20100508$DuplicateCertificateException = {
    message?: string;
  };
  declare type IAM$20100508$DuplicateSSHPublicKeyException = {
    message?: string;
  };
  declare type IAM$20100508$EnableMFADeviceRequest = {
    UserName: string;
    SerialNumber: string;
    AuthenticationCode1: string;
    AuthenticationCode2: string;
  };
  declare type IAM$20100508$EntityAlreadyExistsException = {
    message?: string;
  };
  declare type IAM$20100508$EntityTemporarilyUnmodifiableException = {
    message?: string;
  };
  declare type IAM$20100508$EntityType = 'User' | 'Role' | 'Group' | 'LocalManagedPolicy' | 'AWSManagedPolicy';
  declare type IAM$20100508$EvalDecisionDetailsType = {
    [key: string]: 'allowed' | 'explicitDeny' | 'implicitDeny';
  };
  declare type IAM$20100508$EvaluationResult = {
    EvalActionName: string;
    EvalResourceName?: string;
    EvalDecision: 'allowed' | 'explicitDeny' | 'implicitDeny';
    MatchedStatements?: IAM$20100508$StatementListType;
    MissingContextValues?: IAM$20100508$ContextKeyNamesResultListType;
    EvalDecisionDetails?: {
      [key: string]: 'allowed' | 'explicitDeny' | 'implicitDeny';
    };
    ResourceSpecificResults?: IAM$20100508$ResourceSpecificResultListType;
  };
  declare type IAM$20100508$EvaluationResultsListType = IAM$20100508$EvaluationResult[];
  declare type IAM$20100508$GenerateCredentialReportResponse = {
    State?: 'STARTED' | 'INPROGRESS' | 'COMPLETE';
    Description?: string;
  };
  declare type IAM$20100508$GetAccessKeyLastUsedRequest = {
    AccessKeyId: string;
  };
  declare type IAM$20100508$GetAccessKeyLastUsedResponse = {
    UserName?: string;
    AccessKeyLastUsed?: IAM$20100508$AccessKeyLastUsed;
  };
  declare type IAM$20100508$GetAccountAuthorizationDetailsRequest = {
    Filter?: IAM$20100508$entityListType;
    MaxItems?: number;
    Marker?: string;
  };
  declare type IAM$20100508$GetAccountAuthorizationDetailsResponse = {
    UserDetailList?: IAM$20100508$userDetailListType;
    GroupDetailList?: IAM$20100508$groupDetailListType;
    RoleDetailList?: IAM$20100508$roleDetailListType;
    Policies?: IAM$20100508$ManagedPolicyDetailListType;
    IsTruncated?: boolean;
    Marker?: string;
  };
  declare type IAM$20100508$GetAccountPasswordPolicyResponse = {
    PasswordPolicy: IAM$20100508$PasswordPolicy;
  };
  declare type IAM$20100508$GetAccountSummaryResponse = {
    SummaryMap?: {
      [key: 'Users' | 'UsersQuota' | 'Groups' | 'GroupsQuota' | 'ServerCertificates' | 'ServerCertificatesQuota' | 'UserPolicySizeQuota' | 'GroupPolicySizeQuota' | 'GroupsPerUserQuota' | 'SigningCertificatesPerUserQuota' | 'AccessKeysPerUserQuota' | 'MFADevices' | 'MFADevicesInUse' | 'AccountMFAEnabled' | 'AccountAccessKeysPresent' | 'AccountSigningCertificatesPresent' | 'AttachedPoliciesPerGroupQuota' | 'AttachedPoliciesPerRoleQuota' | 'AttachedPoliciesPerUserQuota' | 'Policies' | 'PoliciesQuota' | 'PolicySizeQuota' | 'PolicyVersionsInUse' | 'PolicyVersionsInUseQuota' | 'VersionsPerPolicyQuota']: number;
    };
  };
  declare type IAM$20100508$GetContextKeysForCustomPolicyRequest = {
    PolicyInputList: IAM$20100508$SimulationPolicyListType;
  };
  declare type IAM$20100508$GetContextKeysForPolicyResponse = {
    ContextKeyNames?: IAM$20100508$ContextKeyNamesResultListType;
  };
  declare type IAM$20100508$GetContextKeysForPrincipalPolicyRequest = {
    PolicySourceArn: string;
    PolicyInputList?: IAM$20100508$SimulationPolicyListType;
  };
  declare type IAM$20100508$GetCredentialReportResponse = {
    Content?: Buffer | $TypedArray | Blob | string;
    ReportFormat?: 'text/csv';
    GeneratedTime?: Date;
  };
  declare type IAM$20100508$GetGroupPolicyRequest = {
    GroupName: string;
    PolicyName: string;
  };
  declare type IAM$20100508$GetGroupPolicyResponse = {
    GroupName: string;
    PolicyName: string;
    PolicyDocument: string;
  };
  declare type IAM$20100508$GetGroupRequest = {
    GroupName: string;
    Marker?: string;
    MaxItems?: number;
  };
  declare type IAM$20100508$GetGroupResponse = {
    Group: IAM$20100508$Group;
    Users: IAM$20100508$userListType;
    IsTruncated?: boolean;
    Marker?: string;
  };
  declare type IAM$20100508$GetInstanceProfileRequest = {
    InstanceProfileName: string;
  };
  declare type IAM$20100508$GetInstanceProfileResponse = {
    InstanceProfile: IAM$20100508$InstanceProfile;
  };
  declare type IAM$20100508$GetLoginProfileRequest = {
    UserName: string;
  };
  declare type IAM$20100508$GetLoginProfileResponse = {
    LoginProfile: IAM$20100508$LoginProfile;
  };
  declare type IAM$20100508$GetOpenIDConnectProviderRequest = {
    OpenIDConnectProviderArn: string;
  };
  declare type IAM$20100508$GetOpenIDConnectProviderResponse = {
    Url?: string;
    ClientIDList?: IAM$20100508$clientIDListType;
    ThumbprintList?: IAM$20100508$thumbprintListType;
    CreateDate?: Date;
  };
  declare type IAM$20100508$GetPolicyRequest = {
    PolicyArn: string;
  };
  declare type IAM$20100508$GetPolicyResponse = {
    Policy?: IAM$20100508$Policy;
  };
  declare type IAM$20100508$GetPolicyVersionRequest = {
    PolicyArn: string;
    VersionId: string;
  };
  declare type IAM$20100508$GetPolicyVersionResponse = {
    PolicyVersion?: IAM$20100508$PolicyVersion;
  };
  declare type IAM$20100508$GetRolePolicyRequest = {
    RoleName: string;
    PolicyName: string;
  };
  declare type IAM$20100508$GetRolePolicyResponse = {
    RoleName: string;
    PolicyName: string;
    PolicyDocument: string;
  };
  declare type IAM$20100508$GetRoleRequest = {
    RoleName: string;
  };
  declare type IAM$20100508$GetRoleResponse = {
    Role: IAM$20100508$Role;
  };
  declare type IAM$20100508$GetSAMLProviderRequest = {
    SAMLProviderArn: string;
  };
  declare type IAM$20100508$GetSAMLProviderResponse = {
    SAMLMetadataDocument?: string;
    CreateDate?: Date;
    ValidUntil?: Date;
  };
  declare type IAM$20100508$GetSSHPublicKeyRequest = {
    UserName: string;
    SSHPublicKeyId: string;
    Encoding: 'SSH' | 'PEM';
  };
  declare type IAM$20100508$GetSSHPublicKeyResponse = {
    SSHPublicKey?: IAM$20100508$SSHPublicKey;
  };
  declare type IAM$20100508$GetServerCertificateRequest = {
    ServerCertificateName: string;
  };
  declare type IAM$20100508$GetServerCertificateResponse = {
    ServerCertificate: IAM$20100508$ServerCertificate;
  };
  declare type IAM$20100508$GetUserPolicyRequest = {
    UserName: string;
    PolicyName: string;
  };
  declare type IAM$20100508$GetUserPolicyResponse = {
    UserName: string;
    PolicyName: string;
    PolicyDocument: string;
  };
  declare type IAM$20100508$GetUserRequest = {
    UserName?: string;
  };
  declare type IAM$20100508$GetUserResponse = {
    User: IAM$20100508$User;
  };
  declare type IAM$20100508$Group = {
    Path: string;
    GroupName: string;
    GroupId: string;
    Arn: string;
    CreateDate: Date;
  };
  declare type IAM$20100508$GroupDetail = {
    Path?: string;
    GroupName?: string;
    GroupId?: string;
    Arn?: string;
    CreateDate?: Date;
    GroupPolicyList?: IAM$20100508$policyDetailListType;
    AttachedManagedPolicies?: IAM$20100508$attachedPoliciesListType;
  };
  declare type IAM$20100508$InstanceProfile = {
    Path: string;
    InstanceProfileName: string;
    InstanceProfileId: string;
    Arn: string;
    CreateDate: Date;
    Roles: IAM$20100508$roleListType;
  };
  declare type IAM$20100508$InvalidAuthenticationCodeException = {
    message?: string;
  };
  declare type IAM$20100508$InvalidCertificateException = {
    message?: string;
  };
  declare type IAM$20100508$InvalidInputException = {
    message?: string;
  };
  declare type IAM$20100508$InvalidPublicKeyException = {
    message?: string;
  };
  declare type IAM$20100508$InvalidUserTypeException = {
    message?: string;
  };
  declare type IAM$20100508$KeyPairMismatchException = {
    message?: string;
  };
  declare type IAM$20100508$LimitExceededException = {
    message?: string;
  };
  declare type IAM$20100508$ListAccessKeysRequest = {
    UserName?: string;
    Marker?: string;
    MaxItems?: number;
  };
  declare type IAM$20100508$ListAccessKeysResponse = {
    AccessKeyMetadata: IAM$20100508$accessKeyMetadataListType;
    IsTruncated?: boolean;
    Marker?: string;
  };
  declare type IAM$20100508$ListAccountAliasesRequest = {
    Marker?: string;
    MaxItems?: number;
  };
  declare type IAM$20100508$ListAccountAliasesResponse = {
    AccountAliases: IAM$20100508$accountAliasListType;
    IsTruncated?: boolean;
    Marker?: string;
  };
  declare type IAM$20100508$ListAttachedGroupPoliciesRequest = {
    GroupName: string;
    PathPrefix?: string;
    Marker?: string;
    MaxItems?: number;
  };
  declare type IAM$20100508$ListAttachedGroupPoliciesResponse = {
    AttachedPolicies?: IAM$20100508$attachedPoliciesListType;
    IsTruncated?: boolean;
    Marker?: string;
  };
  declare type IAM$20100508$ListAttachedRolePoliciesRequest = {
    RoleName: string;
    PathPrefix?: string;
    Marker?: string;
    MaxItems?: number;
  };
  declare type IAM$20100508$ListAttachedRolePoliciesResponse = {
    AttachedPolicies?: IAM$20100508$attachedPoliciesListType;
    IsTruncated?: boolean;
    Marker?: string;
  };
  declare type IAM$20100508$ListAttachedUserPoliciesRequest = {
    UserName: string;
    PathPrefix?: string;
    Marker?: string;
    MaxItems?: number;
  };
  declare type IAM$20100508$ListAttachedUserPoliciesResponse = {
    AttachedPolicies?: IAM$20100508$attachedPoliciesListType;
    IsTruncated?: boolean;
    Marker?: string;
  };
  declare type IAM$20100508$ListEntitiesForPolicyRequest = {
    PolicyArn: string;
    EntityFilter?: 'User' | 'Role' | 'Group' | 'LocalManagedPolicy' | 'AWSManagedPolicy';
    PathPrefix?: string;
    Marker?: string;
    MaxItems?: number;
  };
  declare type IAM$20100508$ListEntitiesForPolicyResponse = {
    PolicyGroups?: IAM$20100508$PolicyGroupListType;
    PolicyUsers?: IAM$20100508$PolicyUserListType;
    PolicyRoles?: IAM$20100508$PolicyRoleListType;
    IsTruncated?: boolean;
    Marker?: string;
  };
  declare type IAM$20100508$ListGroupPoliciesRequest = {
    GroupName: string;
    Marker?: string;
    MaxItems?: number;
  };
  declare type IAM$20100508$ListGroupPoliciesResponse = {
    PolicyNames: IAM$20100508$policyNameListType;
    IsTruncated?: boolean;
    Marker?: string;
  };
  declare type IAM$20100508$ListGroupsForUserRequest = {
    UserName: string;
    Marker?: string;
    MaxItems?: number;
  };
  declare type IAM$20100508$ListGroupsForUserResponse = {
    Groups: IAM$20100508$groupListType;
    IsTruncated?: boolean;
    Marker?: string;
  };
  declare type IAM$20100508$ListGroupsRequest = {
    PathPrefix?: string;
    Marker?: string;
    MaxItems?: number;
  };
  declare type IAM$20100508$ListGroupsResponse = {
    Groups: IAM$20100508$groupListType;
    IsTruncated?: boolean;
    Marker?: string;
  };
  declare type IAM$20100508$ListInstanceProfilesForRoleRequest = {
    RoleName: string;
    Marker?: string;
    MaxItems?: number;
  };
  declare type IAM$20100508$ListInstanceProfilesForRoleResponse = {
    InstanceProfiles: IAM$20100508$instanceProfileListType;
    IsTruncated?: boolean;
    Marker?: string;
  };
  declare type IAM$20100508$ListInstanceProfilesRequest = {
    PathPrefix?: string;
    Marker?: string;
    MaxItems?: number;
  };
  declare type IAM$20100508$ListInstanceProfilesResponse = {
    InstanceProfiles: IAM$20100508$instanceProfileListType;
    IsTruncated?: boolean;
    Marker?: string;
  };
  declare type IAM$20100508$ListMFADevicesRequest = {
    UserName?: string;
    Marker?: string;
    MaxItems?: number;
  };
  declare type IAM$20100508$ListMFADevicesResponse = {
    MFADevices: IAM$20100508$mfaDeviceListType;
    IsTruncated?: boolean;
    Marker?: string;
  };
  declare type IAM$20100508$ListOpenIDConnectProvidersRequest = {};
  declare type IAM$20100508$ListOpenIDConnectProvidersResponse = {
    OpenIDConnectProviderList?: IAM$20100508$OpenIDConnectProviderListType;
  };
  declare type IAM$20100508$ListPoliciesRequest = {
    Scope?: 'All' | 'AWS' | 'Local';
    OnlyAttached?: boolean;
    PathPrefix?: string;
    Marker?: string;
    MaxItems?: number;
  };
  declare type IAM$20100508$ListPoliciesResponse = {
    Policies?: IAM$20100508$policyListType;
    IsTruncated?: boolean;
    Marker?: string;
  };
  declare type IAM$20100508$ListPolicyVersionsRequest = {
    PolicyArn: string;
    Marker?: string;
    MaxItems?: number;
  };
  declare type IAM$20100508$ListPolicyVersionsResponse = {
    Versions?: IAM$20100508$policyDocumentVersionListType;
    IsTruncated?: boolean;
    Marker?: string;
  };
  declare type IAM$20100508$ListRolePoliciesRequest = {
    RoleName: string;
    Marker?: string;
    MaxItems?: number;
  };
  declare type IAM$20100508$ListRolePoliciesResponse = {
    PolicyNames: IAM$20100508$policyNameListType;
    IsTruncated?: boolean;
    Marker?: string;
  };
  declare type IAM$20100508$ListRolesRequest = {
    PathPrefix?: string;
    Marker?: string;
    MaxItems?: number;
  };
  declare type IAM$20100508$ListRolesResponse = {
    Roles: IAM$20100508$roleListType;
    IsTruncated?: boolean;
    Marker?: string;
  };
  declare type IAM$20100508$ListSAMLProvidersRequest = {};
  declare type IAM$20100508$ListSAMLProvidersResponse = {
    SAMLProviderList?: IAM$20100508$SAMLProviderListType;
  };
  declare type IAM$20100508$ListSSHPublicKeysRequest = {
    UserName?: string;
    Marker?: string;
    MaxItems?: number;
  };
  declare type IAM$20100508$ListSSHPublicKeysResponse = {
    SSHPublicKeys?: IAM$20100508$SSHPublicKeyListType;
    IsTruncated?: boolean;
    Marker?: string;
  };
  declare type IAM$20100508$ListServerCertificatesRequest = {
    PathPrefix?: string;
    Marker?: string;
    MaxItems?: number;
  };
  declare type IAM$20100508$ListServerCertificatesResponse = {
    ServerCertificateMetadataList: IAM$20100508$serverCertificateMetadataListType;
    IsTruncated?: boolean;
    Marker?: string;
  };
  declare type IAM$20100508$ListSigningCertificatesRequest = {
    UserName?: string;
    Marker?: string;
    MaxItems?: number;
  };
  declare type IAM$20100508$ListSigningCertificatesResponse = {
    Certificates: IAM$20100508$certificateListType;
    IsTruncated?: boolean;
    Marker?: string;
  };
  declare type IAM$20100508$ListUserPoliciesRequest = {
    UserName: string;
    Marker?: string;
    MaxItems?: number;
  };
  declare type IAM$20100508$ListUserPoliciesResponse = {
    PolicyNames: IAM$20100508$policyNameListType;
    IsTruncated?: boolean;
    Marker?: string;
  };
  declare type IAM$20100508$ListUsersRequest = {
    PathPrefix?: string;
    Marker?: string;
    MaxItems?: number;
  };
  declare type IAM$20100508$ListUsersResponse = {
    Users: IAM$20100508$userListType;
    IsTruncated?: boolean;
    Marker?: string;
  };
  declare type IAM$20100508$ListVirtualMFADevicesRequest = {
    AssignmentStatus?: 'Assigned' | 'Unassigned' | 'Any';
    Marker?: string;
    MaxItems?: number;
  };
  declare type IAM$20100508$ListVirtualMFADevicesResponse = {
    VirtualMFADevices: IAM$20100508$virtualMFADeviceListType;
    IsTruncated?: boolean;
    Marker?: string;
  };
  declare type IAM$20100508$LoginProfile = {
    UserName: string;
    CreateDate: Date;
    PasswordResetRequired?: boolean;
  };
  declare type IAM$20100508$MFADevice = {
    UserName: string;
    SerialNumber: string;
    EnableDate: Date;
  };
  declare type IAM$20100508$MalformedCertificateException = {
    message?: string;
  };
  declare type IAM$20100508$MalformedPolicyDocumentException = {
    message?: string;
  };
  declare type IAM$20100508$ManagedPolicyDetail = {
    PolicyName?: string;
    PolicyId?: string;
    Arn?: string;
    Path?: string;
    DefaultVersionId?: string;
    AttachmentCount?: number;
    IsAttachable?: boolean;
    Description?: string;
    CreateDate?: Date;
    UpdateDate?: Date;
    PolicyVersionList?: IAM$20100508$policyDocumentVersionListType;
  };
  declare type IAM$20100508$ManagedPolicyDetailListType = IAM$20100508$ManagedPolicyDetail[];
  declare type IAM$20100508$NoSuchEntityException = {
    message?: string;
  };
  declare type IAM$20100508$OpenIDConnectProviderListEntry = {
    Arn?: string;
  };
  declare type IAM$20100508$OpenIDConnectProviderListType = IAM$20100508$OpenIDConnectProviderListEntry[];
  declare type IAM$20100508$PasswordPolicy = {
    MinimumPasswordLength?: number;
    RequireSymbols?: boolean;
    RequireNumbers?: boolean;
    RequireUppercaseCharacters?: boolean;
    RequireLowercaseCharacters?: boolean;
    AllowUsersToChangePassword?: boolean;
    ExpirePasswords?: boolean;
    MaxPasswordAge?: number;
    PasswordReusePrevention?: number;
    HardExpiry?: boolean;
  };
  declare type IAM$20100508$PasswordPolicyViolationException = {
    message?: string;
  };
  declare type IAM$20100508$Policy = {
    PolicyName?: string;
    PolicyId?: string;
    Arn?: string;
    Path?: string;
    DefaultVersionId?: string;
    AttachmentCount?: number;
    IsAttachable?: boolean;
    Description?: string;
    CreateDate?: Date;
    UpdateDate?: Date;
  };
  declare type IAM$20100508$PolicyDetail = {
    PolicyName?: string;
    PolicyDocument?: string;
  };
  declare type IAM$20100508$PolicyEvaluationDecisionType = 'allowed' | 'explicitDeny' | 'implicitDeny';
  declare type IAM$20100508$PolicyEvaluationException = {
    message?: string;
  };
  declare type IAM$20100508$PolicyGroup = {
    GroupName?: string;
    GroupId?: string;
  };
  declare type IAM$20100508$PolicyGroupListType = IAM$20100508$PolicyGroup[];
  declare type IAM$20100508$PolicyRole = {
    RoleName?: string;
    RoleId?: string;
  };
  declare type IAM$20100508$PolicyRoleListType = IAM$20100508$PolicyRole[];
  declare type IAM$20100508$PolicySourceType = 'user' | 'group' | 'role' | 'aws-managed' | 'user-managed' | 'resource' | 'none';
  declare type IAM$20100508$PolicyUser = {
    UserName?: string;
    UserId?: string;
  };
  declare type IAM$20100508$PolicyUserListType = IAM$20100508$PolicyUser[];
  declare type IAM$20100508$PolicyVersion = {
    Document?: string;
    VersionId?: string;
    IsDefaultVersion?: boolean;
    CreateDate?: Date;
  };
  declare type IAM$20100508$Position = {
    Line?: number;
    Column?: number;
  };
  declare type IAM$20100508$PutGroupPolicyRequest = {
    GroupName: string;
    PolicyName: string;
    PolicyDocument: string;
  };
  declare type IAM$20100508$PutRolePolicyRequest = {
    RoleName: string;
    PolicyName: string;
    PolicyDocument: string;
  };
  declare type IAM$20100508$PutUserPolicyRequest = {
    UserName: string;
    PolicyName: string;
    PolicyDocument: string;
  };
  declare type IAM$20100508$RemoveClientIDFromOpenIDConnectProviderRequest = {
    OpenIDConnectProviderArn: string;
    ClientID: string;
  };
  declare type IAM$20100508$RemoveRoleFromInstanceProfileRequest = {
    InstanceProfileName: string;
    RoleName: string;
  };
  declare type IAM$20100508$RemoveUserFromGroupRequest = {
    GroupName: string;
    UserName: string;
  };
  declare type IAM$20100508$ReportContentType = Buffer | $TypedArray | Blob | string;
  declare type IAM$20100508$ReportFormatType = 'text/csv';
  declare type IAM$20100508$ReportStateType = 'STARTED' | 'INPROGRESS' | 'COMPLETE';
  declare type IAM$20100508$ResourceNameListType = string[];
  declare type IAM$20100508$ResourceSpecificResult = {
    EvalResourceName: string;
    EvalResourceDecision: 'allowed' | 'explicitDeny' | 'implicitDeny';
    MatchedStatements?: IAM$20100508$StatementListType;
    MissingContextValues?: IAM$20100508$ContextKeyNamesResultListType;
    EvalDecisionDetails?: {
      [key: string]: 'allowed' | 'explicitDeny' | 'implicitDeny';
    };
  };
  declare type IAM$20100508$ResourceSpecificResultListType = IAM$20100508$ResourceSpecificResult[];
  declare type IAM$20100508$ResyncMFADeviceRequest = {
    UserName: string;
    SerialNumber: string;
    AuthenticationCode1: string;
    AuthenticationCode2: string;
  };
  declare type IAM$20100508$Role = {
    Path: string;
    RoleName: string;
    RoleId: string;
    Arn: string;
    CreateDate: Date;
    AssumeRolePolicyDocument?: string;
  };
  declare type IAM$20100508$RoleDetail = {
    Path?: string;
    RoleName?: string;
    RoleId?: string;
    Arn?: string;
    CreateDate?: Date;
    AssumeRolePolicyDocument?: string;
    InstanceProfileList?: IAM$20100508$instanceProfileListType;
    RolePolicyList?: IAM$20100508$policyDetailListType;
    AttachedManagedPolicies?: IAM$20100508$attachedPoliciesListType;
  };
  declare type IAM$20100508$SAMLProviderListEntry = {
    Arn?: string;
    ValidUntil?: Date;
    CreateDate?: Date;
  };
  declare type IAM$20100508$SAMLProviderListType = IAM$20100508$SAMLProviderListEntry[];
  declare type IAM$20100508$SSHPublicKey = {
    UserName: string;
    SSHPublicKeyId: string;
    Fingerprint: string;
    SSHPublicKeyBody: string;
    Status: 'Active' | 'Inactive';
    UploadDate?: Date;
  };
  declare type IAM$20100508$SSHPublicKeyListType = IAM$20100508$SSHPublicKeyMetadata[];
  declare type IAM$20100508$SSHPublicKeyMetadata = {
    UserName: string;
    SSHPublicKeyId: string;
    Status: 'Active' | 'Inactive';
    UploadDate: Date;
  };
  declare type IAM$20100508$ServerCertificate = {
    ServerCertificateMetadata: IAM$20100508$ServerCertificateMetadata;
    CertificateBody: string;
    CertificateChain?: string;
  };
  declare type IAM$20100508$ServerCertificateMetadata = {
    Path: string;
    ServerCertificateName: string;
    ServerCertificateId: string;
    Arn: string;
    UploadDate?: Date;
    Expiration?: Date;
  };
  declare type IAM$20100508$ServiceFailureException = {
    message?: string;
  };
  declare type IAM$20100508$SetDefaultPolicyVersionRequest = {
    PolicyArn: string;
    VersionId: string;
  };
  declare type IAM$20100508$SigningCertificate = {
    UserName: string;
    CertificateId: string;
    CertificateBody: string;
    Status: 'Active' | 'Inactive';
    UploadDate?: Date;
  };
  declare type IAM$20100508$SimulateCustomPolicyRequest = {
    PolicyInputList: IAM$20100508$SimulationPolicyListType;
    ActionNames: IAM$20100508$ActionNameListType;
    ResourceArns?: IAM$20100508$ResourceNameListType;
    ResourcePolicy?: string;
    ResourceOwner?: string;
    CallerArn?: string;
    ContextEntries?: IAM$20100508$ContextEntryListType;
    ResourceHandlingOption?: string;
    MaxItems?: number;
    Marker?: string;
  };
  declare type IAM$20100508$SimulatePolicyResponse = {
    EvaluationResults?: IAM$20100508$EvaluationResultsListType;
    IsTruncated?: boolean;
    Marker?: string;
  };
  declare type IAM$20100508$SimulatePrincipalPolicyRequest = {
    PolicySourceArn: string;
    PolicyInputList?: IAM$20100508$SimulationPolicyListType;
    ActionNames: IAM$20100508$ActionNameListType;
    ResourceArns?: IAM$20100508$ResourceNameListType;
    ResourcePolicy?: string;
    ResourceOwner?: string;
    CallerArn?: string;
    ContextEntries?: IAM$20100508$ContextEntryListType;
    ResourceHandlingOption?: string;
    MaxItems?: number;
    Marker?: string;
  };
  declare type IAM$20100508$SimulationPolicyListType = string[];
  declare type IAM$20100508$Statement = {
    SourcePolicyId?: string;
    SourcePolicyType?: 'user' | 'group' | 'role' | 'aws-managed' | 'user-managed' | 'resource' | 'none';
    StartPosition?: IAM$20100508$Position;
    EndPosition?: IAM$20100508$Position;
  };
  declare type IAM$20100508$StatementListType = IAM$20100508$Statement[];
  declare type IAM$20100508$UnrecognizedPublicKeyEncodingException = {
    message?: string;
  };
  declare type IAM$20100508$UpdateAccessKeyRequest = {
    UserName?: string;
    AccessKeyId: string;
    Status: 'Active' | 'Inactive';
  };
  declare type IAM$20100508$UpdateAccountPasswordPolicyRequest = {
    MinimumPasswordLength?: number;
    RequireSymbols?: boolean;
    RequireNumbers?: boolean;
    RequireUppercaseCharacters?: boolean;
    RequireLowercaseCharacters?: boolean;
    AllowUsersToChangePassword?: boolean;
    MaxPasswordAge?: number;
    PasswordReusePrevention?: number;
    HardExpiry?: boolean;
  };
  declare type IAM$20100508$UpdateAssumeRolePolicyRequest = {
    RoleName: string;
    PolicyDocument: string;
  };
  declare type IAM$20100508$UpdateGroupRequest = {
    GroupName: string;
    NewPath?: string;
    NewGroupName?: string;
  };
  declare type IAM$20100508$UpdateLoginProfileRequest = {
    UserName: string;
    Password?: string;
    PasswordResetRequired?: boolean;
  };
  declare type IAM$20100508$UpdateOpenIDConnectProviderThumbprintRequest = {
    OpenIDConnectProviderArn: string;
    ThumbprintList: IAM$20100508$thumbprintListType;
  };
  declare type IAM$20100508$UpdateSAMLProviderRequest = {
    SAMLMetadataDocument: string;
    SAMLProviderArn: string;
  };
  declare type IAM$20100508$UpdateSAMLProviderResponse = {
    SAMLProviderArn?: string;
  };
  declare type IAM$20100508$UpdateSSHPublicKeyRequest = {
    UserName: string;
    SSHPublicKeyId: string;
    Status: 'Active' | 'Inactive';
  };
  declare type IAM$20100508$UpdateServerCertificateRequest = {
    ServerCertificateName: string;
    NewPath?: string;
    NewServerCertificateName?: string;
  };
  declare type IAM$20100508$UpdateSigningCertificateRequest = {
    UserName?: string;
    CertificateId: string;
    Status: 'Active' | 'Inactive';
  };
  declare type IAM$20100508$UpdateUserRequest = {
    UserName: string;
    NewPath?: string;
    NewUserName?: string;
  };
  declare type IAM$20100508$UploadSSHPublicKeyRequest = {
    UserName: string;
    SSHPublicKeyBody: string;
  };
  declare type IAM$20100508$UploadSSHPublicKeyResponse = {
    SSHPublicKey?: IAM$20100508$SSHPublicKey;
  };
  declare type IAM$20100508$UploadServerCertificateRequest = {
    Path?: string;
    ServerCertificateName: string;
    CertificateBody: string;
    PrivateKey: string;
    CertificateChain?: string;
  };
  declare type IAM$20100508$UploadServerCertificateResponse = {
    ServerCertificateMetadata?: IAM$20100508$ServerCertificateMetadata;
  };
  declare type IAM$20100508$UploadSigningCertificateRequest = {
    UserName?: string;
    CertificateBody: string;
  };
  declare type IAM$20100508$UploadSigningCertificateResponse = {
    Certificate: IAM$20100508$SigningCertificate;
  };
  declare type IAM$20100508$User = {
    Path: string;
    UserName: string;
    UserId: string;
    Arn: string;
    CreateDate: Date;
    PasswordLastUsed?: Date;
  };
  declare type IAM$20100508$UserDetail = {
    Path?: string;
    UserName?: string;
    UserId?: string;
    Arn?: string;
    CreateDate?: Date;
    UserPolicyList?: IAM$20100508$policyDetailListType;
    GroupList?: IAM$20100508$groupNameListType;
    AttachedManagedPolicies?: IAM$20100508$attachedPoliciesListType;
  };
  declare type IAM$20100508$VirtualMFADevice = {
    SerialNumber: string;
    Base32StringSeed?: Buffer | $TypedArray | Blob | string;
    QRCodePNG?: Buffer | $TypedArray | Blob | string;
    User?: IAM$20100508$User;
    EnableDate?: Date;
  };
  declare type IAM$20100508$accessKeyMetadataListType = IAM$20100508$AccessKeyMetadata[];
  declare type IAM$20100508$accountAliasListType = string[];
  declare type IAM$20100508$assignmentStatusType = 'Assigned' | 'Unassigned' | 'Any';
  declare type IAM$20100508$attachedPoliciesListType = IAM$20100508$AttachedPolicy[];
  declare type IAM$20100508$certificateListType = IAM$20100508$SigningCertificate[];
  declare type IAM$20100508$clientIDListType = string[];
  declare type IAM$20100508$dateType = Date;
  declare type IAM$20100508$encodingType = 'SSH' | 'PEM';
  declare type IAM$20100508$entityListType = ('User' | 'Role' | 'Group' | 'LocalManagedPolicy' | 'AWSManagedPolicy')[];
  declare type IAM$20100508$groupDetailListType = IAM$20100508$GroupDetail[];
  declare type IAM$20100508$groupListType = IAM$20100508$Group[];
  declare type IAM$20100508$groupNameListType = string[];
  declare type IAM$20100508$instanceProfileListType = IAM$20100508$InstanceProfile[];
  declare type IAM$20100508$mfaDeviceListType = IAM$20100508$MFADevice[];
  declare type IAM$20100508$policyDetailListType = IAM$20100508$PolicyDetail[];
  declare type IAM$20100508$policyDocumentVersionListType = IAM$20100508$PolicyVersion[];
  declare type IAM$20100508$policyListType = IAM$20100508$Policy[];
  declare type IAM$20100508$policyNameListType = string[];
  declare type IAM$20100508$policyScopeType = 'All' | 'AWS' | 'Local';
  declare type IAM$20100508$roleDetailListType = IAM$20100508$RoleDetail[];
  declare type IAM$20100508$roleListType = IAM$20100508$Role[];
  declare type IAM$20100508$serverCertificateMetadataListType = IAM$20100508$ServerCertificateMetadata[];
  declare type IAM$20100508$statusType = 'Active' | 'Inactive';
  declare type IAM$20100508$summaryKeyType = 'Users' | 'UsersQuota' | 'Groups' | 'GroupsQuota' | 'ServerCertificates' | 'ServerCertificatesQuota' | 'UserPolicySizeQuota' | 'GroupPolicySizeQuota' | 'GroupsPerUserQuota' | 'SigningCertificatesPerUserQuota' | 'AccessKeysPerUserQuota' | 'MFADevices' | 'MFADevicesInUse' | 'AccountMFAEnabled' | 'AccountAccessKeysPresent' | 'AccountSigningCertificatesPresent' | 'AttachedPoliciesPerGroupQuota' | 'AttachedPoliciesPerRoleQuota' | 'AttachedPoliciesPerUserQuota' | 'Policies' | 'PoliciesQuota' | 'PolicySizeQuota' | 'PolicyVersionsInUse' | 'PolicyVersionsInUseQuota' | 'VersionsPerPolicyQuota';
  declare type IAM$20100508$summaryMapType = {
    [key: 'Users' | 'UsersQuota' | 'Groups' | 'GroupsQuota' | 'ServerCertificates' | 'ServerCertificatesQuota' | 'UserPolicySizeQuota' | 'GroupPolicySizeQuota' | 'GroupsPerUserQuota' | 'SigningCertificatesPerUserQuota' | 'AccessKeysPerUserQuota' | 'MFADevices' | 'MFADevicesInUse' | 'AccountMFAEnabled' | 'AccountAccessKeysPresent' | 'AccountSigningCertificatesPresent' | 'AttachedPoliciesPerGroupQuota' | 'AttachedPoliciesPerRoleQuota' | 'AttachedPoliciesPerUserQuota' | 'Policies' | 'PoliciesQuota' | 'PolicySizeQuota' | 'PolicyVersionsInUse' | 'PolicyVersionsInUseQuota' | 'VersionsPerPolicyQuota']: number;
  };
  declare type IAM$20100508$thumbprintListType = string[];
  declare type IAM$20100508$userDetailListType = IAM$20100508$UserDetail[];
  declare type IAM$20100508$userListType = IAM$20100508$User[];
  declare type IAM$20100508$virtualMFADeviceListType = IAM$20100508$VirtualMFADevice[];
  declare type ImportExport$20100601$Artifact = {
    Description?: string;
    URL?: string;
  };
  declare type ImportExport$20100601$ArtifactList = ImportExport$20100601$Artifact[];
  declare type ImportExport$20100601$BucketPermissionException = {
    message?: string;
  };
  declare type ImportExport$20100601$CancelJobInput = {
    JobId: string;
    APIVersion?: string;
  };
  declare type ImportExport$20100601$CancelJobOutput = {
    Success?: boolean;
  };
  declare type ImportExport$20100601$CanceledJobIdException = {
    message?: string;
  };
  declare type ImportExport$20100601$CreateJobInput = {
    JobType: 'Import' | 'Export';
    Manifest: string;
    ManifestAddendum?: string;
    ValidateOnly: boolean;
    APIVersion?: string;
  };
  declare type ImportExport$20100601$CreateJobOutput = {
    JobId?: string;
    JobType?: 'Import' | 'Export';
    Signature?: string;
    SignatureFileContents?: string;
    WarningMessage?: string;
    ArtifactList?: ImportExport$20100601$ArtifactList;
  };
  declare type ImportExport$20100601$CreateJobQuotaExceededException = {
    message?: string;
  };
  declare type ImportExport$20100601$CreationDate = Date;
  declare type ImportExport$20100601$ExpiredJobIdException = {
    message?: string;
  };
  declare type ImportExport$20100601$GetShippingLabelInput = {
    jobIds: ImportExport$20100601$JobIdList;
    name?: string;
    company?: string;
    phoneNumber?: string;
    country?: string;
    stateOrProvince?: string;
    city?: string;
    postalCode?: string;
    street1?: string;
    street2?: string;
    street3?: string;
    APIVersion?: string;
  };
  declare type ImportExport$20100601$GetShippingLabelOutput = {
    ShippingLabelURL?: string;
    Warning?: string;
  };
  declare type ImportExport$20100601$GetStatusInput = {
    JobId: string;
    APIVersion?: string;
  };
  declare type ImportExport$20100601$GetStatusOutput = {
    JobId?: string;
    JobType?: 'Import' | 'Export';
    LocationCode?: string;
    LocationMessage?: string;
    ProgressCode?: string;
    ProgressMessage?: string;
    Carrier?: string;
    TrackingNumber?: string;
    LogBucket?: string;
    LogKey?: string;
    ErrorCount?: number;
    Signature?: string;
    SignatureFileContents?: string;
    CurrentManifest?: string;
    CreationDate?: Date;
    ArtifactList?: ImportExport$20100601$ArtifactList;
  };
  declare type ImportExport$20100601$InvalidAccessKeyIdException = {
    message?: string;
  };
  declare type ImportExport$20100601$InvalidAddressException = {
    message?: string;
  };
  declare type ImportExport$20100601$InvalidCustomsException = {
    message?: string;
  };
  declare type ImportExport$20100601$InvalidFileSystemException = {
    message?: string;
  };
  declare type ImportExport$20100601$InvalidJobIdException = {
    message?: string;
  };
  declare type ImportExport$20100601$InvalidManifestFieldException = {
    message?: string;
  };
  declare type ImportExport$20100601$InvalidParameterException = {
    message?: string;
  };
  declare type ImportExport$20100601$InvalidVersionException = {
    message?: string;
  };
  declare type ImportExport$20100601$Job = {
    JobId?: string;
    CreationDate?: Date;
    IsCanceled?: boolean;
    JobType?: 'Import' | 'Export';
  };
  declare type ImportExport$20100601$JobIdList = string[];
  declare type ImportExport$20100601$JobType = 'Import' | 'Export';
  declare type ImportExport$20100601$JobsList = ImportExport$20100601$Job[];
  declare type ImportExport$20100601$ListJobsInput = {
    MaxJobs?: number;
    Marker?: string;
    APIVersion?: string;
  };
  declare type ImportExport$20100601$ListJobsOutput = {
    Jobs?: ImportExport$20100601$JobsList;
    IsTruncated?: boolean;
  };
  declare type ImportExport$20100601$MalformedManifestException = {
    message?: string;
  };
  declare type ImportExport$20100601$MissingCustomsException = {
    message?: string;
  };
  declare type ImportExport$20100601$MissingManifestFieldException = {
    message?: string;
  };
  declare type ImportExport$20100601$MissingParameterException = {
    message?: string;
  };
  declare type ImportExport$20100601$MultipleRegionsException = {
    message?: string;
  };
  declare type ImportExport$20100601$NoSuchBucketException = {
    message?: string;
  };
  declare type ImportExport$20100601$UnableToCancelJobIdException = {
    message?: string;
  };
  declare type ImportExport$20100601$UnableToUpdateJobIdException = {
    message?: string;
  };
  declare type ImportExport$20100601$UpdateJobInput = {
    JobId: string;
    Manifest: string;
    JobType: 'Import' | 'Export';
    ValidateOnly: boolean;
    APIVersion?: string;
  };
  declare type ImportExport$20100601$UpdateJobOutput = {
    Success?: boolean;
    WarningMessage?: string;
    ArtifactList?: ImportExport$20100601$ArtifactList;
  };
  declare type Inspector$20160216$AccessDeniedErrorCode = 'ACCESS_DENIED_TO_ASSESSMENT_TARGET' | 'ACCESS_DENIED_TO_ASSESSMENT_TEMPLATE' | 'ACCESS_DENIED_TO_ASSESSMENT_RUN' | 'ACCESS_DENIED_TO_FINDING' | 'ACCESS_DENIED_TO_RESOURCE_GROUP' | 'ACCESS_DENIED_TO_RULES_PACKAGE' | 'ACCESS_DENIED_TO_SNS_TOPIC' | 'ACCESS_DENIED_TO_IAM_ROLE';
  declare type Inspector$20160216$AccessDeniedException = {
    message: string;
    errorCode: 'ACCESS_DENIED_TO_ASSESSMENT_TARGET' | 'ACCESS_DENIED_TO_ASSESSMENT_TEMPLATE' | 'ACCESS_DENIED_TO_ASSESSMENT_RUN' | 'ACCESS_DENIED_TO_FINDING' | 'ACCESS_DENIED_TO_RESOURCE_GROUP' | 'ACCESS_DENIED_TO_RULES_PACKAGE' | 'ACCESS_DENIED_TO_SNS_TOPIC' | 'ACCESS_DENIED_TO_IAM_ROLE';
    canRetry: boolean;
  };
  declare type Inspector$20160216$AddAttributesToFindingsRequest = {
    findingArns: Inspector$20160216$AddRemoveAttributesFindingArnList;
    attributes: Inspector$20160216$UserAttributeList;
  };
  declare type Inspector$20160216$AddAttributesToFindingsResponse = {
    failedItems: {
      [key: string]: Inspector$20160216$FailedItemDetails;
    };
  };
  declare type Inspector$20160216$AddRemoveAttributesFindingArnList = string[];
  declare type Inspector$20160216$AgentAlreadyRunningAssessment = {
    agentId: string;
    assessmentRunArn: string;
  };
  declare type Inspector$20160216$AgentAlreadyRunningAssessmentList = Inspector$20160216$AgentAlreadyRunningAssessment[];
  declare type Inspector$20160216$AgentFilter = {
    agentHealths: Inspector$20160216$AgentHealthList;
    agentHealthCodes: Inspector$20160216$AgentHealthCodeList;
  };
  declare type Inspector$20160216$AgentHealth = 'HEALTHY' | 'UNHEALTHY';
  declare type Inspector$20160216$AgentHealthCode = 'IDLE' | 'RUNNING' | 'SHUTDOWN' | 'UNHEALTHY' | 'THROTTLED' | 'UNKNOWN';
  declare type Inspector$20160216$AgentHealthCodeList = ('IDLE' | 'RUNNING' | 'SHUTDOWN' | 'UNHEALTHY' | 'THROTTLED' | 'UNKNOWN')[];
  declare type Inspector$20160216$AgentHealthList = ('HEALTHY' | 'UNHEALTHY')[];
  declare type Inspector$20160216$AgentIdList = string[];
  declare type Inspector$20160216$AgentPreview = {
    agentId: string;
    autoScalingGroup?: string;
  };
  declare type Inspector$20160216$AgentPreviewList = Inspector$20160216$AgentPreview[];
  declare type Inspector$20160216$AgentsAlreadyRunningAssessmentException = {
    message: string;
    agents: Inspector$20160216$AgentAlreadyRunningAssessmentList;
    agentsTruncated: boolean;
    canRetry: boolean;
  };
  declare type Inspector$20160216$AssessmentRulesPackageArnList = string[];
  declare type Inspector$20160216$AssessmentRun = {
    arn: string;
    name: string;
    assessmentTemplateArn: string;
    state: 'CREATED' | 'START_DATA_COLLECTION_PENDING' | 'START_DATA_COLLECTION_IN_PROGRESS' | 'COLLECTING_DATA' | 'STOP_DATA_COLLECTION_PENDING' | 'DATA_COLLECTED' | 'EVALUATING_RULES' | 'FAILED' | 'COMPLETED' | 'COMPLETED_WITH_ERRORS';
    durationInSeconds: number;
    rulesPackageArns: Inspector$20160216$AssessmentRulesPackageArnList;
    userAttributesForFindings: Inspector$20160216$UserAttributeList;
    createdAt: Date;
    startedAt?: Date;
    completedAt?: Date;
    stateChangedAt: Date;
    dataCollected: boolean;
    stateChanges: Inspector$20160216$AssessmentRunStateChangeList;
    notifications: Inspector$20160216$AssessmentRunNotificationList;
  };
  declare type Inspector$20160216$AssessmentRunAgent = {
    agentId: string;
    assessmentRunArn: string;
    agentHealth: 'HEALTHY' | 'UNHEALTHY';
    agentHealthCode: 'IDLE' | 'RUNNING' | 'SHUTDOWN' | 'UNHEALTHY' | 'THROTTLED' | 'UNKNOWN';
    agentHealthDetails?: string;
    autoScalingGroup?: string;
    telemetryMetadata: Inspector$20160216$TelemetryMetadataList;
  };
  declare type Inspector$20160216$AssessmentRunAgentList = Inspector$20160216$AssessmentRunAgent[];
  declare type Inspector$20160216$AssessmentRunFilter = {
    namePattern?: string;
    states?: Inspector$20160216$AssessmentRunStateList;
    durationRange?: Inspector$20160216$DurationRange;
    rulesPackageArns?: Inspector$20160216$FilterRulesPackageArnList;
    startTimeRange?: Inspector$20160216$TimestampRange;
    completionTimeRange?: Inspector$20160216$TimestampRange;
    stateChangeTimeRange?: Inspector$20160216$TimestampRange;
  };
  declare type Inspector$20160216$AssessmentRunInProgressArnList = string[];
  declare type Inspector$20160216$AssessmentRunInProgressException = {
    message: string;
    assessmentRunArns: Inspector$20160216$AssessmentRunInProgressArnList;
    assessmentRunArnsTruncated: boolean;
    canRetry: boolean;
  };
  declare type Inspector$20160216$AssessmentRunList = Inspector$20160216$AssessmentRun[];
  declare type Inspector$20160216$AssessmentRunNotification = {
    date: Date;
    event: 'ASSESSMENT_RUN_STARTED' | 'ASSESSMENT_RUN_COMPLETED' | 'ASSESSMENT_RUN_STATE_CHANGED' | 'FINDING_REPORTED' | 'OTHER';
    message?: string;
    error: boolean;
    snsTopicArn?: string;
    snsPublishStatusCode?: 'SUCCESS' | 'TOPIC_DOES_NOT_EXIST' | 'ACCESS_DENIED' | 'INTERNAL_ERROR';
  };
  declare type Inspector$20160216$AssessmentRunNotificationList = Inspector$20160216$AssessmentRunNotification[];
  declare type Inspector$20160216$AssessmentRunNotificationSnsStatusCode = 'SUCCESS' | 'TOPIC_DOES_NOT_EXIST' | 'ACCESS_DENIED' | 'INTERNAL_ERROR';
  declare type Inspector$20160216$AssessmentRunState = 'CREATED' | 'START_DATA_COLLECTION_PENDING' | 'START_DATA_COLLECTION_IN_PROGRESS' | 'COLLECTING_DATA' | 'STOP_DATA_COLLECTION_PENDING' | 'DATA_COLLECTED' | 'EVALUATING_RULES' | 'FAILED' | 'COMPLETED' | 'COMPLETED_WITH_ERRORS';
  declare type Inspector$20160216$AssessmentRunStateChange = {
    stateChangedAt: Date;
    state: 'CREATED' | 'START_DATA_COLLECTION_PENDING' | 'START_DATA_COLLECTION_IN_PROGRESS' | 'COLLECTING_DATA' | 'STOP_DATA_COLLECTION_PENDING' | 'DATA_COLLECTED' | 'EVALUATING_RULES' | 'FAILED' | 'COMPLETED' | 'COMPLETED_WITH_ERRORS';
  };
  declare type Inspector$20160216$AssessmentRunStateChangeList = Inspector$20160216$AssessmentRunStateChange[];
  declare type Inspector$20160216$AssessmentRunStateList = ('CREATED' | 'START_DATA_COLLECTION_PENDING' | 'START_DATA_COLLECTION_IN_PROGRESS' | 'COLLECTING_DATA' | 'STOP_DATA_COLLECTION_PENDING' | 'DATA_COLLECTED' | 'EVALUATING_RULES' | 'FAILED' | 'COMPLETED' | 'COMPLETED_WITH_ERRORS')[];
  declare type Inspector$20160216$AssessmentTarget = {
    arn: string;
    name: string;
    resourceGroupArn: string;
    createdAt: Date;
    updatedAt: Date;
  };
  declare type Inspector$20160216$AssessmentTargetFilter = {
    assessmentTargetNamePattern?: string;
  };
  declare type Inspector$20160216$AssessmentTargetList = Inspector$20160216$AssessmentTarget[];
  declare type Inspector$20160216$AssessmentTemplate = {
    arn: string;
    name: string;
    assessmentTargetArn: string;
    durationInSeconds: number;
    rulesPackageArns: Inspector$20160216$AssessmentTemplateRulesPackageArnList;
    userAttributesForFindings: Inspector$20160216$UserAttributeList;
    createdAt: Date;
  };
  declare type Inspector$20160216$AssessmentTemplateFilter = {
    namePattern?: string;
    durationRange?: Inspector$20160216$DurationRange;
    rulesPackageArns?: Inspector$20160216$FilterRulesPackageArnList;
  };
  declare type Inspector$20160216$AssessmentTemplateList = Inspector$20160216$AssessmentTemplate[];
  declare type Inspector$20160216$AssessmentTemplateRulesPackageArnList = string[];
  declare type Inspector$20160216$AssetAttributes = {
    schemaVersion: number;
    agentId?: string;
    autoScalingGroup?: string;
    amiId?: string;
    hostname?: string;
    ipv4Addresses?: Inspector$20160216$Ipv4AddressList;
  };
  declare type Inspector$20160216$AssetType = 'ec2-instance';
  declare type Inspector$20160216$Attribute = {
    key: string;
    value?: string;
  };
  declare type Inspector$20160216$AttributeList = Inspector$20160216$Attribute[];
  declare type Inspector$20160216$AutoScalingGroupList = string[];
  declare type Inspector$20160216$BatchDescribeArnList = string[];
  declare type Inspector$20160216$CreateAssessmentTargetRequest = {
    assessmentTargetName: string;
    resourceGroupArn: string;
  };
  declare type Inspector$20160216$CreateAssessmentTargetResponse = {
    assessmentTargetArn: string;
  };
  declare type Inspector$20160216$CreateAssessmentTemplateRequest = {
    assessmentTargetArn: string;
    assessmentTemplateName: string;
    durationInSeconds: number;
    rulesPackageArns: Inspector$20160216$AssessmentTemplateRulesPackageArnList;
    userAttributesForFindings?: Inspector$20160216$UserAttributeList;
  };
  declare type Inspector$20160216$CreateAssessmentTemplateResponse = {
    assessmentTemplateArn: string;
  };
  declare type Inspector$20160216$CreateResourceGroupRequest = {
    resourceGroupTags: Inspector$20160216$ResourceGroupTags;
  };
  declare type Inspector$20160216$CreateResourceGroupResponse = {
    resourceGroupArn: string;
  };
  declare type Inspector$20160216$DeleteAssessmentRunRequest = {
    assessmentRunArn: string;
  };
  declare type Inspector$20160216$DeleteAssessmentTargetRequest = {
    assessmentTargetArn: string;
  };
  declare type Inspector$20160216$DeleteAssessmentTemplateRequest = {
    assessmentTemplateArn: string;
  };
  declare type Inspector$20160216$DescribeAssessmentRunsRequest = {
    assessmentRunArns: Inspector$20160216$BatchDescribeArnList;
  };
  declare type Inspector$20160216$DescribeAssessmentRunsResponse = {
    assessmentRuns: Inspector$20160216$AssessmentRunList;
    failedItems: {
      [key: string]: Inspector$20160216$FailedItemDetails;
    };
  };
  declare type Inspector$20160216$DescribeAssessmentTargetsRequest = {
    assessmentTargetArns: Inspector$20160216$BatchDescribeArnList;
  };
  declare type Inspector$20160216$DescribeAssessmentTargetsResponse = {
    assessmentTargets: Inspector$20160216$AssessmentTargetList;
    failedItems: {
      [key: string]: Inspector$20160216$FailedItemDetails;
    };
  };
  declare type Inspector$20160216$DescribeAssessmentTemplatesRequest = {
    assessmentTemplateArns: Inspector$20160216$BatchDescribeArnList;
  };
  declare type Inspector$20160216$DescribeAssessmentTemplatesResponse = {
    assessmentTemplates: Inspector$20160216$AssessmentTemplateList;
    failedItems: {
      [key: string]: Inspector$20160216$FailedItemDetails;
    };
  };
  declare type Inspector$20160216$DescribeCrossAccountAccessRoleResponse = {
    roleArn: string;
    valid: boolean;
    registeredAt: Date;
  };
  declare type Inspector$20160216$DescribeFindingsRequest = {
    findingArns: Inspector$20160216$BatchDescribeArnList;
    locale?: 'EN_US';
  };
  declare type Inspector$20160216$DescribeFindingsResponse = {
    findings: Inspector$20160216$FindingList;
    failedItems: {
      [key: string]: Inspector$20160216$FailedItemDetails;
    };
  };
  declare type Inspector$20160216$DescribeResourceGroupsRequest = {
    resourceGroupArns: Inspector$20160216$BatchDescribeArnList;
  };
  declare type Inspector$20160216$DescribeResourceGroupsResponse = {
    resourceGroups: Inspector$20160216$ResourceGroupList;
    failedItems: {
      [key: string]: Inspector$20160216$FailedItemDetails;
    };
  };
  declare type Inspector$20160216$DescribeRulesPackagesRequest = {
    rulesPackageArns: Inspector$20160216$BatchDescribeArnList;
    locale?: 'EN_US';
  };
  declare type Inspector$20160216$DescribeRulesPackagesResponse = {
    rulesPackages: Inspector$20160216$RulesPackageList;
    failedItems: {
      [key: string]: Inspector$20160216$FailedItemDetails;
    };
  };
  declare type Inspector$20160216$DurationRange = {
    minSeconds?: number;
    maxSeconds?: number;
  };
  declare type Inspector$20160216$EventSubscription = {
    event: 'ASSESSMENT_RUN_STARTED' | 'ASSESSMENT_RUN_COMPLETED' | 'ASSESSMENT_RUN_STATE_CHANGED' | 'FINDING_REPORTED' | 'OTHER';
    subscribedAt: Date;
  };
  declare type Inspector$20160216$EventSubscriptionList = Inspector$20160216$EventSubscription[];
  declare type Inspector$20160216$FailedItemDetails = {
    failureCode: 'INVALID_ARN' | 'DUPLICATE_ARN' | 'ITEM_DOES_NOT_EXIST' | 'ACCESS_DENIED' | 'LIMIT_EXCEEDED' | 'INTERNAL_ERROR';
    retryable: boolean;
  };
  declare type Inspector$20160216$FailedItemErrorCode = 'INVALID_ARN' | 'DUPLICATE_ARN' | 'ITEM_DOES_NOT_EXIST' | 'ACCESS_DENIED' | 'LIMIT_EXCEEDED' | 'INTERNAL_ERROR';
  declare type Inspector$20160216$FailedItems = {
    [key: string]: Inspector$20160216$FailedItemDetails;
  };
  declare type Inspector$20160216$FilterRulesPackageArnList = string[];
  declare type Inspector$20160216$Finding = {
    arn: string;
    schemaVersion?: number;
    service?: string;
    serviceAttributes?: Inspector$20160216$InspectorServiceAttributes;
    assetType?: 'ec2-instance';
    assetAttributes?: Inspector$20160216$AssetAttributes;
    id?: string;
    title?: string;
    description?: string;
    recommendation?: string;
    severity?: 'Low' | 'Medium' | 'High' | 'Informational' | 'Undefined';
    numericSeverity?: number;
    confidence?: number;
    indicatorOfCompromise?: boolean;
    attributes: Inspector$20160216$AttributeList;
    userAttributes: Inspector$20160216$UserAttributeList;
    createdAt: Date;
    updatedAt: Date;
  };
  declare type Inspector$20160216$FindingFilter = {
    agentIds?: Inspector$20160216$AgentIdList;
    autoScalingGroups?: Inspector$20160216$AutoScalingGroupList;
    ruleNames?: Inspector$20160216$RuleNameList;
    severities?: Inspector$20160216$SeverityList;
    rulesPackageArns?: Inspector$20160216$FilterRulesPackageArnList;
    attributes?: Inspector$20160216$AttributeList;
    userAttributes?: Inspector$20160216$AttributeList;
    creationTimeRange?: Inspector$20160216$TimestampRange;
  };
  declare type Inspector$20160216$FindingList = Inspector$20160216$Finding[];
  declare type Inspector$20160216$GetTelemetryMetadataRequest = {
    assessmentRunArn: string;
  };
  declare type Inspector$20160216$GetTelemetryMetadataResponse = {
    telemetryMetadata: Inspector$20160216$TelemetryMetadataList;
  };
  declare type Inspector$20160216$InspectorEvent = 'ASSESSMENT_RUN_STARTED' | 'ASSESSMENT_RUN_COMPLETED' | 'ASSESSMENT_RUN_STATE_CHANGED' | 'FINDING_REPORTED' | 'OTHER';
  declare type Inspector$20160216$InspectorServiceAttributes = {
    schemaVersion: number;
    assessmentRunArn?: string;
    rulesPackageArn?: string;
  };
  declare type Inspector$20160216$InternalException = {
    message: string;
    canRetry: boolean;
  };
  declare type Inspector$20160216$InvalidCrossAccountRoleErrorCode = 'ROLE_DOES_NOT_EXIST_OR_INVALID_TRUST_RELATIONSHIP' | 'ROLE_DOES_NOT_HAVE_CORRECT_POLICY';
  declare type Inspector$20160216$InvalidCrossAccountRoleException = {
    message: string;
    errorCode: 'ROLE_DOES_NOT_EXIST_OR_INVALID_TRUST_RELATIONSHIP' | 'ROLE_DOES_NOT_HAVE_CORRECT_POLICY';
    canRetry: boolean;
  };
  declare type Inspector$20160216$InvalidInputErrorCode = 'INVALID_ASSESSMENT_TARGET_ARN' | 'INVALID_ASSESSMENT_TEMPLATE_ARN' | 'INVALID_ASSESSMENT_RUN_ARN' | 'INVALID_FINDING_ARN' | 'INVALID_RESOURCE_GROUP_ARN' | 'INVALID_RULES_PACKAGE_ARN' | 'INVALID_RESOURCE_ARN' | 'INVALID_SNS_TOPIC_ARN' | 'INVALID_IAM_ROLE_ARN' | 'INVALID_ASSESSMENT_TARGET_NAME' | 'INVALID_ASSESSMENT_TARGET_NAME_PATTERN' | 'INVALID_ASSESSMENT_TEMPLATE_NAME' | 'INVALID_ASSESSMENT_TEMPLATE_NAME_PATTERN' | 'INVALID_ASSESSMENT_TEMPLATE_DURATION' | 'INVALID_ASSESSMENT_TEMPLATE_DURATION_RANGE' | 'INVALID_ASSESSMENT_RUN_DURATION_RANGE' | 'INVALID_ASSESSMENT_RUN_START_TIME_RANGE' | 'INVALID_ASSESSMENT_RUN_COMPLETION_TIME_RANGE' | 'INVALID_ASSESSMENT_RUN_STATE_CHANGE_TIME_RANGE' | 'INVALID_ASSESSMENT_RUN_STATE' | 'INVALID_TAG' | 'INVALID_TAG_KEY' | 'INVALID_TAG_VALUE' | 'INVALID_RESOURCE_GROUP_TAG_KEY' | 'INVALID_RESOURCE_GROUP_TAG_VALUE' | 'INVALID_ATTRIBUTE' | 'INVALID_USER_ATTRIBUTE' | 'INVALID_USER_ATTRIBUTE_KEY' | 'INVALID_USER_ATTRIBUTE_VALUE' | 'INVALID_PAGINATION_TOKEN' | 'INVALID_MAX_RESULTS' | 'INVALID_AGENT_ID' | 'INVALID_AUTO_SCALING_GROUP' | 'INVALID_RULE_NAME' | 'INVALID_SEVERITY' | 'INVALID_LOCALE' | 'INVALID_EVENT' | 'ASSESSMENT_TARGET_NAME_ALREADY_TAKEN' | 'ASSESSMENT_TEMPLATE_NAME_ALREADY_TAKEN' | 'INVALID_NUMBER_OF_ASSESSMENT_TARGET_ARNS' | 'INVALID_NUMBER_OF_ASSESSMENT_TEMPLATE_ARNS' | 'INVALID_NUMBER_OF_ASSESSMENT_RUN_ARNS' | 'INVALID_NUMBER_OF_FINDING_ARNS' | 'INVALID_NUMBER_OF_RESOURCE_GROUP_ARNS' | 'INVALID_NUMBER_OF_RULES_PACKAGE_ARNS' | 'INVALID_NUMBER_OF_ASSESSMENT_RUN_STATES' | 'INVALID_NUMBER_OF_TAGS' | 'INVALID_NUMBER_OF_RESOURCE_GROUP_TAGS' | 'INVALID_NUMBER_OF_ATTRIBUTES' | 'INVALID_NUMBER_OF_USER_ATTRIBUTES' | 'INVALID_NUMBER_OF_AGENT_IDS' | 'INVALID_NUMBER_OF_AUTO_SCALING_GROUPS' | 'INVALID_NUMBER_OF_RULE_NAMES' | 'INVALID_NUMBER_OF_SEVERITIES';
  declare type Inspector$20160216$InvalidInputException = {
    message: string;
    errorCode: 'INVALID_ASSESSMENT_TARGET_ARN' | 'INVALID_ASSESSMENT_TEMPLATE_ARN' | 'INVALID_ASSESSMENT_RUN_ARN' | 'INVALID_FINDING_ARN' | 'INVALID_RESOURCE_GROUP_ARN' | 'INVALID_RULES_PACKAGE_ARN' | 'INVALID_RESOURCE_ARN' | 'INVALID_SNS_TOPIC_ARN' | 'INVALID_IAM_ROLE_ARN' | 'INVALID_ASSESSMENT_TARGET_NAME' | 'INVALID_ASSESSMENT_TARGET_NAME_PATTERN' | 'INVALID_ASSESSMENT_TEMPLATE_NAME' | 'INVALID_ASSESSMENT_TEMPLATE_NAME_PATTERN' | 'INVALID_ASSESSMENT_TEMPLATE_DURATION' | 'INVALID_ASSESSMENT_TEMPLATE_DURATION_RANGE' | 'INVALID_ASSESSMENT_RUN_DURATION_RANGE' | 'INVALID_ASSESSMENT_RUN_START_TIME_RANGE' | 'INVALID_ASSESSMENT_RUN_COMPLETION_TIME_RANGE' | 'INVALID_ASSESSMENT_RUN_STATE_CHANGE_TIME_RANGE' | 'INVALID_ASSESSMENT_RUN_STATE' | 'INVALID_TAG' | 'INVALID_TAG_KEY' | 'INVALID_TAG_VALUE' | 'INVALID_RESOURCE_GROUP_TAG_KEY' | 'INVALID_RESOURCE_GROUP_TAG_VALUE' | 'INVALID_ATTRIBUTE' | 'INVALID_USER_ATTRIBUTE' | 'INVALID_USER_ATTRIBUTE_KEY' | 'INVALID_USER_ATTRIBUTE_VALUE' | 'INVALID_PAGINATION_TOKEN' | 'INVALID_MAX_RESULTS' | 'INVALID_AGENT_ID' | 'INVALID_AUTO_SCALING_GROUP' | 'INVALID_RULE_NAME' | 'INVALID_SEVERITY' | 'INVALID_LOCALE' | 'INVALID_EVENT' | 'ASSESSMENT_TARGET_NAME_ALREADY_TAKEN' | 'ASSESSMENT_TEMPLATE_NAME_ALREADY_TAKEN' | 'INVALID_NUMBER_OF_ASSESSMENT_TARGET_ARNS' | 'INVALID_NUMBER_OF_ASSESSMENT_TEMPLATE_ARNS' | 'INVALID_NUMBER_OF_ASSESSMENT_RUN_ARNS' | 'INVALID_NUMBER_OF_FINDING_ARNS' | 'INVALID_NUMBER_OF_RESOURCE_GROUP_ARNS' | 'INVALID_NUMBER_OF_RULES_PACKAGE_ARNS' | 'INVALID_NUMBER_OF_ASSESSMENT_RUN_STATES' | 'INVALID_NUMBER_OF_TAGS' | 'INVALID_NUMBER_OF_RESOURCE_GROUP_TAGS' | 'INVALID_NUMBER_OF_ATTRIBUTES' | 'INVALID_NUMBER_OF_USER_ATTRIBUTES' | 'INVALID_NUMBER_OF_AGENT_IDS' | 'INVALID_NUMBER_OF_AUTO_SCALING_GROUPS' | 'INVALID_NUMBER_OF_RULE_NAMES' | 'INVALID_NUMBER_OF_SEVERITIES';
    canRetry: boolean;
  };
  declare type Inspector$20160216$Ipv4AddressList = string[];
  declare type Inspector$20160216$LimitExceededErrorCode = 'ASSESSMENT_TARGET_LIMIT_EXCEEDED' | 'ASSESSMENT_TEMPLATE_LIMIT_EXCEEDED' | 'ASSESSMENT_RUN_LIMIT_EXCEEDED' | 'RESOURCE_GROUP_LIMIT_EXCEEDED' | 'EVENT_SUBSCRIPTION_LIMIT_EXCEEDED';
  declare type Inspector$20160216$LimitExceededException = {
    message: string;
    errorCode: 'ASSESSMENT_TARGET_LIMIT_EXCEEDED' | 'ASSESSMENT_TEMPLATE_LIMIT_EXCEEDED' | 'ASSESSMENT_RUN_LIMIT_EXCEEDED' | 'RESOURCE_GROUP_LIMIT_EXCEEDED' | 'EVENT_SUBSCRIPTION_LIMIT_EXCEEDED';
    canRetry: boolean;
  };
  declare type Inspector$20160216$ListAssessmentRunAgentsRequest = {
    assessmentRunArn: string;
    filter?: Inspector$20160216$AgentFilter;
    nextToken?: string;
    maxResults?: number;
  };
  declare type Inspector$20160216$ListAssessmentRunAgentsResponse = {
    assessmentRunAgents: Inspector$20160216$AssessmentRunAgentList;
    nextToken?: string;
  };
  declare type Inspector$20160216$ListAssessmentRunsRequest = {
    assessmentTemplateArns?: Inspector$20160216$ListParentArnList;
    filter?: Inspector$20160216$AssessmentRunFilter;
    nextToken?: string;
    maxResults?: number;
  };
  declare type Inspector$20160216$ListAssessmentRunsResponse = {
    assessmentRunArns: Inspector$20160216$ListReturnedArnList;
    nextToken?: string;
  };
  declare type Inspector$20160216$ListAssessmentTargetsRequest = {
    filter?: Inspector$20160216$AssessmentTargetFilter;
    nextToken?: string;
    maxResults?: number;
  };
  declare type Inspector$20160216$ListAssessmentTargetsResponse = {
    assessmentTargetArns: Inspector$20160216$ListReturnedArnList;
    nextToken?: string;
  };
  declare type Inspector$20160216$ListAssessmentTemplatesRequest = {
    assessmentTargetArns?: Inspector$20160216$ListParentArnList;
    filter?: Inspector$20160216$AssessmentTemplateFilter;
    nextToken?: string;
    maxResults?: number;
  };
  declare type Inspector$20160216$ListAssessmentTemplatesResponse = {
    assessmentTemplateArns: Inspector$20160216$ListReturnedArnList;
    nextToken?: string;
  };
  declare type Inspector$20160216$ListEventSubscriptionsRequest = {
    resourceArn?: string;
    nextToken?: string;
    maxResults?: number;
  };
  declare type Inspector$20160216$ListEventSubscriptionsResponse = {
    subscriptions: Inspector$20160216$SubscriptionList;
    nextToken?: string;
  };
  declare type Inspector$20160216$ListFindingsRequest = {
    assessmentRunArns?: Inspector$20160216$ListParentArnList;
    filter?: Inspector$20160216$FindingFilter;
    nextToken?: string;
    maxResults?: number;
  };
  declare type Inspector$20160216$ListFindingsResponse = {
    findingArns: Inspector$20160216$ListReturnedArnList;
    nextToken?: string;
  };
  declare type Inspector$20160216$ListParentArnList = string[];
  declare type Inspector$20160216$ListReturnedArnList = string[];
  declare type Inspector$20160216$ListRulesPackagesRequest = {
    nextToken?: string;
    maxResults?: number;
  };
  declare type Inspector$20160216$ListRulesPackagesResponse = {
    rulesPackageArns: Inspector$20160216$ListReturnedArnList;
    nextToken?: string;
  };
  declare type Inspector$20160216$ListTagsForResourceRequest = {
    resourceArn: string;
  };
  declare type Inspector$20160216$ListTagsForResourceResponse = {
    tags: Inspector$20160216$TagList;
  };
  declare type Inspector$20160216$Locale = 'EN_US';
  declare type Inspector$20160216$NoSuchEntityErrorCode = 'ASSESSMENT_TARGET_DOES_NOT_EXIST' | 'ASSESSMENT_TEMPLATE_DOES_NOT_EXIST' | 'ASSESSMENT_RUN_DOES_NOT_EXIST' | 'FINDING_DOES_NOT_EXIST' | 'RESOURCE_GROUP_DOES_NOT_EXIST' | 'RULES_PACKAGE_DOES_NOT_EXIST' | 'SNS_TOPIC_DOES_NOT_EXIST' | 'IAM_ROLE_DOES_NOT_EXIST';
  declare type Inspector$20160216$NoSuchEntityException = {
    message: string;
    errorCode: 'ASSESSMENT_TARGET_DOES_NOT_EXIST' | 'ASSESSMENT_TEMPLATE_DOES_NOT_EXIST' | 'ASSESSMENT_RUN_DOES_NOT_EXIST' | 'FINDING_DOES_NOT_EXIST' | 'RESOURCE_GROUP_DOES_NOT_EXIST' | 'RULES_PACKAGE_DOES_NOT_EXIST' | 'SNS_TOPIC_DOES_NOT_EXIST' | 'IAM_ROLE_DOES_NOT_EXIST';
    canRetry: boolean;
  };
  declare type Inspector$20160216$PreviewAgentsRequest = {
    previewAgentsArn: string;
    nextToken?: string;
    maxResults?: number;
  };
  declare type Inspector$20160216$PreviewAgentsResponse = {
    agentPreviews: Inspector$20160216$AgentPreviewList;
    nextToken?: string;
  };
  declare type Inspector$20160216$RegisterCrossAccountAccessRoleRequest = {
    roleArn: string;
  };
  declare type Inspector$20160216$RemoveAttributesFromFindingsRequest = {
    findingArns: Inspector$20160216$AddRemoveAttributesFindingArnList;
    attributeKeys: Inspector$20160216$UserAttributeKeyList;
  };
  declare type Inspector$20160216$RemoveAttributesFromFindingsResponse = {
    failedItems: {
      [key: string]: Inspector$20160216$FailedItemDetails;
    };
  };
  declare type Inspector$20160216$ResourceGroup = {
    arn: string;
    tags: Inspector$20160216$ResourceGroupTags;
    createdAt: Date;
  };
  declare type Inspector$20160216$ResourceGroupList = Inspector$20160216$ResourceGroup[];
  declare type Inspector$20160216$ResourceGroupTag = {
    key: string;
    value?: string;
  };
  declare type Inspector$20160216$ResourceGroupTags = Inspector$20160216$ResourceGroupTag[];
  declare type Inspector$20160216$RuleNameList = string[];
  declare type Inspector$20160216$RulesPackage = {
    arn: string;
    name: string;
    version: string;
    provider: string;
    description?: string;
  };
  declare type Inspector$20160216$RulesPackageList = Inspector$20160216$RulesPackage[];
  declare type Inspector$20160216$SetTagsForResourceRequest = {
    resourceArn: string;
    tags?: Inspector$20160216$TagList;
  };
  declare type Inspector$20160216$Severity = 'Low' | 'Medium' | 'High' | 'Informational' | 'Undefined';
  declare type Inspector$20160216$SeverityList = ('Low' | 'Medium' | 'High' | 'Informational' | 'Undefined')[];
  declare type Inspector$20160216$StartAssessmentRunRequest = {
    assessmentTemplateArn: string;
    assessmentRunName?: string;
  };
  declare type Inspector$20160216$StartAssessmentRunResponse = {
    assessmentRunArn: string;
  };
  declare type Inspector$20160216$StopAssessmentRunRequest = {
    assessmentRunArn: string;
  };
  declare type Inspector$20160216$SubscribeToEventRequest = {
    resourceArn: string;
    event: 'ASSESSMENT_RUN_STARTED' | 'ASSESSMENT_RUN_COMPLETED' | 'ASSESSMENT_RUN_STATE_CHANGED' | 'FINDING_REPORTED' | 'OTHER';
    topicArn: string;
  };
  declare type Inspector$20160216$Subscription = {
    resourceArn: string;
    topicArn: string;
    eventSubscriptions: Inspector$20160216$EventSubscriptionList;
  };
  declare type Inspector$20160216$SubscriptionList = Inspector$20160216$Subscription[];
  declare type Inspector$20160216$Tag = {
    key: string;
    value?: string;
  };
  declare type Inspector$20160216$TagList = Inspector$20160216$Tag[];
  declare type Inspector$20160216$TelemetryMetadata = {
    messageType: string;
    count: number;
    dataSize?: number;
  };
  declare type Inspector$20160216$TelemetryMetadataList = Inspector$20160216$TelemetryMetadata[];
  declare type Inspector$20160216$Timestamp = Date;
  declare type Inspector$20160216$TimestampRange = {
    beginDate?: Date;
    endDate?: Date;
  };
  declare type Inspector$20160216$UnsubscribeFromEventRequest = {
    resourceArn: string;
    event: 'ASSESSMENT_RUN_STARTED' | 'ASSESSMENT_RUN_COMPLETED' | 'ASSESSMENT_RUN_STATE_CHANGED' | 'FINDING_REPORTED' | 'OTHER';
    topicArn: string;
  };
  declare type Inspector$20160216$UpdateAssessmentTargetRequest = {
    assessmentTargetArn: string;
    assessmentTargetName: string;
    resourceGroupArn: string;
  };
  declare type Inspector$20160216$UserAttributeKeyList = string[];
  declare type Inspector$20160216$UserAttributeList = Inspector$20160216$Attribute[];
  declare type Iot$20150528$AcceptCertificateTransferRequest = {
    certificateId: string;
    setAsActive?: boolean;
  };
  declare type Iot$20150528$Action = {
    dynamoDB?: Iot$20150528$DynamoDBAction;
    lambda?: Iot$20150528$LambdaAction;
    sns?: Iot$20150528$SnsAction;
    sqs?: Iot$20150528$SqsAction;
    kinesis?: Iot$20150528$KinesisAction;
    republish?: Iot$20150528$RepublishAction;
    s3?: Iot$20150528$S3Action;
    firehose?: Iot$20150528$FirehoseAction;
    cloudwatchMetric?: Iot$20150528$CloudwatchMetricAction;
    cloudwatchAlarm?: Iot$20150528$CloudwatchAlarmAction;
    elasticsearch?: Iot$20150528$ElasticsearchAction;
  };
  declare type Iot$20150528$ActionList = Iot$20150528$Action[];
  declare type Iot$20150528$AttachPrincipalPolicyRequest = {
    policyName: string;
    principal: string;
  };
  declare type Iot$20150528$AttachThingPrincipalRequest = {
    thingName: string;
    principal: string;
  };
  declare type Iot$20150528$AttachThingPrincipalResponse = {};
  declare type Iot$20150528$AttributePayload = {
    attributes?: {
      [key: string]: string;
    };
    merge?: boolean;
  };
  declare type Iot$20150528$Attributes = {
    [key: string]: string;
  };
  declare type Iot$20150528$AutoRegistrationStatus = 'ENABLE' | 'DISABLE';
  declare type Iot$20150528$CACertificate = {
    certificateArn?: string;
    certificateId?: string;
    status?: 'ACTIVE' | 'INACTIVE';
    creationDate?: Date;
  };
  declare type Iot$20150528$CACertificateDescription = {
    certificateArn?: string;
    certificateId?: string;
    status?: 'ACTIVE' | 'INACTIVE';
    certificatePem?: string;
    ownedBy?: string;
    creationDate?: Date;
    autoRegistrationStatus?: 'ENABLE' | 'DISABLE';
  };
  declare type Iot$20150528$CACertificateStatus = 'ACTIVE' | 'INACTIVE';
  declare type Iot$20150528$CACertificates = Iot$20150528$CACertificate[];
  declare type Iot$20150528$CancelCertificateTransferRequest = {
    certificateId: string;
  };
  declare type Iot$20150528$Certificate = {
    certificateArn?: string;
    certificateId?: string;
    status?: 'ACTIVE' | 'INACTIVE' | 'REVOKED' | 'PENDING_TRANSFER' | 'REGISTER_INACTIVE' | 'PENDING_ACTIVATION';
    creationDate?: Date;
  };
  declare type Iot$20150528$CertificateConflictException = {
    message?: string;
  };
  declare type Iot$20150528$CertificateDescription = {
    certificateArn?: string;
    certificateId?: string;
    caCertificateId?: string;
    status?: 'ACTIVE' | 'INACTIVE' | 'REVOKED' | 'PENDING_TRANSFER' | 'REGISTER_INACTIVE' | 'PENDING_ACTIVATION';
    certificatePem?: string;
    ownedBy?: string;
    previousOwnedBy?: string;
    creationDate?: Date;
    lastModifiedDate?: Date;
    transferData?: Iot$20150528$TransferData;
  };
  declare type Iot$20150528$CertificateStateException = {
    message?: string;
  };
  declare type Iot$20150528$CertificateStatus = 'ACTIVE' | 'INACTIVE' | 'REVOKED' | 'PENDING_TRANSFER' | 'REGISTER_INACTIVE' | 'PENDING_ACTIVATION';
  declare type Iot$20150528$CertificateValidationException = {
    message?: string;
  };
  declare type Iot$20150528$Certificates = Iot$20150528$Certificate[];
  declare type Iot$20150528$CloudwatchAlarmAction = {
    roleArn: string;
    alarmName: string;
    stateReason: string;
    stateValue: string;
  };
  declare type Iot$20150528$CloudwatchMetricAction = {
    roleArn: string;
    metricNamespace: string;
    metricName: string;
    metricValue: string;
    metricUnit: string;
    metricTimestamp?: string;
  };
  declare type Iot$20150528$CreateCertificateFromCsrRequest = {
    certificateSigningRequest: string;
    setAsActive?: boolean;
  };
  declare type Iot$20150528$CreateCertificateFromCsrResponse = {
    certificateArn?: string;
    certificateId?: string;
    certificatePem?: string;
  };
  declare type Iot$20150528$CreateKeysAndCertificateRequest = {
    setAsActive?: boolean;
  };
  declare type Iot$20150528$CreateKeysAndCertificateResponse = {
    certificateArn?: string;
    certificateId?: string;
    certificatePem?: string;
    keyPair?: Iot$20150528$KeyPair;
  };
  declare type Iot$20150528$CreatePolicyRequest = {
    policyName: string;
    policyDocument: string;
  };
  declare type Iot$20150528$CreatePolicyResponse = {
    policyName?: string;
    policyArn?: string;
    policyDocument?: string;
    policyVersionId?: string;
  };
  declare type Iot$20150528$CreatePolicyVersionRequest = {
    policyName: string;
    policyDocument: string;
    setAsDefault?: boolean;
  };
  declare type Iot$20150528$CreatePolicyVersionResponse = {
    policyArn?: string;
    policyDocument?: string;
    policyVersionId?: string;
    isDefaultVersion?: boolean;
  };
  declare type Iot$20150528$CreateThingRequest = {
    thingName: string;
    thingTypeName?: string;
    attributePayload?: Iot$20150528$AttributePayload;
  };
  declare type Iot$20150528$CreateThingResponse = {
    thingName?: string;
    thingArn?: string;
  };
  declare type Iot$20150528$CreateThingTypeRequest = {
    thingTypeName: string;
    thingTypeProperties?: Iot$20150528$ThingTypeProperties;
  };
  declare type Iot$20150528$CreateThingTypeResponse = {
    thingTypeName?: string;
    thingTypeArn?: string;
  };
  declare type Iot$20150528$CreateTopicRuleRequest = {
    ruleName: string;
    topicRulePayload: Iot$20150528$TopicRulePayload;
  };
  declare type Iot$20150528$CreatedAtDate = Date;
  declare type Iot$20150528$CreationDate = Date;
  declare type Iot$20150528$DateType = Date;
  declare type Iot$20150528$DeleteCACertificateRequest = {
    certificateId: string;
  };
  declare type Iot$20150528$DeleteCACertificateResponse = {};
  declare type Iot$20150528$DeleteCertificateRequest = {
    certificateId: string;
  };
  declare type Iot$20150528$DeleteConflictException = {
    message?: string;
  };
  declare type Iot$20150528$DeletePolicyRequest = {
    policyName: string;
  };
  declare type Iot$20150528$DeletePolicyVersionRequest = {
    policyName: string;
    policyVersionId: string;
  };
  declare type Iot$20150528$DeleteRegistrationCodeRequest = {};
  declare type Iot$20150528$DeleteRegistrationCodeResponse = {};
  declare type Iot$20150528$DeleteThingRequest = {
    thingName: string;
    expectedVersion?: number;
  };
  declare type Iot$20150528$DeleteThingResponse = {};
  declare type Iot$20150528$DeleteThingTypeRequest = {
    thingTypeName: string;
  };
  declare type Iot$20150528$DeleteThingTypeResponse = {};
  declare type Iot$20150528$DeleteTopicRuleRequest = {
    ruleName: string;
  };
  declare type Iot$20150528$DeprecateThingTypeRequest = {
    thingTypeName: string;
    undoDeprecate?: boolean;
  };
  declare type Iot$20150528$DeprecateThingTypeResponse = {};
  declare type Iot$20150528$DeprecationDate = Date;
  declare type Iot$20150528$DescribeCACertificateRequest = {
    certificateId: string;
  };
  declare type Iot$20150528$DescribeCACertificateResponse = {
    certificateDescription?: Iot$20150528$CACertificateDescription;
  };
  declare type Iot$20150528$DescribeCertificateRequest = {
    certificateId: string;
  };
  declare type Iot$20150528$DescribeCertificateResponse = {
    certificateDescription?: Iot$20150528$CertificateDescription;
  };
  declare type Iot$20150528$DescribeEndpointRequest = {};
  declare type Iot$20150528$DescribeEndpointResponse = {
    endpointAddress?: string;
  };
  declare type Iot$20150528$DescribeThingRequest = {
    thingName: string;
  };
  declare type Iot$20150528$DescribeThingResponse = {
    defaultClientId?: string;
    thingName?: string;
    thingTypeName?: string;
    attributes?: {
      [key: string]: string;
    };
    version?: number;
  };
  declare type Iot$20150528$DescribeThingTypeRequest = {
    thingTypeName: string;
  };
  declare type Iot$20150528$DescribeThingTypeResponse = {
    thingTypeName?: string;
    thingTypeProperties?: Iot$20150528$ThingTypeProperties;
    thingTypeMetadata?: Iot$20150528$ThingTypeMetadata;
  };
  declare type Iot$20150528$DetachPrincipalPolicyRequest = {
    policyName: string;
    principal: string;
  };
  declare type Iot$20150528$DetachThingPrincipalRequest = {
    thingName: string;
    principal: string;
  };
  declare type Iot$20150528$DetachThingPrincipalResponse = {};
  declare type Iot$20150528$DisableTopicRuleRequest = {
    ruleName: string;
  };
  declare type Iot$20150528$DynamoDBAction = {
    tableName: string;
    roleArn: string;
    operation?: string;
    hashKeyField: string;
    hashKeyValue: string;
    hashKeyType?: 'STRING' | 'NUMBER';
    rangeKeyField?: string;
    rangeKeyValue?: string;
    rangeKeyType?: 'STRING' | 'NUMBER';
    payloadField?: string;
  };
  declare type Iot$20150528$DynamoKeyType = 'STRING' | 'NUMBER';
  declare type Iot$20150528$ElasticsearchAction = {
    roleArn: string;
    endpoint: string;
    index: string;
    type: string;
    id: string;
  };
  declare type Iot$20150528$EnableTopicRuleRequest = {
    ruleName: string;
  };
  declare type Iot$20150528$FirehoseAction = {
    roleArn: string;
    deliveryStreamName: string;
    separator?: string;
  };
  declare type Iot$20150528$GetLoggingOptionsRequest = {};
  declare type Iot$20150528$GetLoggingOptionsResponse = {
    roleArn?: string;
    logLevel?: 'DEBUG' | 'INFO' | 'ERROR' | 'WARN' | 'DISABLED';
  };
  declare type Iot$20150528$GetPolicyRequest = {
    policyName: string;
  };
  declare type Iot$20150528$GetPolicyResponse = {
    policyName?: string;
    policyArn?: string;
    policyDocument?: string;
    defaultVersionId?: string;
  };
  declare type Iot$20150528$GetPolicyVersionRequest = {
    policyName: string;
    policyVersionId: string;
  };
  declare type Iot$20150528$GetPolicyVersionResponse = {
    policyArn?: string;
    policyName?: string;
    policyDocument?: string;
    policyVersionId?: string;
    isDefaultVersion?: boolean;
  };
  declare type Iot$20150528$GetRegistrationCodeRequest = {};
  declare type Iot$20150528$GetRegistrationCodeResponse = {
    registrationCode?: string;
  };
  declare type Iot$20150528$GetTopicRuleRequest = {
    ruleName: string;
  };
  declare type Iot$20150528$GetTopicRuleResponse = {
    ruleArn?: string;
    rule?: Iot$20150528$TopicRule;
  };
  declare type Iot$20150528$InternalException = {
    message?: string;
  };
  declare type Iot$20150528$InternalFailureException = {
    message?: string;
  };
  declare type Iot$20150528$InvalidRequestException = {
    message?: string;
  };
  declare type Iot$20150528$KeyPair = {
    PublicKey?: string;
    PrivateKey?: string;
  };
  declare type Iot$20150528$KinesisAction = {
    roleArn: string;
    streamName: string;
    partitionKey?: string;
  };
  declare type Iot$20150528$LambdaAction = {
    functionArn: string;
  };
  declare type Iot$20150528$LimitExceededException = {
    message?: string;
  };
  declare type Iot$20150528$ListCACertificatesRequest = {
    pageSize?: number;
    marker?: string;
    ascendingOrder?: boolean;
  };
  declare type Iot$20150528$ListCACertificatesResponse = {
    certificates?: Iot$20150528$CACertificates;
    nextMarker?: string;
  };
  declare type Iot$20150528$ListCertificatesByCARequest = {
    caCertificateId: string;
    pageSize?: number;
    marker?: string;
    ascendingOrder?: boolean;
  };
  declare type Iot$20150528$ListCertificatesByCAResponse = {
    certificates?: Iot$20150528$Certificates;
    nextMarker?: string;
  };
  declare type Iot$20150528$ListCertificatesRequest = {
    pageSize?: number;
    marker?: string;
    ascendingOrder?: boolean;
  };
  declare type Iot$20150528$ListCertificatesResponse = {
    certificates?: Iot$20150528$Certificates;
    nextMarker?: string;
  };
  declare type Iot$20150528$ListOutgoingCertificatesRequest = {
    pageSize?: number;
    marker?: string;
    ascendingOrder?: boolean;
  };
  declare type Iot$20150528$ListOutgoingCertificatesResponse = {
    outgoingCertificates?: Iot$20150528$OutgoingCertificates;
    nextMarker?: string;
  };
  declare type Iot$20150528$ListPoliciesRequest = {
    marker?: string;
    pageSize?: number;
    ascendingOrder?: boolean;
  };
  declare type Iot$20150528$ListPoliciesResponse = {
    policies?: Iot$20150528$Policies;
    nextMarker?: string;
  };
  declare type Iot$20150528$ListPolicyPrincipalsRequest = {
    policyName: string;
    marker?: string;
    pageSize?: number;
    ascendingOrder?: boolean;
  };
  declare type Iot$20150528$ListPolicyPrincipalsResponse = {
    principals?: Iot$20150528$Principals;
    nextMarker?: string;
  };
  declare type Iot$20150528$ListPolicyVersionsRequest = {
    policyName: string;
  };
  declare type Iot$20150528$ListPolicyVersionsResponse = {
    policyVersions?: Iot$20150528$PolicyVersions;
  };
  declare type Iot$20150528$ListPrincipalPoliciesRequest = {
    principal: string;
    marker?: string;
    pageSize?: number;
    ascendingOrder?: boolean;
  };
  declare type Iot$20150528$ListPrincipalPoliciesResponse = {
    policies?: Iot$20150528$Policies;
    nextMarker?: string;
  };
  declare type Iot$20150528$ListPrincipalThingsRequest = {
    nextToken?: string;
    maxResults?: number;
    principal: string;
  };
  declare type Iot$20150528$ListPrincipalThingsResponse = {
    things?: Iot$20150528$ThingNameList;
    nextToken?: string;
  };
  declare type Iot$20150528$ListThingPrincipalsRequest = {
    thingName: string;
  };
  declare type Iot$20150528$ListThingPrincipalsResponse = {
    principals?: Iot$20150528$Principals;
  };
  declare type Iot$20150528$ListThingTypesRequest = {
    nextToken?: string;
    maxResults?: number;
    thingTypeName?: string;
  };
  declare type Iot$20150528$ListThingTypesResponse = {
    thingTypes?: Iot$20150528$ThingTypeList;
    nextToken?: string;
  };
  declare type Iot$20150528$ListThingsRequest = {
    nextToken?: string;
    maxResults?: number;
    attributeName?: string;
    attributeValue?: string;
    thingTypeName?: string;
  };
  declare type Iot$20150528$ListThingsResponse = {
    things?: Iot$20150528$ThingAttributeList;
    nextToken?: string;
  };
  declare type Iot$20150528$ListTopicRulesRequest = {
    topic?: string;
    maxResults?: number;
    nextToken?: string;
    ruleDisabled?: boolean;
  };
  declare type Iot$20150528$ListTopicRulesResponse = {
    rules?: Iot$20150528$TopicRuleList;
    nextToken?: string;
  };
  declare type Iot$20150528$LogLevel = 'DEBUG' | 'INFO' | 'ERROR' | 'WARN' | 'DISABLED';
  declare type Iot$20150528$LoggingOptionsPayload = {
    roleArn: string;
    logLevel?: 'DEBUG' | 'INFO' | 'ERROR' | 'WARN' | 'DISABLED';
  };
  declare type Iot$20150528$MalformedPolicyException = {
    message?: string;
  };
  declare type Iot$20150528$MessageFormat = 'RAW' | 'JSON';
  declare type Iot$20150528$OutgoingCertificate = {
    certificateArn?: string;
    certificateId?: string;
    transferredTo?: string;
    transferDate?: Date;
    transferMessage?: string;
    creationDate?: Date;
  };
  declare type Iot$20150528$OutgoingCertificates = Iot$20150528$OutgoingCertificate[];
  declare type Iot$20150528$Policies = Iot$20150528$Policy[];
  declare type Iot$20150528$Policy = {
    policyName?: string;
    policyArn?: string;
  };
  declare type Iot$20150528$PolicyVersion = {
    versionId?: string;
    isDefaultVersion?: boolean;
    createDate?: Date;
  };
  declare type Iot$20150528$PolicyVersions = Iot$20150528$PolicyVersion[];
  declare type Iot$20150528$Principals = string[];
  declare type Iot$20150528$RegisterCACertificateRequest = {
    caCertificate: string;
    verificationCertificate: string;
    setAsActive?: boolean;
    allowAutoRegistration?: boolean;
  };
  declare type Iot$20150528$RegisterCACertificateResponse = {
    certificateArn?: string;
    certificateId?: string;
  };
  declare type Iot$20150528$RegisterCertificateRequest = {
    certificatePem: string;
    caCertificatePem?: string;
    setAsActive?: boolean;
  };
  declare type Iot$20150528$RegisterCertificateResponse = {
    certificateArn?: string;
    certificateId?: string;
  };
  declare type Iot$20150528$RegistrationCodeValidationException = {
    message?: string;
  };
  declare type Iot$20150528$RejectCertificateTransferRequest = {
    certificateId: string;
    rejectReason?: string;
  };
  declare type Iot$20150528$ReplaceTopicRuleRequest = {
    ruleName: string;
    topicRulePayload: Iot$20150528$TopicRulePayload;
  };
  declare type Iot$20150528$RepublishAction = {
    roleArn: string;
    topic: string;
  };
  declare type Iot$20150528$ResourceAlreadyExistsException = {
    message?: string;
  };
  declare type Iot$20150528$ResourceNotFoundException = {
    message?: string;
  };
  declare type Iot$20150528$S3Action = {
    roleArn: string;
    bucketName: string;
    key: string;
  };
  declare type Iot$20150528$SearchableAttributes = string[];
  declare type Iot$20150528$ServiceUnavailableException = {
    message?: string;
  };
  declare type Iot$20150528$SetDefaultPolicyVersionRequest = {
    policyName: string;
    policyVersionId: string;
  };
  declare type Iot$20150528$SetLoggingOptionsRequest = {
    loggingOptionsPayload: Iot$20150528$LoggingOptionsPayload;
  };
  declare type Iot$20150528$SnsAction = {
    targetArn: string;
    roleArn: string;
    messageFormat?: 'RAW' | 'JSON';
  };
  declare type Iot$20150528$SqlParseException = {
    message?: string;
  };
  declare type Iot$20150528$SqsAction = {
    roleArn: string;
    queueUrl: string;
    useBase64?: boolean;
  };
  declare type Iot$20150528$ThingAttribute = {
    thingName?: string;
    thingTypeName?: string;
    attributes?: {
      [key: string]: string;
    };
    version?: number;
  };
  declare type Iot$20150528$ThingAttributeList = Iot$20150528$ThingAttribute[];
  declare type Iot$20150528$ThingNameList = string[];
  declare type Iot$20150528$ThingTypeDefinition = {
    thingTypeName?: string;
    thingTypeProperties?: Iot$20150528$ThingTypeProperties;
    thingTypeMetadata?: Iot$20150528$ThingTypeMetadata;
  };
  declare type Iot$20150528$ThingTypeList = Iot$20150528$ThingTypeDefinition[];
  declare type Iot$20150528$ThingTypeMetadata = {
    deprecated?: boolean;
    deprecationDate?: Date;
    creationDate?: Date;
  };
  declare type Iot$20150528$ThingTypeProperties = {
    thingTypeDescription?: string;
    searchableAttributes?: Iot$20150528$SearchableAttributes;
  };
  declare type Iot$20150528$ThrottlingException = {
    message?: string;
  };
  declare type Iot$20150528$TopicRule = {
    ruleName?: string;
    sql?: string;
    description?: string;
    createdAt?: Date;
    actions?: Iot$20150528$ActionList;
    ruleDisabled?: boolean;
    awsIotSqlVersion?: string;
  };
  declare type Iot$20150528$TopicRuleList = Iot$20150528$TopicRuleListItem[];
  declare type Iot$20150528$TopicRuleListItem = {
    ruleArn?: string;
    ruleName?: string;
    topicPattern?: string;
    createdAt?: Date;
    ruleDisabled?: boolean;
  };
  declare type Iot$20150528$TopicRulePayload = {
    sql: string;
    description?: string;
    actions: Iot$20150528$ActionList;
    ruleDisabled?: boolean;
    awsIotSqlVersion?: string;
  };
  declare type Iot$20150528$TransferAlreadyCompletedException = {
    message?: string;
  };
  declare type Iot$20150528$TransferCertificateRequest = {
    certificateId: string;
    targetAwsAccount: string;
    transferMessage?: string;
  };
  declare type Iot$20150528$TransferCertificateResponse = {
    transferredCertificateArn?: string;
  };
  declare type Iot$20150528$TransferConflictException = {
    message?: string;
  };
  declare type Iot$20150528$TransferData = {
    transferMessage?: string;
    rejectReason?: string;
    transferDate?: Date;
    acceptDate?: Date;
    rejectDate?: Date;
  };
  declare type Iot$20150528$UnauthorizedException = {
    message?: string;
  };
  declare type Iot$20150528$UpdateCACertificateRequest = {
    certificateId: string;
    newStatus?: 'ACTIVE' | 'INACTIVE';
    newAutoRegistrationStatus?: 'ENABLE' | 'DISABLE';
  };
  declare type Iot$20150528$UpdateCertificateRequest = {
    certificateId: string;
    newStatus: 'ACTIVE' | 'INACTIVE' | 'REVOKED' | 'PENDING_TRANSFER' | 'REGISTER_INACTIVE' | 'PENDING_ACTIVATION';
  };
  declare type Iot$20150528$UpdateThingRequest = {
    thingName: string;
    thingTypeName?: string;
    attributePayload?: Iot$20150528$AttributePayload;
    expectedVersion?: number;
    removeThingType?: boolean;
  };
  declare type Iot$20150528$UpdateThingResponse = {};
  declare type Iot$20150528$VersionConflictException = {
    message?: string;
  };
  declare type Iot$20150528$VersionsLimitExceededException = {
    message?: string;
  };
  declare type IotData$20150528$ConflictException = {
    message?: string;
  };
  declare type IotData$20150528$DeleteThingShadowRequest = {
    thingName: string;
  };
  declare type IotData$20150528$DeleteThingShadowResponse = {
    payload: Buffer | $TypedArray | Blob | string;
  };
  declare type IotData$20150528$GetThingShadowRequest = {
    thingName: string;
  };
  declare type IotData$20150528$GetThingShadowResponse = {
    payload?: Buffer | $TypedArray | Blob | string;
  };
  declare type IotData$20150528$InternalFailureException = {
    message?: string;
  };
  declare type IotData$20150528$InvalidRequestException = {
    message?: string;
  };
  declare type IotData$20150528$JsonDocument = Buffer | $TypedArray | Blob | string;
  declare type IotData$20150528$MethodNotAllowedException = {
    message?: string;
  };
  declare type IotData$20150528$Payload = Buffer | $TypedArray | Blob | string;
  declare type IotData$20150528$PublishRequest = {
    topic: string;
    qos?: number;
    payload?: Buffer | $TypedArray | Blob | string;
  };
  declare type IotData$20150528$RequestEntityTooLargeException = {
    message?: string;
  };
  declare type IotData$20150528$ResourceNotFoundException = {
    message?: string;
  };
  declare type IotData$20150528$ServiceUnavailableException = {
    message?: string;
  };
  declare type IotData$20150528$ThrottlingException = {
    message?: string;
  };
  declare type IotData$20150528$UnauthorizedException = {
    message?: string;
  };
  declare type IotData$20150528$UnsupportedDocumentEncodingException = {
    message?: string;
  };
  declare type IotData$20150528$UpdateThingShadowRequest = {
    thingName: string;
    payload: Buffer | $TypedArray | Blob | string;
  };
  declare type IotData$20150528$UpdateThingShadowResponse = {
    payload?: Buffer | $TypedArray | Blob | string;
  };
  declare type Kinesis$20131202$AddTagsToStreamInput = {
    StreamName: string;
    Tags: {
      [key: string]: string;
    };
  };
  declare type Kinesis$20131202$ApproximateArrivalTimestamp = Date;
  declare type Kinesis$20131202$CreateStreamInput = {
    StreamName: string;
    ShardCount: number;
  };
  declare type Kinesis$20131202$Data = Buffer | $TypedArray | Blob | string;
  declare type Kinesis$20131202$DecreaseStreamRetentionPeriodInput = {
    StreamName: string;
    RetentionPeriodHours: number;
  };
  declare type Kinesis$20131202$DeleteStreamInput = {
    StreamName: string;
  };
  declare type Kinesis$20131202$DescribeStreamInput = {
    StreamName: string;
    Limit?: number;
    ExclusiveStartShardId?: string;
  };
  declare type Kinesis$20131202$DescribeStreamOutput = {
    StreamDescription: Kinesis$20131202$StreamDescription;
  };
  declare type Kinesis$20131202$DisableEnhancedMonitoringInput = {
    StreamName: string;
    ShardLevelMetrics: Kinesis$20131202$MetricsNameList;
  };
  declare type Kinesis$20131202$EnableEnhancedMonitoringInput = {
    StreamName: string;
    ShardLevelMetrics: Kinesis$20131202$MetricsNameList;
  };
  declare type Kinesis$20131202$EnhancedMetrics = {
    ShardLevelMetrics?: Kinesis$20131202$MetricsNameList;
  };
  declare type Kinesis$20131202$EnhancedMonitoringList = Kinesis$20131202$EnhancedMetrics[];
  declare type Kinesis$20131202$EnhancedMonitoringOutput = {
    StreamName?: string;
    CurrentShardLevelMetrics?: Kinesis$20131202$MetricsNameList;
    DesiredShardLevelMetrics?: Kinesis$20131202$MetricsNameList;
  };
  declare type Kinesis$20131202$ExpiredIteratorException = {
    message?: string;
  };
  declare type Kinesis$20131202$GetRecordsInput = {
    ShardIterator: string;
    Limit?: number;
  };
  declare type Kinesis$20131202$GetRecordsOutput = {
    Records: Kinesis$20131202$RecordList;
    NextShardIterator?: string;
    MillisBehindLatest?: number;
  };
  declare type Kinesis$20131202$GetShardIteratorInput = {
    StreamName: string;
    ShardId: string;
    ShardIteratorType: 'AT_SEQUENCE_NUMBER' | 'AFTER_SEQUENCE_NUMBER' | 'TRIM_HORIZON' | 'LATEST' | 'AT_TIMESTAMP';
    StartingSequenceNumber?: string;
    Timestamp?: Date;
  };
  declare type Kinesis$20131202$GetShardIteratorOutput = {
    ShardIterator?: string;
  };
  declare type Kinesis$20131202$HashKeyRange = {
    StartingHashKey: string;
    EndingHashKey: string;
  };
  declare type Kinesis$20131202$IncreaseStreamRetentionPeriodInput = {
    StreamName: string;
    RetentionPeriodHours: number;
  };
  declare type Kinesis$20131202$InvalidArgumentException = {
    message?: string;
  };
  declare type Kinesis$20131202$LimitExceededException = {
    message?: string;
  };
  declare type Kinesis$20131202$ListStreamsInput = {
    Limit?: number;
    ExclusiveStartStreamName?: string;
  };
  declare type Kinesis$20131202$ListStreamsOutput = {
    StreamNames: Kinesis$20131202$StreamNameList;
    HasMoreStreams: boolean;
  };
  declare type Kinesis$20131202$ListTagsForStreamInput = {
    StreamName: string;
    ExclusiveStartTagKey?: string;
    Limit?: number;
  };
  declare type Kinesis$20131202$ListTagsForStreamOutput = {
    Tags: Kinesis$20131202$TagList;
    HasMoreTags: boolean;
  };
  declare type Kinesis$20131202$MergeShardsInput = {
    StreamName: string;
    ShardToMerge: string;
    AdjacentShardToMerge: string;
  };
  declare type Kinesis$20131202$MetricsName = 'IncomingBytes' | 'IncomingRecords' | 'OutgoingBytes' | 'OutgoingRecords' | 'WriteProvisionedThroughputExceeded' | 'ReadProvisionedThroughputExceeded' | 'IteratorAgeMilliseconds' | 'ALL';
  declare type Kinesis$20131202$MetricsNameList = ('IncomingBytes' | 'IncomingRecords' | 'OutgoingBytes' | 'OutgoingRecords' | 'WriteProvisionedThroughputExceeded' | 'ReadProvisionedThroughputExceeded' | 'IteratorAgeMilliseconds' | 'ALL')[];
  declare type Kinesis$20131202$ProvisionedThroughputExceededException = {
    message?: string;
  };
  declare type Kinesis$20131202$PutRecordInput = {
    StreamName: string;
    Data: Buffer | $TypedArray | Blob | string;
    PartitionKey: string;
    ExplicitHashKey?: string;
    SequenceNumberForOrdering?: string;
  };
  declare type Kinesis$20131202$PutRecordOutput = {
    ShardId: string;
    SequenceNumber: string;
  };
  declare type Kinesis$20131202$PutRecordsInput = {
    Records: Kinesis$20131202$PutRecordsRequestEntryList;
    StreamName: string;
  };
  declare type Kinesis$20131202$PutRecordsOutput = {
    FailedRecordCount?: number;
    Records: Kinesis$20131202$PutRecordsResultEntryList;
  };
  declare type Kinesis$20131202$PutRecordsRequestEntry = {
    Data: Buffer | $TypedArray | Blob | string;
    ExplicitHashKey?: string;
    PartitionKey: string;
  };
  declare type Kinesis$20131202$PutRecordsRequestEntryList = Kinesis$20131202$PutRecordsRequestEntry[];
  declare type Kinesis$20131202$PutRecordsResultEntry = {
    SequenceNumber?: string;
    ShardId?: string;
    ErrorCode?: string;
    ErrorMessage?: string;
  };
  declare type Kinesis$20131202$PutRecordsResultEntryList = Kinesis$20131202$PutRecordsResultEntry[];
  declare type Kinesis$20131202$Record = {
    SequenceNumber: string;
    ApproximateArrivalTimestamp?: Date;
    Data: Buffer | $TypedArray | Blob | string;
    PartitionKey: string;
  };
  declare type Kinesis$20131202$RecordList = Kinesis$20131202$Record[];
  declare type Kinesis$20131202$RemoveTagsFromStreamInput = {
    StreamName: string;
    TagKeys: Kinesis$20131202$TagKeyList;
  };
  declare type Kinesis$20131202$ResourceInUseException = {
    message?: string;
  };
  declare type Kinesis$20131202$ResourceNotFoundException = {
    message?: string;
  };
  declare type Kinesis$20131202$SequenceNumberRange = {
    StartingSequenceNumber: string;
    EndingSequenceNumber?: string;
  };
  declare type Kinesis$20131202$Shard = {
    ShardId: string;
    ParentShardId?: string;
    AdjacentParentShardId?: string;
    HashKeyRange: Kinesis$20131202$HashKeyRange;
    SequenceNumberRange: Kinesis$20131202$SequenceNumberRange;
  };
  declare type Kinesis$20131202$ShardIteratorType = 'AT_SEQUENCE_NUMBER' | 'AFTER_SEQUENCE_NUMBER' | 'TRIM_HORIZON' | 'LATEST' | 'AT_TIMESTAMP';
  declare type Kinesis$20131202$ShardList = Kinesis$20131202$Shard[];
  declare type Kinesis$20131202$SplitShardInput = {
    StreamName: string;
    ShardToSplit: string;
    NewStartingHashKey: string;
  };
  declare type Kinesis$20131202$StreamDescription = {
    StreamName: string;
    StreamARN: string;
    StreamStatus: 'CREATING' | 'DELETING' | 'ACTIVE' | 'UPDATING';
    Shards: Kinesis$20131202$ShardList;
    HasMoreShards: boolean;
    RetentionPeriodHours: number;
    EnhancedMonitoring: Kinesis$20131202$EnhancedMonitoringList;
  };
  declare type Kinesis$20131202$StreamNameList = string[];
  declare type Kinesis$20131202$StreamStatus = 'CREATING' | 'DELETING' | 'ACTIVE' | 'UPDATING';
  declare type Kinesis$20131202$Tag = {
    Key: string;
    Value?: string;
  };
  declare type Kinesis$20131202$TagKeyList = string[];
  declare type Kinesis$20131202$TagList = Kinesis$20131202$Tag[];
  declare type Kinesis$20131202$TagMap = {
    [key: string]: string;
  };
  declare type Kinesis$20131202$Timestamp = Date;
  declare type KinesisAnalytics$20150814$AddApplicationInputRequest = {
    ApplicationName: string;
    CurrentApplicationVersionId: number;
    Input: KinesisAnalytics$20150814$Input;
  };
  declare type KinesisAnalytics$20150814$AddApplicationInputResponse = {};
  declare type KinesisAnalytics$20150814$AddApplicationOutputRequest = {
    ApplicationName: string;
    CurrentApplicationVersionId: number;
    Output: KinesisAnalytics$20150814$Output;
  };
  declare type KinesisAnalytics$20150814$AddApplicationOutputResponse = {};
  declare type KinesisAnalytics$20150814$AddApplicationReferenceDataSourceRequest = {
    ApplicationName: string;
    CurrentApplicationVersionId: number;
    ReferenceDataSource: KinesisAnalytics$20150814$ReferenceDataSource;
  };
  declare type KinesisAnalytics$20150814$AddApplicationReferenceDataSourceResponse = {};
  declare type KinesisAnalytics$20150814$ApplicationDetail = {
    ApplicationName: string;
    ApplicationDescription?: string;
    ApplicationARN: string;
    ApplicationStatus: 'DELETING' | 'STARTING' | 'STOPPING' | 'READY' | 'RUNNING' | 'UPDATING';
    CreateTimestamp?: Date;
    LastUpdateTimestamp?: Date;
    InputDescriptions?: KinesisAnalytics$20150814$InputDescriptions;
    OutputDescriptions?: KinesisAnalytics$20150814$OutputDescriptions;
    ReferenceDataSourceDescriptions?: KinesisAnalytics$20150814$ReferenceDataSourceDescriptions;
    ApplicationCode?: string;
    ApplicationVersionId: number;
  };
  declare type KinesisAnalytics$20150814$ApplicationStatus = 'DELETING' | 'STARTING' | 'STOPPING' | 'READY' | 'RUNNING' | 'UPDATING';
  declare type KinesisAnalytics$20150814$ApplicationSummaries = KinesisAnalytics$20150814$ApplicationSummary[];
  declare type KinesisAnalytics$20150814$ApplicationSummary = {
    ApplicationName: string;
    ApplicationARN: string;
    ApplicationStatus: 'DELETING' | 'STARTING' | 'STOPPING' | 'READY' | 'RUNNING' | 'UPDATING';
  };
  declare type KinesisAnalytics$20150814$ApplicationUpdate = {
    InputUpdates?: KinesisAnalytics$20150814$InputUpdates;
    ApplicationCodeUpdate?: string;
    OutputUpdates?: KinesisAnalytics$20150814$OutputUpdates;
    ReferenceDataSourceUpdates?: KinesisAnalytics$20150814$ReferenceDataSourceUpdates;
  };
  declare type KinesisAnalytics$20150814$CSVMappingParameters = {
    RecordRowDelimiter: string;
    RecordColumnDelimiter: string;
  };
  declare type KinesisAnalytics$20150814$CodeValidationException = {
    message?: string;
  };
  declare type KinesisAnalytics$20150814$ConcurrentModificationException = {
    message?: string;
  };
  declare type KinesisAnalytics$20150814$CreateApplicationRequest = {
    ApplicationName: string;
    ApplicationDescription?: string;
    Inputs?: KinesisAnalytics$20150814$Inputs;
    Outputs?: KinesisAnalytics$20150814$Outputs;
    ApplicationCode?: string;
  };
  declare type KinesisAnalytics$20150814$CreateApplicationResponse = {
    ApplicationSummary: KinesisAnalytics$20150814$ApplicationSummary;
  };
  declare type KinesisAnalytics$20150814$DeleteApplicationOutputRequest = {
    ApplicationName: string;
    CurrentApplicationVersionId: number;
    OutputId: string;
  };
  declare type KinesisAnalytics$20150814$DeleteApplicationOutputResponse = {};
  declare type KinesisAnalytics$20150814$DeleteApplicationReferenceDataSourceRequest = {
    ApplicationName: string;
    CurrentApplicationVersionId: number;
    ReferenceId: string;
  };
  declare type KinesisAnalytics$20150814$DeleteApplicationReferenceDataSourceResponse = {};
  declare type KinesisAnalytics$20150814$DeleteApplicationRequest = {
    ApplicationName: string;
    CreateTimestamp: Date;
  };
  declare type KinesisAnalytics$20150814$DeleteApplicationResponse = {};
  declare type KinesisAnalytics$20150814$DescribeApplicationRequest = {
    ApplicationName: string;
  };
  declare type KinesisAnalytics$20150814$DescribeApplicationResponse = {
    ApplicationDetail: KinesisAnalytics$20150814$ApplicationDetail;
  };
  declare type KinesisAnalytics$20150814$DestinationSchema = {
    RecordFormatType?: 'JSON' | 'CSV';
  };
  declare type KinesisAnalytics$20150814$DiscoverInputSchemaRequest = {
    ResourceARN: string;
    RoleARN: string;
    InputStartingPositionConfiguration: KinesisAnalytics$20150814$InputStartingPositionConfiguration;
  };
  declare type KinesisAnalytics$20150814$DiscoverInputSchemaResponse = {
    InputSchema?: KinesisAnalytics$20150814$SourceSchema;
    ParsedInputRecords?: KinesisAnalytics$20150814$ParsedInputRecords;
    RawInputRecords?: KinesisAnalytics$20150814$RawInputRecords;
  };
  declare type KinesisAnalytics$20150814$InAppStreamNames = string[];
  declare type KinesisAnalytics$20150814$Input = {
    NamePrefix: string;
    KinesisStreamsInput?: KinesisAnalytics$20150814$KinesisStreamsInput;
    KinesisFirehoseInput?: KinesisAnalytics$20150814$KinesisFirehoseInput;
    InputParallelism?: KinesisAnalytics$20150814$InputParallelism;
    InputSchema?: KinesisAnalytics$20150814$SourceSchema;
  };
  declare type KinesisAnalytics$20150814$InputConfiguration = {
    Id: string;
    InputStartingPositionConfiguration: KinesisAnalytics$20150814$InputStartingPositionConfiguration;
  };
  declare type KinesisAnalytics$20150814$InputConfigurations = KinesisAnalytics$20150814$InputConfiguration[];
  declare type KinesisAnalytics$20150814$InputDescription = {
    InputId?: string;
    NamePrefix?: string;
    InAppStreamNames?: KinesisAnalytics$20150814$InAppStreamNames;
    KinesisStreamsInputDescription?: KinesisAnalytics$20150814$KinesisStreamsInputDescription;
    KinesisFirehoseInputDescription?: KinesisAnalytics$20150814$KinesisFirehoseInputDescription;
    InputSchema?: KinesisAnalytics$20150814$SourceSchema;
    InputParallelism?: KinesisAnalytics$20150814$InputParallelism;
    InputStartingPositionConfiguration?: KinesisAnalytics$20150814$InputStartingPositionConfiguration;
  };
  declare type KinesisAnalytics$20150814$InputDescriptions = KinesisAnalytics$20150814$InputDescription[];
  declare type KinesisAnalytics$20150814$InputParallelism = {
    Count?: number;
  };
  declare type KinesisAnalytics$20150814$InputParallelismUpdate = {
    CountUpdate?: number;
  };
  declare type KinesisAnalytics$20150814$InputSchemaUpdate = {
    RecordFormatUpdate?: KinesisAnalytics$20150814$RecordFormat;
    RecordEncodingUpdate?: string;
    RecordColumnUpdates?: KinesisAnalytics$20150814$RecordColumns;
  };
  declare type KinesisAnalytics$20150814$InputStartingPosition = 'NOW' | 'TRIM_HORIZON' | 'LAST_STOPPED_POINT';
  declare type KinesisAnalytics$20150814$InputStartingPositionConfiguration = {
    InputStartingPosition?: 'NOW' | 'TRIM_HORIZON' | 'LAST_STOPPED_POINT';
  };
  declare type KinesisAnalytics$20150814$InputUpdate = {
    InputId: string;
    NamePrefixUpdate?: string;
    KinesisStreamsInputUpdate?: KinesisAnalytics$20150814$KinesisStreamsInputUpdate;
    KinesisFirehoseInputUpdate?: KinesisAnalytics$20150814$KinesisFirehoseInputUpdate;
    InputSchemaUpdate?: KinesisAnalytics$20150814$InputSchemaUpdate;
    InputParallelismUpdate?: KinesisAnalytics$20150814$InputParallelismUpdate;
  };
  declare type KinesisAnalytics$20150814$InputUpdates = KinesisAnalytics$20150814$InputUpdate[];
  declare type KinesisAnalytics$20150814$Inputs = KinesisAnalytics$20150814$Input[];
  declare type KinesisAnalytics$20150814$InvalidApplicationConfigurationException = {
    message?: string;
  };
  declare type KinesisAnalytics$20150814$InvalidArgumentException = {
    message?: string;
  };
  declare type KinesisAnalytics$20150814$JSONMappingParameters = {
    RecordRowPath: string;
  };
  declare type KinesisAnalytics$20150814$KinesisFirehoseInput = {
    ResourceARN: string;
    RoleARN: string;
  };
  declare type KinesisAnalytics$20150814$KinesisFirehoseInputDescription = {
    ResourceARN?: string;
    RoleARN?: string;
  };
  declare type KinesisAnalytics$20150814$KinesisFirehoseInputUpdate = {
    ResourceARNUpdate?: string;
    RoleARNUpdate?: string;
  };
  declare type KinesisAnalytics$20150814$KinesisFirehoseOutput = {
    ResourceARN: string;
    RoleARN: string;
  };
  declare type KinesisAnalytics$20150814$KinesisFirehoseOutputDescription = {
    ResourceARN?: string;
    RoleARN?: string;
  };
  declare type KinesisAnalytics$20150814$KinesisFirehoseOutputUpdate = {
    ResourceARNUpdate?: string;
    RoleARNUpdate?: string;
  };
  declare type KinesisAnalytics$20150814$KinesisStreamsInput = {
    ResourceARN: string;
    RoleARN: string;
  };
  declare type KinesisAnalytics$20150814$KinesisStreamsInputDescription = {
    ResourceARN?: string;
    RoleARN?: string;
  };
  declare type KinesisAnalytics$20150814$KinesisStreamsInputUpdate = {
    ResourceARNUpdate?: string;
    RoleARNUpdate?: string;
  };
  declare type KinesisAnalytics$20150814$KinesisStreamsOutput = {
    ResourceARN: string;
    RoleARN: string;
  };
  declare type KinesisAnalytics$20150814$KinesisStreamsOutputDescription = {
    ResourceARN?: string;
    RoleARN?: string;
  };
  declare type KinesisAnalytics$20150814$KinesisStreamsOutputUpdate = {
    ResourceARNUpdate?: string;
    RoleARNUpdate?: string;
  };
  declare type KinesisAnalytics$20150814$LimitExceededException = {
    message?: string;
  };
  declare type KinesisAnalytics$20150814$ListApplicationsRequest = {
    Limit?: number;
    ExclusiveStartApplicationName?: string;
  };
  declare type KinesisAnalytics$20150814$ListApplicationsResponse = {
    ApplicationSummaries: KinesisAnalytics$20150814$ApplicationSummaries;
    HasMoreApplications: boolean;
  };
  declare type KinesisAnalytics$20150814$MappingParameters = {
    JSONMappingParameters?: KinesisAnalytics$20150814$JSONMappingParameters;
    CSVMappingParameters?: KinesisAnalytics$20150814$CSVMappingParameters;
  };
  declare type KinesisAnalytics$20150814$Output = {
    Name: string;
    KinesisStreamsOutput?: KinesisAnalytics$20150814$KinesisStreamsOutput;
    KinesisFirehoseOutput?: KinesisAnalytics$20150814$KinesisFirehoseOutput;
    DestinationSchema: KinesisAnalytics$20150814$DestinationSchema;
  };
  declare type KinesisAnalytics$20150814$OutputDescription = {
    OutputId?: string;
    Name?: string;
    KinesisStreamsOutputDescription?: KinesisAnalytics$20150814$KinesisStreamsOutputDescription;
    KinesisFirehoseOutputDescription?: KinesisAnalytics$20150814$KinesisFirehoseOutputDescription;
    DestinationSchema?: KinesisAnalytics$20150814$DestinationSchema;
  };
  declare type KinesisAnalytics$20150814$OutputDescriptions = KinesisAnalytics$20150814$OutputDescription[];
  declare type KinesisAnalytics$20150814$OutputUpdate = {
    OutputId: string;
    NameUpdate?: string;
    KinesisStreamsOutputUpdate?: KinesisAnalytics$20150814$KinesisStreamsOutputUpdate;
    KinesisFirehoseOutputUpdate?: KinesisAnalytics$20150814$KinesisFirehoseOutputUpdate;
    DestinationSchemaUpdate?: KinesisAnalytics$20150814$DestinationSchema;
  };
  declare type KinesisAnalytics$20150814$OutputUpdates = KinesisAnalytics$20150814$OutputUpdate[];
  declare type KinesisAnalytics$20150814$Outputs = KinesisAnalytics$20150814$Output[];
  declare type KinesisAnalytics$20150814$ParsedInputRecord = string[];
  declare type KinesisAnalytics$20150814$ParsedInputRecords = KinesisAnalytics$20150814$ParsedInputRecord[];
  declare type KinesisAnalytics$20150814$RawInputRecords = string[];
  declare type KinesisAnalytics$20150814$RecordColumn = {
    Name: string;
    Mapping?: string;
    SqlType: string;
  };
  declare type KinesisAnalytics$20150814$RecordColumns = KinesisAnalytics$20150814$RecordColumn[];
  declare type KinesisAnalytics$20150814$RecordFormat = {
    RecordFormatType: 'JSON' | 'CSV';
    MappingParameters?: KinesisAnalytics$20150814$MappingParameters;
  };
  declare type KinesisAnalytics$20150814$RecordFormatType = 'JSON' | 'CSV';
  declare type KinesisAnalytics$20150814$ReferenceDataSource = {
    TableName: string;
    S3ReferenceDataSource?: KinesisAnalytics$20150814$S3ReferenceDataSource;
    ReferenceSchema: KinesisAnalytics$20150814$SourceSchema;
  };
  declare type KinesisAnalytics$20150814$ReferenceDataSourceDescription = {
    ReferenceId: string;
    TableName: string;
    S3ReferenceDataSourceDescription: KinesisAnalytics$20150814$S3ReferenceDataSourceDescription;
    ReferenceSchema?: KinesisAnalytics$20150814$SourceSchema;
  };
  declare type KinesisAnalytics$20150814$ReferenceDataSourceDescriptions = KinesisAnalytics$20150814$ReferenceDataSourceDescription[];
  declare type KinesisAnalytics$20150814$ReferenceDataSourceUpdate = {
    ReferenceId: string;
    TableNameUpdate?: string;
    S3ReferenceDataSourceUpdate?: KinesisAnalytics$20150814$S3ReferenceDataSourceUpdate;
    ReferenceSchemaUpdate?: KinesisAnalytics$20150814$SourceSchema;
  };
  declare type KinesisAnalytics$20150814$ReferenceDataSourceUpdates = KinesisAnalytics$20150814$ReferenceDataSourceUpdate[];
  declare type KinesisAnalytics$20150814$ResourceInUseException = {
    message?: string;
  };
  declare type KinesisAnalytics$20150814$ResourceNotFoundException = {
    message?: string;
  };
  declare type KinesisAnalytics$20150814$ResourceProvisionedThroughputExceededException = {
    message?: string;
  };
  declare type KinesisAnalytics$20150814$S3ReferenceDataSource = {
    BucketARN: string;
    FileKey: string;
    ReferenceRoleARN: string;
  };
  declare type KinesisAnalytics$20150814$S3ReferenceDataSourceDescription = {
    BucketARN: string;
    FileKey: string;
    ReferenceRoleARN: string;
  };
  declare type KinesisAnalytics$20150814$S3ReferenceDataSourceUpdate = {
    BucketARNUpdate?: string;
    FileKeyUpdate?: string;
    ReferenceRoleARNUpdate?: string;
  };
  declare type KinesisAnalytics$20150814$SourceSchema = {
    RecordFormat: KinesisAnalytics$20150814$RecordFormat;
    RecordEncoding?: string;
    RecordColumns: KinesisAnalytics$20150814$RecordColumns;
  };
  declare type KinesisAnalytics$20150814$StartApplicationRequest = {
    ApplicationName: string;
    InputConfigurations: KinesisAnalytics$20150814$InputConfigurations;
  };
  declare type KinesisAnalytics$20150814$StartApplicationResponse = {};
  declare type KinesisAnalytics$20150814$StopApplicationRequest = {
    ApplicationName: string;
  };
  declare type KinesisAnalytics$20150814$StopApplicationResponse = {};
  declare type KinesisAnalytics$20150814$Timestamp = Date;
  declare type KinesisAnalytics$20150814$UnableToDetectSchemaException = {
    message?: string;
  };
  declare type KinesisAnalytics$20150814$UpdateApplicationRequest = {
    ApplicationName: string;
    CurrentApplicationVersionId: number;
    ApplicationUpdate: KinesisAnalytics$20150814$ApplicationUpdate;
  };
  declare type KinesisAnalytics$20150814$UpdateApplicationResponse = {};
  declare type KMS$20141101$AlgorithmSpec = 'RSAES_PKCS1_V1_5' | 'RSAES_OAEP_SHA_1' | 'RSAES_OAEP_SHA_256';
  declare type KMS$20141101$AliasList = KMS$20141101$AliasListEntry[];
  declare type KMS$20141101$AliasListEntry = {
    AliasName?: string;
    AliasArn?: string;
    TargetKeyId?: string;
  };
  declare type KMS$20141101$AlreadyExistsException = {
    message?: string;
  };
  declare type KMS$20141101$CancelKeyDeletionRequest = {
    KeyId: string;
  };
  declare type KMS$20141101$CancelKeyDeletionResponse = {
    KeyId?: string;
  };
  declare type KMS$20141101$CiphertextType = Buffer | $TypedArray | Blob | string;
  declare type KMS$20141101$CreateAliasRequest = {
    AliasName: string;
    TargetKeyId: string;
  };
  declare type KMS$20141101$CreateGrantRequest = {
    KeyId: string;
    GranteePrincipal: string;
    RetiringPrincipal?: string;
    Operations?: KMS$20141101$GrantOperationList;
    Constraints?: KMS$20141101$GrantConstraints;
    GrantTokens?: KMS$20141101$GrantTokenList;
    Name?: string;
  };
  declare type KMS$20141101$CreateGrantResponse = {
    GrantToken?: string;
    GrantId?: string;
  };
  declare type KMS$20141101$CreateKeyRequest = {
    Policy?: string;
    Description?: string;
    KeyUsage?: 'ENCRYPT_DECRYPT';
    Origin?: 'AWS_KMS' | 'EXTERNAL';
    BypassPolicyLockoutSafetyCheck?: boolean;
  };
  declare type KMS$20141101$CreateKeyResponse = {
    KeyMetadata?: KMS$20141101$KeyMetadata;
  };
  declare type KMS$20141101$DataKeySpec = 'AES_256' | 'AES_128';
  declare type KMS$20141101$DateType = Date;
  declare type KMS$20141101$DecryptRequest = {
    CiphertextBlob: Buffer | $TypedArray | Blob | string;
    EncryptionContext?: {
      [key: string]: string;
    };
    GrantTokens?: KMS$20141101$GrantTokenList;
  };
  declare type KMS$20141101$DecryptResponse = {
    KeyId?: string;
    Plaintext?: Buffer | $TypedArray | Blob | string;
  };
  declare type KMS$20141101$DeleteAliasRequest = {
    AliasName: string;
  };
  declare type KMS$20141101$DeleteImportedKeyMaterialRequest = {
    KeyId: string;
  };
  declare type KMS$20141101$DependencyTimeoutException = {
    message?: string;
  };
  declare type KMS$20141101$DescribeKeyRequest = {
    KeyId: string;
    GrantTokens?: KMS$20141101$GrantTokenList;
  };
  declare type KMS$20141101$DescribeKeyResponse = {
    KeyMetadata?: KMS$20141101$KeyMetadata;
  };
  declare type KMS$20141101$DisableKeyRequest = {
    KeyId: string;
  };
  declare type KMS$20141101$DisableKeyRotationRequest = {
    KeyId: string;
  };
  declare type KMS$20141101$DisabledException = {
    message?: string;
  };
  declare type KMS$20141101$EnableKeyRequest = {
    KeyId: string;
  };
  declare type KMS$20141101$EnableKeyRotationRequest = {
    KeyId: string;
  };
  declare type KMS$20141101$EncryptRequest = {
    KeyId: string;
    Plaintext: Buffer | $TypedArray | Blob | string;
    EncryptionContext?: {
      [key: string]: string;
    };
    GrantTokens?: KMS$20141101$GrantTokenList;
  };
  declare type KMS$20141101$EncryptResponse = {
    CiphertextBlob?: Buffer | $TypedArray | Blob | string;
    KeyId?: string;
  };
  declare type KMS$20141101$EncryptionContextType = {
    [key: string]: string;
  };
  declare type KMS$20141101$ExpirationModelType = 'KEY_MATERIAL_EXPIRES' | 'KEY_MATERIAL_DOES_NOT_EXPIRE';
  declare type KMS$20141101$ExpiredImportTokenException = {
    message?: string;
  };
  declare type KMS$20141101$GenerateDataKeyRequest = {
    KeyId: string;
    EncryptionContext?: {
      [key: string]: string;
    };
    NumberOfBytes?: number;
    KeySpec?: 'AES_256' | 'AES_128';
    GrantTokens?: KMS$20141101$GrantTokenList;
  };
  declare type KMS$20141101$GenerateDataKeyResponse = {
    CiphertextBlob?: Buffer | $TypedArray | Blob | string;
    Plaintext?: Buffer | $TypedArray | Blob | string;
    KeyId?: string;
  };
  declare type KMS$20141101$GenerateDataKeyWithoutPlaintextRequest = {
    KeyId: string;
    EncryptionContext?: {
      [key: string]: string;
    };
    KeySpec?: 'AES_256' | 'AES_128';
    NumberOfBytes?: number;
    GrantTokens?: KMS$20141101$GrantTokenList;
  };
  declare type KMS$20141101$GenerateDataKeyWithoutPlaintextResponse = {
    CiphertextBlob?: Buffer | $TypedArray | Blob | string;
    KeyId?: string;
  };
  declare type KMS$20141101$GenerateRandomRequest = {
    NumberOfBytes?: number;
  };
  declare type KMS$20141101$GenerateRandomResponse = {
    Plaintext?: Buffer | $TypedArray | Blob | string;
  };
  declare type KMS$20141101$GetKeyPolicyRequest = {
    KeyId: string;
    PolicyName: string;
  };
  declare type KMS$20141101$GetKeyPolicyResponse = {
    Policy?: string;
  };
  declare type KMS$20141101$GetKeyRotationStatusRequest = {
    KeyId: string;
  };
  declare type KMS$20141101$GetKeyRotationStatusResponse = {
    KeyRotationEnabled?: boolean;
  };
  declare type KMS$20141101$GetParametersForImportRequest = {
    KeyId: string;
    WrappingAlgorithm: 'RSAES_PKCS1_V1_5' | 'RSAES_OAEP_SHA_1' | 'RSAES_OAEP_SHA_256';
    WrappingKeySpec: 'RSA_2048';
  };
  declare type KMS$20141101$GetParametersForImportResponse = {
    KeyId?: string;
    ImportToken?: Buffer | $TypedArray | Blob | string;
    PublicKey?: Buffer | $TypedArray | Blob | string;
    ParametersValidTo?: Date;
  };
  declare type KMS$20141101$GrantConstraints = {
    EncryptionContextSubset?: {
      [key: string]: string;
    };
    EncryptionContextEquals?: {
      [key: string]: string;
    };
  };
  declare type KMS$20141101$GrantList = KMS$20141101$GrantListEntry[];
  declare type KMS$20141101$GrantListEntry = {
    KeyId?: string;
    GrantId?: string;
    Name?: string;
    CreationDate?: Date;
    GranteePrincipal?: string;
    RetiringPrincipal?: string;
    IssuingAccount?: string;
    Operations?: KMS$20141101$GrantOperationList;
    Constraints?: KMS$20141101$GrantConstraints;
  };
  declare type KMS$20141101$GrantOperation = 'Decrypt' | 'Encrypt' | 'GenerateDataKey' | 'GenerateDataKeyWithoutPlaintext' | 'ReEncryptFrom' | 'ReEncryptTo' | 'CreateGrant' | 'RetireGrant' | 'DescribeKey';
  declare type KMS$20141101$GrantOperationList = ('Decrypt' | 'Encrypt' | 'GenerateDataKey' | 'GenerateDataKeyWithoutPlaintext' | 'ReEncryptFrom' | 'ReEncryptTo' | 'CreateGrant' | 'RetireGrant' | 'DescribeKey')[];
  declare type KMS$20141101$GrantTokenList = string[];
  declare type KMS$20141101$ImportKeyMaterialRequest = {
    KeyId: string;
    ImportToken: Buffer | $TypedArray | Blob | string;
    EncryptedKeyMaterial: Buffer | $TypedArray | Blob | string;
    ValidTo: Date;
    ExpirationModel?: 'KEY_MATERIAL_EXPIRES' | 'KEY_MATERIAL_DOES_NOT_EXPIRE';
  };
  declare type KMS$20141101$ImportKeyMaterialResponse = {};
  declare type KMS$20141101$IncorrectKeyMaterialException = {
    message?: string;
  };
  declare type KMS$20141101$InvalidAliasNameException = {
    message?: string;
  };
  declare type KMS$20141101$InvalidArnException = {
    message?: string;
  };
  declare type KMS$20141101$InvalidCiphertextException = {
    message?: string;
  };
  declare type KMS$20141101$InvalidGrantIdException = {
    message?: string;
  };
  declare type KMS$20141101$InvalidGrantTokenException = {
    message?: string;
  };
  declare type KMS$20141101$InvalidImportTokenException = {
    message?: string;
  };
  declare type KMS$20141101$InvalidKeyUsageException = {
    message?: string;
  };
  declare type KMS$20141101$InvalidMarkerException = {
    message?: string;
  };
  declare type KMS$20141101$KMSInternalException = {
    message?: string;
  };
  declare type KMS$20141101$KMSInvalidStateException = {
    message?: string;
  };
  declare type KMS$20141101$KeyList = KMS$20141101$KeyListEntry[];
  declare type KMS$20141101$KeyListEntry = {
    KeyId?: string;
    KeyArn?: string;
  };
  declare type KMS$20141101$KeyMetadata = {
    AWSAccountId?: string;
    KeyId: string;
    Arn?: string;
    CreationDate?: Date;
    Enabled?: boolean;
    Description?: string;
    KeyUsage?: 'ENCRYPT_DECRYPT';
    KeyState?: 'Enabled' | 'Disabled' | 'PendingDeletion' | 'PendingImport';
    DeletionDate?: Date;
    ValidTo?: Date;
    Origin?: 'AWS_KMS' | 'EXTERNAL';
    ExpirationModel?: 'KEY_MATERIAL_EXPIRES' | 'KEY_MATERIAL_DOES_NOT_EXPIRE';
  };
  declare type KMS$20141101$KeyState = 'Enabled' | 'Disabled' | 'PendingDeletion' | 'PendingImport';
  declare type KMS$20141101$KeyUnavailableException = {
    message?: string;
  };
  declare type KMS$20141101$KeyUsageType = 'ENCRYPT_DECRYPT';
  declare type KMS$20141101$LimitExceededException = {
    message?: string;
  };
  declare type KMS$20141101$ListAliasesRequest = {
    Limit?: number;
    Marker?: string;
  };
  declare type KMS$20141101$ListAliasesResponse = {
    Aliases?: KMS$20141101$AliasList;
    NextMarker?: string;
    Truncated?: boolean;
  };
  declare type KMS$20141101$ListGrantsRequest = {
    Limit?: number;
    Marker?: string;
    KeyId: string;
  };
  declare type KMS$20141101$ListGrantsResponse = {
    Grants?: KMS$20141101$GrantList;
    NextMarker?: string;
    Truncated?: boolean;
  };
  declare type KMS$20141101$ListKeyPoliciesRequest = {
    KeyId: string;
    Limit?: number;
    Marker?: string;
  };
  declare type KMS$20141101$ListKeyPoliciesResponse = {
    PolicyNames?: KMS$20141101$PolicyNameList;
    NextMarker?: string;
    Truncated?: boolean;
  };
  declare type KMS$20141101$ListKeysRequest = {
    Limit?: number;
    Marker?: string;
  };
  declare type KMS$20141101$ListKeysResponse = {
    Keys?: KMS$20141101$KeyList;
    NextMarker?: string;
    Truncated?: boolean;
  };
  declare type KMS$20141101$ListRetirableGrantsRequest = {
    Limit?: number;
    Marker?: string;
    RetiringPrincipal: string;
  };
  declare type KMS$20141101$MalformedPolicyDocumentException = {
    message?: string;
  };
  declare type KMS$20141101$NotFoundException = {
    message?: string;
  };
  declare type KMS$20141101$OriginType = 'AWS_KMS' | 'EXTERNAL';
  declare type KMS$20141101$PlaintextType = Buffer | $TypedArray | Blob | string;
  declare type KMS$20141101$PolicyNameList = string[];
  declare type KMS$20141101$PutKeyPolicyRequest = {
    KeyId: string;
    PolicyName: string;
    Policy: string;
    BypassPolicyLockoutSafetyCheck?: boolean;
  };
  declare type KMS$20141101$ReEncryptRequest = {
    CiphertextBlob: Buffer | $TypedArray | Blob | string;
    SourceEncryptionContext?: {
      [key: string]: string;
    };
    DestinationKeyId: string;
    DestinationEncryptionContext?: {
      [key: string]: string;
    };
    GrantTokens?: KMS$20141101$GrantTokenList;
  };
  declare type KMS$20141101$ReEncryptResponse = {
    CiphertextBlob?: Buffer | $TypedArray | Blob | string;
    SourceKeyId?: string;
    KeyId?: string;
  };
  declare type KMS$20141101$RetireGrantRequest = {
    GrantToken?: string;
    KeyId?: string;
    GrantId?: string;
  };
  declare type KMS$20141101$RevokeGrantRequest = {
    KeyId: string;
    GrantId: string;
  };
  declare type KMS$20141101$ScheduleKeyDeletionRequest = {
    KeyId: string;
    PendingWindowInDays?: number;
  };
  declare type KMS$20141101$ScheduleKeyDeletionResponse = {
    KeyId?: string;
    DeletionDate?: Date;
  };
  declare type KMS$20141101$UnsupportedOperationException = {
    message?: string;
  };
  declare type KMS$20141101$UpdateAliasRequest = {
    AliasName: string;
    TargetKeyId: string;
  };
  declare type KMS$20141101$UpdateKeyDescriptionRequest = {
    KeyId: string;
    Description: string;
  };
  declare type KMS$20141101$WrappingKeySpec = 'RSA_2048';
  declare type Lambda$20141111$AddEventSourceRequest = {
    EventSource: string;
    FunctionName: string;
    Role: string;
    BatchSize?: number;
    Parameters?: {
      [key: string]: string;
    };
  };
  declare type Lambda$20141111$Blob = Buffer | $TypedArray | Blob | string;
  declare type Lambda$20141111$DeleteFunctionRequest = {
    FunctionName: string;
  };
  declare type Lambda$20141111$EventSourceConfiguration = {
    UUID?: string;
    BatchSize?: number;
    EventSource?: string;
    FunctionName?: string;
    Parameters?: {
      [key: string]: string;
    };
    Role?: string;
    LastModified?: Date;
    IsActive?: boolean;
    Status?: string;
  };
  declare type Lambda$20141111$EventSourceList = Lambda$20141111$EventSourceConfiguration[];
  declare type Lambda$20141111$FunctionCodeLocation = {
    RepositoryType?: string;
    Location?: string;
  };
  declare type Lambda$20141111$FunctionConfiguration = {
    FunctionName?: string;
    FunctionARN?: string;
    ConfigurationId?: string;
    Runtime?: 'nodejs';
    Role?: string;
    Handler?: string;
    Mode?: 'event';
    CodeSize?: number;
    Description?: string;
    Timeout?: number;
    MemorySize?: number;
    LastModified?: Date;
  };
  declare type Lambda$20141111$FunctionList = Lambda$20141111$FunctionConfiguration[];
  declare type Lambda$20141111$GetEventSourceRequest = {
    UUID: string;
  };
  declare type Lambda$20141111$GetFunctionConfigurationRequest = {
    FunctionName: string;
  };
  declare type Lambda$20141111$GetFunctionRequest = {
    FunctionName: string;
  };
  declare type Lambda$20141111$GetFunctionResponse = {
    Configuration?: Lambda$20141111$FunctionConfiguration;
    Code?: Lambda$20141111$FunctionCodeLocation;
  };
  declare type Lambda$20141111$InvalidParameterValueException = {
    Type?: string;
    message?: string;
  };
  declare type Lambda$20141111$InvalidRequestContentException = {
    Type?: string;
    message?: string;
  };
  declare type Lambda$20141111$InvokeAsyncRequest = {
    FunctionName: string;
    InvokeArgs: Buffer | $TypedArray | Blob | string;
  };
  declare type Lambda$20141111$InvokeAsyncResponse = {
    Status?: number;
  };
  declare type Lambda$20141111$ListEventSourcesRequest = {
    EventSourceArn?: string;
    FunctionName?: string;
    Marker?: string;
    MaxItems?: number;
  };
  declare type Lambda$20141111$ListEventSourcesResponse = {
    NextMarker?: string;
    EventSources?: Lambda$20141111$EventSourceList;
  };
  declare type Lambda$20141111$ListFunctionsRequest = {
    Marker?: string;
    MaxItems?: number;
  };
  declare type Lambda$20141111$ListFunctionsResponse = {
    NextMarker?: string;
    Functions?: Lambda$20141111$FunctionList;
  };
  declare type Lambda$20141111$Map = {
    [key: string]: string;
  };
  declare type Lambda$20141111$Mode = 'event';
  declare type Lambda$20141111$RemoveEventSourceRequest = {
    UUID: string;
  };
  declare type Lambda$20141111$ResourceNotFoundException = {
    Type?: string;
    Message?: string;
  };
  declare type Lambda$20141111$Runtime = 'nodejs';
  declare type Lambda$20141111$ServiceException = {
    Type?: string;
    Message?: string;
  };
  declare type Lambda$20141111$Timestamp = Date;
  declare type Lambda$20141111$UpdateFunctionConfigurationRequest = {
    FunctionName: string;
    Role?: string;
    Handler?: string;
    Description?: string;
    Timeout?: number;
    MemorySize?: number;
  };
  declare type Lambda$20141111$UploadFunctionRequest = {
    FunctionName: string;
    FunctionZip: Buffer | $TypedArray | Blob | string;
    Runtime: 'nodejs';
    Role: string;
    Handler: string;
    Mode: 'event';
    Description?: string;
    Timeout?: number;
    MemorySize?: number;
  };
  declare type Lambda$20150331$AddPermissionRequest = {
    FunctionName: string;
    StatementId: string;
    Action: string;
    Principal: string;
    SourceArn?: string;
    SourceAccount?: string;
    EventSourceToken?: string;
    Qualifier?: string;
  };
  declare type Lambda$20150331$AddPermissionResponse = {
    Statement?: string;
  };
  declare type Lambda$20150331$AliasConfiguration = {
    AliasArn?: string;
    Name?: string;
    FunctionVersion?: string;
    Description?: string;
  };
  declare type Lambda$20150331$AliasList = Lambda$20150331$AliasConfiguration[];
  declare type Lambda$20150331$Blob = Buffer | $TypedArray | Blob | string;
  declare type Lambda$20150331$BlobStream = Buffer | $TypedArray | Blob | string;
  declare type Lambda$20150331$CodeStorageExceededException = {
    Type?: string;
    message?: string;
  };
  declare type Lambda$20150331$CreateAliasRequest = {
    FunctionName: string;
    Name: string;
    FunctionVersion: string;
    Description?: string;
  };
  declare type Lambda$20150331$CreateEventSourceMappingRequest = {
    EventSourceArn: string;
    FunctionName: string;
    Enabled?: boolean;
    BatchSize?: number;
    StartingPosition: 'TRIM_HORIZON' | 'LATEST';
  };
  declare type Lambda$20150331$CreateFunctionRequest = {
    FunctionName: string;
    Runtime: 'nodejs' | 'nodejs4.3' | 'java8' | 'python2.7';
    Role: string;
    Handler: string;
    Code: Lambda$20150331$FunctionCode;
    Description?: string;
    Timeout?: number;
    MemorySize?: number;
    Publish?: boolean;
    VpcConfig?: Lambda$20150331$VpcConfig;
  };
  declare type Lambda$20150331$Date = Date;
  declare type Lambda$20150331$DeleteAliasRequest = {
    FunctionName: string;
    Name: string;
  };
  declare type Lambda$20150331$DeleteEventSourceMappingRequest = {
    UUID: string;
  };
  declare type Lambda$20150331$DeleteFunctionRequest = {
    FunctionName: string;
    Qualifier?: string;
  };
  declare type Lambda$20150331$EC2AccessDeniedException = {
    Type?: string;
    Message?: string;
  };
  declare type Lambda$20150331$EC2ThrottledException = {
    Type?: string;
    Message?: string;
  };
  declare type Lambda$20150331$EC2UnexpectedException = {
    Type?: string;
    Message?: string;
    EC2ErrorCode?: string;
  };
  declare type Lambda$20150331$ENILimitReachedException = {
    Type?: string;
    Message?: string;
  };
  declare type Lambda$20150331$EventSourceMappingConfiguration = {
    UUID?: string;
    BatchSize?: number;
    EventSourceArn?: string;
    FunctionArn?: string;
    LastModified?: Date;
    LastProcessingResult?: string;
    State?: string;
    StateTransitionReason?: string;
  };
  declare type Lambda$20150331$EventSourceMappingsList = Lambda$20150331$EventSourceMappingConfiguration[];
  declare type Lambda$20150331$EventSourcePosition = 'TRIM_HORIZON' | 'LATEST';
  declare type Lambda$20150331$FunctionCode = {
    ZipFile?: Buffer | $TypedArray | Blob | string;
    S3Bucket?: string;
    S3Key?: string;
    S3ObjectVersion?: string;
  };
  declare type Lambda$20150331$FunctionCodeLocation = {
    RepositoryType?: string;
    Location?: string;
  };
  declare type Lambda$20150331$FunctionConfiguration = {
    FunctionName?: string;
    FunctionArn?: string;
    Runtime?: 'nodejs' | 'nodejs4.3' | 'java8' | 'python2.7';
    Role?: string;
    Handler?: string;
    CodeSize?: number;
    Description?: string;
    Timeout?: number;
    MemorySize?: number;
    LastModified?: string;
    CodeSha256?: string;
    Version?: string;
    VpcConfig?: Lambda$20150331$VpcConfigResponse;
  };
  declare type Lambda$20150331$FunctionList = Lambda$20150331$FunctionConfiguration[];
  declare type Lambda$20150331$GetAliasRequest = {
    FunctionName: string;
    Name: string;
  };
  declare type Lambda$20150331$GetEventSourceMappingRequest = {
    UUID: string;
  };
  declare type Lambda$20150331$GetFunctionConfigurationRequest = {
    FunctionName: string;
    Qualifier?: string;
  };
  declare type Lambda$20150331$GetFunctionRequest = {
    FunctionName: string;
    Qualifier?: string;
  };
  declare type Lambda$20150331$GetFunctionResponse = {
    Configuration?: Lambda$20150331$FunctionConfiguration;
    Code?: Lambda$20150331$FunctionCodeLocation;
  };
  declare type Lambda$20150331$GetPolicyRequest = {
    FunctionName: string;
    Qualifier?: string;
  };
  declare type Lambda$20150331$GetPolicyResponse = {
    Policy?: string;
  };
  declare type Lambda$20150331$InvalidParameterValueException = {
    Type?: string;
    message?: string;
  };
  declare type Lambda$20150331$InvalidRequestContentException = {
    Type?: string;
    message?: string;
  };
  declare type Lambda$20150331$InvalidSecurityGroupIDException = {
    Type?: string;
    Message?: string;
  };
  declare type Lambda$20150331$InvalidSubnetIDException = {
    Type?: string;
    Message?: string;
  };
  declare type Lambda$20150331$InvalidZipFileException = {
    Type?: string;
    Message?: string;
  };
  declare type Lambda$20150331$InvocationRequest = {
    FunctionName: string;
    InvocationType?: 'Event' | 'RequestResponse' | 'DryRun';
    LogType?: 'None' | 'Tail';
    ClientContext?: string;
    Payload?: Buffer | $TypedArray | Blob | string;
    Qualifier?: string;
  };
  declare type Lambda$20150331$InvocationResponse = {
    StatusCode?: number;
    FunctionError?: string;
    LogResult?: string;
    Payload?: Buffer | $TypedArray | Blob | string;
  };
  declare type Lambda$20150331$InvocationType = 'Event' | 'RequestResponse' | 'DryRun';
  declare type Lambda$20150331$InvokeAsyncRequest = {
    FunctionName: string;
    InvokeArgs: Buffer | $TypedArray | Blob | string;
  };
  declare type Lambda$20150331$InvokeAsyncResponse = {
    Status?: number;
  };
  declare type Lambda$20150331$ListAliasesRequest = {
    FunctionName: string;
    FunctionVersion?: string;
    Marker?: string;
    MaxItems?: number;
  };
  declare type Lambda$20150331$ListAliasesResponse = {
    NextMarker?: string;
    Aliases?: Lambda$20150331$AliasList;
  };
  declare type Lambda$20150331$ListEventSourceMappingsRequest = {
    EventSourceArn?: string;
    FunctionName?: string;
    Marker?: string;
    MaxItems?: number;
  };
  declare type Lambda$20150331$ListEventSourceMappingsResponse = {
    NextMarker?: string;
    EventSourceMappings?: Lambda$20150331$EventSourceMappingsList;
  };
  declare type Lambda$20150331$ListFunctionsRequest = {
    Marker?: string;
    MaxItems?: number;
  };
  declare type Lambda$20150331$ListFunctionsResponse = {
    NextMarker?: string;
    Functions?: Lambda$20150331$FunctionList;
  };
  declare type Lambda$20150331$ListVersionsByFunctionRequest = {
    FunctionName: string;
    Marker?: string;
    MaxItems?: number;
  };
  declare type Lambda$20150331$ListVersionsByFunctionResponse = {
    NextMarker?: string;
    Versions?: Lambda$20150331$FunctionList;
  };
  declare type Lambda$20150331$LogType = 'None' | 'Tail';
  declare type Lambda$20150331$PolicyLengthExceededException = {
    Type?: string;
    message?: string;
  };
  declare type Lambda$20150331$PublishVersionRequest = {
    FunctionName: string;
    CodeSha256?: string;
    Description?: string;
  };
  declare type Lambda$20150331$RemovePermissionRequest = {
    FunctionName: string;
    StatementId: string;
    Qualifier?: string;
  };
  declare type Lambda$20150331$RequestTooLargeException = {
    Type?: string;
    message?: string;
  };
  declare type Lambda$20150331$ResourceConflictException = {
    Type?: string;
    message?: string;
  };
  declare type Lambda$20150331$ResourceNotFoundException = {
    Type?: string;
    Message?: string;
  };
  declare type Lambda$20150331$Runtime = 'nodejs' | 'nodejs4.3' | 'java8' | 'python2.7';
  declare type Lambda$20150331$SecurityGroupIds = string[];
  declare type Lambda$20150331$ServiceException = {
    Type?: string;
    Message?: string;
  };
  declare type Lambda$20150331$SubnetIPAddressLimitReachedException = {
    Type?: string;
    Message?: string;
  };
  declare type Lambda$20150331$SubnetIds = string[];
  declare type Lambda$20150331$ThrottleReason = 'ConcurrentInvocationLimitExceeded' | 'FunctionInvocationRateLimitExceeded' | 'CallerRateLimitExceeded';
  declare type Lambda$20150331$TooManyRequestsException = {
    retryAfterSeconds?: string;
    Type?: string;
    message?: string;
    Reason?: 'ConcurrentInvocationLimitExceeded' | 'FunctionInvocationRateLimitExceeded' | 'CallerRateLimitExceeded';
  };
  declare type Lambda$20150331$UnsupportedMediaTypeException = {
    Type?: string;
    message?: string;
  };
  declare type Lambda$20150331$UpdateAliasRequest = {
    FunctionName: string;
    Name: string;
    FunctionVersion?: string;
    Description?: string;
  };
  declare type Lambda$20150331$UpdateEventSourceMappingRequest = {
    UUID: string;
    FunctionName?: string;
    Enabled?: boolean;
    BatchSize?: number;
  };
  declare type Lambda$20150331$UpdateFunctionCodeRequest = {
    FunctionName: string;
    ZipFile?: Buffer | $TypedArray | Blob | string;
    S3Bucket?: string;
    S3Key?: string;
    S3ObjectVersion?: string;
    Publish?: boolean;
  };
  declare type Lambda$20150331$UpdateFunctionConfigurationRequest = {
    FunctionName: string;
    Role?: string;
    Handler?: string;
    Description?: string;
    Timeout?: number;
    MemorySize?: number;
    VpcConfig?: Lambda$20150331$VpcConfig;
    Runtime?: 'nodejs' | 'nodejs4.3' | 'java8' | 'python2.7';
  };
  declare type Lambda$20150331$VpcConfig = {
    SubnetIds?: Lambda$20150331$SubnetIds;
    SecurityGroupIds?: Lambda$20150331$SecurityGroupIds;
  };
  declare type Lambda$20150331$VpcConfigResponse = {
    SubnetIds?: Lambda$20150331$SubnetIds;
    SecurityGroupIds?: Lambda$20150331$SecurityGroupIds;
    VpcId?: string;
  };
  declare type MachineLearning$20141212$AddTagsInput = {
    Tags: MachineLearning$20141212$TagList;
    ResourceId: string;
    ResourceType: 'BatchPrediction' | 'DataSource' | 'Evaluation' | 'MLModel';
  };
  declare type MachineLearning$20141212$AddTagsOutput = {
    ResourceId?: string;
    ResourceType?: 'BatchPrediction' | 'DataSource' | 'Evaluation' | 'MLModel';
  };
  declare type MachineLearning$20141212$Algorithm = 'sgd';
  declare type MachineLearning$20141212$BatchPrediction = {
    BatchPredictionId?: string;
    MLModelId?: string;
    BatchPredictionDataSourceId?: string;
    InputDataLocationS3?: string;
    CreatedByIamUser?: string;
    CreatedAt?: Date;
    LastUpdatedAt?: Date;
    Name?: string;
    Status?: 'PENDING' | 'INPROGRESS' | 'FAILED' | 'COMPLETED' | 'DELETED';
    OutputUri?: string;
    Message?: string;
    ComputeTime?: number;
    FinishedAt?: Date;
    StartedAt?: Date;
    TotalRecordCount?: number;
    InvalidRecordCount?: number;
  };
  declare type MachineLearning$20141212$BatchPredictionFilterVariable = 'CreatedAt' | 'LastUpdatedAt' | 'Status' | 'Name' | 'IAMUser' | 'MLModelId' | 'DataSourceId' | 'DataURI';
  declare type MachineLearning$20141212$BatchPredictions = MachineLearning$20141212$BatchPrediction[];
  declare type MachineLearning$20141212$CreateBatchPredictionInput = {
    BatchPredictionId: string;
    BatchPredictionName?: string;
    MLModelId: string;
    BatchPredictionDataSourceId: string;
    OutputUri: string;
  };
  declare type MachineLearning$20141212$CreateBatchPredictionOutput = {
    BatchPredictionId?: string;
  };
  declare type MachineLearning$20141212$CreateDataSourceFromRDSInput = {
    DataSourceId: string;
    DataSourceName?: string;
    RDSData: MachineLearning$20141212$RDSDataSpec;
    RoleARN: string;
    ComputeStatistics?: boolean;
  };
  declare type MachineLearning$20141212$CreateDataSourceFromRDSOutput = {
    DataSourceId?: string;
  };
  declare type MachineLearning$20141212$CreateDataSourceFromRedshiftInput = {
    DataSourceId: string;
    DataSourceName?: string;
    DataSpec: MachineLearning$20141212$RedshiftDataSpec;
    RoleARN: string;
    ComputeStatistics?: boolean;
  };
  declare type MachineLearning$20141212$CreateDataSourceFromRedshiftOutput = {
    DataSourceId?: string;
  };
  declare type MachineLearning$20141212$CreateDataSourceFromS3Input = {
    DataSourceId: string;
    DataSourceName?: string;
    DataSpec: MachineLearning$20141212$S3DataSpec;
    ComputeStatistics?: boolean;
  };
  declare type MachineLearning$20141212$CreateDataSourceFromS3Output = {
    DataSourceId?: string;
  };
  declare type MachineLearning$20141212$CreateEvaluationInput = {
    EvaluationId: string;
    EvaluationName?: string;
    MLModelId: string;
    EvaluationDataSourceId: string;
  };
  declare type MachineLearning$20141212$CreateEvaluationOutput = {
    EvaluationId?: string;
  };
  declare type MachineLearning$20141212$CreateMLModelInput = {
    MLModelId: string;
    MLModelName?: string;
    MLModelType: 'REGRESSION' | 'BINARY' | 'MULTICLASS';
    Parameters?: {
      [key: string]: string;
    };
    TrainingDataSourceId: string;
    Recipe?: string;
    RecipeUri?: string;
  };
  declare type MachineLearning$20141212$CreateMLModelOutput = {
    MLModelId?: string;
  };
  declare type MachineLearning$20141212$CreateRealtimeEndpointInput = {
    MLModelId: string;
  };
  declare type MachineLearning$20141212$CreateRealtimeEndpointOutput = {
    MLModelId?: string;
    RealtimeEndpointInfo?: MachineLearning$20141212$RealtimeEndpointInfo;
  };
  declare type MachineLearning$20141212$DataSource = {
    DataSourceId?: string;
    DataLocationS3?: string;
    DataRearrangement?: string;
    CreatedByIamUser?: string;
    CreatedAt?: Date;
    LastUpdatedAt?: Date;
    DataSizeInBytes?: number;
    NumberOfFiles?: number;
    Name?: string;
    Status?: 'PENDING' | 'INPROGRESS' | 'FAILED' | 'COMPLETED' | 'DELETED';
    Message?: string;
    RedshiftMetadata?: MachineLearning$20141212$RedshiftMetadata;
    RDSMetadata?: MachineLearning$20141212$RDSMetadata;
    RoleARN?: string;
    ComputeStatistics?: boolean;
    ComputeTime?: number;
    FinishedAt?: Date;
    StartedAt?: Date;
  };
  declare type MachineLearning$20141212$DataSourceFilterVariable = 'CreatedAt' | 'LastUpdatedAt' | 'Status' | 'Name' | 'DataLocationS3' | 'IAMUser';
  declare type MachineLearning$20141212$DataSources = MachineLearning$20141212$DataSource[];
  declare type MachineLearning$20141212$DeleteBatchPredictionInput = {
    BatchPredictionId: string;
  };
  declare type MachineLearning$20141212$DeleteBatchPredictionOutput = {
    BatchPredictionId?: string;
  };
  declare type MachineLearning$20141212$DeleteDataSourceInput = {
    DataSourceId: string;
  };
  declare type MachineLearning$20141212$DeleteDataSourceOutput = {
    DataSourceId?: string;
  };
  declare type MachineLearning$20141212$DeleteEvaluationInput = {
    EvaluationId: string;
  };
  declare type MachineLearning$20141212$DeleteEvaluationOutput = {
    EvaluationId?: string;
  };
  declare type MachineLearning$20141212$DeleteMLModelInput = {
    MLModelId: string;
  };
  declare type MachineLearning$20141212$DeleteMLModelOutput = {
    MLModelId?: string;
  };
  declare type MachineLearning$20141212$DeleteRealtimeEndpointInput = {
    MLModelId: string;
  };
  declare type MachineLearning$20141212$DeleteRealtimeEndpointOutput = {
    MLModelId?: string;
    RealtimeEndpointInfo?: MachineLearning$20141212$RealtimeEndpointInfo;
  };
  declare type MachineLearning$20141212$DeleteTagsInput = {
    TagKeys: MachineLearning$20141212$TagKeyList;
    ResourceId: string;
    ResourceType: 'BatchPrediction' | 'DataSource' | 'Evaluation' | 'MLModel';
  };
  declare type MachineLearning$20141212$DeleteTagsOutput = {
    ResourceId?: string;
    ResourceType?: 'BatchPrediction' | 'DataSource' | 'Evaluation' | 'MLModel';
  };
  declare type MachineLearning$20141212$DescribeBatchPredictionsInput = {
    FilterVariable?: 'CreatedAt' | 'LastUpdatedAt' | 'Status' | 'Name' | 'IAMUser' | 'MLModelId' | 'DataSourceId' | 'DataURI';
    EQ?: string;
    GT?: string;
    LT?: string;
    GE?: string;
    LE?: string;
    NE?: string;
    Prefix?: string;
    SortOrder?: 'asc' | 'dsc';
    NextToken?: string;
    Limit?: number;
  };
  declare type MachineLearning$20141212$DescribeBatchPredictionsOutput = {
    Results?: MachineLearning$20141212$BatchPredictions;
    NextToken?: string;
  };
  declare type MachineLearning$20141212$DescribeDataSourcesInput = {
    FilterVariable?: 'CreatedAt' | 'LastUpdatedAt' | 'Status' | 'Name' | 'DataLocationS3' | 'IAMUser';
    EQ?: string;
    GT?: string;
    LT?: string;
    GE?: string;
    LE?: string;
    NE?: string;
    Prefix?: string;
    SortOrder?: 'asc' | 'dsc';
    NextToken?: string;
    Limit?: number;
  };
  declare type MachineLearning$20141212$DescribeDataSourcesOutput = {
    Results?: MachineLearning$20141212$DataSources;
    NextToken?: string;
  };
  declare type MachineLearning$20141212$DescribeEvaluationsInput = {
    FilterVariable?: 'CreatedAt' | 'LastUpdatedAt' | 'Status' | 'Name' | 'IAMUser' | 'MLModelId' | 'DataSourceId' | 'DataURI';
    EQ?: string;
    GT?: string;
    LT?: string;
    GE?: string;
    LE?: string;
    NE?: string;
    Prefix?: string;
    SortOrder?: 'asc' | 'dsc';
    NextToken?: string;
    Limit?: number;
  };
  declare type MachineLearning$20141212$DescribeEvaluationsOutput = {
    Results?: MachineLearning$20141212$Evaluations;
    NextToken?: string;
  };
  declare type MachineLearning$20141212$DescribeMLModelsInput = {
    FilterVariable?: 'CreatedAt' | 'LastUpdatedAt' | 'Status' | 'Name' | 'IAMUser' | 'TrainingDataSourceId' | 'RealtimeEndpointStatus' | 'MLModelType' | 'Algorithm' | 'TrainingDataURI';
    EQ?: string;
    GT?: string;
    LT?: string;
    GE?: string;
    LE?: string;
    NE?: string;
    Prefix?: string;
    SortOrder?: 'asc' | 'dsc';
    NextToken?: string;
    Limit?: number;
  };
  declare type MachineLearning$20141212$DescribeMLModelsOutput = {
    Results?: MachineLearning$20141212$MLModels;
    NextToken?: string;
  };
  declare type MachineLearning$20141212$DescribeTagsInput = {
    ResourceId: string;
    ResourceType: 'BatchPrediction' | 'DataSource' | 'Evaluation' | 'MLModel';
  };
  declare type MachineLearning$20141212$DescribeTagsOutput = {
    ResourceId?: string;
    ResourceType?: 'BatchPrediction' | 'DataSource' | 'Evaluation' | 'MLModel';
    Tags?: MachineLearning$20141212$TagList;
  };
  declare type MachineLearning$20141212$DetailsAttributes = 'PredictiveModelType' | 'Algorithm';
  declare type MachineLearning$20141212$DetailsMap = {
    [key: 'PredictiveModelType' | 'Algorithm']: string;
  };
  declare type MachineLearning$20141212$EDPSecurityGroupIds = string[];
  declare type MachineLearning$20141212$EntityStatus = 'PENDING' | 'INPROGRESS' | 'FAILED' | 'COMPLETED' | 'DELETED';
  declare type MachineLearning$20141212$EpochTime = Date;
  declare type MachineLearning$20141212$Evaluation = {
    EvaluationId?: string;
    MLModelId?: string;
    EvaluationDataSourceId?: string;
    InputDataLocationS3?: string;
    CreatedByIamUser?: string;
    CreatedAt?: Date;
    LastUpdatedAt?: Date;
    Name?: string;
    Status?: 'PENDING' | 'INPROGRESS' | 'FAILED' | 'COMPLETED' | 'DELETED';
    PerformanceMetrics?: MachineLearning$20141212$PerformanceMetrics;
    Message?: string;
    ComputeTime?: number;
    FinishedAt?: Date;
    StartedAt?: Date;
  };
  declare type MachineLearning$20141212$EvaluationFilterVariable = 'CreatedAt' | 'LastUpdatedAt' | 'Status' | 'Name' | 'IAMUser' | 'MLModelId' | 'DataSourceId' | 'DataURI';
  declare type MachineLearning$20141212$Evaluations = MachineLearning$20141212$Evaluation[];
  declare type MachineLearning$20141212$GetBatchPredictionInput = {
    BatchPredictionId: string;
  };
  declare type MachineLearning$20141212$GetBatchPredictionOutput = {
    BatchPredictionId?: string;
    MLModelId?: string;
    BatchPredictionDataSourceId?: string;
    InputDataLocationS3?: string;
    CreatedByIamUser?: string;
    CreatedAt?: Date;
    LastUpdatedAt?: Date;
    Name?: string;
    Status?: 'PENDING' | 'INPROGRESS' | 'FAILED' | 'COMPLETED' | 'DELETED';
    OutputUri?: string;
    LogUri?: string;
    Message?: string;
    ComputeTime?: number;
    FinishedAt?: Date;
    StartedAt?: Date;
    TotalRecordCount?: number;
    InvalidRecordCount?: number;
  };
  declare type MachineLearning$20141212$GetDataSourceInput = {
    DataSourceId: string;
    Verbose?: boolean;
  };
  declare type MachineLearning$20141212$GetDataSourceOutput = {
    DataSourceId?: string;
    DataLocationS3?: string;
    DataRearrangement?: string;
    CreatedByIamUser?: string;
    CreatedAt?: Date;
    LastUpdatedAt?: Date;
    DataSizeInBytes?: number;
    NumberOfFiles?: number;
    Name?: string;
    Status?: 'PENDING' | 'INPROGRESS' | 'FAILED' | 'COMPLETED' | 'DELETED';
    LogUri?: string;
    Message?: string;
    RedshiftMetadata?: MachineLearning$20141212$RedshiftMetadata;
    RDSMetadata?: MachineLearning$20141212$RDSMetadata;
    RoleARN?: string;
    ComputeStatistics?: boolean;
    ComputeTime?: number;
    FinishedAt?: Date;
    StartedAt?: Date;
    DataSourceSchema?: string;
  };
  declare type MachineLearning$20141212$GetEvaluationInput = {
    EvaluationId: string;
  };
  declare type MachineLearning$20141212$GetEvaluationOutput = {
    EvaluationId?: string;
    MLModelId?: string;
    EvaluationDataSourceId?: string;
    InputDataLocationS3?: string;
    CreatedByIamUser?: string;
    CreatedAt?: Date;
    LastUpdatedAt?: Date;
    Name?: string;
    Status?: 'PENDING' | 'INPROGRESS' | 'FAILED' | 'COMPLETED' | 'DELETED';
    PerformanceMetrics?: MachineLearning$20141212$PerformanceMetrics;
    LogUri?: string;
    Message?: string;
    ComputeTime?: number;
    FinishedAt?: Date;
    StartedAt?: Date;
  };
  declare type MachineLearning$20141212$GetMLModelInput = {
    MLModelId: string;
    Verbose?: boolean;
  };
  declare type MachineLearning$20141212$GetMLModelOutput = {
    MLModelId?: string;
    TrainingDataSourceId?: string;
    CreatedByIamUser?: string;
    CreatedAt?: Date;
    LastUpdatedAt?: Date;
    Name?: string;
    Status?: 'PENDING' | 'INPROGRESS' | 'FAILED' | 'COMPLETED' | 'DELETED';
    SizeInBytes?: number;
    EndpointInfo?: MachineLearning$20141212$RealtimeEndpointInfo;
    TrainingParameters?: {
      [key: string]: string;
    };
    InputDataLocationS3?: string;
    MLModelType?: 'REGRESSION' | 'BINARY' | 'MULTICLASS';
    ScoreThreshold?: number;
    ScoreThresholdLastUpdatedAt?: Date;
    LogUri?: string;
    Message?: string;
    ComputeTime?: number;
    FinishedAt?: Date;
    StartedAt?: Date;
    Recipe?: string;
    Schema?: string;
  };
  declare type MachineLearning$20141212$IdempotentParameterMismatchException = {
    message?: string;
    code?: number;
  };
  declare type MachineLearning$20141212$InternalServerException = {
    message?: string;
    code?: number;
  };
  declare type MachineLearning$20141212$InvalidInputException = {
    message?: string;
    code?: number;
  };
  declare type MachineLearning$20141212$InvalidTagException = {
    message?: string;
  };
  declare type MachineLearning$20141212$LimitExceededException = {
    message?: string;
    code?: number;
  };
  declare type MachineLearning$20141212$MLModel = {
    MLModelId?: string;
    TrainingDataSourceId?: string;
    CreatedByIamUser?: string;
    CreatedAt?: Date;
    LastUpdatedAt?: Date;
    Name?: string;
    Status?: 'PENDING' | 'INPROGRESS' | 'FAILED' | 'COMPLETED' | 'DELETED';
    SizeInBytes?: number;
    EndpointInfo?: MachineLearning$20141212$RealtimeEndpointInfo;
    TrainingParameters?: {
      [key: string]: string;
    };
    InputDataLocationS3?: string;
    Algorithm?: 'sgd';
    MLModelType?: 'REGRESSION' | 'BINARY' | 'MULTICLASS';
    ScoreThreshold?: number;
    ScoreThresholdLastUpdatedAt?: Date;
    Message?: string;
    ComputeTime?: number;
    FinishedAt?: Date;
    StartedAt?: Date;
  };
  declare type MachineLearning$20141212$MLModelFilterVariable = 'CreatedAt' | 'LastUpdatedAt' | 'Status' | 'Name' | 'IAMUser' | 'TrainingDataSourceId' | 'RealtimeEndpointStatus' | 'MLModelType' | 'Algorithm' | 'TrainingDataURI';
  declare type MachineLearning$20141212$MLModelType = 'REGRESSION' | 'BINARY' | 'MULTICLASS';
  declare type MachineLearning$20141212$MLModels = MachineLearning$20141212$MLModel[];
  declare type MachineLearning$20141212$PerformanceMetrics = {
    Properties?: {
      [key: string]: string;
    };
  };
  declare type MachineLearning$20141212$PerformanceMetricsProperties = {
    [key: string]: string;
  };
  declare type MachineLearning$20141212$PredictInput = {
    MLModelId: string;
    Record: {
      [key: string]: string;
    };
    PredictEndpoint: string;
  };
  declare type MachineLearning$20141212$PredictOutput = {
    Prediction?: MachineLearning$20141212$Prediction;
  };
  declare type MachineLearning$20141212$Prediction = {
    predictedLabel?: string;
    predictedValue?: number;
    predictedScores?: {
      [key: string]: number;
    };
    details?: {
      [key: 'PredictiveModelType' | 'Algorithm']: string;
    };
  };
  declare type MachineLearning$20141212$PredictorNotMountedException = {
    message?: string;
  };
  declare type MachineLearning$20141212$RDSDataSpec = {
    DatabaseInformation: MachineLearning$20141212$RDSDatabase;
    SelectSqlQuery: string;
    DatabaseCredentials: MachineLearning$20141212$RDSDatabaseCredentials;
    S3StagingLocation: string;
    DataRearrangement?: string;
    DataSchema?: string;
    DataSchemaUri?: string;
    ResourceRole: string;
    ServiceRole: string;
    SubnetId: string;
    SecurityGroupIds: MachineLearning$20141212$EDPSecurityGroupIds;
  };
  declare type MachineLearning$20141212$RDSDatabase = {
    InstanceIdentifier: string;
    DatabaseName: string;
  };
  declare type MachineLearning$20141212$RDSDatabaseCredentials = {
    Username: string;
    Password: string;
  };
  declare type MachineLearning$20141212$RDSMetadata = {
    Database?: MachineLearning$20141212$RDSDatabase;
    DatabaseUserName?: string;
    SelectSqlQuery?: string;
    ResourceRole?: string;
    ServiceRole?: string;
    DataPipelineId?: string;
  };
  declare type MachineLearning$20141212$RealtimeEndpointInfo = {
    PeakRequestsPerSecond?: number;
    CreatedAt?: Date;
    EndpointUrl?: string;
    EndpointStatus?: 'NONE' | 'READY' | 'UPDATING' | 'FAILED';
  };
  declare type MachineLearning$20141212$RealtimeEndpointStatus = 'NONE' | 'READY' | 'UPDATING' | 'FAILED';
  declare type MachineLearning$20141212$Record = {
    [key: string]: string;
  };
  declare type MachineLearning$20141212$RedshiftDataSpec = {
    DatabaseInformation: MachineLearning$20141212$RedshiftDatabase;
    SelectSqlQuery: string;
    DatabaseCredentials: MachineLearning$20141212$RedshiftDatabaseCredentials;
    S3StagingLocation: string;
    DataRearrangement?: string;
    DataSchema?: string;
    DataSchemaUri?: string;
  };
  declare type MachineLearning$20141212$RedshiftDatabase = {
    DatabaseName: string;
    ClusterIdentifier: string;
  };
  declare type MachineLearning$20141212$RedshiftDatabaseCredentials = {
    Username: string;
    Password: string;
  };
  declare type MachineLearning$20141212$RedshiftMetadata = {
    RedshiftDatabase?: MachineLearning$20141212$RedshiftDatabase;
    DatabaseUserName?: string;
    SelectSqlQuery?: string;
  };
  declare type MachineLearning$20141212$ResourceNotFoundException = {
    message?: string;
    code?: number;
  };
  declare type MachineLearning$20141212$S3DataSpec = {
    DataLocationS3: string;
    DataRearrangement?: string;
    DataSchema?: string;
    DataSchemaLocationS3?: string;
  };
  declare type MachineLearning$20141212$ScoreValuePerLabelMap = {
    [key: string]: number;
  };
  declare type MachineLearning$20141212$SortOrder = 'asc' | 'dsc';
  declare type MachineLearning$20141212$Tag = {
    Key?: string;
    Value?: string;
  };
  declare type MachineLearning$20141212$TagKeyList = string[];
  declare type MachineLearning$20141212$TagLimitExceededException = {
    message?: string;
  };
  declare type MachineLearning$20141212$TagList = MachineLearning$20141212$Tag[];
  declare type MachineLearning$20141212$TaggableResourceType = 'BatchPrediction' | 'DataSource' | 'Evaluation' | 'MLModel';
  declare type MachineLearning$20141212$TrainingParameters = {
    [key: string]: string;
  };
  declare type MachineLearning$20141212$UpdateBatchPredictionInput = {
    BatchPredictionId: string;
    BatchPredictionName: string;
  };
  declare type MachineLearning$20141212$UpdateBatchPredictionOutput = {
    BatchPredictionId?: string;
  };
  declare type MachineLearning$20141212$UpdateDataSourceInput = {
    DataSourceId: string;
    DataSourceName: string;
  };
  declare type MachineLearning$20141212$UpdateDataSourceOutput = {
    DataSourceId?: string;
  };
  declare type MachineLearning$20141212$UpdateEvaluationInput = {
    EvaluationId: string;
    EvaluationName: string;
  };
  declare type MachineLearning$20141212$UpdateEvaluationOutput = {
    EvaluationId?: string;
  };
  declare type MachineLearning$20141212$UpdateMLModelInput = {
    MLModelId: string;
    MLModelName?: string;
    ScoreThreshold?: number;
  };
  declare type MachineLearning$20141212$UpdateMLModelOutput = {
    MLModelId?: string;
  };
  declare type MarketplaceCommerceAnalytics$20150701$CustomerDefinedValues = {
    [key: string]: string;
  };
  declare type MarketplaceCommerceAnalytics$20150701$DataSetPublicationDate = Date;
  declare type MarketplaceCommerceAnalytics$20150701$DataSetType = 'customer_subscriber_hourly_monthly_subscriptions' | 'customer_subscriber_annual_subscriptions' | 'daily_business_usage_by_instance_type' | 'daily_business_fees' | 'daily_business_free_trial_conversions' | 'daily_business_new_instances' | 'daily_business_new_product_subscribers' | 'daily_business_canceled_product_subscribers' | 'monthly_revenue_billing_and_revenue_data' | 'monthly_revenue_annual_subscriptions' | 'disbursed_amount_by_product' | 'disbursed_amount_by_product_with_uncollected_funds' | 'disbursed_amount_by_customer_geo' | 'disbursed_amount_by_age_of_uncollected_funds' | 'disbursed_amount_by_age_of_disbursed_funds' | 'customer_profile_by_industry' | 'customer_profile_by_revenue' | 'customer_profile_by_geography';
  declare type MarketplaceCommerceAnalytics$20150701$FromDate = Date;
  declare type MarketplaceCommerceAnalytics$20150701$GenerateDataSetRequest = {
    dataSetType: 'customer_subscriber_hourly_monthly_subscriptions' | 'customer_subscriber_annual_subscriptions' | 'daily_business_usage_by_instance_type' | 'daily_business_fees' | 'daily_business_free_trial_conversions' | 'daily_business_new_instances' | 'daily_business_new_product_subscribers' | 'daily_business_canceled_product_subscribers' | 'monthly_revenue_billing_and_revenue_data' | 'monthly_revenue_annual_subscriptions' | 'disbursed_amount_by_product' | 'disbursed_amount_by_product_with_uncollected_funds' | 'disbursed_amount_by_customer_geo' | 'disbursed_amount_by_age_of_uncollected_funds' | 'disbursed_amount_by_age_of_disbursed_funds' | 'customer_profile_by_industry' | 'customer_profile_by_revenue' | 'customer_profile_by_geography';
    dataSetPublicationDate: Date;
    roleNameArn: string;
    destinationS3BucketName: string;
    destinationS3Prefix?: string;
    snsTopicArn: string;
    customerDefinedValues?: {
      [key: string]: string;
    };
  };
  declare type MarketplaceCommerceAnalytics$20150701$GenerateDataSetResult = {
    dataSetRequestId?: string;
  };
  declare type MarketplaceCommerceAnalytics$20150701$MarketplaceCommerceAnalyticsException = {
    message?: string;
  };
  declare type MarketplaceCommerceAnalytics$20150701$StartSupportDataExportRequest = {
    dataSetType: 'customer_support_contacts_data' | 'test_customer_support_contacts_data';
    fromDate: Date;
    roleNameArn: string;
    destinationS3BucketName: string;
    destinationS3Prefix?: string;
    snsTopicArn: string;
    customerDefinedValues?: {
      [key: string]: string;
    };
  };
  declare type MarketplaceCommerceAnalytics$20150701$StartSupportDataExportResult = {
    dataSetRequestId?: string;
  };
  declare type MarketplaceCommerceAnalytics$20150701$SupportDataSetType = 'customer_support_contacts_data' | 'test_customer_support_contacts_data';
  declare type MarketplaceMetering$20160114$DuplicateRequestException = {
    message?: string;
  };
  declare type MarketplaceMetering$20160114$InternalServiceErrorException = {
    message?: string;
  };
  declare type MarketplaceMetering$20160114$InvalidEndpointRegionException = {
    message?: string;
  };
  declare type MarketplaceMetering$20160114$InvalidProductCodeException = {
    message?: string;
  };
  declare type MarketplaceMetering$20160114$InvalidUsageDimensionException = {
    message?: string;
  };
  declare type MarketplaceMetering$20160114$MeterUsageRequest = {
    ProductCode: string;
    Timestamp: Date;
    UsageDimension: string;
    UsageQuantity: number;
    DryRun: boolean;
  };
  declare type MarketplaceMetering$20160114$MeterUsageResult = {
    MeteringRecordId?: string;
  };
  declare type MarketplaceMetering$20160114$ThrottlingException = {
    message?: string;
  };
  declare type MarketplaceMetering$20160114$Timestamp = Date;
  declare type MarketplaceMetering$20160114$TimestampOutOfBoundsException = {
    message?: string;
  };
  declare type MobileAnalytics$20140605$BadRequestException = {
    message?: string;
  };
  declare type MobileAnalytics$20140605$Event = {
    eventType: string;
    timestamp: string;
    session?: MobileAnalytics$20140605$Session;
    version?: string;
    attributes?: {
      [key: string]: string;
    };
    metrics?: {
      [key: string]: number;
    };
  };
  declare type MobileAnalytics$20140605$EventListDefinition = MobileAnalytics$20140605$Event[];
  declare type MobileAnalytics$20140605$MapOfStringToNumber = {
    [key: string]: number;
  };
  declare type MobileAnalytics$20140605$MapOfStringToString = {
    [key: string]: string;
  };
  declare type MobileAnalytics$20140605$PutEventsInput = {
    events: MobileAnalytics$20140605$EventListDefinition;
    clientContext: string;
    clientContextEncoding?: string;
  };
  declare type MobileAnalytics$20140605$Session = {
    id?: string;
    duration?: number;
    startTimestamp?: string;
    stopTimestamp?: string;
  };
  declare type OpsWorks$20130218$AgentVersion = {
    Version?: string;
    ConfigurationManager?: OpsWorks$20130218$StackConfigurationManager;
  };
  declare type OpsWorks$20130218$AgentVersions = OpsWorks$20130218$AgentVersion[];
  declare type OpsWorks$20130218$App = {
    AppId?: string;
    StackId?: string;
    Shortname?: string;
    Name?: string;
    Description?: string;
    DataSources?: OpsWorks$20130218$DataSources;
    Type?: 'aws-flow-ruby' | 'java' | 'rails' | 'php' | 'nodejs' | 'static' | 'other';
    AppSource?: OpsWorks$20130218$Source;
    Domains?: OpsWorks$20130218$Strings;
    EnableSsl?: boolean;
    SslConfiguration?: OpsWorks$20130218$SslConfiguration;
    Attributes?: {
      [key: 'DocumentRoot' | 'RailsEnv' | 'AutoBundleOnDeploy' | 'AwsFlowRubySettings']: string;
    };
    CreatedAt?: string;
    Environment?: OpsWorks$20130218$EnvironmentVariables;
  };
  declare type OpsWorks$20130218$AppAttributes = {
    [key: 'DocumentRoot' | 'RailsEnv' | 'AutoBundleOnDeploy' | 'AwsFlowRubySettings']: string;
  };
  declare type OpsWorks$20130218$AppAttributesKeys = 'DocumentRoot' | 'RailsEnv' | 'AutoBundleOnDeploy' | 'AwsFlowRubySettings';
  declare type OpsWorks$20130218$AppType = 'aws-flow-ruby' | 'java' | 'rails' | 'php' | 'nodejs' | 'static' | 'other';
  declare type OpsWorks$20130218$Apps = OpsWorks$20130218$App[];
  declare type OpsWorks$20130218$Architecture = 'x86_64' | 'i386';
  declare type OpsWorks$20130218$AssignInstanceRequest = {
    InstanceId: string;
    LayerIds: OpsWorks$20130218$Strings;
  };
  declare type OpsWorks$20130218$AssignVolumeRequest = {
    VolumeId: string;
    InstanceId?: string;
  };
  declare type OpsWorks$20130218$AssociateElasticIpRequest = {
    ElasticIp: string;
    InstanceId?: string;
  };
  declare type OpsWorks$20130218$AttachElasticLoadBalancerRequest = {
    ElasticLoadBalancerName: string;
    LayerId: string;
  };
  declare type OpsWorks$20130218$AutoScalingThresholds = {
    InstanceCount?: number;
    ThresholdsWaitTime?: number;
    IgnoreMetricsTime?: number;
    CpuThreshold?: number;
    MemoryThreshold?: number;
    LoadThreshold?: number;
    Alarms?: OpsWorks$20130218$Strings;
  };
  declare type OpsWorks$20130218$AutoScalingType = 'load' | 'timer';
  declare type OpsWorks$20130218$BlockDeviceMapping = {
    DeviceName?: string;
    NoDevice?: string;
    VirtualName?: string;
    Ebs?: OpsWorks$20130218$EbsBlockDevice;
  };
  declare type OpsWorks$20130218$BlockDeviceMappings = OpsWorks$20130218$BlockDeviceMapping[];
  declare type OpsWorks$20130218$ChefConfiguration = {
    ManageBerkshelf?: boolean;
    BerkshelfVersion?: string;
  };
  declare type OpsWorks$20130218$CloneStackRequest = {
    SourceStackId: string;
    Name?: string;
    Region?: string;
    VpcId?: string;
    Attributes?: {
      [key: 'Color']: string;
    };
    ServiceRoleArn: string;
    DefaultInstanceProfileArn?: string;
    DefaultOs?: string;
    HostnameTheme?: string;
    DefaultAvailabilityZone?: string;
    DefaultSubnetId?: string;
    CustomJson?: string;
    ConfigurationManager?: OpsWorks$20130218$StackConfigurationManager;
    ChefConfiguration?: OpsWorks$20130218$ChefConfiguration;
    UseCustomCookbooks?: boolean;
    UseOpsworksSecurityGroups?: boolean;
    CustomCookbooksSource?: OpsWorks$20130218$Source;
    DefaultSshKeyName?: string;
    ClonePermissions?: boolean;
    CloneAppIds?: OpsWorks$20130218$Strings;
    DefaultRootDeviceType?: 'ebs' | 'instance-store';
    AgentVersion?: string;
  };
  declare type OpsWorks$20130218$CloneStackResult = {
    StackId?: string;
  };
  declare type OpsWorks$20130218$Command = {
    CommandId?: string;
    InstanceId?: string;
    DeploymentId?: string;
    CreatedAt?: string;
    AcknowledgedAt?: string;
    CompletedAt?: string;
    Status?: string;
    ExitCode?: number;
    LogUrl?: string;
    Type?: string;
  };
  declare type OpsWorks$20130218$Commands = OpsWorks$20130218$Command[];
  declare type OpsWorks$20130218$CreateAppRequest = {
    StackId: string;
    Shortname?: string;
    Name: string;
    Description?: string;
    DataSources?: OpsWorks$20130218$DataSources;
    Type: 'aws-flow-ruby' | 'java' | 'rails' | 'php' | 'nodejs' | 'static' | 'other';
    AppSource?: OpsWorks$20130218$Source;
    Domains?: OpsWorks$20130218$Strings;
    EnableSsl?: boolean;
    SslConfiguration?: OpsWorks$20130218$SslConfiguration;
    Attributes?: {
      [key: 'DocumentRoot' | 'RailsEnv' | 'AutoBundleOnDeploy' | 'AwsFlowRubySettings']: string;
    };
    Environment?: OpsWorks$20130218$EnvironmentVariables;
  };
  declare type OpsWorks$20130218$CreateAppResult = {
    AppId?: string;
  };
  declare type OpsWorks$20130218$CreateDeploymentRequest = {
    StackId: string;
    AppId?: string;
    InstanceIds?: OpsWorks$20130218$Strings;
    LayerIds?: OpsWorks$20130218$Strings;
    Command: OpsWorks$20130218$DeploymentCommand;
    Comment?: string;
    CustomJson?: string;
  };
  declare type OpsWorks$20130218$CreateDeploymentResult = {
    DeploymentId?: string;
  };
  declare type OpsWorks$20130218$CreateInstanceRequest = {
    StackId: string;
    LayerIds: OpsWorks$20130218$Strings;
    InstanceType: string;
    AutoScalingType?: 'load' | 'timer';
    Hostname?: string;
    Os?: string;
    AmiId?: string;
    SshKeyName?: string;
    AvailabilityZone?: string;
    VirtualizationType?: string;
    SubnetId?: string;
    Architecture?: 'x86_64' | 'i386';
    RootDeviceType?: 'ebs' | 'instance-store';
    BlockDeviceMappings?: OpsWorks$20130218$BlockDeviceMappings;
    InstallUpdatesOnBoot?: boolean;
    EbsOptimized?: boolean;
    AgentVersion?: string;
    Tenancy?: string;
  };
  declare type OpsWorks$20130218$CreateInstanceResult = {
    InstanceId?: string;
  };
  declare type OpsWorks$20130218$CreateLayerRequest = {
    StackId: string;
    Type: 'aws-flow-ruby' | 'ecs-cluster' | 'java-app' | 'lb' | 'web' | 'php-app' | 'rails-app' | 'nodejs-app' | 'memcached' | 'db-master' | 'monitoring-master' | 'custom';
    Name: string;
    Shortname: string;
    Attributes?: {
      [key: 'EcsClusterArn' | 'EnableHaproxyStats' | 'HaproxyStatsUrl' | 'HaproxyStatsUser' | 'HaproxyStatsPassword' | 'HaproxyHealthCheckUrl' | 'HaproxyHealthCheckMethod' | 'MysqlRootPassword' | 'MysqlRootPasswordUbiquitous' | 'GangliaUrl' | 'GangliaUser' | 'GangliaPassword' | 'MemcachedMemory' | 'NodejsVersion' | 'RubyVersion' | 'RubygemsVersion' | 'ManageBundler' | 'BundlerVersion' | 'RailsStack' | 'PassengerVersion' | 'Jvm' | 'JvmVersion' | 'JvmOptions' | 'JavaAppServer' | 'JavaAppServerVersion']: string;
    };
    CustomInstanceProfileArn?: string;
    CustomJson?: string;
    CustomSecurityGroupIds?: OpsWorks$20130218$Strings;
    Packages?: OpsWorks$20130218$Strings;
    VolumeConfigurations?: OpsWorks$20130218$VolumeConfigurations;
    EnableAutoHealing?: boolean;
    AutoAssignElasticIps?: boolean;
    AutoAssignPublicIps?: boolean;
    CustomRecipes?: OpsWorks$20130218$Recipes;
    InstallUpdatesOnBoot?: boolean;
    UseEbsOptimizedInstances?: boolean;
    LifecycleEventConfiguration?: OpsWorks$20130218$LifecycleEventConfiguration;
  };
  declare type OpsWorks$20130218$CreateLayerResult = {
    LayerId?: string;
  };
  declare type OpsWorks$20130218$CreateStackRequest = {
    Name: string;
    Region: string;
    VpcId?: string;
    Attributes?: {
      [key: 'Color']: string;
    };
    ServiceRoleArn: string;
    DefaultInstanceProfileArn: string;
    DefaultOs?: string;
    HostnameTheme?: string;
    DefaultAvailabilityZone?: string;
    DefaultSubnetId?: string;
    CustomJson?: string;
    ConfigurationManager?: OpsWorks$20130218$StackConfigurationManager;
    ChefConfiguration?: OpsWorks$20130218$ChefConfiguration;
    UseCustomCookbooks?: boolean;
    UseOpsworksSecurityGroups?: boolean;
    CustomCookbooksSource?: OpsWorks$20130218$Source;
    DefaultSshKeyName?: string;
    DefaultRootDeviceType?: 'ebs' | 'instance-store';
    AgentVersion?: string;
  };
  declare type OpsWorks$20130218$CreateStackResult = {
    StackId?: string;
  };
  declare type OpsWorks$20130218$CreateUserProfileRequest = {
    IamUserArn: string;
    SshUsername?: string;
    SshPublicKey?: string;
    AllowSelfManagement?: boolean;
  };
  declare type OpsWorks$20130218$CreateUserProfileResult = {
    IamUserArn?: string;
  };
  declare type OpsWorks$20130218$DailyAutoScalingSchedule = {
    [key: string]: string;
  };
  declare type OpsWorks$20130218$DataSource = {
    Type?: string;
    Arn?: string;
    DatabaseName?: string;
  };
  declare type OpsWorks$20130218$DataSources = OpsWorks$20130218$DataSource[];
  declare type OpsWorks$20130218$DeleteAppRequest = {
    AppId: string;
  };
  declare type OpsWorks$20130218$DeleteInstanceRequest = {
    InstanceId: string;
    DeleteElasticIp?: boolean;
    DeleteVolumes?: boolean;
  };
  declare type OpsWorks$20130218$DeleteLayerRequest = {
    LayerId: string;
  };
  declare type OpsWorks$20130218$DeleteStackRequest = {
    StackId: string;
  };
  declare type OpsWorks$20130218$DeleteUserProfileRequest = {
    IamUserArn: string;
  };
  declare type OpsWorks$20130218$Deployment = {
    DeploymentId?: string;
    StackId?: string;
    AppId?: string;
    CreatedAt?: string;
    CompletedAt?: string;
    Duration?: number;
    IamUserArn?: string;
    Comment?: string;
    Command?: OpsWorks$20130218$DeploymentCommand;
    Status?: string;
    CustomJson?: string;
    InstanceIds?: OpsWorks$20130218$Strings;
  };
  declare type OpsWorks$20130218$DeploymentCommand = {
    Name: 'install_dependencies' | 'update_dependencies' | 'update_custom_cookbooks' | 'execute_recipes' | 'configure' | 'setup' | 'deploy' | 'rollback' | 'start' | 'stop' | 'restart' | 'undeploy';
    Args?: {
      [key: string]: OpsWorks$20130218$Strings;
    };
  };
  declare type OpsWorks$20130218$DeploymentCommandArgs = {
    [key: string]: OpsWorks$20130218$Strings;
  };
  declare type OpsWorks$20130218$DeploymentCommandName = 'install_dependencies' | 'update_dependencies' | 'update_custom_cookbooks' | 'execute_recipes' | 'configure' | 'setup' | 'deploy' | 'rollback' | 'start' | 'stop' | 'restart' | 'undeploy';
  declare type OpsWorks$20130218$Deployments = OpsWorks$20130218$Deployment[];
  declare type OpsWorks$20130218$DeregisterEcsClusterRequest = {
    EcsClusterArn: string;
  };
  declare type OpsWorks$20130218$DeregisterElasticIpRequest = {
    ElasticIp: string;
  };
  declare type OpsWorks$20130218$DeregisterInstanceRequest = {
    InstanceId: string;
  };
  declare type OpsWorks$20130218$DeregisterRdsDbInstanceRequest = {
    RdsDbInstanceArn: string;
  };
  declare type OpsWorks$20130218$DeregisterVolumeRequest = {
    VolumeId: string;
  };
  declare type OpsWorks$20130218$DescribeAgentVersionsRequest = {
    StackId?: string;
    ConfigurationManager?: OpsWorks$20130218$StackConfigurationManager;
  };
  declare type OpsWorks$20130218$DescribeAgentVersionsResult = {
    AgentVersions?: OpsWorks$20130218$AgentVersions;
  };
  declare type OpsWorks$20130218$DescribeAppsRequest = {
    StackId?: string;
    AppIds?: OpsWorks$20130218$Strings;
  };
  declare type OpsWorks$20130218$DescribeAppsResult = {
    Apps?: OpsWorks$20130218$Apps;
  };
  declare type OpsWorks$20130218$DescribeCommandsRequest = {
    DeploymentId?: string;
    InstanceId?: string;
    CommandIds?: OpsWorks$20130218$Strings;
  };
  declare type OpsWorks$20130218$DescribeCommandsResult = {
    Commands?: OpsWorks$20130218$Commands;
  };
  declare type OpsWorks$20130218$DescribeDeploymentsRequest = {
    StackId?: string;
    AppId?: string;
    DeploymentIds?: OpsWorks$20130218$Strings;
  };
  declare type OpsWorks$20130218$DescribeDeploymentsResult = {
    Deployments?: OpsWorks$20130218$Deployments;
  };
  declare type OpsWorks$20130218$DescribeEcsClustersRequest = {
    EcsClusterArns?: OpsWorks$20130218$Strings;
    StackId?: string;
    NextToken?: string;
    MaxResults?: number;
  };
  declare type OpsWorks$20130218$DescribeEcsClustersResult = {
    EcsClusters?: OpsWorks$20130218$EcsClusters;
    NextToken?: string;
  };
  declare type OpsWorks$20130218$DescribeElasticIpsRequest = {
    InstanceId?: string;
    StackId?: string;
    Ips?: OpsWorks$20130218$Strings;
  };
  declare type OpsWorks$20130218$DescribeElasticIpsResult = {
    ElasticIps?: OpsWorks$20130218$ElasticIps;
  };
  declare type OpsWorks$20130218$DescribeElasticLoadBalancersRequest = {
    StackId?: string;
    LayerIds?: OpsWorks$20130218$Strings;
  };
  declare type OpsWorks$20130218$DescribeElasticLoadBalancersResult = {
    ElasticLoadBalancers?: OpsWorks$20130218$ElasticLoadBalancers;
  };
  declare type OpsWorks$20130218$DescribeInstancesRequest = {
    StackId?: string;
    LayerId?: string;
    InstanceIds?: OpsWorks$20130218$Strings;
  };
  declare type OpsWorks$20130218$DescribeInstancesResult = {
    Instances?: OpsWorks$20130218$Instances;
  };
  declare type OpsWorks$20130218$DescribeLayersRequest = {
    StackId?: string;
    LayerIds?: OpsWorks$20130218$Strings;
  };
  declare type OpsWorks$20130218$DescribeLayersResult = {
    Layers?: OpsWorks$20130218$Layers;
  };
  declare type OpsWorks$20130218$DescribeLoadBasedAutoScalingRequest = {
    LayerIds: OpsWorks$20130218$Strings;
  };
  declare type OpsWorks$20130218$DescribeLoadBasedAutoScalingResult = {
    LoadBasedAutoScalingConfigurations?: OpsWorks$20130218$LoadBasedAutoScalingConfigurations;
  };
  declare type OpsWorks$20130218$DescribeMyUserProfileResult = {
    UserProfile?: OpsWorks$20130218$SelfUserProfile;
  };
  declare type OpsWorks$20130218$DescribePermissionsRequest = {
    IamUserArn?: string;
    StackId?: string;
  };
  declare type OpsWorks$20130218$DescribePermissionsResult = {
    Permissions?: OpsWorks$20130218$Permissions;
  };
  declare type OpsWorks$20130218$DescribeRaidArraysRequest = {
    InstanceId?: string;
    StackId?: string;
    RaidArrayIds?: OpsWorks$20130218$Strings;
  };
  declare type OpsWorks$20130218$DescribeRaidArraysResult = {
    RaidArrays?: OpsWorks$20130218$RaidArrays;
  };
  declare type OpsWorks$20130218$DescribeRdsDbInstancesRequest = {
    StackId: string;
    RdsDbInstanceArns?: OpsWorks$20130218$Strings;
  };
  declare type OpsWorks$20130218$DescribeRdsDbInstancesResult = {
    RdsDbInstances?: OpsWorks$20130218$RdsDbInstances;
  };
  declare type OpsWorks$20130218$DescribeServiceErrorsRequest = {
    StackId?: string;
    InstanceId?: string;
    ServiceErrorIds?: OpsWorks$20130218$Strings;
  };
  declare type OpsWorks$20130218$DescribeServiceErrorsResult = {
    ServiceErrors?: OpsWorks$20130218$ServiceErrors;
  };
  declare type OpsWorks$20130218$DescribeStackProvisioningParametersRequest = {
    StackId: string;
  };
  declare type OpsWorks$20130218$DescribeStackProvisioningParametersResult = {
    AgentInstallerUrl?: string;
    Parameters?: {
      [key: string]: string;
    };
  };
  declare type OpsWorks$20130218$DescribeStackSummaryRequest = {
    StackId: string;
  };
  declare type OpsWorks$20130218$DescribeStackSummaryResult = {
    StackSummary?: OpsWorks$20130218$StackSummary;
  };
  declare type OpsWorks$20130218$DescribeStacksRequest = {
    StackIds?: OpsWorks$20130218$Strings;
  };
  declare type OpsWorks$20130218$DescribeStacksResult = {
    Stacks?: OpsWorks$20130218$Stacks;
  };
  declare type OpsWorks$20130218$DescribeTimeBasedAutoScalingRequest = {
    InstanceIds: OpsWorks$20130218$Strings;
  };
  declare type OpsWorks$20130218$DescribeTimeBasedAutoScalingResult = {
    TimeBasedAutoScalingConfigurations?: OpsWorks$20130218$TimeBasedAutoScalingConfigurations;
  };
  declare type OpsWorks$20130218$DescribeUserProfilesRequest = {
    IamUserArns?: OpsWorks$20130218$Strings;
  };
  declare type OpsWorks$20130218$DescribeUserProfilesResult = {
    UserProfiles?: OpsWorks$20130218$UserProfiles;
  };
  declare type OpsWorks$20130218$DescribeVolumesRequest = {
    InstanceId?: string;
    StackId?: string;
    RaidArrayId?: string;
    VolumeIds?: OpsWorks$20130218$Strings;
  };
  declare type OpsWorks$20130218$DescribeVolumesResult = {
    Volumes?: OpsWorks$20130218$Volumes;
  };
  declare type OpsWorks$20130218$DetachElasticLoadBalancerRequest = {
    ElasticLoadBalancerName: string;
    LayerId: string;
  };
  declare type OpsWorks$20130218$DisassociateElasticIpRequest = {
    ElasticIp: string;
  };
  declare type OpsWorks$20130218$EbsBlockDevice = {
    SnapshotId?: string;
    Iops?: number;
    VolumeSize?: number;
    VolumeType?: 'gp2' | 'io1' | 'standard';
    DeleteOnTermination?: boolean;
  };
  declare type OpsWorks$20130218$EcsCluster = {
    EcsClusterArn?: string;
    EcsClusterName?: string;
    StackId?: string;
    RegisteredAt?: string;
  };
  declare type OpsWorks$20130218$EcsClusters = OpsWorks$20130218$EcsCluster[];
  declare type OpsWorks$20130218$ElasticIp = {
    Ip?: string;
    Name?: string;
    Domain?: string;
    Region?: string;
    InstanceId?: string;
  };
  declare type OpsWorks$20130218$ElasticIps = OpsWorks$20130218$ElasticIp[];
  declare type OpsWorks$20130218$ElasticLoadBalancer = {
    ElasticLoadBalancerName?: string;
    Region?: string;
    DnsName?: string;
    StackId?: string;
    LayerId?: string;
    VpcId?: string;
    AvailabilityZones?: OpsWorks$20130218$Strings;
    SubnetIds?: OpsWorks$20130218$Strings;
    Ec2InstanceIds?: OpsWorks$20130218$Strings;
  };
  declare type OpsWorks$20130218$ElasticLoadBalancers = OpsWorks$20130218$ElasticLoadBalancer[];
  declare type OpsWorks$20130218$EnvironmentVariable = {
    Key: string;
    Value: string;
    Secure?: boolean;
  };
  declare type OpsWorks$20130218$EnvironmentVariables = OpsWorks$20130218$EnvironmentVariable[];
  declare type OpsWorks$20130218$GetHostnameSuggestionRequest = {
    LayerId: string;
  };
  declare type OpsWorks$20130218$GetHostnameSuggestionResult = {
    LayerId?: string;
    Hostname?: string;
  };
  declare type OpsWorks$20130218$GrantAccessRequest = {
    InstanceId: string;
    ValidForInMinutes?: number;
  };
  declare type OpsWorks$20130218$GrantAccessResult = {
    TemporaryCredential?: OpsWorks$20130218$TemporaryCredential;
  };
  declare type OpsWorks$20130218$Instance = {
    AgentVersion?: string;
    AmiId?: string;
    Architecture?: 'x86_64' | 'i386';
    AutoScalingType?: 'load' | 'timer';
    AvailabilityZone?: string;
    BlockDeviceMappings?: OpsWorks$20130218$BlockDeviceMappings;
    CreatedAt?: string;
    EbsOptimized?: boolean;
    Ec2InstanceId?: string;
    EcsClusterArn?: string;
    EcsContainerInstanceArn?: string;
    ElasticIp?: string;
    Hostname?: string;
    InfrastructureClass?: string;
    InstallUpdatesOnBoot?: boolean;
    InstanceId?: string;
    InstanceProfileArn?: string;
    InstanceType?: string;
    LastServiceErrorId?: string;
    LayerIds?: OpsWorks$20130218$Strings;
    Os?: string;
    Platform?: string;
    PrivateDns?: string;
    PrivateIp?: string;
    PublicDns?: string;
    PublicIp?: string;
    RegisteredBy?: string;
    ReportedAgentVersion?: string;
    ReportedOs?: OpsWorks$20130218$ReportedOs;
    RootDeviceType?: 'ebs' | 'instance-store';
    RootDeviceVolumeId?: string;
    SecurityGroupIds?: OpsWorks$20130218$Strings;
    SshHostDsaKeyFingerprint?: string;
    SshHostRsaKeyFingerprint?: string;
    SshKeyName?: string;
    StackId?: string;
    Status?: string;
    SubnetId?: string;
    Tenancy?: string;
    VirtualizationType?: 'paravirtual' | 'hvm';
  };
  declare type OpsWorks$20130218$InstanceIdentity = {
    Document?: string;
    Signature?: string;
  };
  declare type OpsWorks$20130218$Instances = OpsWorks$20130218$Instance[];
  declare type OpsWorks$20130218$InstancesCount = {
    Assigning?: number;
    Booting?: number;
    ConnectionLost?: number;
    Deregistering?: number;
    Online?: number;
    Pending?: number;
    Rebooting?: number;
    Registered?: number;
    Registering?: number;
    Requested?: number;
    RunningSetup?: number;
    SetupFailed?: number;
    ShuttingDown?: number;
    StartFailed?: number;
    Stopped?: number;
    Stopping?: number;
    Terminated?: number;
    Terminating?: number;
    Unassigning?: number;
  };
  declare type OpsWorks$20130218$Layer = {
    StackId?: string;
    LayerId?: string;
    Type?: 'aws-flow-ruby' | 'ecs-cluster' | 'java-app' | 'lb' | 'web' | 'php-app' | 'rails-app' | 'nodejs-app' | 'memcached' | 'db-master' | 'monitoring-master' | 'custom';
    Name?: string;
    Shortname?: string;
    Attributes?: {
      [key: 'EcsClusterArn' | 'EnableHaproxyStats' | 'HaproxyStatsUrl' | 'HaproxyStatsUser' | 'HaproxyStatsPassword' | 'HaproxyHealthCheckUrl' | 'HaproxyHealthCheckMethod' | 'MysqlRootPassword' | 'MysqlRootPasswordUbiquitous' | 'GangliaUrl' | 'GangliaUser' | 'GangliaPassword' | 'MemcachedMemory' | 'NodejsVersion' | 'RubyVersion' | 'RubygemsVersion' | 'ManageBundler' | 'BundlerVersion' | 'RailsStack' | 'PassengerVersion' | 'Jvm' | 'JvmVersion' | 'JvmOptions' | 'JavaAppServer' | 'JavaAppServerVersion']: string;
    };
    CustomInstanceProfileArn?: string;
    CustomJson?: string;
    CustomSecurityGroupIds?: OpsWorks$20130218$Strings;
    DefaultSecurityGroupNames?: OpsWorks$20130218$Strings;
    Packages?: OpsWorks$20130218$Strings;
    VolumeConfigurations?: OpsWorks$20130218$VolumeConfigurations;
    EnableAutoHealing?: boolean;
    AutoAssignElasticIps?: boolean;
    AutoAssignPublicIps?: boolean;
    DefaultRecipes?: OpsWorks$20130218$Recipes;
    CustomRecipes?: OpsWorks$20130218$Recipes;
    CreatedAt?: string;
    InstallUpdatesOnBoot?: boolean;
    UseEbsOptimizedInstances?: boolean;
    LifecycleEventConfiguration?: OpsWorks$20130218$LifecycleEventConfiguration;
  };
  declare type OpsWorks$20130218$LayerAttributes = {
    [key: 'EcsClusterArn' | 'EnableHaproxyStats' | 'HaproxyStatsUrl' | 'HaproxyStatsUser' | 'HaproxyStatsPassword' | 'HaproxyHealthCheckUrl' | 'HaproxyHealthCheckMethod' | 'MysqlRootPassword' | 'MysqlRootPasswordUbiquitous' | 'GangliaUrl' | 'GangliaUser' | 'GangliaPassword' | 'MemcachedMemory' | 'NodejsVersion' | 'RubyVersion' | 'RubygemsVersion' | 'ManageBundler' | 'BundlerVersion' | 'RailsStack' | 'PassengerVersion' | 'Jvm' | 'JvmVersion' | 'JvmOptions' | 'JavaAppServer' | 'JavaAppServerVersion']: string;
  };
  declare type OpsWorks$20130218$LayerAttributesKeys = 'EcsClusterArn' | 'EnableHaproxyStats' | 'HaproxyStatsUrl' | 'HaproxyStatsUser' | 'HaproxyStatsPassword' | 'HaproxyHealthCheckUrl' | 'HaproxyHealthCheckMethod' | 'MysqlRootPassword' | 'MysqlRootPasswordUbiquitous' | 'GangliaUrl' | 'GangliaUser' | 'GangliaPassword' | 'MemcachedMemory' | 'NodejsVersion' | 'RubyVersion' | 'RubygemsVersion' | 'ManageBundler' | 'BundlerVersion' | 'RailsStack' | 'PassengerVersion' | 'Jvm' | 'JvmVersion' | 'JvmOptions' | 'JavaAppServer' | 'JavaAppServerVersion';
  declare type OpsWorks$20130218$LayerType = 'aws-flow-ruby' | 'ecs-cluster' | 'java-app' | 'lb' | 'web' | 'php-app' | 'rails-app' | 'nodejs-app' | 'memcached' | 'db-master' | 'monitoring-master' | 'custom';
  declare type OpsWorks$20130218$Layers = OpsWorks$20130218$Layer[];
  declare type OpsWorks$20130218$LifecycleEventConfiguration = {
    Shutdown?: OpsWorks$20130218$ShutdownEventConfiguration;
  };
  declare type OpsWorks$20130218$LoadBasedAutoScalingConfiguration = {
    LayerId?: string;
    Enable?: boolean;
    UpScaling?: OpsWorks$20130218$AutoScalingThresholds;
    DownScaling?: OpsWorks$20130218$AutoScalingThresholds;
  };
  declare type OpsWorks$20130218$LoadBasedAutoScalingConfigurations = OpsWorks$20130218$LoadBasedAutoScalingConfiguration[];
  declare type OpsWorks$20130218$Parameters = {
    [key: string]: string;
  };
  declare type OpsWorks$20130218$Permission = {
    StackId?: string;
    IamUserArn?: string;
    AllowSsh?: boolean;
    AllowSudo?: boolean;
    Level?: string;
  };
  declare type OpsWorks$20130218$Permissions = OpsWorks$20130218$Permission[];
  declare type OpsWorks$20130218$RaidArray = {
    RaidArrayId?: string;
    InstanceId?: string;
    Name?: string;
    RaidLevel?: number;
    NumberOfDisks?: number;
    Size?: number;
    Device?: string;
    MountPoint?: string;
    AvailabilityZone?: string;
    CreatedAt?: string;
    StackId?: string;
    VolumeType?: string;
    Iops?: number;
  };
  declare type OpsWorks$20130218$RaidArrays = OpsWorks$20130218$RaidArray[];
  declare type OpsWorks$20130218$RdsDbInstance = {
    RdsDbInstanceArn?: string;
    DbInstanceIdentifier?: string;
    DbUser?: string;
    DbPassword?: string;
    Region?: string;
    Address?: string;
    Engine?: string;
    StackId?: string;
    MissingOnRds?: boolean;
  };
  declare type OpsWorks$20130218$RdsDbInstances = OpsWorks$20130218$RdsDbInstance[];
  declare type OpsWorks$20130218$RebootInstanceRequest = {
    InstanceId: string;
  };
  declare type OpsWorks$20130218$Recipes = {
    Setup?: OpsWorks$20130218$Strings;
    Configure?: OpsWorks$20130218$Strings;
    Deploy?: OpsWorks$20130218$Strings;
    Undeploy?: OpsWorks$20130218$Strings;
    Shutdown?: OpsWorks$20130218$Strings;
  };
  declare type OpsWorks$20130218$RegisterEcsClusterRequest = {
    EcsClusterArn: string;
    StackId: string;
  };
  declare type OpsWorks$20130218$RegisterEcsClusterResult = {
    EcsClusterArn?: string;
  };
  declare type OpsWorks$20130218$RegisterElasticIpRequest = {
    ElasticIp: string;
    StackId: string;
  };
  declare type OpsWorks$20130218$RegisterElasticIpResult = {
    ElasticIp?: string;
  };
  declare type OpsWorks$20130218$RegisterInstanceRequest = {
    StackId: string;
    Hostname?: string;
    PublicIp?: string;
    PrivateIp?: string;
    RsaPublicKey?: string;
    RsaPublicKeyFingerprint?: string;
    InstanceIdentity?: OpsWorks$20130218$InstanceIdentity;
  };
  declare type OpsWorks$20130218$RegisterInstanceResult = {
    InstanceId?: string;
  };
  declare type OpsWorks$20130218$RegisterRdsDbInstanceRequest = {
    StackId: string;
    RdsDbInstanceArn: string;
    DbUser: string;
    DbPassword: string;
  };
  declare type OpsWorks$20130218$RegisterVolumeRequest = {
    Ec2VolumeId?: string;
    StackId: string;
  };
  declare type OpsWorks$20130218$RegisterVolumeResult = {
    VolumeId?: string;
  };
  declare type OpsWorks$20130218$ReportedOs = {
    Family?: string;
    Name?: string;
    Version?: string;
  };
  declare type OpsWorks$20130218$ResourceNotFoundException = {
    message?: string;
  };
  declare type OpsWorks$20130218$RootDeviceType = 'ebs' | 'instance-store';
  declare type OpsWorks$20130218$SelfUserProfile = {
    IamUserArn?: string;
    Name?: string;
    SshUsername?: string;
    SshPublicKey?: string;
  };
  declare type OpsWorks$20130218$ServiceError = {
    ServiceErrorId?: string;
    StackId?: string;
    InstanceId?: string;
    Type?: string;
    Message?: string;
    CreatedAt?: string;
  };
  declare type OpsWorks$20130218$ServiceErrors = OpsWorks$20130218$ServiceError[];
  declare type OpsWorks$20130218$SetLoadBasedAutoScalingRequest = {
    LayerId: string;
    Enable?: boolean;
    UpScaling?: OpsWorks$20130218$AutoScalingThresholds;
    DownScaling?: OpsWorks$20130218$AutoScalingThresholds;
  };
  declare type OpsWorks$20130218$SetPermissionRequest = {
    StackId: string;
    IamUserArn: string;
    AllowSsh?: boolean;
    AllowSudo?: boolean;
    Level?: string;
  };
  declare type OpsWorks$20130218$SetTimeBasedAutoScalingRequest = {
    InstanceId: string;
    AutoScalingSchedule?: OpsWorks$20130218$WeeklyAutoScalingSchedule;
  };
  declare type OpsWorks$20130218$ShutdownEventConfiguration = {
    ExecutionTimeout?: number;
    DelayUntilElbConnectionsDrained?: boolean;
  };
  declare type OpsWorks$20130218$Source = {
    Type?: 'git' | 'svn' | 'archive' | 's3';
    Url?: string;
    Username?: string;
    Password?: string;
    SshKey?: string;
    Revision?: string;
  };
  declare type OpsWorks$20130218$SourceType = 'git' | 'svn' | 'archive' | 's3';
  declare type OpsWorks$20130218$SslConfiguration = {
    Certificate: string;
    PrivateKey: string;
    Chain?: string;
  };
  declare type OpsWorks$20130218$Stack = {
    StackId?: string;
    Name?: string;
    Arn?: string;
    Region?: string;
    VpcId?: string;
    Attributes?: {
      [key: 'Color']: string;
    };
    ServiceRoleArn?: string;
    DefaultInstanceProfileArn?: string;
    DefaultOs?: string;
    HostnameTheme?: string;
    DefaultAvailabilityZone?: string;
    DefaultSubnetId?: string;
    CustomJson?: string;
    ConfigurationManager?: OpsWorks$20130218$StackConfigurationManager;
    ChefConfiguration?: OpsWorks$20130218$ChefConfiguration;
    UseCustomCookbooks?: boolean;
    UseOpsworksSecurityGroups?: boolean;
    CustomCookbooksSource?: OpsWorks$20130218$Source;
    DefaultSshKeyName?: string;
    CreatedAt?: string;
    DefaultRootDeviceType?: 'ebs' | 'instance-store';
    AgentVersion?: string;
  };
  declare type OpsWorks$20130218$StackAttributes = {
    [key: 'Color']: string;
  };
  declare type OpsWorks$20130218$StackAttributesKeys = 'Color';
  declare type OpsWorks$20130218$StackConfigurationManager = {
    Name?: string;
    Version?: string;
  };
  declare type OpsWorks$20130218$StackSummary = {
    StackId?: string;
    Name?: string;
    Arn?: string;
    LayersCount?: number;
    AppsCount?: number;
    InstancesCount?: OpsWorks$20130218$InstancesCount;
  };
  declare type OpsWorks$20130218$Stacks = OpsWorks$20130218$Stack[];
  declare type OpsWorks$20130218$StartInstanceRequest = {
    InstanceId: string;
  };
  declare type OpsWorks$20130218$StartStackRequest = {
    StackId: string;
  };
  declare type OpsWorks$20130218$StopInstanceRequest = {
    InstanceId: string;
  };
  declare type OpsWorks$20130218$StopStackRequest = {
    StackId: string;
  };
  declare type OpsWorks$20130218$Strings = string[];
  declare type OpsWorks$20130218$TemporaryCredential = {
    Username?: string;
    Password?: string;
    ValidForInMinutes?: number;
    InstanceId?: string;
  };
  declare type OpsWorks$20130218$TimeBasedAutoScalingConfiguration = {
    InstanceId?: string;
    AutoScalingSchedule?: OpsWorks$20130218$WeeklyAutoScalingSchedule;
  };
  declare type OpsWorks$20130218$TimeBasedAutoScalingConfigurations = OpsWorks$20130218$TimeBasedAutoScalingConfiguration[];
  declare type OpsWorks$20130218$UnassignInstanceRequest = {
    InstanceId: string;
  };
  declare type OpsWorks$20130218$UnassignVolumeRequest = {
    VolumeId: string;
  };
  declare type OpsWorks$20130218$UpdateAppRequest = {
    AppId: string;
    Name?: string;
    Description?: string;
    DataSources?: OpsWorks$20130218$DataSources;
    Type?: 'aws-flow-ruby' | 'java' | 'rails' | 'php' | 'nodejs' | 'static' | 'other';
    AppSource?: OpsWorks$20130218$Source;
    Domains?: OpsWorks$20130218$Strings;
    EnableSsl?: boolean;
    SslConfiguration?: OpsWorks$20130218$SslConfiguration;
    Attributes?: {
      [key: 'DocumentRoot' | 'RailsEnv' | 'AutoBundleOnDeploy' | 'AwsFlowRubySettings']: string;
    };
    Environment?: OpsWorks$20130218$EnvironmentVariables;
  };
  declare type OpsWorks$20130218$UpdateElasticIpRequest = {
    ElasticIp: string;
    Name?: string;
  };
  declare type OpsWorks$20130218$UpdateInstanceRequest = {
    InstanceId: string;
    LayerIds?: OpsWorks$20130218$Strings;
    InstanceType?: string;
    AutoScalingType?: 'load' | 'timer';
    Hostname?: string;
    Os?: string;
    AmiId?: string;
    SshKeyName?: string;
    Architecture?: 'x86_64' | 'i386';
    InstallUpdatesOnBoot?: boolean;
    EbsOptimized?: boolean;
    AgentVersion?: string;
  };
  declare type OpsWorks$20130218$UpdateLayerRequest = {
    LayerId: string;
    Name?: string;
    Shortname?: string;
    Attributes?: {
      [key: 'EcsClusterArn' | 'EnableHaproxyStats' | 'HaproxyStatsUrl' | 'HaproxyStatsUser' | 'HaproxyStatsPassword' | 'HaproxyHealthCheckUrl' | 'HaproxyHealthCheckMethod' | 'MysqlRootPassword' | 'MysqlRootPasswordUbiquitous' | 'GangliaUrl' | 'GangliaUser' | 'GangliaPassword' | 'MemcachedMemory' | 'NodejsVersion' | 'RubyVersion' | 'RubygemsVersion' | 'ManageBundler' | 'BundlerVersion' | 'RailsStack' | 'PassengerVersion' | 'Jvm' | 'JvmVersion' | 'JvmOptions' | 'JavaAppServer' | 'JavaAppServerVersion']: string;
    };
    CustomInstanceProfileArn?: string;
    CustomJson?: string;
    CustomSecurityGroupIds?: OpsWorks$20130218$Strings;
    Packages?: OpsWorks$20130218$Strings;
    VolumeConfigurations?: OpsWorks$20130218$VolumeConfigurations;
    EnableAutoHealing?: boolean;
    AutoAssignElasticIps?: boolean;
    AutoAssignPublicIps?: boolean;
    CustomRecipes?: OpsWorks$20130218$Recipes;
    InstallUpdatesOnBoot?: boolean;
    UseEbsOptimizedInstances?: boolean;
    LifecycleEventConfiguration?: OpsWorks$20130218$LifecycleEventConfiguration;
  };
  declare type OpsWorks$20130218$UpdateMyUserProfileRequest = {
    SshPublicKey?: string;
  };
  declare type OpsWorks$20130218$UpdateRdsDbInstanceRequest = {
    RdsDbInstanceArn: string;
    DbUser?: string;
    DbPassword?: string;
  };
  declare type OpsWorks$20130218$UpdateStackRequest = {
    StackId: string;
    Name?: string;
    Attributes?: {
      [key: 'Color']: string;
    };
    ServiceRoleArn?: string;
    DefaultInstanceProfileArn?: string;
    DefaultOs?: string;
    HostnameTheme?: string;
    DefaultAvailabilityZone?: string;
    DefaultSubnetId?: string;
    CustomJson?: string;
    ConfigurationManager?: OpsWorks$20130218$StackConfigurationManager;
    ChefConfiguration?: OpsWorks$20130218$ChefConfiguration;
    UseCustomCookbooks?: boolean;
    CustomCookbooksSource?: OpsWorks$20130218$Source;
    DefaultSshKeyName?: string;
    DefaultRootDeviceType?: 'ebs' | 'instance-store';
    UseOpsworksSecurityGroups?: boolean;
    AgentVersion?: string;
  };
  declare type OpsWorks$20130218$UpdateUserProfileRequest = {
    IamUserArn: string;
    SshUsername?: string;
    SshPublicKey?: string;
    AllowSelfManagement?: boolean;
  };
  declare type OpsWorks$20130218$UpdateVolumeRequest = {
    VolumeId: string;
    Name?: string;
    MountPoint?: string;
  };
  declare type OpsWorks$20130218$UserProfile = {
    IamUserArn?: string;
    Name?: string;
    SshUsername?: string;
    SshPublicKey?: string;
    AllowSelfManagement?: boolean;
  };
  declare type OpsWorks$20130218$UserProfiles = OpsWorks$20130218$UserProfile[];
  declare type OpsWorks$20130218$ValidationException = {
    message?: string;
  };
  declare type OpsWorks$20130218$VirtualizationType = 'paravirtual' | 'hvm';
  declare type OpsWorks$20130218$Volume = {
    VolumeId?: string;
    Ec2VolumeId?: string;
    Name?: string;
    RaidArrayId?: string;
    InstanceId?: string;
    Status?: string;
    Size?: number;
    Device?: string;
    MountPoint?: string;
    Region?: string;
    AvailabilityZone?: string;
    VolumeType?: string;
    Iops?: number;
  };
  declare type OpsWorks$20130218$VolumeConfiguration = {
    MountPoint: string;
    RaidLevel?: number;
    NumberOfDisks: number;
    Size: number;
    VolumeType?: string;
    Iops?: number;
  };
  declare type OpsWorks$20130218$VolumeConfigurations = OpsWorks$20130218$VolumeConfiguration[];
  declare type OpsWorks$20130218$VolumeType = 'gp2' | 'io1' | 'standard';
  declare type OpsWorks$20130218$Volumes = OpsWorks$20130218$Volume[];
  declare type OpsWorks$20130218$WeeklyAutoScalingSchedule = {
    Monday?: {
      [key: string]: string;
    };
    Tuesday?: {
      [key: string]: string;
    };
    Wednesday?: {
      [key: string]: string;
    };
    Thursday?: {
      [key: string]: string;
    };
    Friday?: {
      [key: string]: string;
    };
    Saturday?: {
      [key: string]: string;
    };
    Sunday?: {
      [key: string]: string;
    };
  };
  declare type RDS$20130110$AddSourceIdentifierToSubscriptionMessage = {
    SubscriptionName: string;
    SourceIdentifier: string;
  };
  declare type RDS$20130110$AddSourceIdentifierToSubscriptionResult = {
    EventSubscription?: RDS$20130110$EventSubscription;
  };
  declare type RDS$20130110$AddTagsToResourceMessage = {
    ResourceName: string;
    Tags: RDS$20130110$TagList;
  };
  declare type RDS$20130110$ApplyMethod = 'immediate' | 'pending-reboot';
  declare type RDS$20130110$AuthorizationAlreadyExistsFault = {};
  declare type RDS$20130110$AuthorizationNotFoundFault = {};
  declare type RDS$20130110$AuthorizationQuotaExceededFault = {};
  declare type RDS$20130110$AuthorizeDBSecurityGroupIngressMessage = {
    DBSecurityGroupName: string;
    CIDRIP?: string;
    EC2SecurityGroupName?: string;
    EC2SecurityGroupId?: string;
    EC2SecurityGroupOwnerId?: string;
  };
  declare type RDS$20130110$AuthorizeDBSecurityGroupIngressResult = {
    DBSecurityGroup?: RDS$20130110$DBSecurityGroup;
  };
  declare type RDS$20130110$AvailabilityZone = {
    Name?: string;
    ProvisionedIopsCapable?: boolean;
  };
  declare type RDS$20130110$AvailabilityZoneList = RDS$20130110$AvailabilityZone[];
  declare type RDS$20130110$CharacterSet = {
    CharacterSetName?: string;
    CharacterSetDescription?: string;
  };
  declare type RDS$20130110$CopyDBSnapshotMessage = {
    SourceDBSnapshotIdentifier: string;
    TargetDBSnapshotIdentifier: string;
  };
  declare type RDS$20130110$CopyDBSnapshotResult = {
    DBSnapshot?: RDS$20130110$DBSnapshot;
  };
  declare type RDS$20130110$CreateDBInstanceMessage = {
    DBName?: string;
    DBInstanceIdentifier: string;
    AllocatedStorage: number;
    DBInstanceClass: string;
    Engine: string;
    MasterUsername: string;
    MasterUserPassword: string;
    DBSecurityGroups?: RDS$20130110$DBSecurityGroupNameList;
    VpcSecurityGroupIds?: RDS$20130110$VpcSecurityGroupIdList;
    AvailabilityZone?: string;
    DBSubnetGroupName?: string;
    PreferredMaintenanceWindow?: string;
    DBParameterGroupName?: string;
    BackupRetentionPeriod?: number;
    PreferredBackupWindow?: string;
    Port?: number;
    MultiAZ?: boolean;
    EngineVersion?: string;
    AutoMinorVersionUpgrade?: boolean;
    LicenseModel?: string;
    Iops?: number;
    OptionGroupName?: string;
    CharacterSetName?: string;
    PubliclyAccessible?: boolean;
  };
  declare type RDS$20130110$CreateDBInstanceReadReplicaMessage = {
    DBInstanceIdentifier: string;
    SourceDBInstanceIdentifier: string;
    DBInstanceClass?: string;
    AvailabilityZone?: string;
    Port?: number;
    AutoMinorVersionUpgrade?: boolean;
    Iops?: number;
    OptionGroupName?: string;
    PubliclyAccessible?: boolean;
  };
  declare type RDS$20130110$CreateDBInstanceReadReplicaResult = {
    DBInstance?: RDS$20130110$DBInstance;
  };
  declare type RDS$20130110$CreateDBInstanceResult = {
    DBInstance?: RDS$20130110$DBInstance;
  };
  declare type RDS$20130110$CreateDBParameterGroupMessage = {
    DBParameterGroupName: string;
    DBParameterGroupFamily: string;
    Description: string;
  };
  declare type RDS$20130110$CreateDBParameterGroupResult = {
    DBParameterGroup?: RDS$20130110$DBParameterGroup;
  };
  declare type RDS$20130110$CreateDBSecurityGroupMessage = {
    DBSecurityGroupName: string;
    DBSecurityGroupDescription: string;
  };
  declare type RDS$20130110$CreateDBSecurityGroupResult = {
    DBSecurityGroup?: RDS$20130110$DBSecurityGroup;
  };
  declare type RDS$20130110$CreateDBSnapshotMessage = {
    DBSnapshotIdentifier: string;
    DBInstanceIdentifier: string;
  };
  declare type RDS$20130110$CreateDBSnapshotResult = {
    DBSnapshot?: RDS$20130110$DBSnapshot;
  };
  declare type RDS$20130110$CreateDBSubnetGroupMessage = {
    DBSubnetGroupName: string;
    DBSubnetGroupDescription: string;
    SubnetIds: RDS$20130110$SubnetIdentifierList;
  };
  declare type RDS$20130110$CreateDBSubnetGroupResult = {
    DBSubnetGroup?: RDS$20130110$DBSubnetGroup;
  };
  declare type RDS$20130110$CreateEventSubscriptionMessage = {
    SubscriptionName: string;
    SnsTopicArn: string;
    SourceType?: string;
    EventCategories?: RDS$20130110$EventCategoriesList;
    SourceIds?: RDS$20130110$SourceIdsList;
    Enabled?: boolean;
  };
  declare type RDS$20130110$CreateEventSubscriptionResult = {
    EventSubscription?: RDS$20130110$EventSubscription;
  };
  declare type RDS$20130110$CreateOptionGroupMessage = {
    OptionGroupName: string;
    EngineName: string;
    MajorEngineVersion: string;
    OptionGroupDescription: string;
  };
  declare type RDS$20130110$CreateOptionGroupResult = {
    OptionGroup?: RDS$20130110$OptionGroup;
  };
  declare type RDS$20130110$DBEngineVersion = {
    Engine?: string;
    EngineVersion?: string;
    DBParameterGroupFamily?: string;
    DBEngineDescription?: string;
    DBEngineVersionDescription?: string;
    DefaultCharacterSet?: RDS$20130110$CharacterSet;
    SupportedCharacterSets?: RDS$20130110$SupportedCharacterSetsList;
  };
  declare type RDS$20130110$DBEngineVersionList = RDS$20130110$DBEngineVersion[];
  declare type RDS$20130110$DBEngineVersionMessage = {
    Marker?: string;
    DBEngineVersions?: RDS$20130110$DBEngineVersionList;
  };
  declare type RDS$20130110$DBInstance = {
    DBInstanceIdentifier?: string;
    DBInstanceClass?: string;
    Engine?: string;
    DBInstanceStatus?: string;
    MasterUsername?: string;
    DBName?: string;
    Endpoint?: RDS$20130110$Endpoint;
    AllocatedStorage?: number;
    InstanceCreateTime?: Date;
    PreferredBackupWindow?: string;
    BackupRetentionPeriod?: number;
    DBSecurityGroups?: RDS$20130110$DBSecurityGroupMembershipList;
    VpcSecurityGroups?: RDS$20130110$VpcSecurityGroupMembershipList;
    DBParameterGroups?: RDS$20130110$DBParameterGroupStatusList;
    AvailabilityZone?: string;
    DBSubnetGroup?: RDS$20130110$DBSubnetGroup;
    PreferredMaintenanceWindow?: string;
    PendingModifiedValues?: RDS$20130110$PendingModifiedValues;
    LatestRestorableTime?: Date;
    MultiAZ?: boolean;
    EngineVersion?: string;
    AutoMinorVersionUpgrade?: boolean;
    ReadReplicaSourceDBInstanceIdentifier?: string;
    ReadReplicaDBInstanceIdentifiers?: RDS$20130110$ReadReplicaDBInstanceIdentifierList;
    LicenseModel?: string;
    Iops?: number;
    OptionGroupMembership?: RDS$20130110$OptionGroupMembership;
    CharacterSetName?: string;
    SecondaryAvailabilityZone?: string;
    PubliclyAccessible?: boolean;
  };
  declare type RDS$20130110$DBInstanceAlreadyExistsFault = {};
  declare type RDS$20130110$DBInstanceList = RDS$20130110$DBInstance[];
  declare type RDS$20130110$DBInstanceMessage = {
    Marker?: string;
    DBInstances?: RDS$20130110$DBInstanceList;
  };
  declare type RDS$20130110$DBInstanceNotFoundFault = {};
  declare type RDS$20130110$DBParameterGroup = {
    DBParameterGroupName?: string;
    DBParameterGroupFamily?: string;
    Description?: string;
  };
  declare type RDS$20130110$DBParameterGroupAlreadyExistsFault = {};
  declare type RDS$20130110$DBParameterGroupDetails = {
    Parameters?: RDS$20130110$ParametersList;
    Marker?: string;
  };
  declare type RDS$20130110$DBParameterGroupList = RDS$20130110$DBParameterGroup[];
  declare type RDS$20130110$DBParameterGroupNameMessage = {
    DBParameterGroupName?: string;
  };
  declare type RDS$20130110$DBParameterGroupNotFoundFault = {};
  declare type RDS$20130110$DBParameterGroupQuotaExceededFault = {};
  declare type RDS$20130110$DBParameterGroupStatus = {
    DBParameterGroupName?: string;
    ParameterApplyStatus?: string;
  };
  declare type RDS$20130110$DBParameterGroupStatusList = RDS$20130110$DBParameterGroupStatus[];
  declare type RDS$20130110$DBParameterGroupsMessage = {
    Marker?: string;
    DBParameterGroups?: RDS$20130110$DBParameterGroupList;
  };
  declare type RDS$20130110$DBSecurityGroup = {
    OwnerId?: string;
    DBSecurityGroupName?: string;
    DBSecurityGroupDescription?: string;
    VpcId?: string;
    EC2SecurityGroups?: RDS$20130110$EC2SecurityGroupList;
    IPRanges?: RDS$20130110$IPRangeList;
  };
  declare type RDS$20130110$DBSecurityGroupAlreadyExistsFault = {};
  declare type RDS$20130110$DBSecurityGroupMembership = {
    DBSecurityGroupName?: string;
    Status?: string;
  };
  declare type RDS$20130110$DBSecurityGroupMembershipList = RDS$20130110$DBSecurityGroupMembership[];
  declare type RDS$20130110$DBSecurityGroupMessage = {
    Marker?: string;
    DBSecurityGroups?: RDS$20130110$DBSecurityGroups;
  };
  declare type RDS$20130110$DBSecurityGroupNameList = string[];
  declare type RDS$20130110$DBSecurityGroupNotFoundFault = {};
  declare type RDS$20130110$DBSecurityGroupNotSupportedFault = {};
  declare type RDS$20130110$DBSecurityGroupQuotaExceededFault = {};
  declare type RDS$20130110$DBSecurityGroups = RDS$20130110$DBSecurityGroup[];
  declare type RDS$20130110$DBSnapshot = {
    DBSnapshotIdentifier?: string;
    DBInstanceIdentifier?: string;
    SnapshotCreateTime?: Date;
    Engine?: string;
    AllocatedStorage?: number;
    Status?: string;
    Port?: number;
    AvailabilityZone?: string;
    VpcId?: string;
    InstanceCreateTime?: Date;
    MasterUsername?: string;
    EngineVersion?: string;
    LicenseModel?: string;
    SnapshotType?: string;
    Iops?: number;
  };
  declare type RDS$20130110$DBSnapshotAlreadyExistsFault = {};
  declare type RDS$20130110$DBSnapshotList = RDS$20130110$DBSnapshot[];
  declare type RDS$20130110$DBSnapshotMessage = {
    Marker?: string;
    DBSnapshots?: RDS$20130110$DBSnapshotList;
  };
  declare type RDS$20130110$DBSnapshotNotFoundFault = {};
  declare type RDS$20130110$DBSubnetGroup = {
    DBSubnetGroupName?: string;
    DBSubnetGroupDescription?: string;
    VpcId?: string;
    SubnetGroupStatus?: string;
    Subnets?: RDS$20130110$SubnetList;
  };
  declare type RDS$20130110$DBSubnetGroupAlreadyExistsFault = {};
  declare type RDS$20130110$DBSubnetGroupDoesNotCoverEnoughAZs = {};
  declare type RDS$20130110$DBSubnetGroupMessage = {
    Marker?: string;
    DBSubnetGroups?: RDS$20130110$DBSubnetGroups;
  };
  declare type RDS$20130110$DBSubnetGroupNotFoundFault = {};
  declare type RDS$20130110$DBSubnetGroupQuotaExceededFault = {};
  declare type RDS$20130110$DBSubnetGroups = RDS$20130110$DBSubnetGroup[];
  declare type RDS$20130110$DBSubnetQuotaExceededFault = {};
  declare type RDS$20130110$DBUpgradeDependencyFailureFault = {};
  declare type RDS$20130110$DeleteDBInstanceMessage = {
    DBInstanceIdentifier: string;
    SkipFinalSnapshot?: boolean;
    FinalDBSnapshotIdentifier?: string;
  };
  declare type RDS$20130110$DeleteDBInstanceResult = {
    DBInstance?: RDS$20130110$DBInstance;
  };
  declare type RDS$20130110$DeleteDBParameterGroupMessage = {
    DBParameterGroupName: string;
  };
  declare type RDS$20130110$DeleteDBSecurityGroupMessage = {
    DBSecurityGroupName: string;
  };
  declare type RDS$20130110$DeleteDBSnapshotMessage = {
    DBSnapshotIdentifier: string;
  };
  declare type RDS$20130110$DeleteDBSnapshotResult = {
    DBSnapshot?: RDS$20130110$DBSnapshot;
  };
  declare type RDS$20130110$DeleteDBSubnetGroupMessage = {
    DBSubnetGroupName: string;
  };
  declare type RDS$20130110$DeleteEventSubscriptionMessage = {
    SubscriptionName: string;
  };
  declare type RDS$20130110$DeleteEventSubscriptionResult = {
    EventSubscription?: RDS$20130110$EventSubscription;
  };
  declare type RDS$20130110$DeleteOptionGroupMessage = {
    OptionGroupName: string;
  };
  declare type RDS$20130110$DescribeDBEngineVersionsMessage = {
    Engine?: string;
    EngineVersion?: string;
    DBParameterGroupFamily?: string;
    MaxRecords?: number;
    Marker?: string;
    DefaultOnly?: boolean;
    ListSupportedCharacterSets?: boolean;
  };
  declare type RDS$20130110$DescribeDBInstancesMessage = {
    DBInstanceIdentifier?: string;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20130110$DescribeDBParameterGroupsMessage = {
    DBParameterGroupName?: string;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20130110$DescribeDBParametersMessage = {
    DBParameterGroupName: string;
    Source?: string;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20130110$DescribeDBSecurityGroupsMessage = {
    DBSecurityGroupName?: string;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20130110$DescribeDBSnapshotsMessage = {
    DBInstanceIdentifier?: string;
    DBSnapshotIdentifier?: string;
    SnapshotType?: string;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20130110$DescribeDBSubnetGroupsMessage = {
    DBSubnetGroupName?: string;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20130110$DescribeEngineDefaultParametersMessage = {
    DBParameterGroupFamily: string;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20130110$DescribeEngineDefaultParametersResult = {
    EngineDefaults?: RDS$20130110$EngineDefaults;
  };
  declare type RDS$20130110$DescribeEventCategoriesMessage = {
    SourceType?: string;
  };
  declare type RDS$20130110$DescribeEventSubscriptionsMessage = {
    SubscriptionName?: string;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20130110$DescribeEventsMessage = {
    SourceIdentifier?: string;
    SourceType?: 'db-instance' | 'db-parameter-group' | 'db-security-group' | 'db-snapshot';
    StartTime?: Date;
    EndTime?: Date;
    Duration?: number;
    EventCategories?: RDS$20130110$EventCategoriesList;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20130110$DescribeOptionGroupOptionsMessage = {
    EngineName: string;
    MajorEngineVersion?: string;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20130110$DescribeOptionGroupsMessage = {
    OptionGroupName?: string;
    Marker?: string;
    MaxRecords?: number;
    EngineName?: string;
    MajorEngineVersion?: string;
  };
  declare type RDS$20130110$DescribeOrderableDBInstanceOptionsMessage = {
    Engine: string;
    EngineVersion?: string;
    DBInstanceClass?: string;
    LicenseModel?: string;
    Vpc?: boolean;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20130110$DescribeReservedDBInstancesMessage = {
    ReservedDBInstanceId?: string;
    ReservedDBInstancesOfferingId?: string;
    DBInstanceClass?: string;
    Duration?: string;
    ProductDescription?: string;
    OfferingType?: string;
    MultiAZ?: boolean;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20130110$DescribeReservedDBInstancesOfferingsMessage = {
    ReservedDBInstancesOfferingId?: string;
    DBInstanceClass?: string;
    Duration?: string;
    ProductDescription?: string;
    OfferingType?: string;
    MultiAZ?: boolean;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20130110$EC2SecurityGroup = {
    Status?: string;
    EC2SecurityGroupName?: string;
    EC2SecurityGroupId?: string;
    EC2SecurityGroupOwnerId?: string;
  };
  declare type RDS$20130110$EC2SecurityGroupList = RDS$20130110$EC2SecurityGroup[];
  declare type RDS$20130110$Endpoint = {
    Address?: string;
    Port?: number;
  };
  declare type RDS$20130110$EngineDefaults = {
    DBParameterGroupFamily?: string;
    Marker?: string;
    Parameters?: RDS$20130110$ParametersList;
  };
  declare type RDS$20130110$Event = {
    SourceIdentifier?: string;
    SourceType?: 'db-instance' | 'db-parameter-group' | 'db-security-group' | 'db-snapshot';
    Message?: string;
    EventCategories?: RDS$20130110$EventCategoriesList;
    Date?: Date;
  };
  declare type RDS$20130110$EventCategoriesList = string[];
  declare type RDS$20130110$EventCategoriesMap = {
    SourceType?: string;
    EventCategories?: RDS$20130110$EventCategoriesList;
  };
  declare type RDS$20130110$EventCategoriesMapList = RDS$20130110$EventCategoriesMap[];
  declare type RDS$20130110$EventCategoriesMessage = {
    EventCategoriesMapList?: RDS$20130110$EventCategoriesMapList;
  };
  declare type RDS$20130110$EventList = RDS$20130110$Event[];
  declare type RDS$20130110$EventSubscription = {
    Id?: string;
    CustomerAwsId?: string;
    CustSubscriptionId?: string;
    SnsTopicArn?: string;
    Status?: string;
    SubscriptionCreationTime?: string;
    SourceType?: string;
    SourceIdsList?: RDS$20130110$SourceIdsList;
    EventCategoriesList?: RDS$20130110$EventCategoriesList;
    Enabled?: boolean;
  };
  declare type RDS$20130110$EventSubscriptionQuotaExceededFault = {};
  declare type RDS$20130110$EventSubscriptionsList = RDS$20130110$EventSubscription[];
  declare type RDS$20130110$EventSubscriptionsMessage = {
    Marker?: string;
    EventSubscriptionsList?: RDS$20130110$EventSubscriptionsList;
  };
  declare type RDS$20130110$EventsMessage = {
    Marker?: string;
    Events?: RDS$20130110$EventList;
  };
  declare type RDS$20130110$IPRange = {
    Status?: string;
    CIDRIP?: string;
  };
  declare type RDS$20130110$IPRangeList = RDS$20130110$IPRange[];
  declare type RDS$20130110$InstanceQuotaExceededFault = {};
  declare type RDS$20130110$InsufficientDBInstanceCapacityFault = {};
  declare type RDS$20130110$InvalidDBInstanceStateFault = {};
  declare type RDS$20130110$InvalidDBParameterGroupStateFault = {};
  declare type RDS$20130110$InvalidDBSecurityGroupStateFault = {};
  declare type RDS$20130110$InvalidDBSnapshotStateFault = {};
  declare type RDS$20130110$InvalidDBSubnetGroupStateFault = {};
  declare type RDS$20130110$InvalidDBSubnetStateFault = {};
  declare type RDS$20130110$InvalidEventSubscriptionStateFault = {};
  declare type RDS$20130110$InvalidOptionGroupStateFault = {};
  declare type RDS$20130110$InvalidRestoreFault = {};
  declare type RDS$20130110$InvalidSubnet = {};
  declare type RDS$20130110$InvalidVPCNetworkStateFault = {};
  declare type RDS$20130110$KeyList = string[];
  declare type RDS$20130110$ListTagsForResourceMessage = {
    ResourceName: string;
  };
  declare type RDS$20130110$ModifyDBInstanceMessage = {
    DBInstanceIdentifier: string;
    AllocatedStorage?: number;
    DBInstanceClass?: string;
    DBSecurityGroups?: RDS$20130110$DBSecurityGroupNameList;
    VpcSecurityGroupIds?: RDS$20130110$VpcSecurityGroupIdList;
    ApplyImmediately?: boolean;
    MasterUserPassword?: string;
    DBParameterGroupName?: string;
    BackupRetentionPeriod?: number;
    PreferredBackupWindow?: string;
    PreferredMaintenanceWindow?: string;
    MultiAZ?: boolean;
    EngineVersion?: string;
    AllowMajorVersionUpgrade?: boolean;
    AutoMinorVersionUpgrade?: boolean;
    Iops?: number;
    OptionGroupName?: string;
    NewDBInstanceIdentifier?: string;
  };
  declare type RDS$20130110$ModifyDBInstanceResult = {
    DBInstance?: RDS$20130110$DBInstance;
  };
  declare type RDS$20130110$ModifyDBParameterGroupMessage = {
    DBParameterGroupName: string;
    Parameters: RDS$20130110$ParametersList;
  };
  declare type RDS$20130110$ModifyDBSubnetGroupMessage = {
    DBSubnetGroupName: string;
    DBSubnetGroupDescription?: string;
    SubnetIds: RDS$20130110$SubnetIdentifierList;
  };
  declare type RDS$20130110$ModifyDBSubnetGroupResult = {
    DBSubnetGroup?: RDS$20130110$DBSubnetGroup;
  };
  declare type RDS$20130110$ModifyEventSubscriptionMessage = {
    SubscriptionName: string;
    SnsTopicArn?: string;
    SourceType?: string;
    EventCategories?: RDS$20130110$EventCategoriesList;
    Enabled?: boolean;
  };
  declare type RDS$20130110$ModifyEventSubscriptionResult = {
    EventSubscription?: RDS$20130110$EventSubscription;
  };
  declare type RDS$20130110$ModifyOptionGroupMessage = {
    OptionGroupName: string;
    OptionsToInclude?: RDS$20130110$OptionConfigurationList;
    OptionsToRemove?: RDS$20130110$OptionNamesList;
    ApplyImmediately?: boolean;
  };
  declare type RDS$20130110$ModifyOptionGroupResult = {
    OptionGroup?: RDS$20130110$OptionGroup;
  };
  declare type RDS$20130110$Option = {
    OptionName?: string;
    OptionDescription?: string;
    Port?: number;
    DBSecurityGroupMemberships?: RDS$20130110$DBSecurityGroupMembershipList;
    VpcSecurityGroupMemberships?: RDS$20130110$VpcSecurityGroupMembershipList;
  };
  declare type RDS$20130110$OptionConfiguration = {
    OptionName: string;
    Port?: number;
    DBSecurityGroupMemberships?: RDS$20130110$DBSecurityGroupNameList;
    VpcSecurityGroupMemberships?: RDS$20130110$VpcSecurityGroupIdList;
  };
  declare type RDS$20130110$OptionConfigurationList = RDS$20130110$OptionConfiguration[];
  declare type RDS$20130110$OptionGroup = {
    OptionGroupName?: string;
    OptionGroupDescription?: string;
    EngineName?: string;
    MajorEngineVersion?: string;
    Options?: RDS$20130110$OptionsList;
    AllowsVpcAndNonVpcInstanceMemberships?: boolean;
    VpcId?: string;
  };
  declare type RDS$20130110$OptionGroupAlreadyExistsFault = {};
  declare type RDS$20130110$OptionGroupMembership = {
    OptionGroupName?: string;
    Status?: string;
  };
  declare type RDS$20130110$OptionGroupNotFoundFault = {};
  declare type RDS$20130110$OptionGroupOption = {
    Name?: string;
    Description?: string;
    EngineName?: string;
    MajorEngineVersion?: string;
    MinimumRequiredMinorEngineVersion?: string;
    PortRequired?: boolean;
    DefaultPort?: number;
    OptionsDependedOn?: RDS$20130110$OptionsDependedOn;
  };
  declare type RDS$20130110$OptionGroupOptionsList = RDS$20130110$OptionGroupOption[];
  declare type RDS$20130110$OptionGroupOptionsMessage = {
    OptionGroupOptions?: RDS$20130110$OptionGroupOptionsList;
    Marker?: string;
  };
  declare type RDS$20130110$OptionGroupQuotaExceededFault = {};
  declare type RDS$20130110$OptionGroups = {
    OptionGroupsList?: RDS$20130110$OptionGroupsList;
    Marker?: string;
  };
  declare type RDS$20130110$OptionGroupsList = RDS$20130110$OptionGroup[];
  declare type RDS$20130110$OptionNamesList = string[];
  declare type RDS$20130110$OptionsDependedOn = string[];
  declare type RDS$20130110$OptionsList = RDS$20130110$Option[];
  declare type RDS$20130110$OrderableDBInstanceOption = {
    Engine?: string;
    EngineVersion?: string;
    DBInstanceClass?: string;
    LicenseModel?: string;
    AvailabilityZones?: RDS$20130110$AvailabilityZoneList;
    MultiAZCapable?: boolean;
    ReadReplicaCapable?: boolean;
    Vpc?: boolean;
  };
  declare type RDS$20130110$OrderableDBInstanceOptionsList = RDS$20130110$OrderableDBInstanceOption[];
  declare type RDS$20130110$OrderableDBInstanceOptionsMessage = {
    OrderableDBInstanceOptions?: RDS$20130110$OrderableDBInstanceOptionsList;
    Marker?: string;
  };
  declare type RDS$20130110$Parameter = {
    ParameterName?: string;
    ParameterValue?: string;
    Description?: string;
    Source?: string;
    ApplyType?: string;
    DataType?: string;
    AllowedValues?: string;
    IsModifiable?: boolean;
    MinimumEngineVersion?: string;
    ApplyMethod?: 'immediate' | 'pending-reboot';
  };
  declare type RDS$20130110$ParametersList = RDS$20130110$Parameter[];
  declare type RDS$20130110$PendingModifiedValues = {
    DBInstanceClass?: string;
    AllocatedStorage?: number;
    MasterUserPassword?: string;
    Port?: number;
    BackupRetentionPeriod?: number;
    MultiAZ?: boolean;
    EngineVersion?: string;
    Iops?: number;
    DBInstanceIdentifier?: string;
  };
  declare type RDS$20130110$PointInTimeRestoreNotEnabledFault = {};
  declare type RDS$20130110$PromoteReadReplicaMessage = {
    DBInstanceIdentifier: string;
    BackupRetentionPeriod?: number;
    PreferredBackupWindow?: string;
  };
  declare type RDS$20130110$PromoteReadReplicaResult = {
    DBInstance?: RDS$20130110$DBInstance;
  };
  declare type RDS$20130110$ProvisionedIopsNotAvailableInAZFault = {};
  declare type RDS$20130110$PurchaseReservedDBInstancesOfferingMessage = {
    ReservedDBInstancesOfferingId: string;
    ReservedDBInstanceId?: string;
    DBInstanceCount?: number;
  };
  declare type RDS$20130110$PurchaseReservedDBInstancesOfferingResult = {
    ReservedDBInstance?: RDS$20130110$ReservedDBInstance;
  };
  declare type RDS$20130110$ReadReplicaDBInstanceIdentifierList = string[];
  declare type RDS$20130110$RebootDBInstanceMessage = {
    DBInstanceIdentifier: string;
    ForceFailover?: boolean;
  };
  declare type RDS$20130110$RebootDBInstanceResult = {
    DBInstance?: RDS$20130110$DBInstance;
  };
  declare type RDS$20130110$RecurringCharge = {
    RecurringChargeAmount?: number;
    RecurringChargeFrequency?: string;
  };
  declare type RDS$20130110$RecurringChargeList = RDS$20130110$RecurringCharge[];
  declare type RDS$20130110$RemoveSourceIdentifierFromSubscriptionMessage = {
    SubscriptionName: string;
    SourceIdentifier: string;
  };
  declare type RDS$20130110$RemoveSourceIdentifierFromSubscriptionResult = {
    EventSubscription?: RDS$20130110$EventSubscription;
  };
  declare type RDS$20130110$RemoveTagsFromResourceMessage = {
    ResourceName: string;
    TagKeys: RDS$20130110$KeyList;
  };
  declare type RDS$20130110$ReservedDBInstance = {
    ReservedDBInstanceId?: string;
    ReservedDBInstancesOfferingId?: string;
    DBInstanceClass?: string;
    StartTime?: Date;
    Duration?: number;
    FixedPrice?: number;
    UsagePrice?: number;
    CurrencyCode?: string;
    DBInstanceCount?: number;
    ProductDescription?: string;
    OfferingType?: string;
    MultiAZ?: boolean;
    State?: string;
    RecurringCharges?: RDS$20130110$RecurringChargeList;
  };
  declare type RDS$20130110$ReservedDBInstanceAlreadyExistsFault = {};
  declare type RDS$20130110$ReservedDBInstanceList = RDS$20130110$ReservedDBInstance[];
  declare type RDS$20130110$ReservedDBInstanceMessage = {
    Marker?: string;
    ReservedDBInstances?: RDS$20130110$ReservedDBInstanceList;
  };
  declare type RDS$20130110$ReservedDBInstanceNotFoundFault = {};
  declare type RDS$20130110$ReservedDBInstanceQuotaExceededFault = {};
  declare type RDS$20130110$ReservedDBInstancesOffering = {
    ReservedDBInstancesOfferingId?: string;
    DBInstanceClass?: string;
    Duration?: number;
    FixedPrice?: number;
    UsagePrice?: number;
    CurrencyCode?: string;
    ProductDescription?: string;
    OfferingType?: string;
    MultiAZ?: boolean;
    RecurringCharges?: RDS$20130110$RecurringChargeList;
  };
  declare type RDS$20130110$ReservedDBInstancesOfferingList = RDS$20130110$ReservedDBInstancesOffering[];
  declare type RDS$20130110$ReservedDBInstancesOfferingMessage = {
    Marker?: string;
    ReservedDBInstancesOfferings?: RDS$20130110$ReservedDBInstancesOfferingList;
  };
  declare type RDS$20130110$ReservedDBInstancesOfferingNotFoundFault = {};
  declare type RDS$20130110$ResetDBParameterGroupMessage = {
    DBParameterGroupName: string;
    ResetAllParameters?: boolean;
    Parameters?: RDS$20130110$ParametersList;
  };
  declare type RDS$20130110$RestoreDBInstanceFromDBSnapshotMessage = {
    DBInstanceIdentifier: string;
    DBSnapshotIdentifier: string;
    DBInstanceClass?: string;
    Port?: number;
    AvailabilityZone?: string;
    DBSubnetGroupName?: string;
    MultiAZ?: boolean;
    PubliclyAccessible?: boolean;
    AutoMinorVersionUpgrade?: boolean;
    LicenseModel?: string;
    DBName?: string;
    Engine?: string;
    Iops?: number;
    OptionGroupName?: string;
  };
  declare type RDS$20130110$RestoreDBInstanceFromDBSnapshotResult = {
    DBInstance?: RDS$20130110$DBInstance;
  };
  declare type RDS$20130110$RestoreDBInstanceToPointInTimeMessage = {
    SourceDBInstanceIdentifier: string;
    TargetDBInstanceIdentifier: string;
    RestoreTime?: Date;
    UseLatestRestorableTime?: boolean;
    DBInstanceClass?: string;
    Port?: number;
    AvailabilityZone?: string;
    DBSubnetGroupName?: string;
    MultiAZ?: boolean;
    PubliclyAccessible?: boolean;
    AutoMinorVersionUpgrade?: boolean;
    LicenseModel?: string;
    DBName?: string;
    Engine?: string;
    Iops?: number;
    OptionGroupName?: string;
  };
  declare type RDS$20130110$RestoreDBInstanceToPointInTimeResult = {
    DBInstance?: RDS$20130110$DBInstance;
  };
  declare type RDS$20130110$RevokeDBSecurityGroupIngressMessage = {
    DBSecurityGroupName: string;
    CIDRIP?: string;
    EC2SecurityGroupName?: string;
    EC2SecurityGroupId?: string;
    EC2SecurityGroupOwnerId?: string;
  };
  declare type RDS$20130110$RevokeDBSecurityGroupIngressResult = {
    DBSecurityGroup?: RDS$20130110$DBSecurityGroup;
  };
  declare type RDS$20130110$SNSInvalidTopicFault = {};
  declare type RDS$20130110$SNSNoAuthorizationFault = {};
  declare type RDS$20130110$SNSTopicArnNotFoundFault = {};
  declare type RDS$20130110$SnapshotQuotaExceededFault = {};
  declare type RDS$20130110$SourceIdsList = string[];
  declare type RDS$20130110$SourceNotFoundFault = {};
  declare type RDS$20130110$SourceType = 'db-instance' | 'db-parameter-group' | 'db-security-group' | 'db-snapshot';
  declare type RDS$20130110$StorageQuotaExceededFault = {};
  declare type RDS$20130110$Subnet = {
    SubnetIdentifier?: string;
    SubnetAvailabilityZone?: RDS$20130110$AvailabilityZone;
    SubnetStatus?: string;
  };
  declare type RDS$20130110$SubnetAlreadyInUse = {};
  declare type RDS$20130110$SubnetIdentifierList = string[];
  declare type RDS$20130110$SubnetList = RDS$20130110$Subnet[];
  declare type RDS$20130110$SubscriptionAlreadyExistFault = {};
  declare type RDS$20130110$SubscriptionCategoryNotFoundFault = {};
  declare type RDS$20130110$SubscriptionNotFoundFault = {};
  declare type RDS$20130110$SupportedCharacterSetsList = RDS$20130110$CharacterSet[];
  declare type RDS$20130110$TStamp = Date;
  declare type RDS$20130110$Tag = {
    Key?: string;
    Value?: string;
  };
  declare type RDS$20130110$TagList = RDS$20130110$Tag[];
  declare type RDS$20130110$TagListMessage = {
    TagList?: RDS$20130110$TagList;
  };
  declare type RDS$20130110$VpcSecurityGroupIdList = string[];
  declare type RDS$20130110$VpcSecurityGroupMembership = {
    VpcSecurityGroupId?: string;
    Status?: string;
  };
  declare type RDS$20130110$VpcSecurityGroupMembershipList = RDS$20130110$VpcSecurityGroupMembership[];
  declare type RDS$20130212$AddSourceIdentifierToSubscriptionMessage = {
    SubscriptionName: string;
    SourceIdentifier: string;
  };
  declare type RDS$20130212$AddSourceIdentifierToSubscriptionResult = {
    EventSubscription?: RDS$20130212$EventSubscription;
  };
  declare type RDS$20130212$AddTagsToResourceMessage = {
    ResourceName: string;
    Tags: RDS$20130212$TagList;
  };
  declare type RDS$20130212$ApplyMethod = 'immediate' | 'pending-reboot';
  declare type RDS$20130212$AuthorizationAlreadyExistsFault = {};
  declare type RDS$20130212$AuthorizationNotFoundFault = {};
  declare type RDS$20130212$AuthorizationQuotaExceededFault = {};
  declare type RDS$20130212$AuthorizeDBSecurityGroupIngressMessage = {
    DBSecurityGroupName: string;
    CIDRIP?: string;
    EC2SecurityGroupName?: string;
    EC2SecurityGroupId?: string;
    EC2SecurityGroupOwnerId?: string;
  };
  declare type RDS$20130212$AuthorizeDBSecurityGroupIngressResult = {
    DBSecurityGroup?: RDS$20130212$DBSecurityGroup;
  };
  declare type RDS$20130212$AvailabilityZone = {
    Name?: string;
    ProvisionedIopsCapable?: boolean;
  };
  declare type RDS$20130212$AvailabilityZoneList = RDS$20130212$AvailabilityZone[];
  declare type RDS$20130212$CharacterSet = {
    CharacterSetName?: string;
    CharacterSetDescription?: string;
  };
  declare type RDS$20130212$CopyDBSnapshotMessage = {
    SourceDBSnapshotIdentifier: string;
    TargetDBSnapshotIdentifier: string;
  };
  declare type RDS$20130212$CopyDBSnapshotResult = {
    DBSnapshot?: RDS$20130212$DBSnapshot;
  };
  declare type RDS$20130212$CreateDBInstanceMessage = {
    DBName?: string;
    DBInstanceIdentifier: string;
    AllocatedStorage: number;
    DBInstanceClass: string;
    Engine: string;
    MasterUsername: string;
    MasterUserPassword: string;
    DBSecurityGroups?: RDS$20130212$DBSecurityGroupNameList;
    VpcSecurityGroupIds?: RDS$20130212$VpcSecurityGroupIdList;
    AvailabilityZone?: string;
    DBSubnetGroupName?: string;
    PreferredMaintenanceWindow?: string;
    DBParameterGroupName?: string;
    BackupRetentionPeriod?: number;
    PreferredBackupWindow?: string;
    Port?: number;
    MultiAZ?: boolean;
    EngineVersion?: string;
    AutoMinorVersionUpgrade?: boolean;
    LicenseModel?: string;
    Iops?: number;
    OptionGroupName?: string;
    CharacterSetName?: string;
    PubliclyAccessible?: boolean;
  };
  declare type RDS$20130212$CreateDBInstanceReadReplicaMessage = {
    DBInstanceIdentifier: string;
    SourceDBInstanceIdentifier: string;
    DBInstanceClass?: string;
    AvailabilityZone?: string;
    Port?: number;
    AutoMinorVersionUpgrade?: boolean;
    Iops?: number;
    OptionGroupName?: string;
    PubliclyAccessible?: boolean;
  };
  declare type RDS$20130212$CreateDBInstanceReadReplicaResult = {
    DBInstance?: RDS$20130212$DBInstance;
  };
  declare type RDS$20130212$CreateDBInstanceResult = {
    DBInstance?: RDS$20130212$DBInstance;
  };
  declare type RDS$20130212$CreateDBParameterGroupMessage = {
    DBParameterGroupName: string;
    DBParameterGroupFamily: string;
    Description: string;
  };
  declare type RDS$20130212$CreateDBParameterGroupResult = {
    DBParameterGroup?: RDS$20130212$DBParameterGroup;
  };
  declare type RDS$20130212$CreateDBSecurityGroupMessage = {
    DBSecurityGroupName: string;
    DBSecurityGroupDescription: string;
  };
  declare type RDS$20130212$CreateDBSecurityGroupResult = {
    DBSecurityGroup?: RDS$20130212$DBSecurityGroup;
  };
  declare type RDS$20130212$CreateDBSnapshotMessage = {
    DBSnapshotIdentifier: string;
    DBInstanceIdentifier: string;
  };
  declare type RDS$20130212$CreateDBSnapshotResult = {
    DBSnapshot?: RDS$20130212$DBSnapshot;
  };
  declare type RDS$20130212$CreateDBSubnetGroupMessage = {
    DBSubnetGroupName: string;
    DBSubnetGroupDescription: string;
    SubnetIds: RDS$20130212$SubnetIdentifierList;
  };
  declare type RDS$20130212$CreateDBSubnetGroupResult = {
    DBSubnetGroup?: RDS$20130212$DBSubnetGroup;
  };
  declare type RDS$20130212$CreateEventSubscriptionMessage = {
    SubscriptionName: string;
    SnsTopicArn: string;
    SourceType?: string;
    EventCategories?: RDS$20130212$EventCategoriesList;
    SourceIds?: RDS$20130212$SourceIdsList;
    Enabled?: boolean;
  };
  declare type RDS$20130212$CreateEventSubscriptionResult = {
    EventSubscription?: RDS$20130212$EventSubscription;
  };
  declare type RDS$20130212$CreateOptionGroupMessage = {
    OptionGroupName: string;
    EngineName: string;
    MajorEngineVersion: string;
    OptionGroupDescription: string;
  };
  declare type RDS$20130212$CreateOptionGroupResult = {
    OptionGroup?: RDS$20130212$OptionGroup;
  };
  declare type RDS$20130212$DBEngineVersion = {
    Engine?: string;
    EngineVersion?: string;
    DBParameterGroupFamily?: string;
    DBEngineDescription?: string;
    DBEngineVersionDescription?: string;
    DefaultCharacterSet?: RDS$20130212$CharacterSet;
    SupportedCharacterSets?: RDS$20130212$SupportedCharacterSetsList;
  };
  declare type RDS$20130212$DBEngineVersionList = RDS$20130212$DBEngineVersion[];
  declare type RDS$20130212$DBEngineVersionMessage = {
    Marker?: string;
    DBEngineVersions?: RDS$20130212$DBEngineVersionList;
  };
  declare type RDS$20130212$DBInstance = {
    DBInstanceIdentifier?: string;
    DBInstanceClass?: string;
    Engine?: string;
    DBInstanceStatus?: string;
    MasterUsername?: string;
    DBName?: string;
    Endpoint?: RDS$20130212$Endpoint;
    AllocatedStorage?: number;
    InstanceCreateTime?: Date;
    PreferredBackupWindow?: string;
    BackupRetentionPeriod?: number;
    DBSecurityGroups?: RDS$20130212$DBSecurityGroupMembershipList;
    VpcSecurityGroups?: RDS$20130212$VpcSecurityGroupMembershipList;
    DBParameterGroups?: RDS$20130212$DBParameterGroupStatusList;
    AvailabilityZone?: string;
    DBSubnetGroup?: RDS$20130212$DBSubnetGroup;
    PreferredMaintenanceWindow?: string;
    PendingModifiedValues?: RDS$20130212$PendingModifiedValues;
    LatestRestorableTime?: Date;
    MultiAZ?: boolean;
    EngineVersion?: string;
    AutoMinorVersionUpgrade?: boolean;
    ReadReplicaSourceDBInstanceIdentifier?: string;
    ReadReplicaDBInstanceIdentifiers?: RDS$20130212$ReadReplicaDBInstanceIdentifierList;
    LicenseModel?: string;
    Iops?: number;
    OptionGroupMemberships?: RDS$20130212$OptionGroupMembershipList;
    CharacterSetName?: string;
    SecondaryAvailabilityZone?: string;
    PubliclyAccessible?: boolean;
  };
  declare type RDS$20130212$DBInstanceAlreadyExistsFault = {};
  declare type RDS$20130212$DBInstanceList = RDS$20130212$DBInstance[];
  declare type RDS$20130212$DBInstanceMessage = {
    Marker?: string;
    DBInstances?: RDS$20130212$DBInstanceList;
  };
  declare type RDS$20130212$DBInstanceNotFoundFault = {};
  declare type RDS$20130212$DBLogFileNotFoundFault = {};
  declare type RDS$20130212$DBParameterGroup = {
    DBParameterGroupName?: string;
    DBParameterGroupFamily?: string;
    Description?: string;
  };
  declare type RDS$20130212$DBParameterGroupAlreadyExistsFault = {};
  declare type RDS$20130212$DBParameterGroupDetails = {
    Parameters?: RDS$20130212$ParametersList;
    Marker?: string;
  };
  declare type RDS$20130212$DBParameterGroupList = RDS$20130212$DBParameterGroup[];
  declare type RDS$20130212$DBParameterGroupNameMessage = {
    DBParameterGroupName?: string;
  };
  declare type RDS$20130212$DBParameterGroupNotFoundFault = {};
  declare type RDS$20130212$DBParameterGroupQuotaExceededFault = {};
  declare type RDS$20130212$DBParameterGroupStatus = {
    DBParameterGroupName?: string;
    ParameterApplyStatus?: string;
  };
  declare type RDS$20130212$DBParameterGroupStatusList = RDS$20130212$DBParameterGroupStatus[];
  declare type RDS$20130212$DBParameterGroupsMessage = {
    Marker?: string;
    DBParameterGroups?: RDS$20130212$DBParameterGroupList;
  };
  declare type RDS$20130212$DBSecurityGroup = {
    OwnerId?: string;
    DBSecurityGroupName?: string;
    DBSecurityGroupDescription?: string;
    VpcId?: string;
    EC2SecurityGroups?: RDS$20130212$EC2SecurityGroupList;
    IPRanges?: RDS$20130212$IPRangeList;
  };
  declare type RDS$20130212$DBSecurityGroupAlreadyExistsFault = {};
  declare type RDS$20130212$DBSecurityGroupMembership = {
    DBSecurityGroupName?: string;
    Status?: string;
  };
  declare type RDS$20130212$DBSecurityGroupMembershipList = RDS$20130212$DBSecurityGroupMembership[];
  declare type RDS$20130212$DBSecurityGroupMessage = {
    Marker?: string;
    DBSecurityGroups?: RDS$20130212$DBSecurityGroups;
  };
  declare type RDS$20130212$DBSecurityGroupNameList = string[];
  declare type RDS$20130212$DBSecurityGroupNotFoundFault = {};
  declare type RDS$20130212$DBSecurityGroupNotSupportedFault = {};
  declare type RDS$20130212$DBSecurityGroupQuotaExceededFault = {};
  declare type RDS$20130212$DBSecurityGroups = RDS$20130212$DBSecurityGroup[];
  declare type RDS$20130212$DBSnapshot = {
    DBSnapshotIdentifier?: string;
    DBInstanceIdentifier?: string;
    SnapshotCreateTime?: Date;
    Engine?: string;
    AllocatedStorage?: number;
    Status?: string;
    Port?: number;
    AvailabilityZone?: string;
    VpcId?: string;
    InstanceCreateTime?: Date;
    MasterUsername?: string;
    EngineVersion?: string;
    LicenseModel?: string;
    SnapshotType?: string;
    Iops?: number;
    OptionGroupName?: string;
  };
  declare type RDS$20130212$DBSnapshotAlreadyExistsFault = {};
  declare type RDS$20130212$DBSnapshotList = RDS$20130212$DBSnapshot[];
  declare type RDS$20130212$DBSnapshotMessage = {
    Marker?: string;
    DBSnapshots?: RDS$20130212$DBSnapshotList;
  };
  declare type RDS$20130212$DBSnapshotNotFoundFault = {};
  declare type RDS$20130212$DBSubnetGroup = {
    DBSubnetGroupName?: string;
    DBSubnetGroupDescription?: string;
    VpcId?: string;
    SubnetGroupStatus?: string;
    Subnets?: RDS$20130212$SubnetList;
  };
  declare type RDS$20130212$DBSubnetGroupAlreadyExistsFault = {};
  declare type RDS$20130212$DBSubnetGroupDoesNotCoverEnoughAZs = {};
  declare type RDS$20130212$DBSubnetGroupMessage = {
    Marker?: string;
    DBSubnetGroups?: RDS$20130212$DBSubnetGroups;
  };
  declare type RDS$20130212$DBSubnetGroupNotFoundFault = {};
  declare type RDS$20130212$DBSubnetGroupQuotaExceededFault = {};
  declare type RDS$20130212$DBSubnetGroups = RDS$20130212$DBSubnetGroup[];
  declare type RDS$20130212$DBSubnetQuotaExceededFault = {};
  declare type RDS$20130212$DBUpgradeDependencyFailureFault = {};
  declare type RDS$20130212$DeleteDBInstanceMessage = {
    DBInstanceIdentifier: string;
    SkipFinalSnapshot?: boolean;
    FinalDBSnapshotIdentifier?: string;
  };
  declare type RDS$20130212$DeleteDBInstanceResult = {
    DBInstance?: RDS$20130212$DBInstance;
  };
  declare type RDS$20130212$DeleteDBParameterGroupMessage = {
    DBParameterGroupName: string;
  };
  declare type RDS$20130212$DeleteDBSecurityGroupMessage = {
    DBSecurityGroupName: string;
  };
  declare type RDS$20130212$DeleteDBSnapshotMessage = {
    DBSnapshotIdentifier: string;
  };
  declare type RDS$20130212$DeleteDBSnapshotResult = {
    DBSnapshot?: RDS$20130212$DBSnapshot;
  };
  declare type RDS$20130212$DeleteDBSubnetGroupMessage = {
    DBSubnetGroupName: string;
  };
  declare type RDS$20130212$DeleteEventSubscriptionMessage = {
    SubscriptionName: string;
  };
  declare type RDS$20130212$DeleteEventSubscriptionResult = {
    EventSubscription?: RDS$20130212$EventSubscription;
  };
  declare type RDS$20130212$DeleteOptionGroupMessage = {
    OptionGroupName: string;
  };
  declare type RDS$20130212$DescribeDBEngineVersionsMessage = {
    Engine?: string;
    EngineVersion?: string;
    DBParameterGroupFamily?: string;
    MaxRecords?: number;
    Marker?: string;
    DefaultOnly?: boolean;
    ListSupportedCharacterSets?: boolean;
  };
  declare type RDS$20130212$DescribeDBInstancesMessage = {
    DBInstanceIdentifier?: string;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20130212$DescribeDBLogFilesDetails = {
    LogFileName?: string;
    LastWritten?: number;
    Size?: number;
  };
  declare type RDS$20130212$DescribeDBLogFilesList = RDS$20130212$DescribeDBLogFilesDetails[];
  declare type RDS$20130212$DescribeDBLogFilesMessage = {
    DBInstanceIdentifier: string;
    FilenameContains?: string;
    FileLastWritten?: number;
    FileSize?: number;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20130212$DescribeDBLogFilesResponse = {
    DescribeDBLogFiles?: RDS$20130212$DescribeDBLogFilesList;
    Marker?: string;
  };
  declare type RDS$20130212$DescribeDBParameterGroupsMessage = {
    DBParameterGroupName?: string;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20130212$DescribeDBParametersMessage = {
    DBParameterGroupName: string;
    Source?: string;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20130212$DescribeDBSecurityGroupsMessage = {
    DBSecurityGroupName?: string;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20130212$DescribeDBSnapshotsMessage = {
    DBInstanceIdentifier?: string;
    DBSnapshotIdentifier?: string;
    SnapshotType?: string;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20130212$DescribeDBSubnetGroupsMessage = {
    DBSubnetGroupName?: string;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20130212$DescribeEngineDefaultParametersMessage = {
    DBParameterGroupFamily: string;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20130212$DescribeEngineDefaultParametersResult = {
    EngineDefaults?: RDS$20130212$EngineDefaults;
  };
  declare type RDS$20130212$DescribeEventCategoriesMessage = {
    SourceType?: string;
  };
  declare type RDS$20130212$DescribeEventSubscriptionsMessage = {
    SubscriptionName?: string;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20130212$DescribeEventsMessage = {
    SourceIdentifier?: string;
    SourceType?: 'db-instance' | 'db-parameter-group' | 'db-security-group' | 'db-snapshot';
    StartTime?: Date;
    EndTime?: Date;
    Duration?: number;
    EventCategories?: RDS$20130212$EventCategoriesList;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20130212$DescribeOptionGroupOptionsMessage = {
    EngineName: string;
    MajorEngineVersion?: string;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20130212$DescribeOptionGroupsMessage = {
    OptionGroupName?: string;
    Marker?: string;
    MaxRecords?: number;
    EngineName?: string;
    MajorEngineVersion?: string;
  };
  declare type RDS$20130212$DescribeOrderableDBInstanceOptionsMessage = {
    Engine: string;
    EngineVersion?: string;
    DBInstanceClass?: string;
    LicenseModel?: string;
    Vpc?: boolean;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20130212$DescribeReservedDBInstancesMessage = {
    ReservedDBInstanceId?: string;
    ReservedDBInstancesOfferingId?: string;
    DBInstanceClass?: string;
    Duration?: string;
    ProductDescription?: string;
    OfferingType?: string;
    MultiAZ?: boolean;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20130212$DescribeReservedDBInstancesOfferingsMessage = {
    ReservedDBInstancesOfferingId?: string;
    DBInstanceClass?: string;
    Duration?: string;
    ProductDescription?: string;
    OfferingType?: string;
    MultiAZ?: boolean;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20130212$DownloadDBLogFilePortionDetails = {
    LogFileData?: string;
    Marker?: string;
    AdditionalDataPending?: boolean;
  };
  declare type RDS$20130212$DownloadDBLogFilePortionMessage = {
    DBInstanceIdentifier: string;
    LogFileName: string;
    Marker?: string;
    NumberOfLines?: number;
  };
  declare type RDS$20130212$EC2SecurityGroup = {
    Status?: string;
    EC2SecurityGroupName?: string;
    EC2SecurityGroupId?: string;
    EC2SecurityGroupOwnerId?: string;
  };
  declare type RDS$20130212$EC2SecurityGroupList = RDS$20130212$EC2SecurityGroup[];
  declare type RDS$20130212$Endpoint = {
    Address?: string;
    Port?: number;
  };
  declare type RDS$20130212$EngineDefaults = {
    DBParameterGroupFamily?: string;
    Marker?: string;
    Parameters?: RDS$20130212$ParametersList;
  };
  declare type RDS$20130212$Event = {
    SourceIdentifier?: string;
    SourceType?: 'db-instance' | 'db-parameter-group' | 'db-security-group' | 'db-snapshot';
    Message?: string;
    EventCategories?: RDS$20130212$EventCategoriesList;
    Date?: Date;
  };
  declare type RDS$20130212$EventCategoriesList = string[];
  declare type RDS$20130212$EventCategoriesMap = {
    SourceType?: string;
    EventCategories?: RDS$20130212$EventCategoriesList;
  };
  declare type RDS$20130212$EventCategoriesMapList = RDS$20130212$EventCategoriesMap[];
  declare type RDS$20130212$EventCategoriesMessage = {
    EventCategoriesMapList?: RDS$20130212$EventCategoriesMapList;
  };
  declare type RDS$20130212$EventList = RDS$20130212$Event[];
  declare type RDS$20130212$EventSubscription = {
    CustomerAwsId?: string;
    CustSubscriptionId?: string;
    SnsTopicArn?: string;
    Status?: string;
    SubscriptionCreationTime?: string;
    SourceType?: string;
    SourceIdsList?: RDS$20130212$SourceIdsList;
    EventCategoriesList?: RDS$20130212$EventCategoriesList;
    Enabled?: boolean;
  };
  declare type RDS$20130212$EventSubscriptionQuotaExceededFault = {};
  declare type RDS$20130212$EventSubscriptionsList = RDS$20130212$EventSubscription[];
  declare type RDS$20130212$EventSubscriptionsMessage = {
    Marker?: string;
    EventSubscriptionsList?: RDS$20130212$EventSubscriptionsList;
  };
  declare type RDS$20130212$EventsMessage = {
    Marker?: string;
    Events?: RDS$20130212$EventList;
  };
  declare type RDS$20130212$IPRange = {
    Status?: string;
    CIDRIP?: string;
  };
  declare type RDS$20130212$IPRangeList = RDS$20130212$IPRange[];
  declare type RDS$20130212$InstanceQuotaExceededFault = {};
  declare type RDS$20130212$InsufficientDBInstanceCapacityFault = {};
  declare type RDS$20130212$InvalidDBInstanceStateFault = {};
  declare type RDS$20130212$InvalidDBParameterGroupStateFault = {};
  declare type RDS$20130212$InvalidDBSecurityGroupStateFault = {};
  declare type RDS$20130212$InvalidDBSnapshotStateFault = {};
  declare type RDS$20130212$InvalidDBSubnetGroupStateFault = {};
  declare type RDS$20130212$InvalidDBSubnetStateFault = {};
  declare type RDS$20130212$InvalidEventSubscriptionStateFault = {};
  declare type RDS$20130212$InvalidOptionGroupStateFault = {};
  declare type RDS$20130212$InvalidRestoreFault = {};
  declare type RDS$20130212$InvalidSubnet = {};
  declare type RDS$20130212$InvalidVPCNetworkStateFault = {};
  declare type RDS$20130212$KeyList = string[];
  declare type RDS$20130212$ListTagsForResourceMessage = {
    ResourceName: string;
  };
  declare type RDS$20130212$ModifyDBInstanceMessage = {
    DBInstanceIdentifier: string;
    AllocatedStorage?: number;
    DBInstanceClass?: string;
    DBSecurityGroups?: RDS$20130212$DBSecurityGroupNameList;
    VpcSecurityGroupIds?: RDS$20130212$VpcSecurityGroupIdList;
    ApplyImmediately?: boolean;
    MasterUserPassword?: string;
    DBParameterGroupName?: string;
    BackupRetentionPeriod?: number;
    PreferredBackupWindow?: string;
    PreferredMaintenanceWindow?: string;
    MultiAZ?: boolean;
    EngineVersion?: string;
    AllowMajorVersionUpgrade?: boolean;
    AutoMinorVersionUpgrade?: boolean;
    Iops?: number;
    OptionGroupName?: string;
    NewDBInstanceIdentifier?: string;
  };
  declare type RDS$20130212$ModifyDBInstanceResult = {
    DBInstance?: RDS$20130212$DBInstance;
  };
  declare type RDS$20130212$ModifyDBParameterGroupMessage = {
    DBParameterGroupName: string;
    Parameters: RDS$20130212$ParametersList;
  };
  declare type RDS$20130212$ModifyDBSubnetGroupMessage = {
    DBSubnetGroupName: string;
    DBSubnetGroupDescription?: string;
    SubnetIds: RDS$20130212$SubnetIdentifierList;
  };
  declare type RDS$20130212$ModifyDBSubnetGroupResult = {
    DBSubnetGroup?: RDS$20130212$DBSubnetGroup;
  };
  declare type RDS$20130212$ModifyEventSubscriptionMessage = {
    SubscriptionName: string;
    SnsTopicArn?: string;
    SourceType?: string;
    EventCategories?: RDS$20130212$EventCategoriesList;
    Enabled?: boolean;
  };
  declare type RDS$20130212$ModifyEventSubscriptionResult = {
    EventSubscription?: RDS$20130212$EventSubscription;
  };
  declare type RDS$20130212$ModifyOptionGroupMessage = {
    OptionGroupName: string;
    OptionsToInclude?: RDS$20130212$OptionConfigurationList;
    OptionsToRemove?: RDS$20130212$OptionNamesList;
    ApplyImmediately?: boolean;
  };
  declare type RDS$20130212$ModifyOptionGroupResult = {
    OptionGroup?: RDS$20130212$OptionGroup;
  };
  declare type RDS$20130212$Option = {
    OptionName?: string;
    OptionDescription?: string;
    Persistent?: boolean;
    Port?: number;
    OptionSettings?: RDS$20130212$OptionSettingConfigurationList;
    DBSecurityGroupMemberships?: RDS$20130212$DBSecurityGroupMembershipList;
    VpcSecurityGroupMemberships?: RDS$20130212$VpcSecurityGroupMembershipList;
  };
  declare type RDS$20130212$OptionConfiguration = {
    OptionName: string;
    Port?: number;
    DBSecurityGroupMemberships?: RDS$20130212$DBSecurityGroupNameList;
    VpcSecurityGroupMemberships?: RDS$20130212$VpcSecurityGroupIdList;
    OptionSettings?: RDS$20130212$OptionSettingsList;
  };
  declare type RDS$20130212$OptionConfigurationList = RDS$20130212$OptionConfiguration[];
  declare type RDS$20130212$OptionGroup = {
    OptionGroupName?: string;
    OptionGroupDescription?: string;
    EngineName?: string;
    MajorEngineVersion?: string;
    Options?: RDS$20130212$OptionsList;
    AllowsVpcAndNonVpcInstanceMemberships?: boolean;
    VpcId?: string;
  };
  declare type RDS$20130212$OptionGroupAlreadyExistsFault = {};
  declare type RDS$20130212$OptionGroupMembership = {
    OptionGroupName?: string;
    Status?: string;
  };
  declare type RDS$20130212$OptionGroupMembershipList = RDS$20130212$OptionGroupMembership[];
  declare type RDS$20130212$OptionGroupNotFoundFault = {};
  declare type RDS$20130212$OptionGroupOption = {
    Name?: string;
    Description?: string;
    EngineName?: string;
    MajorEngineVersion?: string;
    MinimumRequiredMinorEngineVersion?: string;
    PortRequired?: boolean;
    DefaultPort?: number;
    OptionsDependedOn?: RDS$20130212$OptionsDependedOn;
    Persistent?: boolean;
    OptionGroupOptionSettings?: RDS$20130212$OptionGroupOptionSettingsList;
  };
  declare type RDS$20130212$OptionGroupOptionSetting = {
    SettingName?: string;
    SettingDescription?: string;
    DefaultValue?: string;
    ApplyType?: string;
    AllowedValues?: string;
    IsModifiable?: boolean;
  };
  declare type RDS$20130212$OptionGroupOptionSettingsList = RDS$20130212$OptionGroupOptionSetting[];
  declare type RDS$20130212$OptionGroupOptionsList = RDS$20130212$OptionGroupOption[];
  declare type RDS$20130212$OptionGroupOptionsMessage = {
    OptionGroupOptions?: RDS$20130212$OptionGroupOptionsList;
    Marker?: string;
  };
  declare type RDS$20130212$OptionGroupQuotaExceededFault = {};
  declare type RDS$20130212$OptionGroups = {
    OptionGroupsList?: RDS$20130212$OptionGroupsList;
    Marker?: string;
  };
  declare type RDS$20130212$OptionGroupsList = RDS$20130212$OptionGroup[];
  declare type RDS$20130212$OptionNamesList = string[];
  declare type RDS$20130212$OptionSetting = {
    Name?: string;
    Value?: string;
    DefaultValue?: string;
    Description?: string;
    ApplyType?: string;
    DataType?: string;
    AllowedValues?: string;
    IsModifiable?: boolean;
    IsCollection?: boolean;
  };
  declare type RDS$20130212$OptionSettingConfigurationList = RDS$20130212$OptionSetting[];
  declare type RDS$20130212$OptionSettingsList = RDS$20130212$OptionSetting[];
  declare type RDS$20130212$OptionsDependedOn = string[];
  declare type RDS$20130212$OptionsList = RDS$20130212$Option[];
  declare type RDS$20130212$OrderableDBInstanceOption = {
    Engine?: string;
    EngineVersion?: string;
    DBInstanceClass?: string;
    LicenseModel?: string;
    AvailabilityZones?: RDS$20130212$AvailabilityZoneList;
    MultiAZCapable?: boolean;
    ReadReplicaCapable?: boolean;
    Vpc?: boolean;
  };
  declare type RDS$20130212$OrderableDBInstanceOptionsList = RDS$20130212$OrderableDBInstanceOption[];
  declare type RDS$20130212$OrderableDBInstanceOptionsMessage = {
    OrderableDBInstanceOptions?: RDS$20130212$OrderableDBInstanceOptionsList;
    Marker?: string;
  };
  declare type RDS$20130212$Parameter = {
    ParameterName?: string;
    ParameterValue?: string;
    Description?: string;
    Source?: string;
    ApplyType?: string;
    DataType?: string;
    AllowedValues?: string;
    IsModifiable?: boolean;
    MinimumEngineVersion?: string;
    ApplyMethod?: 'immediate' | 'pending-reboot';
  };
  declare type RDS$20130212$ParametersList = RDS$20130212$Parameter[];
  declare type RDS$20130212$PendingModifiedValues = {
    DBInstanceClass?: string;
    AllocatedStorage?: number;
    MasterUserPassword?: string;
    Port?: number;
    BackupRetentionPeriod?: number;
    MultiAZ?: boolean;
    EngineVersion?: string;
    Iops?: number;
    DBInstanceIdentifier?: string;
  };
  declare type RDS$20130212$PointInTimeRestoreNotEnabledFault = {};
  declare type RDS$20130212$PromoteReadReplicaMessage = {
    DBInstanceIdentifier: string;
    BackupRetentionPeriod?: number;
    PreferredBackupWindow?: string;
  };
  declare type RDS$20130212$PromoteReadReplicaResult = {
    DBInstance?: RDS$20130212$DBInstance;
  };
  declare type RDS$20130212$ProvisionedIopsNotAvailableInAZFault = {};
  declare type RDS$20130212$PurchaseReservedDBInstancesOfferingMessage = {
    ReservedDBInstancesOfferingId: string;
    ReservedDBInstanceId?: string;
    DBInstanceCount?: number;
  };
  declare type RDS$20130212$PurchaseReservedDBInstancesOfferingResult = {
    ReservedDBInstance?: RDS$20130212$ReservedDBInstance;
  };
  declare type RDS$20130212$ReadReplicaDBInstanceIdentifierList = string[];
  declare type RDS$20130212$RebootDBInstanceMessage = {
    DBInstanceIdentifier: string;
    ForceFailover?: boolean;
  };
  declare type RDS$20130212$RebootDBInstanceResult = {
    DBInstance?: RDS$20130212$DBInstance;
  };
  declare type RDS$20130212$RecurringCharge = {
    RecurringChargeAmount?: number;
    RecurringChargeFrequency?: string;
  };
  declare type RDS$20130212$RecurringChargeList = RDS$20130212$RecurringCharge[];
  declare type RDS$20130212$RemoveSourceIdentifierFromSubscriptionMessage = {
    SubscriptionName: string;
    SourceIdentifier: string;
  };
  declare type RDS$20130212$RemoveSourceIdentifierFromSubscriptionResult = {
    EventSubscription?: RDS$20130212$EventSubscription;
  };
  declare type RDS$20130212$RemoveTagsFromResourceMessage = {
    ResourceName: string;
    TagKeys: RDS$20130212$KeyList;
  };
  declare type RDS$20130212$ReservedDBInstance = {
    ReservedDBInstanceId?: string;
    ReservedDBInstancesOfferingId?: string;
    DBInstanceClass?: string;
    StartTime?: Date;
    Duration?: number;
    FixedPrice?: number;
    UsagePrice?: number;
    CurrencyCode?: string;
    DBInstanceCount?: number;
    ProductDescription?: string;
    OfferingType?: string;
    MultiAZ?: boolean;
    State?: string;
    RecurringCharges?: RDS$20130212$RecurringChargeList;
  };
  declare type RDS$20130212$ReservedDBInstanceAlreadyExistsFault = {};
  declare type RDS$20130212$ReservedDBInstanceList = RDS$20130212$ReservedDBInstance[];
  declare type RDS$20130212$ReservedDBInstanceMessage = {
    Marker?: string;
    ReservedDBInstances?: RDS$20130212$ReservedDBInstanceList;
  };
  declare type RDS$20130212$ReservedDBInstanceNotFoundFault = {};
  declare type RDS$20130212$ReservedDBInstanceQuotaExceededFault = {};
  declare type RDS$20130212$ReservedDBInstancesOffering = {
    ReservedDBInstancesOfferingId?: string;
    DBInstanceClass?: string;
    Duration?: number;
    FixedPrice?: number;
    UsagePrice?: number;
    CurrencyCode?: string;
    ProductDescription?: string;
    OfferingType?: string;
    MultiAZ?: boolean;
    RecurringCharges?: RDS$20130212$RecurringChargeList;
  };
  declare type RDS$20130212$ReservedDBInstancesOfferingList = RDS$20130212$ReservedDBInstancesOffering[];
  declare type RDS$20130212$ReservedDBInstancesOfferingMessage = {
    Marker?: string;
    ReservedDBInstancesOfferings?: RDS$20130212$ReservedDBInstancesOfferingList;
  };
  declare type RDS$20130212$ReservedDBInstancesOfferingNotFoundFault = {};
  declare type RDS$20130212$ResetDBParameterGroupMessage = {
    DBParameterGroupName: string;
    ResetAllParameters?: boolean;
    Parameters?: RDS$20130212$ParametersList;
  };
  declare type RDS$20130212$RestoreDBInstanceFromDBSnapshotMessage = {
    DBInstanceIdentifier: string;
    DBSnapshotIdentifier: string;
    DBInstanceClass?: string;
    Port?: number;
    AvailabilityZone?: string;
    DBSubnetGroupName?: string;
    MultiAZ?: boolean;
    PubliclyAccessible?: boolean;
    AutoMinorVersionUpgrade?: boolean;
    LicenseModel?: string;
    DBName?: string;
    Engine?: string;
    Iops?: number;
    OptionGroupName?: string;
  };
  declare type RDS$20130212$RestoreDBInstanceFromDBSnapshotResult = {
    DBInstance?: RDS$20130212$DBInstance;
  };
  declare type RDS$20130212$RestoreDBInstanceToPointInTimeMessage = {
    SourceDBInstanceIdentifier: string;
    TargetDBInstanceIdentifier: string;
    RestoreTime?: Date;
    UseLatestRestorableTime?: boolean;
    DBInstanceClass?: string;
    Port?: number;
    AvailabilityZone?: string;
    DBSubnetGroupName?: string;
    MultiAZ?: boolean;
    PubliclyAccessible?: boolean;
    AutoMinorVersionUpgrade?: boolean;
    LicenseModel?: string;
    DBName?: string;
    Engine?: string;
    Iops?: number;
    OptionGroupName?: string;
  };
  declare type RDS$20130212$RestoreDBInstanceToPointInTimeResult = {
    DBInstance?: RDS$20130212$DBInstance;
  };
  declare type RDS$20130212$RevokeDBSecurityGroupIngressMessage = {
    DBSecurityGroupName: string;
    CIDRIP?: string;
    EC2SecurityGroupName?: string;
    EC2SecurityGroupId?: string;
    EC2SecurityGroupOwnerId?: string;
  };
  declare type RDS$20130212$RevokeDBSecurityGroupIngressResult = {
    DBSecurityGroup?: RDS$20130212$DBSecurityGroup;
  };
  declare type RDS$20130212$SNSInvalidTopicFault = {};
  declare type RDS$20130212$SNSNoAuthorizationFault = {};
  declare type RDS$20130212$SNSTopicArnNotFoundFault = {};
  declare type RDS$20130212$SnapshotQuotaExceededFault = {};
  declare type RDS$20130212$SourceIdsList = string[];
  declare type RDS$20130212$SourceNotFoundFault = {};
  declare type RDS$20130212$SourceType = 'db-instance' | 'db-parameter-group' | 'db-security-group' | 'db-snapshot';
  declare type RDS$20130212$StorageQuotaExceededFault = {};
  declare type RDS$20130212$Subnet = {
    SubnetIdentifier?: string;
    SubnetAvailabilityZone?: RDS$20130212$AvailabilityZone;
    SubnetStatus?: string;
  };
  declare type RDS$20130212$SubnetAlreadyInUse = {};
  declare type RDS$20130212$SubnetIdentifierList = string[];
  declare type RDS$20130212$SubnetList = RDS$20130212$Subnet[];
  declare type RDS$20130212$SubscriptionAlreadyExistFault = {};
  declare type RDS$20130212$SubscriptionCategoryNotFoundFault = {};
  declare type RDS$20130212$SubscriptionNotFoundFault = {};
  declare type RDS$20130212$SupportedCharacterSetsList = RDS$20130212$CharacterSet[];
  declare type RDS$20130212$TStamp = Date;
  declare type RDS$20130212$Tag = {
    Key?: string;
    Value?: string;
  };
  declare type RDS$20130212$TagList = RDS$20130212$Tag[];
  declare type RDS$20130212$TagListMessage = {
    TagList?: RDS$20130212$TagList;
  };
  declare type RDS$20130212$VpcSecurityGroupIdList = string[];
  declare type RDS$20130212$VpcSecurityGroupMembership = {
    VpcSecurityGroupId?: string;
    Status?: string;
  };
  declare type RDS$20130212$VpcSecurityGroupMembershipList = RDS$20130212$VpcSecurityGroupMembership[];
  declare type RDS$20130909$AddSourceIdentifierToSubscriptionMessage = {
    SubscriptionName: string;
    SourceIdentifier: string;
  };
  declare type RDS$20130909$AddSourceIdentifierToSubscriptionResult = {
    EventSubscription?: RDS$20130909$EventSubscription;
  };
  declare type RDS$20130909$AddTagsToResourceMessage = {
    ResourceName: string;
    Tags: RDS$20130909$TagList;
  };
  declare type RDS$20130909$ApplyMethod = 'immediate' | 'pending-reboot';
  declare type RDS$20130909$AuthorizationAlreadyExistsFault = {};
  declare type RDS$20130909$AuthorizationNotFoundFault = {};
  declare type RDS$20130909$AuthorizationQuotaExceededFault = {};
  declare type RDS$20130909$AuthorizeDBSecurityGroupIngressMessage = {
    DBSecurityGroupName: string;
    CIDRIP?: string;
    EC2SecurityGroupName?: string;
    EC2SecurityGroupId?: string;
    EC2SecurityGroupOwnerId?: string;
  };
  declare type RDS$20130909$AuthorizeDBSecurityGroupIngressResult = {
    DBSecurityGroup?: RDS$20130909$DBSecurityGroup;
  };
  declare type RDS$20130909$AvailabilityZone = {
    Name?: string;
    ProvisionedIopsCapable?: boolean;
  };
  declare type RDS$20130909$AvailabilityZoneList = RDS$20130909$AvailabilityZone[];
  declare type RDS$20130909$CharacterSet = {
    CharacterSetName?: string;
    CharacterSetDescription?: string;
  };
  declare type RDS$20130909$CopyDBSnapshotMessage = {
    SourceDBSnapshotIdentifier: string;
    TargetDBSnapshotIdentifier: string;
    Tags?: RDS$20130909$TagList;
  };
  declare type RDS$20130909$CopyDBSnapshotResult = {
    DBSnapshot?: RDS$20130909$DBSnapshot;
  };
  declare type RDS$20130909$CreateDBInstanceMessage = {
    DBName?: string;
    DBInstanceIdentifier: string;
    AllocatedStorage: number;
    DBInstanceClass: string;
    Engine: string;
    MasterUsername: string;
    MasterUserPassword: string;
    DBSecurityGroups?: RDS$20130909$DBSecurityGroupNameList;
    VpcSecurityGroupIds?: RDS$20130909$VpcSecurityGroupIdList;
    AvailabilityZone?: string;
    DBSubnetGroupName?: string;
    PreferredMaintenanceWindow?: string;
    DBParameterGroupName?: string;
    BackupRetentionPeriod?: number;
    PreferredBackupWindow?: string;
    Port?: number;
    MultiAZ?: boolean;
    EngineVersion?: string;
    AutoMinorVersionUpgrade?: boolean;
    LicenseModel?: string;
    Iops?: number;
    OptionGroupName?: string;
    CharacterSetName?: string;
    PubliclyAccessible?: boolean;
    Tags?: RDS$20130909$TagList;
  };
  declare type RDS$20130909$CreateDBInstanceReadReplicaMessage = {
    DBInstanceIdentifier: string;
    SourceDBInstanceIdentifier: string;
    DBInstanceClass?: string;
    AvailabilityZone?: string;
    Port?: number;
    AutoMinorVersionUpgrade?: boolean;
    Iops?: number;
    OptionGroupName?: string;
    PubliclyAccessible?: boolean;
    Tags?: RDS$20130909$TagList;
    DBSubnetGroupName?: string;
  };
  declare type RDS$20130909$CreateDBInstanceReadReplicaResult = {
    DBInstance?: RDS$20130909$DBInstance;
  };
  declare type RDS$20130909$CreateDBInstanceResult = {
    DBInstance?: RDS$20130909$DBInstance;
  };
  declare type RDS$20130909$CreateDBParameterGroupMessage = {
    DBParameterGroupName: string;
    DBParameterGroupFamily: string;
    Description: string;
    Tags?: RDS$20130909$TagList;
  };
  declare type RDS$20130909$CreateDBParameterGroupResult = {
    DBParameterGroup?: RDS$20130909$DBParameterGroup;
  };
  declare type RDS$20130909$CreateDBSecurityGroupMessage = {
    DBSecurityGroupName: string;
    DBSecurityGroupDescription: string;
    Tags?: RDS$20130909$TagList;
  };
  declare type RDS$20130909$CreateDBSecurityGroupResult = {
    DBSecurityGroup?: RDS$20130909$DBSecurityGroup;
  };
  declare type RDS$20130909$CreateDBSnapshotMessage = {
    DBSnapshotIdentifier: string;
    DBInstanceIdentifier: string;
    Tags?: RDS$20130909$TagList;
  };
  declare type RDS$20130909$CreateDBSnapshotResult = {
    DBSnapshot?: RDS$20130909$DBSnapshot;
  };
  declare type RDS$20130909$CreateDBSubnetGroupMessage = {
    DBSubnetGroupName: string;
    DBSubnetGroupDescription: string;
    SubnetIds: RDS$20130909$SubnetIdentifierList;
    Tags?: RDS$20130909$TagList;
  };
  declare type RDS$20130909$CreateDBSubnetGroupResult = {
    DBSubnetGroup?: RDS$20130909$DBSubnetGroup;
  };
  declare type RDS$20130909$CreateEventSubscriptionMessage = {
    SubscriptionName: string;
    SnsTopicArn: string;
    SourceType?: string;
    EventCategories?: RDS$20130909$EventCategoriesList;
    SourceIds?: RDS$20130909$SourceIdsList;
    Enabled?: boolean;
    Tags?: RDS$20130909$TagList;
  };
  declare type RDS$20130909$CreateEventSubscriptionResult = {
    EventSubscription?: RDS$20130909$EventSubscription;
  };
  declare type RDS$20130909$CreateOptionGroupMessage = {
    OptionGroupName: string;
    EngineName: string;
    MajorEngineVersion: string;
    OptionGroupDescription: string;
    Tags?: RDS$20130909$TagList;
  };
  declare type RDS$20130909$CreateOptionGroupResult = {
    OptionGroup?: RDS$20130909$OptionGroup;
  };
  declare type RDS$20130909$DBEngineVersion = {
    Engine?: string;
    EngineVersion?: string;
    DBParameterGroupFamily?: string;
    DBEngineDescription?: string;
    DBEngineVersionDescription?: string;
    DefaultCharacterSet?: RDS$20130909$CharacterSet;
    SupportedCharacterSets?: RDS$20130909$SupportedCharacterSetsList;
  };
  declare type RDS$20130909$DBEngineVersionList = RDS$20130909$DBEngineVersion[];
  declare type RDS$20130909$DBEngineVersionMessage = {
    Marker?: string;
    DBEngineVersions?: RDS$20130909$DBEngineVersionList;
  };
  declare type RDS$20130909$DBInstance = {
    DBInstanceIdentifier?: string;
    DBInstanceClass?: string;
    Engine?: string;
    DBInstanceStatus?: string;
    MasterUsername?: string;
    DBName?: string;
    Endpoint?: RDS$20130909$Endpoint;
    AllocatedStorage?: number;
    InstanceCreateTime?: Date;
    PreferredBackupWindow?: string;
    BackupRetentionPeriod?: number;
    DBSecurityGroups?: RDS$20130909$DBSecurityGroupMembershipList;
    VpcSecurityGroups?: RDS$20130909$VpcSecurityGroupMembershipList;
    DBParameterGroups?: RDS$20130909$DBParameterGroupStatusList;
    AvailabilityZone?: string;
    DBSubnetGroup?: RDS$20130909$DBSubnetGroup;
    PreferredMaintenanceWindow?: string;
    PendingModifiedValues?: RDS$20130909$PendingModifiedValues;
    LatestRestorableTime?: Date;
    MultiAZ?: boolean;
    EngineVersion?: string;
    AutoMinorVersionUpgrade?: boolean;
    ReadReplicaSourceDBInstanceIdentifier?: string;
    ReadReplicaDBInstanceIdentifiers?: RDS$20130909$ReadReplicaDBInstanceIdentifierList;
    LicenseModel?: string;
    Iops?: number;
    OptionGroupMemberships?: RDS$20130909$OptionGroupMembershipList;
    CharacterSetName?: string;
    SecondaryAvailabilityZone?: string;
    PubliclyAccessible?: boolean;
    StatusInfos?: RDS$20130909$DBInstanceStatusInfoList;
  };
  declare type RDS$20130909$DBInstanceAlreadyExistsFault = {};
  declare type RDS$20130909$DBInstanceList = RDS$20130909$DBInstance[];
  declare type RDS$20130909$DBInstanceMessage = {
    Marker?: string;
    DBInstances?: RDS$20130909$DBInstanceList;
  };
  declare type RDS$20130909$DBInstanceNotFoundFault = {};
  declare type RDS$20130909$DBInstanceStatusInfo = {
    StatusType?: string;
    Normal?: boolean;
    Status?: string;
    Message?: string;
  };
  declare type RDS$20130909$DBInstanceStatusInfoList = RDS$20130909$DBInstanceStatusInfo[];
  declare type RDS$20130909$DBLogFileNotFoundFault = {};
  declare type RDS$20130909$DBParameterGroup = {
    DBParameterGroupName?: string;
    DBParameterGroupFamily?: string;
    Description?: string;
  };
  declare type RDS$20130909$DBParameterGroupAlreadyExistsFault = {};
  declare type RDS$20130909$DBParameterGroupDetails = {
    Parameters?: RDS$20130909$ParametersList;
    Marker?: string;
  };
  declare type RDS$20130909$DBParameterGroupList = RDS$20130909$DBParameterGroup[];
  declare type RDS$20130909$DBParameterGroupNameMessage = {
    DBParameterGroupName?: string;
  };
  declare type RDS$20130909$DBParameterGroupNotFoundFault = {};
  declare type RDS$20130909$DBParameterGroupQuotaExceededFault = {};
  declare type RDS$20130909$DBParameterGroupStatus = {
    DBParameterGroupName?: string;
    ParameterApplyStatus?: string;
  };
  declare type RDS$20130909$DBParameterGroupStatusList = RDS$20130909$DBParameterGroupStatus[];
  declare type RDS$20130909$DBParameterGroupsMessage = {
    Marker?: string;
    DBParameterGroups?: RDS$20130909$DBParameterGroupList;
  };
  declare type RDS$20130909$DBSecurityGroup = {
    OwnerId?: string;
    DBSecurityGroupName?: string;
    DBSecurityGroupDescription?: string;
    VpcId?: string;
    EC2SecurityGroups?: RDS$20130909$EC2SecurityGroupList;
    IPRanges?: RDS$20130909$IPRangeList;
  };
  declare type RDS$20130909$DBSecurityGroupAlreadyExistsFault = {};
  declare type RDS$20130909$DBSecurityGroupMembership = {
    DBSecurityGroupName?: string;
    Status?: string;
  };
  declare type RDS$20130909$DBSecurityGroupMembershipList = RDS$20130909$DBSecurityGroupMembership[];
  declare type RDS$20130909$DBSecurityGroupMessage = {
    Marker?: string;
    DBSecurityGroups?: RDS$20130909$DBSecurityGroups;
  };
  declare type RDS$20130909$DBSecurityGroupNameList = string[];
  declare type RDS$20130909$DBSecurityGroupNotFoundFault = {};
  declare type RDS$20130909$DBSecurityGroupNotSupportedFault = {};
  declare type RDS$20130909$DBSecurityGroupQuotaExceededFault = {};
  declare type RDS$20130909$DBSecurityGroups = RDS$20130909$DBSecurityGroup[];
  declare type RDS$20130909$DBSnapshot = {
    DBSnapshotIdentifier?: string;
    DBInstanceIdentifier?: string;
    SnapshotCreateTime?: Date;
    Engine?: string;
    AllocatedStorage?: number;
    Status?: string;
    Port?: number;
    AvailabilityZone?: string;
    VpcId?: string;
    InstanceCreateTime?: Date;
    MasterUsername?: string;
    EngineVersion?: string;
    LicenseModel?: string;
    SnapshotType?: string;
    Iops?: number;
    OptionGroupName?: string;
    PercentProgress?: number;
    SourceRegion?: string;
  };
  declare type RDS$20130909$DBSnapshotAlreadyExistsFault = {};
  declare type RDS$20130909$DBSnapshotList = RDS$20130909$DBSnapshot[];
  declare type RDS$20130909$DBSnapshotMessage = {
    Marker?: string;
    DBSnapshots?: RDS$20130909$DBSnapshotList;
  };
  declare type RDS$20130909$DBSnapshotNotFoundFault = {};
  declare type RDS$20130909$DBSubnetGroup = {
    DBSubnetGroupName?: string;
    DBSubnetGroupDescription?: string;
    VpcId?: string;
    SubnetGroupStatus?: string;
    Subnets?: RDS$20130909$SubnetList;
  };
  declare type RDS$20130909$DBSubnetGroupAlreadyExistsFault = {};
  declare type RDS$20130909$DBSubnetGroupDoesNotCoverEnoughAZs = {};
  declare type RDS$20130909$DBSubnetGroupMessage = {
    Marker?: string;
    DBSubnetGroups?: RDS$20130909$DBSubnetGroups;
  };
  declare type RDS$20130909$DBSubnetGroupNotAllowedFault = {};
  declare type RDS$20130909$DBSubnetGroupNotFoundFault = {};
  declare type RDS$20130909$DBSubnetGroupQuotaExceededFault = {};
  declare type RDS$20130909$DBSubnetGroups = RDS$20130909$DBSubnetGroup[];
  declare type RDS$20130909$DBSubnetQuotaExceededFault = {};
  declare type RDS$20130909$DBUpgradeDependencyFailureFault = {};
  declare type RDS$20130909$DeleteDBInstanceMessage = {
    DBInstanceIdentifier: string;
    SkipFinalSnapshot?: boolean;
    FinalDBSnapshotIdentifier?: string;
  };
  declare type RDS$20130909$DeleteDBInstanceResult = {
    DBInstance?: RDS$20130909$DBInstance;
  };
  declare type RDS$20130909$DeleteDBParameterGroupMessage = {
    DBParameterGroupName: string;
  };
  declare type RDS$20130909$DeleteDBSecurityGroupMessage = {
    DBSecurityGroupName: string;
  };
  declare type RDS$20130909$DeleteDBSnapshotMessage = {
    DBSnapshotIdentifier: string;
  };
  declare type RDS$20130909$DeleteDBSnapshotResult = {
    DBSnapshot?: RDS$20130909$DBSnapshot;
  };
  declare type RDS$20130909$DeleteDBSubnetGroupMessage = {
    DBSubnetGroupName: string;
  };
  declare type RDS$20130909$DeleteEventSubscriptionMessage = {
    SubscriptionName: string;
  };
  declare type RDS$20130909$DeleteEventSubscriptionResult = {
    EventSubscription?: RDS$20130909$EventSubscription;
  };
  declare type RDS$20130909$DeleteOptionGroupMessage = {
    OptionGroupName: string;
  };
  declare type RDS$20130909$DescribeDBEngineVersionsMessage = {
    Engine?: string;
    EngineVersion?: string;
    DBParameterGroupFamily?: string;
    Filters?: RDS$20130909$FilterList;
    MaxRecords?: number;
    Marker?: string;
    DefaultOnly?: boolean;
    ListSupportedCharacterSets?: boolean;
  };
  declare type RDS$20130909$DescribeDBInstancesMessage = {
    DBInstanceIdentifier?: string;
    Filters?: RDS$20130909$FilterList;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20130909$DescribeDBLogFilesDetails = {
    LogFileName?: string;
    LastWritten?: number;
    Size?: number;
  };
  declare type RDS$20130909$DescribeDBLogFilesList = RDS$20130909$DescribeDBLogFilesDetails[];
  declare type RDS$20130909$DescribeDBLogFilesMessage = {
    DBInstanceIdentifier: string;
    FilenameContains?: string;
    FileLastWritten?: number;
    FileSize?: number;
    Filters?: RDS$20130909$FilterList;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20130909$DescribeDBLogFilesResponse = {
    DescribeDBLogFiles?: RDS$20130909$DescribeDBLogFilesList;
    Marker?: string;
  };
  declare type RDS$20130909$DescribeDBParameterGroupsMessage = {
    DBParameterGroupName?: string;
    Filters?: RDS$20130909$FilterList;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20130909$DescribeDBParametersMessage = {
    DBParameterGroupName: string;
    Source?: string;
    Filters?: RDS$20130909$FilterList;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20130909$DescribeDBSecurityGroupsMessage = {
    DBSecurityGroupName?: string;
    Filters?: RDS$20130909$FilterList;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20130909$DescribeDBSnapshotsMessage = {
    DBInstanceIdentifier?: string;
    DBSnapshotIdentifier?: string;
    SnapshotType?: string;
    Filters?: RDS$20130909$FilterList;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20130909$DescribeDBSubnetGroupsMessage = {
    DBSubnetGroupName?: string;
    Filters?: RDS$20130909$FilterList;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20130909$DescribeEngineDefaultParametersMessage = {
    DBParameterGroupFamily: string;
    Filters?: RDS$20130909$FilterList;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20130909$DescribeEngineDefaultParametersResult = {
    EngineDefaults?: RDS$20130909$EngineDefaults;
  };
  declare type RDS$20130909$DescribeEventCategoriesMessage = {
    SourceType?: string;
    Filters?: RDS$20130909$FilterList;
  };
  declare type RDS$20130909$DescribeEventSubscriptionsMessage = {
    SubscriptionName?: string;
    Filters?: RDS$20130909$FilterList;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20130909$DescribeEventsMessage = {
    SourceIdentifier?: string;
    SourceType?: 'db-instance' | 'db-parameter-group' | 'db-security-group' | 'db-snapshot';
    StartTime?: Date;
    EndTime?: Date;
    Duration?: number;
    EventCategories?: RDS$20130909$EventCategoriesList;
    Filters?: RDS$20130909$FilterList;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20130909$DescribeOptionGroupOptionsMessage = {
    EngineName: string;
    MajorEngineVersion?: string;
    Filters?: RDS$20130909$FilterList;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20130909$DescribeOptionGroupsMessage = {
    OptionGroupName?: string;
    Filters?: RDS$20130909$FilterList;
    Marker?: string;
    MaxRecords?: number;
    EngineName?: string;
    MajorEngineVersion?: string;
  };
  declare type RDS$20130909$DescribeOrderableDBInstanceOptionsMessage = {
    Engine: string;
    EngineVersion?: string;
    DBInstanceClass?: string;
    LicenseModel?: string;
    Vpc?: boolean;
    Filters?: RDS$20130909$FilterList;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20130909$DescribeReservedDBInstancesMessage = {
    ReservedDBInstanceId?: string;
    ReservedDBInstancesOfferingId?: string;
    DBInstanceClass?: string;
    Duration?: string;
    ProductDescription?: string;
    OfferingType?: string;
    MultiAZ?: boolean;
    Filters?: RDS$20130909$FilterList;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20130909$DescribeReservedDBInstancesOfferingsMessage = {
    ReservedDBInstancesOfferingId?: string;
    DBInstanceClass?: string;
    Duration?: string;
    ProductDescription?: string;
    OfferingType?: string;
    MultiAZ?: boolean;
    Filters?: RDS$20130909$FilterList;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20130909$DownloadDBLogFilePortionDetails = {
    LogFileData?: string;
    Marker?: string;
    AdditionalDataPending?: boolean;
  };
  declare type RDS$20130909$DownloadDBLogFilePortionMessage = {
    DBInstanceIdentifier: string;
    LogFileName: string;
    Marker?: string;
    NumberOfLines?: number;
  };
  declare type RDS$20130909$EC2SecurityGroup = {
    Status?: string;
    EC2SecurityGroupName?: string;
    EC2SecurityGroupId?: string;
    EC2SecurityGroupOwnerId?: string;
  };
  declare type RDS$20130909$EC2SecurityGroupList = RDS$20130909$EC2SecurityGroup[];
  declare type RDS$20130909$Endpoint = {
    Address?: string;
    Port?: number;
  };
  declare type RDS$20130909$EngineDefaults = {
    DBParameterGroupFamily?: string;
    Marker?: string;
    Parameters?: RDS$20130909$ParametersList;
  };
  declare type RDS$20130909$Event = {
    SourceIdentifier?: string;
    SourceType?: 'db-instance' | 'db-parameter-group' | 'db-security-group' | 'db-snapshot';
    Message?: string;
    EventCategories?: RDS$20130909$EventCategoriesList;
    Date?: Date;
  };
  declare type RDS$20130909$EventCategoriesList = string[];
  declare type RDS$20130909$EventCategoriesMap = {
    SourceType?: string;
    EventCategories?: RDS$20130909$EventCategoriesList;
  };
  declare type RDS$20130909$EventCategoriesMapList = RDS$20130909$EventCategoriesMap[];
  declare type RDS$20130909$EventCategoriesMessage = {
    EventCategoriesMapList?: RDS$20130909$EventCategoriesMapList;
  };
  declare type RDS$20130909$EventList = RDS$20130909$Event[];
  declare type RDS$20130909$EventSubscription = {
    CustomerAwsId?: string;
    CustSubscriptionId?: string;
    SnsTopicArn?: string;
    Status?: string;
    SubscriptionCreationTime?: string;
    SourceType?: string;
    SourceIdsList?: RDS$20130909$SourceIdsList;
    EventCategoriesList?: RDS$20130909$EventCategoriesList;
    Enabled?: boolean;
  };
  declare type RDS$20130909$EventSubscriptionQuotaExceededFault = {};
  declare type RDS$20130909$EventSubscriptionsList = RDS$20130909$EventSubscription[];
  declare type RDS$20130909$EventSubscriptionsMessage = {
    Marker?: string;
    EventSubscriptionsList?: RDS$20130909$EventSubscriptionsList;
  };
  declare type RDS$20130909$EventsMessage = {
    Marker?: string;
    Events?: RDS$20130909$EventList;
  };
  declare type RDS$20130909$Filter = {
    Name: string;
    Values: RDS$20130909$FilterValueList;
  };
  declare type RDS$20130909$FilterList = RDS$20130909$Filter[];
  declare type RDS$20130909$FilterValueList = string[];
  declare type RDS$20130909$IPRange = {
    Status?: string;
    CIDRIP?: string;
  };
  declare type RDS$20130909$IPRangeList = RDS$20130909$IPRange[];
  declare type RDS$20130909$InstanceQuotaExceededFault = {};
  declare type RDS$20130909$InsufficientDBInstanceCapacityFault = {};
  declare type RDS$20130909$InvalidDBInstanceStateFault = {};
  declare type RDS$20130909$InvalidDBParameterGroupStateFault = {};
  declare type RDS$20130909$InvalidDBSecurityGroupStateFault = {};
  declare type RDS$20130909$InvalidDBSnapshotStateFault = {};
  declare type RDS$20130909$InvalidDBSubnetGroupFault = {};
  declare type RDS$20130909$InvalidDBSubnetGroupStateFault = {};
  declare type RDS$20130909$InvalidDBSubnetStateFault = {};
  declare type RDS$20130909$InvalidEventSubscriptionStateFault = {};
  declare type RDS$20130909$InvalidOptionGroupStateFault = {};
  declare type RDS$20130909$InvalidRestoreFault = {};
  declare type RDS$20130909$InvalidSubnet = {};
  declare type RDS$20130909$InvalidVPCNetworkStateFault = {};
  declare type RDS$20130909$KeyList = string[];
  declare type RDS$20130909$ListTagsForResourceMessage = {
    ResourceName: string;
    Filters?: RDS$20130909$FilterList;
  };
  declare type RDS$20130909$ModifyDBInstanceMessage = {
    DBInstanceIdentifier: string;
    AllocatedStorage?: number;
    DBInstanceClass?: string;
    DBSecurityGroups?: RDS$20130909$DBSecurityGroupNameList;
    VpcSecurityGroupIds?: RDS$20130909$VpcSecurityGroupIdList;
    ApplyImmediately?: boolean;
    MasterUserPassword?: string;
    DBParameterGroupName?: string;
    BackupRetentionPeriod?: number;
    PreferredBackupWindow?: string;
    PreferredMaintenanceWindow?: string;
    MultiAZ?: boolean;
    EngineVersion?: string;
    AllowMajorVersionUpgrade?: boolean;
    AutoMinorVersionUpgrade?: boolean;
    Iops?: number;
    OptionGroupName?: string;
    NewDBInstanceIdentifier?: string;
  };
  declare type RDS$20130909$ModifyDBInstanceResult = {
    DBInstance?: RDS$20130909$DBInstance;
  };
  declare type RDS$20130909$ModifyDBParameterGroupMessage = {
    DBParameterGroupName: string;
    Parameters: RDS$20130909$ParametersList;
  };
  declare type RDS$20130909$ModifyDBSubnetGroupMessage = {
    DBSubnetGroupName: string;
    DBSubnetGroupDescription?: string;
    SubnetIds: RDS$20130909$SubnetIdentifierList;
  };
  declare type RDS$20130909$ModifyDBSubnetGroupResult = {
    DBSubnetGroup?: RDS$20130909$DBSubnetGroup;
  };
  declare type RDS$20130909$ModifyEventSubscriptionMessage = {
    SubscriptionName: string;
    SnsTopicArn?: string;
    SourceType?: string;
    EventCategories?: RDS$20130909$EventCategoriesList;
    Enabled?: boolean;
  };
  declare type RDS$20130909$ModifyEventSubscriptionResult = {
    EventSubscription?: RDS$20130909$EventSubscription;
  };
  declare type RDS$20130909$ModifyOptionGroupMessage = {
    OptionGroupName: string;
    OptionsToInclude?: RDS$20130909$OptionConfigurationList;
    OptionsToRemove?: RDS$20130909$OptionNamesList;
    ApplyImmediately?: boolean;
  };
  declare type RDS$20130909$ModifyOptionGroupResult = {
    OptionGroup?: RDS$20130909$OptionGroup;
  };
  declare type RDS$20130909$Option = {
    OptionName?: string;
    OptionDescription?: string;
    Persistent?: boolean;
    Permanent?: boolean;
    Port?: number;
    OptionSettings?: RDS$20130909$OptionSettingConfigurationList;
    DBSecurityGroupMemberships?: RDS$20130909$DBSecurityGroupMembershipList;
    VpcSecurityGroupMemberships?: RDS$20130909$VpcSecurityGroupMembershipList;
  };
  declare type RDS$20130909$OptionConfiguration = {
    OptionName: string;
    Port?: number;
    DBSecurityGroupMemberships?: RDS$20130909$DBSecurityGroupNameList;
    VpcSecurityGroupMemberships?: RDS$20130909$VpcSecurityGroupIdList;
    OptionSettings?: RDS$20130909$OptionSettingsList;
  };
  declare type RDS$20130909$OptionConfigurationList = RDS$20130909$OptionConfiguration[];
  declare type RDS$20130909$OptionGroup = {
    OptionGroupName?: string;
    OptionGroupDescription?: string;
    EngineName?: string;
    MajorEngineVersion?: string;
    Options?: RDS$20130909$OptionsList;
    AllowsVpcAndNonVpcInstanceMemberships?: boolean;
    VpcId?: string;
  };
  declare type RDS$20130909$OptionGroupAlreadyExistsFault = {};
  declare type RDS$20130909$OptionGroupMembership = {
    OptionGroupName?: string;
    Status?: string;
  };
  declare type RDS$20130909$OptionGroupMembershipList = RDS$20130909$OptionGroupMembership[];
  declare type RDS$20130909$OptionGroupNotFoundFault = {};
  declare type RDS$20130909$OptionGroupOption = {
    Name?: string;
    Description?: string;
    EngineName?: string;
    MajorEngineVersion?: string;
    MinimumRequiredMinorEngineVersion?: string;
    PortRequired?: boolean;
    DefaultPort?: number;
    OptionsDependedOn?: RDS$20130909$OptionsDependedOn;
    Persistent?: boolean;
    Permanent?: boolean;
    OptionGroupOptionSettings?: RDS$20130909$OptionGroupOptionSettingsList;
  };
  declare type RDS$20130909$OptionGroupOptionSetting = {
    SettingName?: string;
    SettingDescription?: string;
    DefaultValue?: string;
    ApplyType?: string;
    AllowedValues?: string;
    IsModifiable?: boolean;
  };
  declare type RDS$20130909$OptionGroupOptionSettingsList = RDS$20130909$OptionGroupOptionSetting[];
  declare type RDS$20130909$OptionGroupOptionsList = RDS$20130909$OptionGroupOption[];
  declare type RDS$20130909$OptionGroupOptionsMessage = {
    OptionGroupOptions?: RDS$20130909$OptionGroupOptionsList;
    Marker?: string;
  };
  declare type RDS$20130909$OptionGroupQuotaExceededFault = {};
  declare type RDS$20130909$OptionGroups = {
    OptionGroupsList?: RDS$20130909$OptionGroupsList;
    Marker?: string;
  };
  declare type RDS$20130909$OptionGroupsList = RDS$20130909$OptionGroup[];
  declare type RDS$20130909$OptionNamesList = string[];
  declare type RDS$20130909$OptionSetting = {
    Name?: string;
    Value?: string;
    DefaultValue?: string;
    Description?: string;
    ApplyType?: string;
    DataType?: string;
    AllowedValues?: string;
    IsModifiable?: boolean;
    IsCollection?: boolean;
  };
  declare type RDS$20130909$OptionSettingConfigurationList = RDS$20130909$OptionSetting[];
  declare type RDS$20130909$OptionSettingsList = RDS$20130909$OptionSetting[];
  declare type RDS$20130909$OptionsDependedOn = string[];
  declare type RDS$20130909$OptionsList = RDS$20130909$Option[];
  declare type RDS$20130909$OrderableDBInstanceOption = {
    Engine?: string;
    EngineVersion?: string;
    DBInstanceClass?: string;
    LicenseModel?: string;
    AvailabilityZones?: RDS$20130909$AvailabilityZoneList;
    MultiAZCapable?: boolean;
    ReadReplicaCapable?: boolean;
    Vpc?: boolean;
  };
  declare type RDS$20130909$OrderableDBInstanceOptionsList = RDS$20130909$OrderableDBInstanceOption[];
  declare type RDS$20130909$OrderableDBInstanceOptionsMessage = {
    OrderableDBInstanceOptions?: RDS$20130909$OrderableDBInstanceOptionsList;
    Marker?: string;
  };
  declare type RDS$20130909$Parameter = {
    ParameterName?: string;
    ParameterValue?: string;
    Description?: string;
    Source?: string;
    ApplyType?: string;
    DataType?: string;
    AllowedValues?: string;
    IsModifiable?: boolean;
    MinimumEngineVersion?: string;
    ApplyMethod?: 'immediate' | 'pending-reboot';
  };
  declare type RDS$20130909$ParametersList = RDS$20130909$Parameter[];
  declare type RDS$20130909$PendingModifiedValues = {
    DBInstanceClass?: string;
    AllocatedStorage?: number;
    MasterUserPassword?: string;
    Port?: number;
    BackupRetentionPeriod?: number;
    MultiAZ?: boolean;
    EngineVersion?: string;
    Iops?: number;
    DBInstanceIdentifier?: string;
  };
  declare type RDS$20130909$PointInTimeRestoreNotEnabledFault = {};
  declare type RDS$20130909$PromoteReadReplicaMessage = {
    DBInstanceIdentifier: string;
    BackupRetentionPeriod?: number;
    PreferredBackupWindow?: string;
  };
  declare type RDS$20130909$PromoteReadReplicaResult = {
    DBInstance?: RDS$20130909$DBInstance;
  };
  declare type RDS$20130909$ProvisionedIopsNotAvailableInAZFault = {};
  declare type RDS$20130909$PurchaseReservedDBInstancesOfferingMessage = {
    ReservedDBInstancesOfferingId: string;
    ReservedDBInstanceId?: string;
    DBInstanceCount?: number;
    Tags?: RDS$20130909$TagList;
  };
  declare type RDS$20130909$PurchaseReservedDBInstancesOfferingResult = {
    ReservedDBInstance?: RDS$20130909$ReservedDBInstance;
  };
  declare type RDS$20130909$ReadReplicaDBInstanceIdentifierList = string[];
  declare type RDS$20130909$RebootDBInstanceMessage = {
    DBInstanceIdentifier: string;
    ForceFailover?: boolean;
  };
  declare type RDS$20130909$RebootDBInstanceResult = {
    DBInstance?: RDS$20130909$DBInstance;
  };
  declare type RDS$20130909$RecurringCharge = {
    RecurringChargeAmount?: number;
    RecurringChargeFrequency?: string;
  };
  declare type RDS$20130909$RecurringChargeList = RDS$20130909$RecurringCharge[];
  declare type RDS$20130909$RemoveSourceIdentifierFromSubscriptionMessage = {
    SubscriptionName: string;
    SourceIdentifier: string;
  };
  declare type RDS$20130909$RemoveSourceIdentifierFromSubscriptionResult = {
    EventSubscription?: RDS$20130909$EventSubscription;
  };
  declare type RDS$20130909$RemoveTagsFromResourceMessage = {
    ResourceName: string;
    TagKeys: RDS$20130909$KeyList;
  };
  declare type RDS$20130909$ReservedDBInstance = {
    ReservedDBInstanceId?: string;
    ReservedDBInstancesOfferingId?: string;
    DBInstanceClass?: string;
    StartTime?: Date;
    Duration?: number;
    FixedPrice?: number;
    UsagePrice?: number;
    CurrencyCode?: string;
    DBInstanceCount?: number;
    ProductDescription?: string;
    OfferingType?: string;
    MultiAZ?: boolean;
    State?: string;
    RecurringCharges?: RDS$20130909$RecurringChargeList;
  };
  declare type RDS$20130909$ReservedDBInstanceAlreadyExistsFault = {};
  declare type RDS$20130909$ReservedDBInstanceList = RDS$20130909$ReservedDBInstance[];
  declare type RDS$20130909$ReservedDBInstanceMessage = {
    Marker?: string;
    ReservedDBInstances?: RDS$20130909$ReservedDBInstanceList;
  };
  declare type RDS$20130909$ReservedDBInstanceNotFoundFault = {};
  declare type RDS$20130909$ReservedDBInstanceQuotaExceededFault = {};
  declare type RDS$20130909$ReservedDBInstancesOffering = {
    ReservedDBInstancesOfferingId?: string;
    DBInstanceClass?: string;
    Duration?: number;
    FixedPrice?: number;
    UsagePrice?: number;
    CurrencyCode?: string;
    ProductDescription?: string;
    OfferingType?: string;
    MultiAZ?: boolean;
    RecurringCharges?: RDS$20130909$RecurringChargeList;
  };
  declare type RDS$20130909$ReservedDBInstancesOfferingList = RDS$20130909$ReservedDBInstancesOffering[];
  declare type RDS$20130909$ReservedDBInstancesOfferingMessage = {
    Marker?: string;
    ReservedDBInstancesOfferings?: RDS$20130909$ReservedDBInstancesOfferingList;
  };
  declare type RDS$20130909$ReservedDBInstancesOfferingNotFoundFault = {};
  declare type RDS$20130909$ResetDBParameterGroupMessage = {
    DBParameterGroupName: string;
    ResetAllParameters?: boolean;
    Parameters?: RDS$20130909$ParametersList;
  };
  declare type RDS$20130909$RestoreDBInstanceFromDBSnapshotMessage = {
    DBInstanceIdentifier: string;
    DBSnapshotIdentifier: string;
    DBInstanceClass?: string;
    Port?: number;
    AvailabilityZone?: string;
    DBSubnetGroupName?: string;
    MultiAZ?: boolean;
    PubliclyAccessible?: boolean;
    AutoMinorVersionUpgrade?: boolean;
    LicenseModel?: string;
    DBName?: string;
    Engine?: string;
    Iops?: number;
    OptionGroupName?: string;
    Tags?: RDS$20130909$TagList;
  };
  declare type RDS$20130909$RestoreDBInstanceFromDBSnapshotResult = {
    DBInstance?: RDS$20130909$DBInstance;
  };
  declare type RDS$20130909$RestoreDBInstanceToPointInTimeMessage = {
    SourceDBInstanceIdentifier: string;
    TargetDBInstanceIdentifier: string;
    RestoreTime?: Date;
    UseLatestRestorableTime?: boolean;
    DBInstanceClass?: string;
    Port?: number;
    AvailabilityZone?: string;
    DBSubnetGroupName?: string;
    MultiAZ?: boolean;
    PubliclyAccessible?: boolean;
    AutoMinorVersionUpgrade?: boolean;
    LicenseModel?: string;
    DBName?: string;
    Engine?: string;
    Iops?: number;
    OptionGroupName?: string;
    Tags?: RDS$20130909$TagList;
  };
  declare type RDS$20130909$RestoreDBInstanceToPointInTimeResult = {
    DBInstance?: RDS$20130909$DBInstance;
  };
  declare type RDS$20130909$RevokeDBSecurityGroupIngressMessage = {
    DBSecurityGroupName: string;
    CIDRIP?: string;
    EC2SecurityGroupName?: string;
    EC2SecurityGroupId?: string;
    EC2SecurityGroupOwnerId?: string;
  };
  declare type RDS$20130909$RevokeDBSecurityGroupIngressResult = {
    DBSecurityGroup?: RDS$20130909$DBSecurityGroup;
  };
  declare type RDS$20130909$SNSInvalidTopicFault = {};
  declare type RDS$20130909$SNSNoAuthorizationFault = {};
  declare type RDS$20130909$SNSTopicArnNotFoundFault = {};
  declare type RDS$20130909$SnapshotQuotaExceededFault = {};
  declare type RDS$20130909$SourceIdsList = string[];
  declare type RDS$20130909$SourceNotFoundFault = {};
  declare type RDS$20130909$SourceType = 'db-instance' | 'db-parameter-group' | 'db-security-group' | 'db-snapshot';
  declare type RDS$20130909$StorageQuotaExceededFault = {};
  declare type RDS$20130909$Subnet = {
    SubnetIdentifier?: string;
    SubnetAvailabilityZone?: RDS$20130909$AvailabilityZone;
    SubnetStatus?: string;
  };
  declare type RDS$20130909$SubnetAlreadyInUse = {};
  declare type RDS$20130909$SubnetIdentifierList = string[];
  declare type RDS$20130909$SubnetList = RDS$20130909$Subnet[];
  declare type RDS$20130909$SubscriptionAlreadyExistFault = {};
  declare type RDS$20130909$SubscriptionCategoryNotFoundFault = {};
  declare type RDS$20130909$SubscriptionNotFoundFault = {};
  declare type RDS$20130909$SupportedCharacterSetsList = RDS$20130909$CharacterSet[];
  declare type RDS$20130909$TStamp = Date;
  declare type RDS$20130909$Tag = {
    Key?: string;
    Value?: string;
  };
  declare type RDS$20130909$TagList = RDS$20130909$Tag[];
  declare type RDS$20130909$TagListMessage = {
    TagList?: RDS$20130909$TagList;
  };
  declare type RDS$20130909$VpcSecurityGroupIdList = string[];
  declare type RDS$20130909$VpcSecurityGroupMembership = {
    VpcSecurityGroupId?: string;
    Status?: string;
  };
  declare type RDS$20130909$VpcSecurityGroupMembershipList = RDS$20130909$VpcSecurityGroupMembership[];
  declare type RDS$20141031$AccountAttributesMessage = {
    AccountQuotas?: RDS$20141031$AccountQuotaList;
  };
  declare type RDS$20141031$AccountQuota = {
    AccountQuotaName?: string;
    Used?: number;
    Max?: number;
  };
  declare type RDS$20141031$AccountQuotaList = RDS$20141031$AccountQuota[];
  declare type RDS$20141031$AddSourceIdentifierToSubscriptionMessage = {
    SubscriptionName: string;
    SourceIdentifier: string;
  };
  declare type RDS$20141031$AddSourceIdentifierToSubscriptionResult = {
    EventSubscription?: RDS$20141031$EventSubscription;
  };
  declare type RDS$20141031$AddTagsToResourceMessage = {
    ResourceName: string;
    Tags: RDS$20141031$TagList;
  };
  declare type RDS$20141031$ApplyMethod = 'immediate' | 'pending-reboot';
  declare type RDS$20141031$ApplyPendingMaintenanceActionMessage = {
    ResourceIdentifier: string;
    ApplyAction: string;
    OptInType: string;
  };
  declare type RDS$20141031$ApplyPendingMaintenanceActionResult = {
    ResourcePendingMaintenanceActions?: RDS$20141031$ResourcePendingMaintenanceActions;
  };
  declare type RDS$20141031$AttributeValueList = string[];
  declare type RDS$20141031$AuthorizationAlreadyExistsFault = {};
  declare type RDS$20141031$AuthorizationNotFoundFault = {};
  declare type RDS$20141031$AuthorizationQuotaExceededFault = {};
  declare type RDS$20141031$AuthorizeDBSecurityGroupIngressMessage = {
    DBSecurityGroupName: string;
    CIDRIP?: string;
    EC2SecurityGroupName?: string;
    EC2SecurityGroupId?: string;
    EC2SecurityGroupOwnerId?: string;
  };
  declare type RDS$20141031$AuthorizeDBSecurityGroupIngressResult = {
    DBSecurityGroup?: RDS$20141031$DBSecurityGroup;
  };
  declare type RDS$20141031$AvailabilityZone = {
    Name?: string;
  };
  declare type RDS$20141031$AvailabilityZoneList = RDS$20141031$AvailabilityZone[];
  declare type RDS$20141031$AvailabilityZones = string[];
  declare type RDS$20141031$Certificate = {
    CertificateIdentifier?: string;
    CertificateType?: string;
    Thumbprint?: string;
    ValidFrom?: Date;
    ValidTill?: Date;
  };
  declare type RDS$20141031$CertificateList = RDS$20141031$Certificate[];
  declare type RDS$20141031$CertificateMessage = {
    Certificates?: RDS$20141031$CertificateList;
    Marker?: string;
  };
  declare type RDS$20141031$CertificateNotFoundFault = {};
  declare type RDS$20141031$CharacterSet = {
    CharacterSetName?: string;
    CharacterSetDescription?: string;
  };
  declare type RDS$20141031$CopyDBClusterParameterGroupMessage = {
    SourceDBClusterParameterGroupIdentifier: string;
    TargetDBClusterParameterGroupIdentifier: string;
    TargetDBClusterParameterGroupDescription: string;
    Tags?: RDS$20141031$TagList;
  };
  declare type RDS$20141031$CopyDBClusterParameterGroupResult = {
    DBClusterParameterGroup?: RDS$20141031$DBClusterParameterGroup;
  };
  declare type RDS$20141031$CopyDBClusterSnapshotMessage = {
    SourceDBClusterSnapshotIdentifier: string;
    TargetDBClusterSnapshotIdentifier: string;
    Tags?: RDS$20141031$TagList;
  };
  declare type RDS$20141031$CopyDBClusterSnapshotResult = {
    DBClusterSnapshot?: RDS$20141031$DBClusterSnapshot;
  };
  declare type RDS$20141031$CopyDBParameterGroupMessage = {
    SourceDBParameterGroupIdentifier: string;
    TargetDBParameterGroupIdentifier: string;
    TargetDBParameterGroupDescription: string;
    Tags?: RDS$20141031$TagList;
  };
  declare type RDS$20141031$CopyDBParameterGroupResult = {
    DBParameterGroup?: RDS$20141031$DBParameterGroup;
  };
  declare type RDS$20141031$CopyDBSnapshotMessage = {
    SourceDBSnapshotIdentifier: string;
    TargetDBSnapshotIdentifier: string;
    KmsKeyId?: string;
    Tags?: RDS$20141031$TagList;
    CopyTags?: boolean;
  };
  declare type RDS$20141031$CopyDBSnapshotResult = {
    DBSnapshot?: RDS$20141031$DBSnapshot;
  };
  declare type RDS$20141031$CopyOptionGroupMessage = {
    SourceOptionGroupIdentifier: string;
    TargetOptionGroupIdentifier: string;
    TargetOptionGroupDescription: string;
    Tags?: RDS$20141031$TagList;
  };
  declare type RDS$20141031$CopyOptionGroupResult = {
    OptionGroup?: RDS$20141031$OptionGroup;
  };
  declare type RDS$20141031$CreateDBClusterMessage = {
    AvailabilityZones?: RDS$20141031$AvailabilityZones;
    BackupRetentionPeriod?: number;
    CharacterSetName?: string;
    DatabaseName?: string;
    DBClusterIdentifier: string;
    DBClusterParameterGroupName?: string;
    VpcSecurityGroupIds?: RDS$20141031$VpcSecurityGroupIdList;
    DBSubnetGroupName?: string;
    Engine: string;
    EngineVersion?: string;
    Port?: number;
    MasterUsername?: string;
    MasterUserPassword?: string;
    OptionGroupName?: string;
    PreferredBackupWindow?: string;
    PreferredMaintenanceWindow?: string;
    ReplicationSourceIdentifier?: string;
    Tags?: RDS$20141031$TagList;
    StorageEncrypted?: boolean;
    KmsKeyId?: string;
  };
  declare type RDS$20141031$CreateDBClusterParameterGroupMessage = {
    DBClusterParameterGroupName: string;
    DBParameterGroupFamily: string;
    Description: string;
    Tags?: RDS$20141031$TagList;
  };
  declare type RDS$20141031$CreateDBClusterParameterGroupResult = {
    DBClusterParameterGroup?: RDS$20141031$DBClusterParameterGroup;
  };
  declare type RDS$20141031$CreateDBClusterResult = {
    DBCluster?: RDS$20141031$DBCluster;
  };
  declare type RDS$20141031$CreateDBClusterSnapshotMessage = {
    DBClusterSnapshotIdentifier: string;
    DBClusterIdentifier: string;
    Tags?: RDS$20141031$TagList;
  };
  declare type RDS$20141031$CreateDBClusterSnapshotResult = {
    DBClusterSnapshot?: RDS$20141031$DBClusterSnapshot;
  };
  declare type RDS$20141031$CreateDBInstanceMessage = {
    DBName?: string;
    DBInstanceIdentifier: string;
    AllocatedStorage?: number;
    DBInstanceClass: string;
    Engine: string;
    MasterUsername?: string;
    MasterUserPassword?: string;
    DBSecurityGroups?: RDS$20141031$DBSecurityGroupNameList;
    VpcSecurityGroupIds?: RDS$20141031$VpcSecurityGroupIdList;
    AvailabilityZone?: string;
    DBSubnetGroupName?: string;
    PreferredMaintenanceWindow?: string;
    DBParameterGroupName?: string;
    BackupRetentionPeriod?: number;
    PreferredBackupWindow?: string;
    Port?: number;
    MultiAZ?: boolean;
    EngineVersion?: string;
    AutoMinorVersionUpgrade?: boolean;
    LicenseModel?: string;
    Iops?: number;
    OptionGroupName?: string;
    CharacterSetName?: string;
    PubliclyAccessible?: boolean;
    Tags?: RDS$20141031$TagList;
    DBClusterIdentifier?: string;
    StorageType?: string;
    TdeCredentialArn?: string;
    TdeCredentialPassword?: string;
    StorageEncrypted?: boolean;
    KmsKeyId?: string;
    Domain?: string;
    CopyTagsToSnapshot?: boolean;
    MonitoringInterval?: number;
    MonitoringRoleArn?: string;
    DomainIAMRoleName?: string;
    PromotionTier?: number;
  };
  declare type RDS$20141031$CreateDBInstanceReadReplicaMessage = {
    DBInstanceIdentifier: string;
    SourceDBInstanceIdentifier: string;
    DBInstanceClass?: string;
    AvailabilityZone?: string;
    Port?: number;
    AutoMinorVersionUpgrade?: boolean;
    Iops?: number;
    OptionGroupName?: string;
    PubliclyAccessible?: boolean;
    Tags?: RDS$20141031$TagList;
    DBSubnetGroupName?: string;
    StorageType?: string;
    CopyTagsToSnapshot?: boolean;
    MonitoringInterval?: number;
    MonitoringRoleArn?: string;
  };
  declare type RDS$20141031$CreateDBInstanceReadReplicaResult = {
    DBInstance?: RDS$20141031$DBInstance;
  };
  declare type RDS$20141031$CreateDBInstanceResult = {
    DBInstance?: RDS$20141031$DBInstance;
  };
  declare type RDS$20141031$CreateDBParameterGroupMessage = {
    DBParameterGroupName: string;
    DBParameterGroupFamily: string;
    Description: string;
    Tags?: RDS$20141031$TagList;
  };
  declare type RDS$20141031$CreateDBParameterGroupResult = {
    DBParameterGroup?: RDS$20141031$DBParameterGroup;
  };
  declare type RDS$20141031$CreateDBSecurityGroupMessage = {
    DBSecurityGroupName: string;
    DBSecurityGroupDescription: string;
    Tags?: RDS$20141031$TagList;
  };
  declare type RDS$20141031$CreateDBSecurityGroupResult = {
    DBSecurityGroup?: RDS$20141031$DBSecurityGroup;
  };
  declare type RDS$20141031$CreateDBSnapshotMessage = {
    DBSnapshotIdentifier: string;
    DBInstanceIdentifier: string;
    Tags?: RDS$20141031$TagList;
  };
  declare type RDS$20141031$CreateDBSnapshotResult = {
    DBSnapshot?: RDS$20141031$DBSnapshot;
  };
  declare type RDS$20141031$CreateDBSubnetGroupMessage = {
    DBSubnetGroupName: string;
    DBSubnetGroupDescription: string;
    SubnetIds: RDS$20141031$SubnetIdentifierList;
    Tags?: RDS$20141031$TagList;
  };
  declare type RDS$20141031$CreateDBSubnetGroupResult = {
    DBSubnetGroup?: RDS$20141031$DBSubnetGroup;
  };
  declare type RDS$20141031$CreateEventSubscriptionMessage = {
    SubscriptionName: string;
    SnsTopicArn: string;
    SourceType?: string;
    EventCategories?: RDS$20141031$EventCategoriesList;
    SourceIds?: RDS$20141031$SourceIdsList;
    Enabled?: boolean;
    Tags?: RDS$20141031$TagList;
  };
  declare type RDS$20141031$CreateEventSubscriptionResult = {
    EventSubscription?: RDS$20141031$EventSubscription;
  };
  declare type RDS$20141031$CreateOptionGroupMessage = {
    OptionGroupName: string;
    EngineName: string;
    MajorEngineVersion: string;
    OptionGroupDescription: string;
    Tags?: RDS$20141031$TagList;
  };
  declare type RDS$20141031$CreateOptionGroupResult = {
    OptionGroup?: RDS$20141031$OptionGroup;
  };
  declare type RDS$20141031$DBCluster = {
    AllocatedStorage?: number;
    AvailabilityZones?: RDS$20141031$AvailabilityZones;
    BackupRetentionPeriod?: number;
    CharacterSetName?: string;
    DatabaseName?: string;
    DBClusterIdentifier?: string;
    DBClusterParameterGroup?: string;
    DBSubnetGroup?: string;
    Status?: string;
    PercentProgress?: string;
    EarliestRestorableTime?: Date;
    Endpoint?: string;
    Engine?: string;
    EngineVersion?: string;
    LatestRestorableTime?: Date;
    Port?: number;
    MasterUsername?: string;
    DBClusterOptionGroupMemberships?: RDS$20141031$DBClusterOptionGroupMemberships;
    PreferredBackupWindow?: string;
    PreferredMaintenanceWindow?: string;
    ReplicationSourceIdentifier?: string;
    ReadReplicaIdentifiers?: RDS$20141031$ReadReplicaIdentifierList;
    DBClusterMembers?: RDS$20141031$DBClusterMemberList;
    VpcSecurityGroups?: RDS$20141031$VpcSecurityGroupMembershipList;
    HostedZoneId?: string;
    StorageEncrypted?: boolean;
    KmsKeyId?: string;
    DbClusterResourceId?: string;
  };
  declare type RDS$20141031$DBClusterAlreadyExistsFault = {};
  declare type RDS$20141031$DBClusterList = RDS$20141031$DBCluster[];
  declare type RDS$20141031$DBClusterMember = {
    DBInstanceIdentifier?: string;
    IsClusterWriter?: boolean;
    DBClusterParameterGroupStatus?: string;
    PromotionTier?: number;
  };
  declare type RDS$20141031$DBClusterMemberList = RDS$20141031$DBClusterMember[];
  declare type RDS$20141031$DBClusterMessage = {
    Marker?: string;
    DBClusters?: RDS$20141031$DBClusterList;
  };
  declare type RDS$20141031$DBClusterNotFoundFault = {};
  declare type RDS$20141031$DBClusterOptionGroupMemberships = RDS$20141031$DBClusterOptionGroupStatus[];
  declare type RDS$20141031$DBClusterOptionGroupStatus = {
    DBClusterOptionGroupName?: string;
    Status?: string;
  };
  declare type RDS$20141031$DBClusterParameterGroup = {
    DBClusterParameterGroupName?: string;
    DBParameterGroupFamily?: string;
    Description?: string;
  };
  declare type RDS$20141031$DBClusterParameterGroupDetails = {
    Parameters?: RDS$20141031$ParametersList;
    Marker?: string;
  };
  declare type RDS$20141031$DBClusterParameterGroupList = RDS$20141031$DBClusterParameterGroup[];
  declare type RDS$20141031$DBClusterParameterGroupNameMessage = {
    DBClusterParameterGroupName?: string;
  };
  declare type RDS$20141031$DBClusterParameterGroupNotFoundFault = {};
  declare type RDS$20141031$DBClusterParameterGroupsMessage = {
    Marker?: string;
    DBClusterParameterGroups?: RDS$20141031$DBClusterParameterGroupList;
  };
  declare type RDS$20141031$DBClusterQuotaExceededFault = {};
  declare type RDS$20141031$DBClusterSnapshot = {
    AvailabilityZones?: RDS$20141031$AvailabilityZones;
    DBClusterSnapshotIdentifier?: string;
    DBClusterIdentifier?: string;
    SnapshotCreateTime?: Date;
    Engine?: string;
    AllocatedStorage?: number;
    Status?: string;
    Port?: number;
    VpcId?: string;
    ClusterCreateTime?: Date;
    MasterUsername?: string;
    EngineVersion?: string;
    LicenseModel?: string;
    SnapshotType?: string;
    PercentProgress?: number;
    StorageEncrypted?: boolean;
    KmsKeyId?: string;
  };
  declare type RDS$20141031$DBClusterSnapshotAlreadyExistsFault = {};
  declare type RDS$20141031$DBClusterSnapshotAttribute = {
    AttributeName?: string;
    AttributeValues?: RDS$20141031$AttributeValueList;
  };
  declare type RDS$20141031$DBClusterSnapshotAttributeList = RDS$20141031$DBClusterSnapshotAttribute[];
  declare type RDS$20141031$DBClusterSnapshotAttributesResult = {
    DBClusterSnapshotIdentifier?: string;
    DBClusterSnapshotAttributes?: RDS$20141031$DBClusterSnapshotAttributeList;
  };
  declare type RDS$20141031$DBClusterSnapshotList = RDS$20141031$DBClusterSnapshot[];
  declare type RDS$20141031$DBClusterSnapshotMessage = {
    Marker?: string;
    DBClusterSnapshots?: RDS$20141031$DBClusterSnapshotList;
  };
  declare type RDS$20141031$DBClusterSnapshotNotFoundFault = {};
  declare type RDS$20141031$DBEngineVersion = {
    Engine?: string;
    EngineVersion?: string;
    DBParameterGroupFamily?: string;
    DBEngineDescription?: string;
    DBEngineVersionDescription?: string;
    DefaultCharacterSet?: RDS$20141031$CharacterSet;
    SupportedCharacterSets?: RDS$20141031$SupportedCharacterSetsList;
    ValidUpgradeTarget?: RDS$20141031$ValidUpgradeTargetList;
  };
  declare type RDS$20141031$DBEngineVersionList = RDS$20141031$DBEngineVersion[];
  declare type RDS$20141031$DBEngineVersionMessage = {
    Marker?: string;
    DBEngineVersions?: RDS$20141031$DBEngineVersionList;
  };
  declare type RDS$20141031$DBInstance = {
    DBInstanceIdentifier?: string;
    DBInstanceClass?: string;
    Engine?: string;
    DBInstanceStatus?: string;
    MasterUsername?: string;
    DBName?: string;
    Endpoint?: RDS$20141031$Endpoint;
    AllocatedStorage?: number;
    InstanceCreateTime?: Date;
    PreferredBackupWindow?: string;
    BackupRetentionPeriod?: number;
    DBSecurityGroups?: RDS$20141031$DBSecurityGroupMembershipList;
    VpcSecurityGroups?: RDS$20141031$VpcSecurityGroupMembershipList;
    DBParameterGroups?: RDS$20141031$DBParameterGroupStatusList;
    AvailabilityZone?: string;
    DBSubnetGroup?: RDS$20141031$DBSubnetGroup;
    PreferredMaintenanceWindow?: string;
    PendingModifiedValues?: RDS$20141031$PendingModifiedValues;
    LatestRestorableTime?: Date;
    MultiAZ?: boolean;
    EngineVersion?: string;
    AutoMinorVersionUpgrade?: boolean;
    ReadReplicaSourceDBInstanceIdentifier?: string;
    ReadReplicaDBInstanceIdentifiers?: RDS$20141031$ReadReplicaDBInstanceIdentifierList;
    LicenseModel?: string;
    Iops?: number;
    OptionGroupMemberships?: RDS$20141031$OptionGroupMembershipList;
    CharacterSetName?: string;
    SecondaryAvailabilityZone?: string;
    PubliclyAccessible?: boolean;
    StatusInfos?: RDS$20141031$DBInstanceStatusInfoList;
    StorageType?: string;
    TdeCredentialArn?: string;
    DbInstancePort?: number;
    DBClusterIdentifier?: string;
    StorageEncrypted?: boolean;
    KmsKeyId?: string;
    DbiResourceId?: string;
    CACertificateIdentifier?: string;
    DomainMemberships?: RDS$20141031$DomainMembershipList;
    CopyTagsToSnapshot?: boolean;
    MonitoringInterval?: number;
    EnhancedMonitoringResourceArn?: string;
    MonitoringRoleArn?: string;
    PromotionTier?: number;
  };
  declare type RDS$20141031$DBInstanceAlreadyExistsFault = {};
  declare type RDS$20141031$DBInstanceList = RDS$20141031$DBInstance[];
  declare type RDS$20141031$DBInstanceMessage = {
    Marker?: string;
    DBInstances?: RDS$20141031$DBInstanceList;
  };
  declare type RDS$20141031$DBInstanceNotFoundFault = {};
  declare type RDS$20141031$DBInstanceStatusInfo = {
    StatusType?: string;
    Normal?: boolean;
    Status?: string;
    Message?: string;
  };
  declare type RDS$20141031$DBInstanceStatusInfoList = RDS$20141031$DBInstanceStatusInfo[];
  declare type RDS$20141031$DBLogFileNotFoundFault = {};
  declare type RDS$20141031$DBParameterGroup = {
    DBParameterGroupName?: string;
    DBParameterGroupFamily?: string;
    Description?: string;
  };
  declare type RDS$20141031$DBParameterGroupAlreadyExistsFault = {};
  declare type RDS$20141031$DBParameterGroupDetails = {
    Parameters?: RDS$20141031$ParametersList;
    Marker?: string;
  };
  declare type RDS$20141031$DBParameterGroupList = RDS$20141031$DBParameterGroup[];
  declare type RDS$20141031$DBParameterGroupNameMessage = {
    DBParameterGroupName?: string;
  };
  declare type RDS$20141031$DBParameterGroupNotFoundFault = {};
  declare type RDS$20141031$DBParameterGroupQuotaExceededFault = {};
  declare type RDS$20141031$DBParameterGroupStatus = {
    DBParameterGroupName?: string;
    ParameterApplyStatus?: string;
  };
  declare type RDS$20141031$DBParameterGroupStatusList = RDS$20141031$DBParameterGroupStatus[];
  declare type RDS$20141031$DBParameterGroupsMessage = {
    Marker?: string;
    DBParameterGroups?: RDS$20141031$DBParameterGroupList;
  };
  declare type RDS$20141031$DBSecurityGroup = {
    OwnerId?: string;
    DBSecurityGroupName?: string;
    DBSecurityGroupDescription?: string;
    VpcId?: string;
    EC2SecurityGroups?: RDS$20141031$EC2SecurityGroupList;
    IPRanges?: RDS$20141031$IPRangeList;
  };
  declare type RDS$20141031$DBSecurityGroupAlreadyExistsFault = {};
  declare type RDS$20141031$DBSecurityGroupMembership = {
    DBSecurityGroupName?: string;
    Status?: string;
  };
  declare type RDS$20141031$DBSecurityGroupMembershipList = RDS$20141031$DBSecurityGroupMembership[];
  declare type RDS$20141031$DBSecurityGroupMessage = {
    Marker?: string;
    DBSecurityGroups?: RDS$20141031$DBSecurityGroups;
  };
  declare type RDS$20141031$DBSecurityGroupNameList = string[];
  declare type RDS$20141031$DBSecurityGroupNotFoundFault = {};
  declare type RDS$20141031$DBSecurityGroupNotSupportedFault = {};
  declare type RDS$20141031$DBSecurityGroupQuotaExceededFault = {};
  declare type RDS$20141031$DBSecurityGroups = RDS$20141031$DBSecurityGroup[];
  declare type RDS$20141031$DBSnapshot = {
    DBSnapshotIdentifier?: string;
    DBInstanceIdentifier?: string;
    SnapshotCreateTime?: Date;
    Engine?: string;
    AllocatedStorage?: number;
    Status?: string;
    Port?: number;
    AvailabilityZone?: string;
    VpcId?: string;
    InstanceCreateTime?: Date;
    MasterUsername?: string;
    EngineVersion?: string;
    LicenseModel?: string;
    SnapshotType?: string;
    Iops?: number;
    OptionGroupName?: string;
    PercentProgress?: number;
    SourceRegion?: string;
    SourceDBSnapshotIdentifier?: string;
    StorageType?: string;
    TdeCredentialArn?: string;
    Encrypted?: boolean;
    KmsKeyId?: string;
  };
  declare type RDS$20141031$DBSnapshotAlreadyExistsFault = {};
  declare type RDS$20141031$DBSnapshotAttribute = {
    AttributeName?: string;
    AttributeValues?: RDS$20141031$AttributeValueList;
  };
  declare type RDS$20141031$DBSnapshotAttributeList = RDS$20141031$DBSnapshotAttribute[];
  declare type RDS$20141031$DBSnapshotAttributesResult = {
    DBSnapshotIdentifier?: string;
    DBSnapshotAttributes?: RDS$20141031$DBSnapshotAttributeList;
  };
  declare type RDS$20141031$DBSnapshotList = RDS$20141031$DBSnapshot[];
  declare type RDS$20141031$DBSnapshotMessage = {
    Marker?: string;
    DBSnapshots?: RDS$20141031$DBSnapshotList;
  };
  declare type RDS$20141031$DBSnapshotNotFoundFault = {};
  declare type RDS$20141031$DBSubnetGroup = {
    DBSubnetGroupName?: string;
    DBSubnetGroupDescription?: string;
    VpcId?: string;
    SubnetGroupStatus?: string;
    Subnets?: RDS$20141031$SubnetList;
  };
  declare type RDS$20141031$DBSubnetGroupAlreadyExistsFault = {};
  declare type RDS$20141031$DBSubnetGroupDoesNotCoverEnoughAZs = {};
  declare type RDS$20141031$DBSubnetGroupMessage = {
    Marker?: string;
    DBSubnetGroups?: RDS$20141031$DBSubnetGroups;
  };
  declare type RDS$20141031$DBSubnetGroupNotAllowedFault = {};
  declare type RDS$20141031$DBSubnetGroupNotFoundFault = {};
  declare type RDS$20141031$DBSubnetGroupQuotaExceededFault = {};
  declare type RDS$20141031$DBSubnetGroups = RDS$20141031$DBSubnetGroup[];
  declare type RDS$20141031$DBSubnetQuotaExceededFault = {};
  declare type RDS$20141031$DBUpgradeDependencyFailureFault = {};
  declare type RDS$20141031$DeleteDBClusterMessage = {
    DBClusterIdentifier: string;
    SkipFinalSnapshot?: boolean;
    FinalDBSnapshotIdentifier?: string;
  };
  declare type RDS$20141031$DeleteDBClusterParameterGroupMessage = {
    DBClusterParameterGroupName: string;
  };
  declare type RDS$20141031$DeleteDBClusterResult = {
    DBCluster?: RDS$20141031$DBCluster;
  };
  declare type RDS$20141031$DeleteDBClusterSnapshotMessage = {
    DBClusterSnapshotIdentifier: string;
  };
  declare type RDS$20141031$DeleteDBClusterSnapshotResult = {
    DBClusterSnapshot?: RDS$20141031$DBClusterSnapshot;
  };
  declare type RDS$20141031$DeleteDBInstanceMessage = {
    DBInstanceIdentifier: string;
    SkipFinalSnapshot?: boolean;
    FinalDBSnapshotIdentifier?: string;
  };
  declare type RDS$20141031$DeleteDBInstanceResult = {
    DBInstance?: RDS$20141031$DBInstance;
  };
  declare type RDS$20141031$DeleteDBParameterGroupMessage = {
    DBParameterGroupName: string;
  };
  declare type RDS$20141031$DeleteDBSecurityGroupMessage = {
    DBSecurityGroupName: string;
  };
  declare type RDS$20141031$DeleteDBSnapshotMessage = {
    DBSnapshotIdentifier: string;
  };
  declare type RDS$20141031$DeleteDBSnapshotResult = {
    DBSnapshot?: RDS$20141031$DBSnapshot;
  };
  declare type RDS$20141031$DeleteDBSubnetGroupMessage = {
    DBSubnetGroupName: string;
  };
  declare type RDS$20141031$DeleteEventSubscriptionMessage = {
    SubscriptionName: string;
  };
  declare type RDS$20141031$DeleteEventSubscriptionResult = {
    EventSubscription?: RDS$20141031$EventSubscription;
  };
  declare type RDS$20141031$DeleteOptionGroupMessage = {
    OptionGroupName: string;
  };
  declare type RDS$20141031$DescribeAccountAttributesMessage = {};
  declare type RDS$20141031$DescribeCertificatesMessage = {
    CertificateIdentifier?: string;
    Filters?: RDS$20141031$FilterList;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20141031$DescribeDBClusterParameterGroupsMessage = {
    DBClusterParameterGroupName?: string;
    Filters?: RDS$20141031$FilterList;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20141031$DescribeDBClusterParametersMessage = {
    DBClusterParameterGroupName: string;
    Source?: string;
    Filters?: RDS$20141031$FilterList;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20141031$DescribeDBClusterSnapshotAttributesMessage = {
    DBClusterSnapshotIdentifier: string;
  };
  declare type RDS$20141031$DescribeDBClusterSnapshotAttributesResult = {
    DBClusterSnapshotAttributesResult?: RDS$20141031$DBClusterSnapshotAttributesResult;
  };
  declare type RDS$20141031$DescribeDBClusterSnapshotsMessage = {
    DBClusterIdentifier?: string;
    DBClusterSnapshotIdentifier?: string;
    SnapshotType?: string;
    Filters?: RDS$20141031$FilterList;
    MaxRecords?: number;
    Marker?: string;
    IncludeShared?: boolean;
    IncludePublic?: boolean;
  };
  declare type RDS$20141031$DescribeDBClustersMessage = {
    DBClusterIdentifier?: string;
    Filters?: RDS$20141031$FilterList;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20141031$DescribeDBEngineVersionsMessage = {
    Engine?: string;
    EngineVersion?: string;
    DBParameterGroupFamily?: string;
    Filters?: RDS$20141031$FilterList;
    MaxRecords?: number;
    Marker?: string;
    DefaultOnly?: boolean;
    ListSupportedCharacterSets?: boolean;
  };
  declare type RDS$20141031$DescribeDBInstancesMessage = {
    DBInstanceIdentifier?: string;
    Filters?: RDS$20141031$FilterList;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20141031$DescribeDBLogFilesDetails = {
    LogFileName?: string;
    LastWritten?: number;
    Size?: number;
  };
  declare type RDS$20141031$DescribeDBLogFilesList = RDS$20141031$DescribeDBLogFilesDetails[];
  declare type RDS$20141031$DescribeDBLogFilesMessage = {
    DBInstanceIdentifier: string;
    FilenameContains?: string;
    FileLastWritten?: number;
    FileSize?: number;
    Filters?: RDS$20141031$FilterList;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20141031$DescribeDBLogFilesResponse = {
    DescribeDBLogFiles?: RDS$20141031$DescribeDBLogFilesList;
    Marker?: string;
  };
  declare type RDS$20141031$DescribeDBParameterGroupsMessage = {
    DBParameterGroupName?: string;
    Filters?: RDS$20141031$FilterList;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20141031$DescribeDBParametersMessage = {
    DBParameterGroupName: string;
    Source?: string;
    Filters?: RDS$20141031$FilterList;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20141031$DescribeDBSecurityGroupsMessage = {
    DBSecurityGroupName?: string;
    Filters?: RDS$20141031$FilterList;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20141031$DescribeDBSnapshotAttributesMessage = {
    DBSnapshotIdentifier: string;
  };
  declare type RDS$20141031$DescribeDBSnapshotAttributesResult = {
    DBSnapshotAttributesResult?: RDS$20141031$DBSnapshotAttributesResult;
  };
  declare type RDS$20141031$DescribeDBSnapshotsMessage = {
    DBInstanceIdentifier?: string;
    DBSnapshotIdentifier?: string;
    SnapshotType?: string;
    Filters?: RDS$20141031$FilterList;
    MaxRecords?: number;
    Marker?: string;
    IncludeShared?: boolean;
    IncludePublic?: boolean;
  };
  declare type RDS$20141031$DescribeDBSubnetGroupsMessage = {
    DBSubnetGroupName?: string;
    Filters?: RDS$20141031$FilterList;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20141031$DescribeEngineDefaultClusterParametersMessage = {
    DBParameterGroupFamily: string;
    Filters?: RDS$20141031$FilterList;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20141031$DescribeEngineDefaultClusterParametersResult = {
    EngineDefaults?: RDS$20141031$EngineDefaults;
  };
  declare type RDS$20141031$DescribeEngineDefaultParametersMessage = {
    DBParameterGroupFamily: string;
    Filters?: RDS$20141031$FilterList;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20141031$DescribeEngineDefaultParametersResult = {
    EngineDefaults?: RDS$20141031$EngineDefaults;
  };
  declare type RDS$20141031$DescribeEventCategoriesMessage = {
    SourceType?: string;
    Filters?: RDS$20141031$FilterList;
  };
  declare type RDS$20141031$DescribeEventSubscriptionsMessage = {
    SubscriptionName?: string;
    Filters?: RDS$20141031$FilterList;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20141031$DescribeEventsMessage = {
    SourceIdentifier?: string;
    SourceType?: 'db-instance' | 'db-parameter-group' | 'db-security-group' | 'db-snapshot' | 'db-cluster' | 'db-cluster-snapshot';
    StartTime?: Date;
    EndTime?: Date;
    Duration?: number;
    EventCategories?: RDS$20141031$EventCategoriesList;
    Filters?: RDS$20141031$FilterList;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20141031$DescribeOptionGroupOptionsMessage = {
    EngineName: string;
    MajorEngineVersion?: string;
    Filters?: RDS$20141031$FilterList;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20141031$DescribeOptionGroupsMessage = {
    OptionGroupName?: string;
    Filters?: RDS$20141031$FilterList;
    Marker?: string;
    MaxRecords?: number;
    EngineName?: string;
    MajorEngineVersion?: string;
  };
  declare type RDS$20141031$DescribeOrderableDBInstanceOptionsMessage = {
    Engine: string;
    EngineVersion?: string;
    DBInstanceClass?: string;
    LicenseModel?: string;
    Vpc?: boolean;
    Filters?: RDS$20141031$FilterList;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20141031$DescribePendingMaintenanceActionsMessage = {
    ResourceIdentifier?: string;
    Filters?: RDS$20141031$FilterList;
    Marker?: string;
    MaxRecords?: number;
  };
  declare type RDS$20141031$DescribeReservedDBInstancesMessage = {
    ReservedDBInstanceId?: string;
    ReservedDBInstancesOfferingId?: string;
    DBInstanceClass?: string;
    Duration?: string;
    ProductDescription?: string;
    OfferingType?: string;
    MultiAZ?: boolean;
    Filters?: RDS$20141031$FilterList;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20141031$DescribeReservedDBInstancesOfferingsMessage = {
    ReservedDBInstancesOfferingId?: string;
    DBInstanceClass?: string;
    Duration?: string;
    ProductDescription?: string;
    OfferingType?: string;
    MultiAZ?: boolean;
    Filters?: RDS$20141031$FilterList;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type RDS$20141031$DomainMembership = {
    Domain?: string;
    Status?: string;
    FQDN?: string;
    IAMRoleName?: string;
  };
  declare type RDS$20141031$DomainMembershipList = RDS$20141031$DomainMembership[];
  declare type RDS$20141031$DomainNotFoundFault = {};
  declare type RDS$20141031$DownloadDBLogFilePortionDetails = {
    LogFileData?: string;
    Marker?: string;
    AdditionalDataPending?: boolean;
  };
  declare type RDS$20141031$DownloadDBLogFilePortionMessage = {
    DBInstanceIdentifier: string;
    LogFileName: string;
    Marker?: string;
    NumberOfLines?: number;
  };
  declare type RDS$20141031$EC2SecurityGroup = {
    Status?: string;
    EC2SecurityGroupName?: string;
    EC2SecurityGroupId?: string;
    EC2SecurityGroupOwnerId?: string;
  };
  declare type RDS$20141031$EC2SecurityGroupList = RDS$20141031$EC2SecurityGroup[];
  declare type RDS$20141031$Endpoint = {
    Address?: string;
    Port?: number;
    HostedZoneId?: string;
  };
  declare type RDS$20141031$EngineDefaults = {
    DBParameterGroupFamily?: string;
    Marker?: string;
    Parameters?: RDS$20141031$ParametersList;
  };
  declare type RDS$20141031$Event = {
    SourceIdentifier?: string;
    SourceType?: 'db-instance' | 'db-parameter-group' | 'db-security-group' | 'db-snapshot' | 'db-cluster' | 'db-cluster-snapshot';
    Message?: string;
    EventCategories?: RDS$20141031$EventCategoriesList;
    Date?: Date;
  };
  declare type RDS$20141031$EventCategoriesList = string[];
  declare type RDS$20141031$EventCategoriesMap = {
    SourceType?: string;
    EventCategories?: RDS$20141031$EventCategoriesList;
  };
  declare type RDS$20141031$EventCategoriesMapList = RDS$20141031$EventCategoriesMap[];
  declare type RDS$20141031$EventCategoriesMessage = {
    EventCategoriesMapList?: RDS$20141031$EventCategoriesMapList;
  };
  declare type RDS$20141031$EventList = RDS$20141031$Event[];
  declare type RDS$20141031$EventSubscription = {
    CustomerAwsId?: string;
    CustSubscriptionId?: string;
    SnsTopicArn?: string;
    Status?: string;
    SubscriptionCreationTime?: string;
    SourceType?: string;
    SourceIdsList?: RDS$20141031$SourceIdsList;
    EventCategoriesList?: RDS$20141031$EventCategoriesList;
    Enabled?: boolean;
  };
  declare type RDS$20141031$EventSubscriptionQuotaExceededFault = {};
  declare type RDS$20141031$EventSubscriptionsList = RDS$20141031$EventSubscription[];
  declare type RDS$20141031$EventSubscriptionsMessage = {
    Marker?: string;
    EventSubscriptionsList?: RDS$20141031$EventSubscriptionsList;
  };
  declare type RDS$20141031$EventsMessage = {
    Marker?: string;
    Events?: RDS$20141031$EventList;
  };
  declare type RDS$20141031$FailoverDBClusterMessage = {
    DBClusterIdentifier?: string;
    TargetDBInstanceIdentifier?: string;
  };
  declare type RDS$20141031$FailoverDBClusterResult = {
    DBCluster?: RDS$20141031$DBCluster;
  };
  declare type RDS$20141031$Filter = {
    Name: string;
    Values: RDS$20141031$FilterValueList;
  };
  declare type RDS$20141031$FilterList = RDS$20141031$Filter[];
  declare type RDS$20141031$FilterValueList = string[];
  declare type RDS$20141031$IPRange = {
    Status?: string;
    CIDRIP?: string;
  };
  declare type RDS$20141031$IPRangeList = RDS$20141031$IPRange[];
  declare type RDS$20141031$InstanceQuotaExceededFault = {};
  declare type RDS$20141031$InsufficientDBClusterCapacityFault = {};
  declare type RDS$20141031$InsufficientDBInstanceCapacityFault = {};
  declare type RDS$20141031$InsufficientStorageClusterCapacityFault = {};
  declare type RDS$20141031$InvalidDBClusterSnapshotStateFault = {};
  declare type RDS$20141031$InvalidDBClusterStateFault = {};
  declare type RDS$20141031$InvalidDBInstanceStateFault = {};
  declare type RDS$20141031$InvalidDBParameterGroupStateFault = {};
  declare type RDS$20141031$InvalidDBSecurityGroupStateFault = {};
  declare type RDS$20141031$InvalidDBSnapshotStateFault = {};
  declare type RDS$20141031$InvalidDBSubnetGroupFault = {};
  declare type RDS$20141031$InvalidDBSubnetGroupStateFault = {};
  declare type RDS$20141031$InvalidDBSubnetStateFault = {};
  declare type RDS$20141031$InvalidEventSubscriptionStateFault = {};
  declare type RDS$20141031$InvalidOptionGroupStateFault = {};
  declare type RDS$20141031$InvalidRestoreFault = {};
  declare type RDS$20141031$InvalidS3BucketFault = {};
  declare type RDS$20141031$InvalidSubnet = {};
  declare type RDS$20141031$InvalidVPCNetworkStateFault = {};
  declare type RDS$20141031$KMSKeyNotAccessibleFault = {};
  declare type RDS$20141031$KeyList = string[];
  declare type RDS$20141031$ListTagsForResourceMessage = {
    ResourceName: string;
    Filters?: RDS$20141031$FilterList;
  };
  declare type RDS$20141031$ModifyDBClusterMessage = {
    DBClusterIdentifier: string;
    NewDBClusterIdentifier?: string;
    ApplyImmediately?: boolean;
    BackupRetentionPeriod?: number;
    DBClusterParameterGroupName?: string;
    VpcSecurityGroupIds?: RDS$20141031$VpcSecurityGroupIdList;
    Port?: number;
    MasterUserPassword?: string;
    OptionGroupName?: string;
    PreferredBackupWindow?: string;
    PreferredMaintenanceWindow?: string;
  };
  declare type RDS$20141031$ModifyDBClusterParameterGroupMessage = {
    DBClusterParameterGroupName: string;
    Parameters: RDS$20141031$ParametersList;
  };
  declare type RDS$20141031$ModifyDBClusterResult = {
    DBCluster?: RDS$20141031$DBCluster;
  };
  declare type RDS$20141031$ModifyDBClusterSnapshotAttributeMessage = {
    DBClusterSnapshotIdentifier: string;
    AttributeName: string;
    ValuesToAdd?: RDS$20141031$AttributeValueList;
    ValuesToRemove?: RDS$20141031$AttributeValueList;
  };
  declare type RDS$20141031$ModifyDBClusterSnapshotAttributeResult = {
    DBClusterSnapshotAttributesResult?: RDS$20141031$DBClusterSnapshotAttributesResult;
  };
  declare type RDS$20141031$ModifyDBInstanceMessage = {
    DBInstanceIdentifier: string;
    AllocatedStorage?: number;
    DBInstanceClass?: string;
    DBSubnetGroupName?: string;
    DBSecurityGroups?: RDS$20141031$DBSecurityGroupNameList;
    VpcSecurityGroupIds?: RDS$20141031$VpcSecurityGroupIdList;
    ApplyImmediately?: boolean;
    MasterUserPassword?: string;
    DBParameterGroupName?: string;
    BackupRetentionPeriod?: number;
    PreferredBackupWindow?: string;
    PreferredMaintenanceWindow?: string;
    MultiAZ?: boolean;
    EngineVersion?: string;
    AllowMajorVersionUpgrade?: boolean;
    AutoMinorVersionUpgrade?: boolean;
    LicenseModel?: string;
    Iops?: number;
    OptionGroupName?: string;
    NewDBInstanceIdentifier?: string;
    StorageType?: string;
    TdeCredentialArn?: string;
    TdeCredentialPassword?: string;
    CACertificateIdentifier?: string;
    Domain?: string;
    CopyTagsToSnapshot?: boolean;
    MonitoringInterval?: number;
    DBPortNumber?: number;
    PubliclyAccessible?: boolean;
    MonitoringRoleArn?: string;
    DomainIAMRoleName?: string;
    PromotionTier?: number;
  };
  declare type RDS$20141031$ModifyDBInstanceResult = {
    DBInstance?: RDS$20141031$DBInstance;
  };
  declare type RDS$20141031$ModifyDBParameterGroupMessage = {
    DBParameterGroupName: string;
    Parameters: RDS$20141031$ParametersList;
  };
  declare type RDS$20141031$ModifyDBSnapshotAttributeMessage = {
    DBSnapshotIdentifier: string;
    AttributeName: string;
    ValuesToAdd?: RDS$20141031$AttributeValueList;
    ValuesToRemove?: RDS$20141031$AttributeValueList;
  };
  declare type RDS$20141031$ModifyDBSnapshotAttributeResult = {
    DBSnapshotAttributesResult?: RDS$20141031$DBSnapshotAttributesResult;
  };
  declare type RDS$20141031$ModifyDBSubnetGroupMessage = {
    DBSubnetGroupName: string;
    DBSubnetGroupDescription?: string;
    SubnetIds: RDS$20141031$SubnetIdentifierList;
  };
  declare type RDS$20141031$ModifyDBSubnetGroupResult = {
    DBSubnetGroup?: RDS$20141031$DBSubnetGroup;
  };
  declare type RDS$20141031$ModifyEventSubscriptionMessage = {
    SubscriptionName: string;
    SnsTopicArn?: string;
    SourceType?: string;
    EventCategories?: RDS$20141031$EventCategoriesList;
    Enabled?: boolean;
  };
  declare type RDS$20141031$ModifyEventSubscriptionResult = {
    EventSubscription?: RDS$20141031$EventSubscription;
  };
  declare type RDS$20141031$ModifyOptionGroupMessage = {
    OptionGroupName: string;
    OptionsToInclude?: RDS$20141031$OptionConfigurationList;
    OptionsToRemove?: RDS$20141031$OptionNamesList;
    ApplyImmediately?: boolean;
  };
  declare type RDS$20141031$ModifyOptionGroupResult = {
    OptionGroup?: RDS$20141031$OptionGroup;
  };
  declare type RDS$20141031$Option = {
    OptionName?: string;
    OptionDescription?: string;
    Persistent?: boolean;
    Permanent?: boolean;
    Port?: number;
    OptionVersion?: string;
    OptionSettings?: RDS$20141031$OptionSettingConfigurationList;
    DBSecurityGroupMemberships?: RDS$20141031$DBSecurityGroupMembershipList;
    VpcSecurityGroupMemberships?: RDS$20141031$VpcSecurityGroupMembershipList;
  };
  declare type RDS$20141031$OptionConfiguration = {
    OptionName: string;
    Port?: number;
    OptionVersion?: string;
    DBSecurityGroupMemberships?: RDS$20141031$DBSecurityGroupNameList;
    VpcSecurityGroupMemberships?: RDS$20141031$VpcSecurityGroupIdList;
    OptionSettings?: RDS$20141031$OptionSettingsList;
  };
  declare type RDS$20141031$OptionConfigurationList = RDS$20141031$OptionConfiguration[];
  declare type RDS$20141031$OptionGroup = {
    OptionGroupName?: string;
    OptionGroupDescription?: string;
    EngineName?: string;
    MajorEngineVersion?: string;
    Options?: RDS$20141031$OptionsList;
    AllowsVpcAndNonVpcInstanceMemberships?: boolean;
    VpcId?: string;
  };
  declare type RDS$20141031$OptionGroupAlreadyExistsFault = {};
  declare type RDS$20141031$OptionGroupMembership = {
    OptionGroupName?: string;
    Status?: string;
  };
  declare type RDS$20141031$OptionGroupMembershipList = RDS$20141031$OptionGroupMembership[];
  declare type RDS$20141031$OptionGroupNotFoundFault = {};
  declare type RDS$20141031$OptionGroupOption = {
    Name?: string;
    Description?: string;
    EngineName?: string;
    MajorEngineVersion?: string;
    MinimumRequiredMinorEngineVersion?: string;
    PortRequired?: boolean;
    DefaultPort?: number;
    OptionsDependedOn?: RDS$20141031$OptionsDependedOn;
    Persistent?: boolean;
    Permanent?: boolean;
    OptionGroupOptionSettings?: RDS$20141031$OptionGroupOptionSettingsList;
    OptionGroupOptionVersions?: RDS$20141031$OptionGroupOptionVersionsList;
  };
  declare type RDS$20141031$OptionGroupOptionSetting = {
    SettingName?: string;
    SettingDescription?: string;
    DefaultValue?: string;
    ApplyType?: string;
    AllowedValues?: string;
    IsModifiable?: boolean;
  };
  declare type RDS$20141031$OptionGroupOptionSettingsList = RDS$20141031$OptionGroupOptionSetting[];
  declare type RDS$20141031$OptionGroupOptionVersionsList = RDS$20141031$OptionVersion[];
  declare type RDS$20141031$OptionGroupOptionsList = RDS$20141031$OptionGroupOption[];
  declare type RDS$20141031$OptionGroupOptionsMessage = {
    OptionGroupOptions?: RDS$20141031$OptionGroupOptionsList;
    Marker?: string;
  };
  declare type RDS$20141031$OptionGroupQuotaExceededFault = {};
  declare type RDS$20141031$OptionGroups = {
    OptionGroupsList?: RDS$20141031$OptionGroupsList;
    Marker?: string;
  };
  declare type RDS$20141031$OptionGroupsList = RDS$20141031$OptionGroup[];
  declare type RDS$20141031$OptionNamesList = string[];
  declare type RDS$20141031$OptionSetting = {
    Name?: string;
    Value?: string;
    DefaultValue?: string;
    Description?: string;
    ApplyType?: string;
    DataType?: string;
    AllowedValues?: string;
    IsModifiable?: boolean;
    IsCollection?: boolean;
  };
  declare type RDS$20141031$OptionSettingConfigurationList = RDS$20141031$OptionSetting[];
  declare type RDS$20141031$OptionSettingsList = RDS$20141031$OptionSetting[];
  declare type RDS$20141031$OptionVersion = {
    Version?: string;
    IsDefault?: boolean;
  };
  declare type RDS$20141031$OptionsDependedOn = string[];
  declare type RDS$20141031$OptionsList = RDS$20141031$Option[];
  declare type RDS$20141031$OrderableDBInstanceOption = {
    Engine?: string;
    EngineVersion?: string;
    DBInstanceClass?: string;
    LicenseModel?: string;
    AvailabilityZones?: RDS$20141031$AvailabilityZoneList;
    MultiAZCapable?: boolean;
    ReadReplicaCapable?: boolean;
    Vpc?: boolean;
    SupportsStorageEncryption?: boolean;
    StorageType?: string;
    SupportsIops?: boolean;
    SupportsEnhancedMonitoring?: boolean;
  };
  declare type RDS$20141031$OrderableDBInstanceOptionsList = RDS$20141031$OrderableDBInstanceOption[];
  declare type RDS$20141031$OrderableDBInstanceOptionsMessage = {
    OrderableDBInstanceOptions?: RDS$20141031$OrderableDBInstanceOptionsList;
    Marker?: string;
  };
  declare type RDS$20141031$Parameter = {
    ParameterName?: string;
    ParameterValue?: string;
    Description?: string;
    Source?: string;
    ApplyType?: string;
    DataType?: string;
    AllowedValues?: string;
    IsModifiable?: boolean;
    MinimumEngineVersion?: string;
    ApplyMethod?: 'immediate' | 'pending-reboot';
  };
  declare type RDS$20141031$ParametersList = RDS$20141031$Parameter[];
  declare type RDS$20141031$PendingMaintenanceAction = {
    Action?: string;
    AutoAppliedAfterDate?: Date;
    ForcedApplyDate?: Date;
    OptInStatus?: string;
    CurrentApplyDate?: Date;
    Description?: string;
  };
  declare type RDS$20141031$PendingMaintenanceActionDetails = RDS$20141031$PendingMaintenanceAction[];
  declare type RDS$20141031$PendingMaintenanceActions = RDS$20141031$ResourcePendingMaintenanceActions[];
  declare type RDS$20141031$PendingMaintenanceActionsMessage = {
    PendingMaintenanceActions?: RDS$20141031$PendingMaintenanceActions;
    Marker?: string;
  };
  declare type RDS$20141031$PendingModifiedValues = {
    DBInstanceClass?: string;
    AllocatedStorage?: number;
    MasterUserPassword?: string;
    Port?: number;
    BackupRetentionPeriod?: number;
    MultiAZ?: boolean;
    EngineVersion?: string;
    LicenseModel?: string;
    Iops?: number;
    DBInstanceIdentifier?: string;
    StorageType?: string;
    CACertificateIdentifier?: string;
    DBSubnetGroupName?: string;
  };
  declare type RDS$20141031$PointInTimeRestoreNotEnabledFault = {};
  declare type RDS$20141031$PromoteReadReplicaDBClusterMessage = {
    DBClusterIdentifier: string;
  };
  declare type RDS$20141031$PromoteReadReplicaDBClusterResult = {
    DBCluster?: RDS$20141031$DBCluster;
  };
  declare type RDS$20141031$PromoteReadReplicaMessage = {
    DBInstanceIdentifier: string;
    BackupRetentionPeriod?: number;
    PreferredBackupWindow?: string;
  };
  declare type RDS$20141031$PromoteReadReplicaResult = {
    DBInstance?: RDS$20141031$DBInstance;
  };
  declare type RDS$20141031$ProvisionedIopsNotAvailableInAZFault = {};
  declare type RDS$20141031$PurchaseReservedDBInstancesOfferingMessage = {
    ReservedDBInstancesOfferingId: string;
    ReservedDBInstanceId?: string;
    DBInstanceCount?: number;
    Tags?: RDS$20141031$TagList;
  };
  declare type RDS$20141031$PurchaseReservedDBInstancesOfferingResult = {
    ReservedDBInstance?: RDS$20141031$ReservedDBInstance;
  };
  declare type RDS$20141031$ReadReplicaDBInstanceIdentifierList = string[];
  declare type RDS$20141031$ReadReplicaIdentifierList = string[];
  declare type RDS$20141031$RebootDBInstanceMessage = {
    DBInstanceIdentifier: string;
    ForceFailover?: boolean;
  };
  declare type RDS$20141031$RebootDBInstanceResult = {
    DBInstance?: RDS$20141031$DBInstance;
  };
  declare type RDS$20141031$RecurringCharge = {
    RecurringChargeAmount?: number;
    RecurringChargeFrequency?: string;
  };
  declare type RDS$20141031$RecurringChargeList = RDS$20141031$RecurringCharge[];
  declare type RDS$20141031$RemoveSourceIdentifierFromSubscriptionMessage = {
    SubscriptionName: string;
    SourceIdentifier: string;
  };
  declare type RDS$20141031$RemoveSourceIdentifierFromSubscriptionResult = {
    EventSubscription?: RDS$20141031$EventSubscription;
  };
  declare type RDS$20141031$RemoveTagsFromResourceMessage = {
    ResourceName: string;
    TagKeys: RDS$20141031$KeyList;
  };
  declare type RDS$20141031$ReservedDBInstance = {
    ReservedDBInstanceId?: string;
    ReservedDBInstancesOfferingId?: string;
    DBInstanceClass?: string;
    StartTime?: Date;
    Duration?: number;
    FixedPrice?: number;
    UsagePrice?: number;
    CurrencyCode?: string;
    DBInstanceCount?: number;
    ProductDescription?: string;
    OfferingType?: string;
    MultiAZ?: boolean;
    State?: string;
    RecurringCharges?: RDS$20141031$RecurringChargeList;
  };
  declare type RDS$20141031$ReservedDBInstanceAlreadyExistsFault = {};
  declare type RDS$20141031$ReservedDBInstanceList = RDS$20141031$ReservedDBInstance[];
  declare type RDS$20141031$ReservedDBInstanceMessage = {
    Marker?: string;
    ReservedDBInstances?: RDS$20141031$ReservedDBInstanceList;
  };
  declare type RDS$20141031$ReservedDBInstanceNotFoundFault = {};
  declare type RDS$20141031$ReservedDBInstanceQuotaExceededFault = {};
  declare type RDS$20141031$ReservedDBInstancesOffering = {
    ReservedDBInstancesOfferingId?: string;
    DBInstanceClass?: string;
    Duration?: number;
    FixedPrice?: number;
    UsagePrice?: number;
    CurrencyCode?: string;
    ProductDescription?: string;
    OfferingType?: string;
    MultiAZ?: boolean;
    RecurringCharges?: RDS$20141031$RecurringChargeList;
  };
  declare type RDS$20141031$ReservedDBInstancesOfferingList = RDS$20141031$ReservedDBInstancesOffering[];
  declare type RDS$20141031$ReservedDBInstancesOfferingMessage = {
    Marker?: string;
    ReservedDBInstancesOfferings?: RDS$20141031$ReservedDBInstancesOfferingList;
  };
  declare type RDS$20141031$ReservedDBInstancesOfferingNotFoundFault = {};
  declare type RDS$20141031$ResetDBClusterParameterGroupMessage = {
    DBClusterParameterGroupName: string;
    ResetAllParameters?: boolean;
    Parameters?: RDS$20141031$ParametersList;
  };
  declare type RDS$20141031$ResetDBParameterGroupMessage = {
    DBParameterGroupName: string;
    ResetAllParameters?: boolean;
    Parameters?: RDS$20141031$ParametersList;
  };
  declare type RDS$20141031$ResourceNotFoundFault = {};
  declare type RDS$20141031$ResourcePendingMaintenanceActions = {
    ResourceIdentifier?: string;
    PendingMaintenanceActionDetails?: RDS$20141031$PendingMaintenanceActionDetails;
  };
  declare type RDS$20141031$RestoreDBClusterFromS3Message = {
    AvailabilityZones?: RDS$20141031$AvailabilityZones;
    BackupRetentionPeriod?: number;
    CharacterSetName?: string;
    DatabaseName?: string;
    DBClusterIdentifier: string;
    DBClusterParameterGroupName?: string;
    VpcSecurityGroupIds?: RDS$20141031$VpcSecurityGroupIdList;
    DBSubnetGroupName?: string;
    Engine: string;
    EngineVersion?: string;
    Port?: number;
    MasterUsername: string;
    MasterUserPassword: string;
    OptionGroupName?: string;
    PreferredBackupWindow?: string;
    PreferredMaintenanceWindow?: string;
    Tags?: RDS$20141031$TagList;
    StorageEncrypted?: boolean;
    KmsKeyId?: string;
    SourceEngine: string;
    SourceEngineVersion: string;
    S3BucketName: string;
    S3Prefix?: string;
    S3IngestionRoleArn: string;
  };
  declare type RDS$20141031$RestoreDBClusterFromS3Result = {
    DBCluster?: RDS$20141031$DBCluster;
  };
  declare type RDS$20141031$RestoreDBClusterFromSnapshotMessage = {
    AvailabilityZones?: RDS$20141031$AvailabilityZones;
    DBClusterIdentifier: string;
    SnapshotIdentifier: string;
    Engine: string;
    EngineVersion?: string;
    Port?: number;
    DBSubnetGroupName?: string;
    DatabaseName?: string;
    OptionGroupName?: string;
    VpcSecurityGroupIds?: RDS$20141031$VpcSecurityGroupIdList;
    Tags?: RDS$20141031$TagList;
    KmsKeyId?: string;
  };
  declare type RDS$20141031$RestoreDBClusterFromSnapshotResult = {
    DBCluster?: RDS$20141031$DBCluster;
  };
  declare type RDS$20141031$RestoreDBClusterToPointInTimeMessage = {
    DBClusterIdentifier: string;
    SourceDBClusterIdentifier: string;
    RestoreToTime?: Date;
    UseLatestRestorableTime?: boolean;
    Port?: number;
    DBSubnetGroupName?: string;
    OptionGroupName?: string;
    VpcSecurityGroupIds?: RDS$20141031$VpcSecurityGroupIdList;
    Tags?: RDS$20141031$TagList;
    KmsKeyId?: string;
  };
  declare type RDS$20141031$RestoreDBClusterToPointInTimeResult = {
    DBCluster?: RDS$20141031$DBCluster;
  };
  declare type RDS$20141031$RestoreDBInstanceFromDBSnapshotMessage = {
    DBInstanceIdentifier: string;
    DBSnapshotIdentifier: string;
    DBInstanceClass?: string;
    Port?: number;
    AvailabilityZone?: string;
    DBSubnetGroupName?: string;
    MultiAZ?: boolean;
    PubliclyAccessible?: boolean;
    AutoMinorVersionUpgrade?: boolean;
    LicenseModel?: string;
    DBName?: string;
    Engine?: string;
    Iops?: number;
    OptionGroupName?: string;
    Tags?: RDS$20141031$TagList;
    StorageType?: string;
    TdeCredentialArn?: string;
    TdeCredentialPassword?: string;
    Domain?: string;
    CopyTagsToSnapshot?: boolean;
    DomainIAMRoleName?: string;
  };
  declare type RDS$20141031$RestoreDBInstanceFromDBSnapshotResult = {
    DBInstance?: RDS$20141031$DBInstance;
  };
  declare type RDS$20141031$RestoreDBInstanceToPointInTimeMessage = {
    SourceDBInstanceIdentifier: string;
    TargetDBInstanceIdentifier: string;
    RestoreTime?: Date;
    UseLatestRestorableTime?: boolean;
    DBInstanceClass?: string;
    Port?: number;
    AvailabilityZone?: string;
    DBSubnetGroupName?: string;
    MultiAZ?: boolean;
    PubliclyAccessible?: boolean;
    AutoMinorVersionUpgrade?: boolean;
    LicenseModel?: string;
    DBName?: string;
    Engine?: string;
    Iops?: number;
    OptionGroupName?: string;
    CopyTagsToSnapshot?: boolean;
    Tags?: RDS$20141031$TagList;
    StorageType?: string;
    TdeCredentialArn?: string;
    TdeCredentialPassword?: string;
    Domain?: string;
    DomainIAMRoleName?: string;
  };
  declare type RDS$20141031$RestoreDBInstanceToPointInTimeResult = {
    DBInstance?: RDS$20141031$DBInstance;
  };
  declare type RDS$20141031$RevokeDBSecurityGroupIngressMessage = {
    DBSecurityGroupName: string;
    CIDRIP?: string;
    EC2SecurityGroupName?: string;
    EC2SecurityGroupId?: string;
    EC2SecurityGroupOwnerId?: string;
  };
  declare type RDS$20141031$RevokeDBSecurityGroupIngressResult = {
    DBSecurityGroup?: RDS$20141031$DBSecurityGroup;
  };
  declare type RDS$20141031$SNSInvalidTopicFault = {};
  declare type RDS$20141031$SNSNoAuthorizationFault = {};
  declare type RDS$20141031$SNSTopicArnNotFoundFault = {};
  declare type RDS$20141031$SharedSnapshotQuotaExceededFault = {};
  declare type RDS$20141031$SnapshotQuotaExceededFault = {};
  declare type RDS$20141031$SourceIdsList = string[];
  declare type RDS$20141031$SourceNotFoundFault = {};
  declare type RDS$20141031$SourceType = 'db-instance' | 'db-parameter-group' | 'db-security-group' | 'db-snapshot' | 'db-cluster' | 'db-cluster-snapshot';
  declare type RDS$20141031$StorageQuotaExceededFault = {};
  declare type RDS$20141031$StorageTypeNotSupportedFault = {};
  declare type RDS$20141031$Subnet = {
    SubnetIdentifier?: string;
    SubnetAvailabilityZone?: RDS$20141031$AvailabilityZone;
    SubnetStatus?: string;
  };
  declare type RDS$20141031$SubnetAlreadyInUse = {};
  declare type RDS$20141031$SubnetIdentifierList = string[];
  declare type RDS$20141031$SubnetList = RDS$20141031$Subnet[];
  declare type RDS$20141031$SubscriptionAlreadyExistFault = {};
  declare type RDS$20141031$SubscriptionCategoryNotFoundFault = {};
  declare type RDS$20141031$SubscriptionNotFoundFault = {};
  declare type RDS$20141031$SupportedCharacterSetsList = RDS$20141031$CharacterSet[];
  declare type RDS$20141031$TStamp = Date;
  declare type RDS$20141031$Tag = {
    Key?: string;
    Value?: string;
  };
  declare type RDS$20141031$TagList = RDS$20141031$Tag[];
  declare type RDS$20141031$TagListMessage = {
    TagList?: RDS$20141031$TagList;
  };
  declare type RDS$20141031$UpgradeTarget = {
    Engine?: string;
    EngineVersion?: string;
    Description?: string;
    AutoUpgrade?: boolean;
    IsMajorVersionUpgrade?: boolean;
  };
  declare type RDS$20141031$ValidUpgradeTargetList = RDS$20141031$UpgradeTarget[];
  declare type RDS$20141031$VpcSecurityGroupIdList = string[];
  declare type RDS$20141031$VpcSecurityGroupMembership = {
    VpcSecurityGroupId?: string;
    Status?: string;
  };
  declare type RDS$20141031$VpcSecurityGroupMembershipList = RDS$20141031$VpcSecurityGroupMembership[];
  declare type Redshift$20121201$AccessToSnapshotDeniedFault = {};
  declare type Redshift$20121201$AccountWithRestoreAccess = {
    AccountId?: string;
  };
  declare type Redshift$20121201$AccountsWithRestoreAccessList = Redshift$20121201$AccountWithRestoreAccess[];
  declare type Redshift$20121201$AuthorizationAlreadyExistsFault = {};
  declare type Redshift$20121201$AuthorizationNotFoundFault = {};
  declare type Redshift$20121201$AuthorizationQuotaExceededFault = {};
  declare type Redshift$20121201$AuthorizeClusterSecurityGroupIngressMessage = {
    ClusterSecurityGroupName: string;
    CIDRIP?: string;
    EC2SecurityGroupName?: string;
    EC2SecurityGroupOwnerId?: string;
  };
  declare type Redshift$20121201$AuthorizeClusterSecurityGroupIngressResult = {
    ClusterSecurityGroup?: Redshift$20121201$ClusterSecurityGroup;
  };
  declare type Redshift$20121201$AuthorizeSnapshotAccessMessage = {
    SnapshotIdentifier: string;
    SnapshotClusterIdentifier?: string;
    AccountWithRestoreAccess: string;
  };
  declare type Redshift$20121201$AuthorizeSnapshotAccessResult = {
    Snapshot?: Redshift$20121201$Snapshot;
  };
  declare type Redshift$20121201$AvailabilityZone = {
    Name?: string;
  };
  declare type Redshift$20121201$AvailabilityZoneList = Redshift$20121201$AvailabilityZone[];
  declare type Redshift$20121201$BucketNotFoundFault = {};
  declare type Redshift$20121201$Cluster = {
    ClusterIdentifier?: string;
    NodeType?: string;
    ClusterStatus?: string;
    ModifyStatus?: string;
    MasterUsername?: string;
    DBName?: string;
    Endpoint?: Redshift$20121201$Endpoint;
    ClusterCreateTime?: Date;
    AutomatedSnapshotRetentionPeriod?: number;
    ClusterSecurityGroups?: Redshift$20121201$ClusterSecurityGroupMembershipList;
    VpcSecurityGroups?: Redshift$20121201$VpcSecurityGroupMembershipList;
    ClusterParameterGroups?: Redshift$20121201$ClusterParameterGroupStatusList;
    ClusterSubnetGroupName?: string;
    VpcId?: string;
    AvailabilityZone?: string;
    PreferredMaintenanceWindow?: string;
    PendingModifiedValues?: Redshift$20121201$PendingModifiedValues;
    ClusterVersion?: string;
    AllowVersionUpgrade?: boolean;
    NumberOfNodes?: number;
    PubliclyAccessible?: boolean;
    Encrypted?: boolean;
    RestoreStatus?: Redshift$20121201$RestoreStatus;
    HsmStatus?: Redshift$20121201$HsmStatus;
    ClusterSnapshotCopyStatus?: Redshift$20121201$ClusterSnapshotCopyStatus;
    ClusterPublicKey?: string;
    ClusterNodes?: Redshift$20121201$ClusterNodesList;
    ElasticIpStatus?: Redshift$20121201$ElasticIpStatus;
    ClusterRevisionNumber?: string;
    Tags?: Redshift$20121201$TagList;
    KmsKeyId?: string;
    IamRoles?: Redshift$20121201$ClusterIamRoleList;
  };
  declare type Redshift$20121201$ClusterAlreadyExistsFault = {};
  declare type Redshift$20121201$ClusterIamRole = {
    IamRoleArn?: string;
    ApplyStatus?: string;
  };
  declare type Redshift$20121201$ClusterIamRoleList = Redshift$20121201$ClusterIamRole[];
  declare type Redshift$20121201$ClusterList = Redshift$20121201$Cluster[];
  declare type Redshift$20121201$ClusterNode = {
    NodeRole?: string;
    PrivateIPAddress?: string;
    PublicIPAddress?: string;
  };
  declare type Redshift$20121201$ClusterNodesList = Redshift$20121201$ClusterNode[];
  declare type Redshift$20121201$ClusterNotFoundFault = {};
  declare type Redshift$20121201$ClusterParameterGroup = {
    ParameterGroupName?: string;
    ParameterGroupFamily?: string;
    Description?: string;
    Tags?: Redshift$20121201$TagList;
  };
  declare type Redshift$20121201$ClusterParameterGroupAlreadyExistsFault = {};
  declare type Redshift$20121201$ClusterParameterGroupDetails = {
    Parameters?: Redshift$20121201$ParametersList;
    Marker?: string;
  };
  declare type Redshift$20121201$ClusterParameterGroupNameMessage = {
    ParameterGroupName?: string;
    ParameterGroupStatus?: string;
  };
  declare type Redshift$20121201$ClusterParameterGroupNotFoundFault = {};
  declare type Redshift$20121201$ClusterParameterGroupQuotaExceededFault = {};
  declare type Redshift$20121201$ClusterParameterGroupStatus = {
    ParameterGroupName?: string;
    ParameterApplyStatus?: string;
    ClusterParameterStatusList?: Redshift$20121201$ClusterParameterStatusList;
  };
  declare type Redshift$20121201$ClusterParameterGroupStatusList = Redshift$20121201$ClusterParameterGroupStatus[];
  declare type Redshift$20121201$ClusterParameterGroupsMessage = {
    Marker?: string;
    ParameterGroups?: Redshift$20121201$ParameterGroupList;
  };
  declare type Redshift$20121201$ClusterParameterStatus = {
    ParameterName?: string;
    ParameterApplyStatus?: string;
    ParameterApplyErrorDescription?: string;
  };
  declare type Redshift$20121201$ClusterParameterStatusList = Redshift$20121201$ClusterParameterStatus[];
  declare type Redshift$20121201$ClusterQuotaExceededFault = {};
  declare type Redshift$20121201$ClusterSecurityGroup = {
    ClusterSecurityGroupName?: string;
    Description?: string;
    EC2SecurityGroups?: Redshift$20121201$EC2SecurityGroupList;
    IPRanges?: Redshift$20121201$IPRangeList;
    Tags?: Redshift$20121201$TagList;
  };
  declare type Redshift$20121201$ClusterSecurityGroupAlreadyExistsFault = {};
  declare type Redshift$20121201$ClusterSecurityGroupMembership = {
    ClusterSecurityGroupName?: string;
    Status?: string;
  };
  declare type Redshift$20121201$ClusterSecurityGroupMembershipList = Redshift$20121201$ClusterSecurityGroupMembership[];
  declare type Redshift$20121201$ClusterSecurityGroupMessage = {
    Marker?: string;
    ClusterSecurityGroups?: Redshift$20121201$ClusterSecurityGroups;
  };
  declare type Redshift$20121201$ClusterSecurityGroupNameList = string[];
  declare type Redshift$20121201$ClusterSecurityGroupNotFoundFault = {};
  declare type Redshift$20121201$ClusterSecurityGroupQuotaExceededFault = {};
  declare type Redshift$20121201$ClusterSecurityGroups = Redshift$20121201$ClusterSecurityGroup[];
  declare type Redshift$20121201$ClusterSnapshotAlreadyExistsFault = {};
  declare type Redshift$20121201$ClusterSnapshotCopyStatus = {
    DestinationRegion?: string;
    RetentionPeriod?: number;
    SnapshotCopyGrantName?: string;
  };
  declare type Redshift$20121201$ClusterSnapshotNotFoundFault = {};
  declare type Redshift$20121201$ClusterSnapshotQuotaExceededFault = {};
  declare type Redshift$20121201$ClusterSubnetGroup = {
    ClusterSubnetGroupName?: string;
    Description?: string;
    VpcId?: string;
    SubnetGroupStatus?: string;
    Subnets?: Redshift$20121201$SubnetList;
    Tags?: Redshift$20121201$TagList;
  };
  declare type Redshift$20121201$ClusterSubnetGroupAlreadyExistsFault = {};
  declare type Redshift$20121201$ClusterSubnetGroupMessage = {
    Marker?: string;
    ClusterSubnetGroups?: Redshift$20121201$ClusterSubnetGroups;
  };
  declare type Redshift$20121201$ClusterSubnetGroupNotFoundFault = {};
  declare type Redshift$20121201$ClusterSubnetGroupQuotaExceededFault = {};
  declare type Redshift$20121201$ClusterSubnetGroups = Redshift$20121201$ClusterSubnetGroup[];
  declare type Redshift$20121201$ClusterSubnetQuotaExceededFault = {};
  declare type Redshift$20121201$ClusterVersion = {
    ClusterVersion?: string;
    ClusterParameterGroupFamily?: string;
    Description?: string;
  };
  declare type Redshift$20121201$ClusterVersionList = Redshift$20121201$ClusterVersion[];
  declare type Redshift$20121201$ClusterVersionsMessage = {
    Marker?: string;
    ClusterVersions?: Redshift$20121201$ClusterVersionList;
  };
  declare type Redshift$20121201$ClustersMessage = {
    Marker?: string;
    Clusters?: Redshift$20121201$ClusterList;
  };
  declare type Redshift$20121201$CopyClusterSnapshotMessage = {
    SourceSnapshotIdentifier: string;
    SourceSnapshotClusterIdentifier?: string;
    TargetSnapshotIdentifier: string;
  };
  declare type Redshift$20121201$CopyClusterSnapshotResult = {
    Snapshot?: Redshift$20121201$Snapshot;
  };
  declare type Redshift$20121201$CopyToRegionDisabledFault = {};
  declare type Redshift$20121201$CreateClusterMessage = {
    DBName?: string;
    ClusterIdentifier: string;
    ClusterType?: string;
    NodeType: string;
    MasterUsername: string;
    MasterUserPassword: string;
    ClusterSecurityGroups?: Redshift$20121201$ClusterSecurityGroupNameList;
    VpcSecurityGroupIds?: Redshift$20121201$VpcSecurityGroupIdList;
    ClusterSubnetGroupName?: string;
    AvailabilityZone?: string;
    PreferredMaintenanceWindow?: string;
    ClusterParameterGroupName?: string;
    AutomatedSnapshotRetentionPeriod?: number;
    Port?: number;
    ClusterVersion?: string;
    AllowVersionUpgrade?: boolean;
    NumberOfNodes?: number;
    PubliclyAccessible?: boolean;
    Encrypted?: boolean;
    HsmClientCertificateIdentifier?: string;
    HsmConfigurationIdentifier?: string;
    ElasticIp?: string;
    Tags?: Redshift$20121201$TagList;
    KmsKeyId?: string;
    AdditionalInfo?: string;
    IamRoles?: Redshift$20121201$IamRoleArnList;
  };
  declare type Redshift$20121201$CreateClusterParameterGroupMessage = {
    ParameterGroupName: string;
    ParameterGroupFamily: string;
    Description: string;
    Tags?: Redshift$20121201$TagList;
  };
  declare type Redshift$20121201$CreateClusterParameterGroupResult = {
    ClusterParameterGroup?: Redshift$20121201$ClusterParameterGroup;
  };
  declare type Redshift$20121201$CreateClusterResult = {
    Cluster?: Redshift$20121201$Cluster;
  };
  declare type Redshift$20121201$CreateClusterSecurityGroupMessage = {
    ClusterSecurityGroupName: string;
    Description: string;
    Tags?: Redshift$20121201$TagList;
  };
  declare type Redshift$20121201$CreateClusterSecurityGroupResult = {
    ClusterSecurityGroup?: Redshift$20121201$ClusterSecurityGroup;
  };
  declare type Redshift$20121201$CreateClusterSnapshotMessage = {
    SnapshotIdentifier: string;
    ClusterIdentifier: string;
    Tags?: Redshift$20121201$TagList;
  };
  declare type Redshift$20121201$CreateClusterSnapshotResult = {
    Snapshot?: Redshift$20121201$Snapshot;
  };
  declare type Redshift$20121201$CreateClusterSubnetGroupMessage = {
    ClusterSubnetGroupName: string;
    Description: string;
    SubnetIds: Redshift$20121201$SubnetIdentifierList;
    Tags?: Redshift$20121201$TagList;
  };
  declare type Redshift$20121201$CreateClusterSubnetGroupResult = {
    ClusterSubnetGroup?: Redshift$20121201$ClusterSubnetGroup;
  };
  declare type Redshift$20121201$CreateEventSubscriptionMessage = {
    SubscriptionName: string;
    SnsTopicArn: string;
    SourceType?: string;
    SourceIds?: Redshift$20121201$SourceIdsList;
    EventCategories?: Redshift$20121201$EventCategoriesList;
    Severity?: string;
    Enabled?: boolean;
    Tags?: Redshift$20121201$TagList;
  };
  declare type Redshift$20121201$CreateEventSubscriptionResult = {
    EventSubscription?: Redshift$20121201$EventSubscription;
  };
  declare type Redshift$20121201$CreateHsmClientCertificateMessage = {
    HsmClientCertificateIdentifier: string;
    Tags?: Redshift$20121201$TagList;
  };
  declare type Redshift$20121201$CreateHsmClientCertificateResult = {
    HsmClientCertificate?: Redshift$20121201$HsmClientCertificate;
  };
  declare type Redshift$20121201$CreateHsmConfigurationMessage = {
    HsmConfigurationIdentifier: string;
    Description: string;
    HsmIpAddress: string;
    HsmPartitionName: string;
    HsmPartitionPassword: string;
    HsmServerPublicCertificate: string;
    Tags?: Redshift$20121201$TagList;
  };
  declare type Redshift$20121201$CreateHsmConfigurationResult = {
    HsmConfiguration?: Redshift$20121201$HsmConfiguration;
  };
  declare type Redshift$20121201$CreateSnapshotCopyGrantMessage = {
    SnapshotCopyGrantName: string;
    KmsKeyId?: string;
    Tags?: Redshift$20121201$TagList;
  };
  declare type Redshift$20121201$CreateSnapshotCopyGrantResult = {
    SnapshotCopyGrant?: Redshift$20121201$SnapshotCopyGrant;
  };
  declare type Redshift$20121201$CreateTagsMessage = {
    ResourceName: string;
    Tags: Redshift$20121201$TagList;
  };
  declare type Redshift$20121201$DefaultClusterParameters = {
    ParameterGroupFamily?: string;
    Marker?: string;
    Parameters?: Redshift$20121201$ParametersList;
  };
  declare type Redshift$20121201$DeleteClusterMessage = {
    ClusterIdentifier: string;
    SkipFinalClusterSnapshot?: boolean;
    FinalClusterSnapshotIdentifier?: string;
  };
  declare type Redshift$20121201$DeleteClusterParameterGroupMessage = {
    ParameterGroupName: string;
  };
  declare type Redshift$20121201$DeleteClusterResult = {
    Cluster?: Redshift$20121201$Cluster;
  };
  declare type Redshift$20121201$DeleteClusterSecurityGroupMessage = {
    ClusterSecurityGroupName: string;
  };
  declare type Redshift$20121201$DeleteClusterSnapshotMessage = {
    SnapshotIdentifier: string;
    SnapshotClusterIdentifier?: string;
  };
  declare type Redshift$20121201$DeleteClusterSnapshotResult = {
    Snapshot?: Redshift$20121201$Snapshot;
  };
  declare type Redshift$20121201$DeleteClusterSubnetGroupMessage = {
    ClusterSubnetGroupName: string;
  };
  declare type Redshift$20121201$DeleteEventSubscriptionMessage = {
    SubscriptionName: string;
  };
  declare type Redshift$20121201$DeleteHsmClientCertificateMessage = {
    HsmClientCertificateIdentifier: string;
  };
  declare type Redshift$20121201$DeleteHsmConfigurationMessage = {
    HsmConfigurationIdentifier: string;
  };
  declare type Redshift$20121201$DeleteSnapshotCopyGrantMessage = {
    SnapshotCopyGrantName: string;
  };
  declare type Redshift$20121201$DeleteTagsMessage = {
    ResourceName: string;
    TagKeys: Redshift$20121201$TagKeyList;
  };
  declare type Redshift$20121201$DependentServiceRequestThrottlingFault = {};
  declare type Redshift$20121201$DescribeClusterParameterGroupsMessage = {
    ParameterGroupName?: string;
    MaxRecords?: number;
    Marker?: string;
    TagKeys?: Redshift$20121201$TagKeyList;
    TagValues?: Redshift$20121201$TagValueList;
  };
  declare type Redshift$20121201$DescribeClusterParametersMessage = {
    ParameterGroupName: string;
    Source?: string;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type Redshift$20121201$DescribeClusterSecurityGroupsMessage = {
    ClusterSecurityGroupName?: string;
    MaxRecords?: number;
    Marker?: string;
    TagKeys?: Redshift$20121201$TagKeyList;
    TagValues?: Redshift$20121201$TagValueList;
  };
  declare type Redshift$20121201$DescribeClusterSnapshotsMessage = {
    ClusterIdentifier?: string;
    SnapshotIdentifier?: string;
    SnapshotType?: string;
    StartTime?: Date;
    EndTime?: Date;
    MaxRecords?: number;
    Marker?: string;
    OwnerAccount?: string;
    TagKeys?: Redshift$20121201$TagKeyList;
    TagValues?: Redshift$20121201$TagValueList;
  };
  declare type Redshift$20121201$DescribeClusterSubnetGroupsMessage = {
    ClusterSubnetGroupName?: string;
    MaxRecords?: number;
    Marker?: string;
    TagKeys?: Redshift$20121201$TagKeyList;
    TagValues?: Redshift$20121201$TagValueList;
  };
  declare type Redshift$20121201$DescribeClusterVersionsMessage = {
    ClusterVersion?: string;
    ClusterParameterGroupFamily?: string;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type Redshift$20121201$DescribeClustersMessage = {
    ClusterIdentifier?: string;
    MaxRecords?: number;
    Marker?: string;
    TagKeys?: Redshift$20121201$TagKeyList;
    TagValues?: Redshift$20121201$TagValueList;
  };
  declare type Redshift$20121201$DescribeDefaultClusterParametersMessage = {
    ParameterGroupFamily: string;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type Redshift$20121201$DescribeDefaultClusterParametersResult = {
    DefaultClusterParameters?: Redshift$20121201$DefaultClusterParameters;
  };
  declare type Redshift$20121201$DescribeEventCategoriesMessage = {
    SourceType?: string;
  };
  declare type Redshift$20121201$DescribeEventSubscriptionsMessage = {
    SubscriptionName?: string;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type Redshift$20121201$DescribeEventsMessage = {
    SourceIdentifier?: string;
    SourceType?: 'cluster' | 'cluster-parameter-group' | 'cluster-security-group' | 'cluster-snapshot';
    StartTime?: Date;
    EndTime?: Date;
    Duration?: number;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type Redshift$20121201$DescribeHsmClientCertificatesMessage = {
    HsmClientCertificateIdentifier?: string;
    MaxRecords?: number;
    Marker?: string;
    TagKeys?: Redshift$20121201$TagKeyList;
    TagValues?: Redshift$20121201$TagValueList;
  };
  declare type Redshift$20121201$DescribeHsmConfigurationsMessage = {
    HsmConfigurationIdentifier?: string;
    MaxRecords?: number;
    Marker?: string;
    TagKeys?: Redshift$20121201$TagKeyList;
    TagValues?: Redshift$20121201$TagValueList;
  };
  declare type Redshift$20121201$DescribeLoggingStatusMessage = {
    ClusterIdentifier: string;
  };
  declare type Redshift$20121201$DescribeOrderableClusterOptionsMessage = {
    ClusterVersion?: string;
    NodeType?: string;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type Redshift$20121201$DescribeReservedNodeOfferingsMessage = {
    ReservedNodeOfferingId?: string;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type Redshift$20121201$DescribeReservedNodesMessage = {
    ReservedNodeId?: string;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type Redshift$20121201$DescribeResizeMessage = {
    ClusterIdentifier: string;
  };
  declare type Redshift$20121201$DescribeSnapshotCopyGrantsMessage = {
    SnapshotCopyGrantName?: string;
    MaxRecords?: number;
    Marker?: string;
    TagKeys?: Redshift$20121201$TagKeyList;
    TagValues?: Redshift$20121201$TagValueList;
  };
  declare type Redshift$20121201$DescribeTableRestoreStatusMessage = {
    ClusterIdentifier?: string;
    TableRestoreRequestId?: string;
    MaxRecords?: number;
    Marker?: string;
  };
  declare type Redshift$20121201$DescribeTagsMessage = {
    ResourceName?: string;
    ResourceType?: string;
    MaxRecords?: number;
    Marker?: string;
    TagKeys?: Redshift$20121201$TagKeyList;
    TagValues?: Redshift$20121201$TagValueList;
  };
  declare type Redshift$20121201$DisableLoggingMessage = {
    ClusterIdentifier: string;
  };
  declare type Redshift$20121201$DisableSnapshotCopyMessage = {
    ClusterIdentifier: string;
  };
  declare type Redshift$20121201$DisableSnapshotCopyResult = {
    Cluster?: Redshift$20121201$Cluster;
  };
  declare type Redshift$20121201$EC2SecurityGroup = {
    Status?: string;
    EC2SecurityGroupName?: string;
    EC2SecurityGroupOwnerId?: string;
    Tags?: Redshift$20121201$TagList;
  };
  declare type Redshift$20121201$EC2SecurityGroupList = Redshift$20121201$EC2SecurityGroup[];
  declare type Redshift$20121201$ElasticIpStatus = {
    ElasticIp?: string;
    Status?: string;
  };
  declare type Redshift$20121201$EnableLoggingMessage = {
    ClusterIdentifier: string;
    BucketName: string;
    S3KeyPrefix?: string;
  };
  declare type Redshift$20121201$EnableSnapshotCopyMessage = {
    ClusterIdentifier: string;
    DestinationRegion: string;
    RetentionPeriod?: number;
    SnapshotCopyGrantName?: string;
  };
  declare type Redshift$20121201$EnableSnapshotCopyResult = {
    Cluster?: Redshift$20121201$Cluster;
  };
  declare type Redshift$20121201$Endpoint = {
    Address?: string;
    Port?: number;
  };
  declare type Redshift$20121201$Event = {
    SourceIdentifier?: string;
    SourceType?: 'cluster' | 'cluster-parameter-group' | 'cluster-security-group' | 'cluster-snapshot';
    Message?: string;
    EventCategories?: Redshift$20121201$EventCategoriesList;
    Severity?: string;
    Date?: Date;
    EventId?: string;
  };
  declare type Redshift$20121201$EventCategoriesList = string[];
  declare type Redshift$20121201$EventCategoriesMap = {
    SourceType?: string;
    Events?: Redshift$20121201$EventInfoMapList;
  };
  declare type Redshift$20121201$EventCategoriesMapList = Redshift$20121201$EventCategoriesMap[];
  declare type Redshift$20121201$EventCategoriesMessage = {
    EventCategoriesMapList?: Redshift$20121201$EventCategoriesMapList;
  };
  declare type Redshift$20121201$EventInfoMap = {
    EventId?: string;
    EventCategories?: Redshift$20121201$EventCategoriesList;
    EventDescription?: string;
    Severity?: string;
  };
  declare type Redshift$20121201$EventInfoMapList = Redshift$20121201$EventInfoMap[];
  declare type Redshift$20121201$EventList = Redshift$20121201$Event[];
  declare type Redshift$20121201$EventSubscription = {
    CustomerAwsId?: string;
    CustSubscriptionId?: string;
    SnsTopicArn?: string;
    Status?: string;
    SubscriptionCreationTime?: Date;
    SourceType?: string;
    SourceIdsList?: Redshift$20121201$SourceIdsList;
    EventCategoriesList?: Redshift$20121201$EventCategoriesList;
    Severity?: string;
    Enabled?: boolean;
    Tags?: Redshift$20121201$TagList;
  };
  declare type Redshift$20121201$EventSubscriptionQuotaExceededFault = {};
  declare type Redshift$20121201$EventSubscriptionsList = Redshift$20121201$EventSubscription[];
  declare type Redshift$20121201$EventSubscriptionsMessage = {
    Marker?: string;
    EventSubscriptionsList?: Redshift$20121201$EventSubscriptionsList;
  };
  declare type Redshift$20121201$EventsMessage = {
    Marker?: string;
    Events?: Redshift$20121201$EventList;
  };
  declare type Redshift$20121201$HsmClientCertificate = {
    HsmClientCertificateIdentifier?: string;
    HsmClientCertificatePublicKey?: string;
    Tags?: Redshift$20121201$TagList;
  };
  declare type Redshift$20121201$HsmClientCertificateAlreadyExistsFault = {};
  declare type Redshift$20121201$HsmClientCertificateList = Redshift$20121201$HsmClientCertificate[];
  declare type Redshift$20121201$HsmClientCertificateMessage = {
    Marker?: string;
    HsmClientCertificates?: Redshift$20121201$HsmClientCertificateList;
  };
  declare type Redshift$20121201$HsmClientCertificateNotFoundFault = {};
  declare type Redshift$20121201$HsmClientCertificateQuotaExceededFault = {};
  declare type Redshift$20121201$HsmConfiguration = {
    HsmConfigurationIdentifier?: string;
    Description?: string;
    HsmIpAddress?: string;
    HsmPartitionName?: string;
    Tags?: Redshift$20121201$TagList;
  };
  declare type Redshift$20121201$HsmConfigurationAlreadyExistsFault = {};
  declare type Redshift$20121201$HsmConfigurationList = Redshift$20121201$HsmConfiguration[];
  declare type Redshift$20121201$HsmConfigurationMessage = {
    Marker?: string;
    HsmConfigurations?: Redshift$20121201$HsmConfigurationList;
  };
  declare type Redshift$20121201$HsmConfigurationNotFoundFault = {};
  declare type Redshift$20121201$HsmConfigurationQuotaExceededFault = {};
  declare type Redshift$20121201$HsmStatus = {
    HsmClientCertificateIdentifier?: string;
    HsmConfigurationIdentifier?: string;
    Status?: string;
  };
  declare type Redshift$20121201$IPRange = {
    Status?: string;
    CIDRIP?: string;
    Tags?: Redshift$20121201$TagList;
  };
  declare type Redshift$20121201$IPRangeList = Redshift$20121201$IPRange[];
  declare type Redshift$20121201$IamRoleArnList = string[];
  declare type Redshift$20121201$ImportTablesCompleted = string[];
  declare type Redshift$20121201$ImportTablesInProgress = string[];
  declare type Redshift$20121201$ImportTablesNotStarted = string[];
  declare type Redshift$20121201$InProgressTableRestoreQuotaExceededFault = {};
  declare type Redshift$20121201$IncompatibleOrderableOptions = {};
  declare type Redshift$20121201$InsufficientClusterCapacityFault = {};
  declare type Redshift$20121201$InsufficientS3BucketPolicyFault = {};
  declare type Redshift$20121201$InvalidClusterParameterGroupStateFault = {};
  declare type Redshift$20121201$InvalidClusterSecurityGroupStateFault = {};
  declare type Redshift$20121201$InvalidClusterSnapshotStateFault = {};
  declare type Redshift$20121201$InvalidClusterStateFault = {};
  declare type Redshift$20121201$InvalidClusterSubnetGroupStateFault = {};
  declare type Redshift$20121201$InvalidClusterSubnetStateFault = {};
  declare type Redshift$20121201$InvalidElasticIpFault = {};
  declare type Redshift$20121201$InvalidHsmClientCertificateStateFault = {};
  declare type Redshift$20121201$InvalidHsmConfigurationStateFault = {};
  declare type Redshift$20121201$InvalidRestoreFault = {};
  declare type Redshift$20121201$InvalidS3BucketNameFault = {};
  declare type Redshift$20121201$InvalidS3KeyPrefixFault = {};
  declare type Redshift$20121201$InvalidSnapshotCopyGrantStateFault = {};
  declare type Redshift$20121201$InvalidSubnet = {};
  declare type Redshift$20121201$InvalidSubscriptionStateFault = {};
  declare type Redshift$20121201$InvalidTableRestoreArgumentFault = {};
  declare type Redshift$20121201$InvalidTagFault = {};
  declare type Redshift$20121201$InvalidVPCNetworkStateFault = {};
  declare type Redshift$20121201$LimitExceededFault = {};
  declare type Redshift$20121201$LoggingStatus = {
    LoggingEnabled?: boolean;
    BucketName?: string;
    S3KeyPrefix?: string;
    LastSuccessfulDeliveryTime?: Date;
    LastFailureTime?: Date;
    LastFailureMessage?: string;
  };
  declare type Redshift$20121201$ModifyClusterIamRolesMessage = {
    ClusterIdentifier: string;
    AddIamRoles?: Redshift$20121201$IamRoleArnList;
    RemoveIamRoles?: Redshift$20121201$IamRoleArnList;
  };
  declare type Redshift$20121201$ModifyClusterIamRolesResult = {
    Cluster?: Redshift$20121201$Cluster;
  };
  declare type Redshift$20121201$ModifyClusterMessage = {
    ClusterIdentifier: string;
    ClusterType?: string;
    NodeType?: string;
    NumberOfNodes?: number;
    ClusterSecurityGroups?: Redshift$20121201$ClusterSecurityGroupNameList;
    VpcSecurityGroupIds?: Redshift$20121201$VpcSecurityGroupIdList;
    MasterUserPassword?: string;
    ClusterParameterGroupName?: string;
    AutomatedSnapshotRetentionPeriod?: number;
    PreferredMaintenanceWindow?: string;
    ClusterVersion?: string;
    AllowVersionUpgrade?: boolean;
    HsmClientCertificateIdentifier?: string;
    HsmConfigurationIdentifier?: string;
    NewClusterIdentifier?: string;
    PubliclyAccessible?: boolean;
    ElasticIp?: string;
  };
  declare type Redshift$20121201$ModifyClusterParameterGroupMessage = {
    ParameterGroupName: string;
    Parameters: Redshift$20121201$ParametersList;
  };
  declare type Redshift$20121201$ModifyClusterResult = {
    Cluster?: Redshift$20121201$Cluster;
  };
  declare type Redshift$20121201$ModifyClusterSubnetGroupMessage = {
    ClusterSubnetGroupName: string;
    Description?: string;
    SubnetIds: Redshift$20121201$SubnetIdentifierList;
  };
  declare type Redshift$20121201$ModifyClusterSubnetGroupResult = {
    ClusterSubnetGroup?: Redshift$20121201$ClusterSubnetGroup;
  };
  declare type Redshift$20121201$ModifyEventSubscriptionMessage = {
    SubscriptionName: string;
    SnsTopicArn?: string;
    SourceType?: string;
    SourceIds?: Redshift$20121201$SourceIdsList;
    EventCategories?: Redshift$20121201$EventCategoriesList;
    Severity?: string;
    Enabled?: boolean;
  };
  declare type Redshift$20121201$ModifyEventSubscriptionResult = {
    EventSubscription?: Redshift$20121201$EventSubscription;
  };
  declare type Redshift$20121201$ModifySnapshotCopyRetentionPeriodMessage = {
    ClusterIdentifier: string;
    RetentionPeriod: number;
  };
  declare type Redshift$20121201$ModifySnapshotCopyRetentionPeriodResult = {
    Cluster?: Redshift$20121201$Cluster;
  };
  declare type Redshift$20121201$NumberOfNodesPerClusterLimitExceededFault = {};
  declare type Redshift$20121201$NumberOfNodesQuotaExceededFault = {};
  declare type Redshift$20121201$OrderableClusterOption = {
    ClusterVersion?: string;
    ClusterType?: string;
    NodeType?: string;
    AvailabilityZones?: Redshift$20121201$AvailabilityZoneList;
  };
  declare type Redshift$20121201$OrderableClusterOptionsList = Redshift$20121201$OrderableClusterOption[];
  declare type Redshift$20121201$OrderableClusterOptionsMessage = {
    OrderableClusterOptions?: Redshift$20121201$OrderableClusterOptionsList;
    Marker?: string;
  };
  declare type Redshift$20121201$Parameter = {
    ParameterName?: string;
    ParameterValue?: string;
    Description?: string;
    Source?: string;
    DataType?: string;
    AllowedValues?: string;
    ApplyType?: 'static' | 'dynamic';
    IsModifiable?: boolean;
    MinimumEngineVersion?: string;
  };
  declare type Redshift$20121201$ParameterApplyType = 'static' | 'dynamic';
  declare type Redshift$20121201$ParameterGroupList = Redshift$20121201$ClusterParameterGroup[];
  declare type Redshift$20121201$ParametersList = Redshift$20121201$Parameter[];
  declare type Redshift$20121201$PendingModifiedValues = {
    MasterUserPassword?: string;
    NodeType?: string;
    NumberOfNodes?: number;
    ClusterType?: string;
    ClusterVersion?: string;
    AutomatedSnapshotRetentionPeriod?: number;
    ClusterIdentifier?: string;
    PubliclyAccessible?: boolean;
  };
  declare type Redshift$20121201$PurchaseReservedNodeOfferingMessage = {
    ReservedNodeOfferingId: string;
    NodeCount?: number;
  };
  declare type Redshift$20121201$PurchaseReservedNodeOfferingResult = {
    ReservedNode?: Redshift$20121201$ReservedNode;
  };
  declare type Redshift$20121201$RebootClusterMessage = {
    ClusterIdentifier: string;
  };
  declare type Redshift$20121201$RebootClusterResult = {
    Cluster?: Redshift$20121201$Cluster;
  };
  declare type Redshift$20121201$RecurringCharge = {
    RecurringChargeAmount?: number;
    RecurringChargeFrequency?: string;
  };
  declare type Redshift$20121201$RecurringChargeList = Redshift$20121201$RecurringCharge[];
  declare type Redshift$20121201$ReservedNode = {
    ReservedNodeId?: string;
    ReservedNodeOfferingId?: string;
    NodeType?: string;
    StartTime?: Date;
    Duration?: number;
    FixedPrice?: number;
    UsagePrice?: number;
    CurrencyCode?: string;
    NodeCount?: number;
    State?: string;
    OfferingType?: string;
    RecurringCharges?: Redshift$20121201$RecurringChargeList;
  };
  declare type Redshift$20121201$ReservedNodeAlreadyExistsFault = {};
  declare type Redshift$20121201$ReservedNodeList = Redshift$20121201$ReservedNode[];
  declare type Redshift$20121201$ReservedNodeNotFoundFault = {};
  declare type Redshift$20121201$ReservedNodeOffering = {
    ReservedNodeOfferingId?: string;
    NodeType?: string;
    Duration?: number;
    FixedPrice?: number;
    UsagePrice?: number;
    CurrencyCode?: string;
    OfferingType?: string;
    RecurringCharges?: Redshift$20121201$RecurringChargeList;
  };
  declare type Redshift$20121201$ReservedNodeOfferingList = Redshift$20121201$ReservedNodeOffering[];
  declare type Redshift$20121201$ReservedNodeOfferingNotFoundFault = {};
  declare type Redshift$20121201$ReservedNodeOfferingsMessage = {
    Marker?: string;
    ReservedNodeOfferings?: Redshift$20121201$ReservedNodeOfferingList;
  };
  declare type Redshift$20121201$ReservedNodeQuotaExceededFault = {};
  declare type Redshift$20121201$ReservedNodesMessage = {
    Marker?: string;
    ReservedNodes?: Redshift$20121201$ReservedNodeList;
  };
  declare type Redshift$20121201$ResetClusterParameterGroupMessage = {
    ParameterGroupName: string;
    ResetAllParameters?: boolean;
    Parameters?: Redshift$20121201$ParametersList;
  };
  declare type Redshift$20121201$ResizeNotFoundFault = {};
  declare type Redshift$20121201$ResizeProgressMessage = {
    TargetNodeType?: string;
    TargetNumberOfNodes?: number;
    TargetClusterType?: string;
    Status?: string;
    ImportTablesCompleted?: Redshift$20121201$ImportTablesCompleted;
    ImportTablesInProgress?: Redshift$20121201$ImportTablesInProgress;
    ImportTablesNotStarted?: Redshift$20121201$ImportTablesNotStarted;
    AvgResizeRateInMegaBytesPerSecond?: number;
    TotalResizeDataInMegaBytes?: number;
    ProgressInMegaBytes?: number;
    ElapsedTimeInSeconds?: number;
    EstimatedTimeToCompletionInSeconds?: number;
  };
  declare type Redshift$20121201$ResourceNotFoundFault = {};
  declare type Redshift$20121201$RestorableNodeTypeList = string[];
  declare type Redshift$20121201$RestoreFromClusterSnapshotMessage = {
    ClusterIdentifier: string;
    SnapshotIdentifier: string;
    SnapshotClusterIdentifier?: string;
    Port?: number;
    AvailabilityZone?: string;
    AllowVersionUpgrade?: boolean;
    ClusterSubnetGroupName?: string;
    PubliclyAccessible?: boolean;
    OwnerAccount?: string;
    HsmClientCertificateIdentifier?: string;
    HsmConfigurationIdentifier?: string;
    ElasticIp?: string;
    ClusterParameterGroupName?: string;
    ClusterSecurityGroups?: Redshift$20121201$ClusterSecurityGroupNameList;
    VpcSecurityGroupIds?: Redshift$20121201$VpcSecurityGroupIdList;
    PreferredMaintenanceWindow?: string;
    AutomatedSnapshotRetentionPeriod?: number;
    KmsKeyId?: string;
    NodeType?: string;
    AdditionalInfo?: string;
    IamRoles?: Redshift$20121201$IamRoleArnList;
  };
  declare type Redshift$20121201$RestoreFromClusterSnapshotResult = {
    Cluster?: Redshift$20121201$Cluster;
  };
  declare type Redshift$20121201$RestoreStatus = {
    Status?: string;
    CurrentRestoreRateInMegaBytesPerSecond?: number;
    SnapshotSizeInMegaBytes?: number;
    ProgressInMegaBytes?: number;
    ElapsedTimeInSeconds?: number;
    EstimatedTimeToCompletionInSeconds?: number;
  };
  declare type Redshift$20121201$RestoreTableFromClusterSnapshotMessage = {
    ClusterIdentifier: string;
    SnapshotIdentifier: string;
    SourceDatabaseName: string;
    SourceSchemaName?: string;
    SourceTableName: string;
    TargetDatabaseName?: string;
    TargetSchemaName?: string;
    NewTableName: string;
  };
  declare type Redshift$20121201$RestoreTableFromClusterSnapshotResult = {
    TableRestoreStatus?: Redshift$20121201$TableRestoreStatus;
  };
  declare type Redshift$20121201$RevokeClusterSecurityGroupIngressMessage = {
    ClusterSecurityGroupName: string;
    CIDRIP?: string;
    EC2SecurityGroupName?: string;
    EC2SecurityGroupOwnerId?: string;
  };
  declare type Redshift$20121201$RevokeClusterSecurityGroupIngressResult = {
    ClusterSecurityGroup?: Redshift$20121201$ClusterSecurityGroup;
  };
  declare type Redshift$20121201$RevokeSnapshotAccessMessage = {
    SnapshotIdentifier: string;
    SnapshotClusterIdentifier?: string;
    AccountWithRestoreAccess: string;
  };
  declare type Redshift$20121201$RevokeSnapshotAccessResult = {
    Snapshot?: Redshift$20121201$Snapshot;
  };
  declare type Redshift$20121201$RotateEncryptionKeyMessage = {
    ClusterIdentifier: string;
  };
  declare type Redshift$20121201$RotateEncryptionKeyResult = {
    Cluster?: Redshift$20121201$Cluster;
  };
  declare type Redshift$20121201$SNSInvalidTopicFault = {};
  declare type Redshift$20121201$SNSNoAuthorizationFault = {};
  declare type Redshift$20121201$SNSTopicArnNotFoundFault = {};
  declare type Redshift$20121201$Snapshot = {
    SnapshotIdentifier?: string;
    ClusterIdentifier?: string;
    SnapshotCreateTime?: Date;
    Status?: string;
    Port?: number;
    AvailabilityZone?: string;
    ClusterCreateTime?: Date;
    MasterUsername?: string;
    ClusterVersion?: string;
    SnapshotType?: string;
    NodeType?: string;
    NumberOfNodes?: number;
    DBName?: string;
    VpcId?: string;
    Encrypted?: boolean;
    KmsKeyId?: string;
    EncryptedWithHSM?: boolean;
    AccountsWithRestoreAccess?: Redshift$20121201$AccountsWithRestoreAccessList;
    OwnerAccount?: string;
    TotalBackupSizeInMegaBytes?: number;
    ActualIncrementalBackupSizeInMegaBytes?: number;
    BackupProgressInMegaBytes?: number;
    CurrentBackupRateInMegaBytesPerSecond?: number;
    EstimatedSecondsToCompletion?: number;
    ElapsedTimeInSeconds?: number;
    SourceRegion?: string;
    Tags?: Redshift$20121201$TagList;
    RestorableNodeTypes?: Redshift$20121201$RestorableNodeTypeList;
  };
  declare type Redshift$20121201$SnapshotCopyAlreadyDisabledFault = {};
  declare type Redshift$20121201$SnapshotCopyAlreadyEnabledFault = {};
  declare type Redshift$20121201$SnapshotCopyDisabledFault = {};
  declare type Redshift$20121201$SnapshotCopyGrant = {
    SnapshotCopyGrantName?: string;
    KmsKeyId?: string;
    Tags?: Redshift$20121201$TagList;
  };
  declare type Redshift$20121201$SnapshotCopyGrantAlreadyExistsFault = {};
  declare type Redshift$20121201$SnapshotCopyGrantList = Redshift$20121201$SnapshotCopyGrant[];
  declare type Redshift$20121201$SnapshotCopyGrantMessage = {
    Marker?: string;
    SnapshotCopyGrants?: Redshift$20121201$SnapshotCopyGrantList;
  };
  declare type Redshift$20121201$SnapshotCopyGrantNotFoundFault = {};
  declare type Redshift$20121201$SnapshotCopyGrantQuotaExceededFault = {};
  declare type Redshift$20121201$SnapshotList = Redshift$20121201$Snapshot[];
  declare type Redshift$20121201$SnapshotMessage = {
    Marker?: string;
    Snapshots?: Redshift$20121201$SnapshotList;
  };
  declare type Redshift$20121201$SourceIdsList = string[];
  declare type Redshift$20121201$SourceNotFoundFault = {};
  declare type Redshift$20121201$SourceType = 'cluster' | 'cluster-parameter-group' | 'cluster-security-group' | 'cluster-snapshot';
  declare type Redshift$20121201$Subnet = {
    SubnetIdentifier?: string;
    SubnetAvailabilityZone?: Redshift$20121201$AvailabilityZone;
    SubnetStatus?: string;
  };
  declare type Redshift$20121201$SubnetAlreadyInUse = {};
  declare type Redshift$20121201$SubnetIdentifierList = string[];
  declare type Redshift$20121201$SubnetList = Redshift$20121201$Subnet[];
  declare type Redshift$20121201$SubscriptionAlreadyExistFault = {};
  declare type Redshift$20121201$SubscriptionCategoryNotFoundFault = {};
  declare type Redshift$20121201$SubscriptionEventIdNotFoundFault = {};
  declare type Redshift$20121201$SubscriptionNotFoundFault = {};
  declare type Redshift$20121201$SubscriptionSeverityNotFoundFault = {};
  declare type Redshift$20121201$TStamp = Date;
  declare type Redshift$20121201$TableRestoreNotFoundFault = {};
  declare type Redshift$20121201$TableRestoreStatus = {
    TableRestoreRequestId?: string;
    Status?: 'PENDING' | 'IN_PROGRESS' | 'SUCCEEDED' | 'FAILED' | 'CANCELED';
    Message?: string;
    RequestTime?: Date;
    ProgressInMegaBytes?: number;
    TotalDataInMegaBytes?: number;
    ClusterIdentifier?: string;
    SnapshotIdentifier?: string;
    SourceDatabaseName?: string;
    SourceSchemaName?: string;
    SourceTableName?: string;
    TargetDatabaseName?: string;
    TargetSchemaName?: string;
    NewTableName?: string;
  };
  declare type Redshift$20121201$TableRestoreStatusList = Redshift$20121201$TableRestoreStatus[];
  declare type Redshift$20121201$TableRestoreStatusMessage = {
    TableRestoreStatusDetails?: Redshift$20121201$TableRestoreStatusList;
    Marker?: string;
  };
  declare type Redshift$20121201$TableRestoreStatusType = 'PENDING' | 'IN_PROGRESS' | 'SUCCEEDED' | 'FAILED' | 'CANCELED';
  declare type Redshift$20121201$Tag = {
    Key?: string;
    Value?: string;
  };
  declare type Redshift$20121201$TagKeyList = string[];
  declare type Redshift$20121201$TagLimitExceededFault = {};
  declare type Redshift$20121201$TagList = Redshift$20121201$Tag[];
  declare type Redshift$20121201$TagValueList = string[];
  declare type Redshift$20121201$TaggedResource = {
    Tag?: Redshift$20121201$Tag;
    ResourceName?: string;
    ResourceType?: string;
  };
  declare type Redshift$20121201$TaggedResourceList = Redshift$20121201$TaggedResource[];
  declare type Redshift$20121201$TaggedResourceListMessage = {
    TaggedResources?: Redshift$20121201$TaggedResourceList;
    Marker?: string;
  };
  declare type Redshift$20121201$UnauthorizedOperation = {};
  declare type Redshift$20121201$UnknownSnapshotCopyRegionFault = {};
  declare type Redshift$20121201$UnsupportedOperationFault = {};
  declare type Redshift$20121201$UnsupportedOptionFault = {};
  declare type Redshift$20121201$VpcSecurityGroupIdList = string[];
  declare type Redshift$20121201$VpcSecurityGroupMembership = {
    VpcSecurityGroupId?: string;
    Status?: string;
  };
  declare type Redshift$20121201$VpcSecurityGroupMembershipList = Redshift$20121201$VpcSecurityGroupMembership[];
  declare type Route53$20130401$AlarmIdentifier = {
    Region: 'us-east-1' | 'us-west-1' | 'us-west-2' | 'eu-central-1' | 'eu-west-1' | 'ap-southeast-1' | 'ap-southeast-2' | 'ap-northeast-1' | 'ap-northeast-2' | 'sa-east-1';
    Name: string;
  };
  declare type Route53$20130401$AliasTarget = {
    HostedZoneId: string;
    DNSName: string;
    EvaluateTargetHealth: boolean;
  };
  declare type Route53$20130401$AssociateVPCWithHostedZoneRequest = {
    HostedZoneId: string;
    VPC: Route53$20130401$VPC;
    Comment?: string;
  };
  declare type Route53$20130401$AssociateVPCWithHostedZoneResponse = {
    ChangeInfo: Route53$20130401$ChangeInfo;
  };
  declare type Route53$20130401$Change = {
    Action: 'CREATE' | 'DELETE' | 'UPSERT';
    ResourceRecordSet: Route53$20130401$ResourceRecordSet;
  };
  declare type Route53$20130401$ChangeAction = 'CREATE' | 'DELETE' | 'UPSERT';
  declare type Route53$20130401$ChangeBatch = {
    Comment?: string;
    Changes: Route53$20130401$Changes;
  };
  declare type Route53$20130401$ChangeBatchRecord = {
    Id: string;
    SubmittedAt?: Date;
    Status: 'PENDING' | 'INSYNC';
    Comment?: string;
    Submitter?: string;
    Changes?: Route53$20130401$Changes;
  };
  declare type Route53$20130401$ChangeBatchRecords = Route53$20130401$ChangeBatchRecord[];
  declare type Route53$20130401$ChangeInfo = {
    Id: string;
    Status: 'PENDING' | 'INSYNC';
    SubmittedAt: Date;
    Comment?: string;
  };
  declare type Route53$20130401$ChangeResourceRecordSetsRequest = {
    HostedZoneId: string;
    ChangeBatch: Route53$20130401$ChangeBatch;
  };
  declare type Route53$20130401$ChangeResourceRecordSetsResponse = {
    ChangeInfo: Route53$20130401$ChangeInfo;
  };
  declare type Route53$20130401$ChangeStatus = 'PENDING' | 'INSYNC';
  declare type Route53$20130401$ChangeTagsForResourceRequest = {
    ResourceType: 'healthcheck' | 'hostedzone';
    ResourceId: string;
    AddTags?: Route53$20130401$TagList;
    RemoveTagKeys?: Route53$20130401$TagKeyList;
  };
  declare type Route53$20130401$ChangeTagsForResourceResponse = {};
  declare type Route53$20130401$Changes = Route53$20130401$Change[];
  declare type Route53$20130401$CheckerIpRanges = string[];
  declare type Route53$20130401$ChildHealthCheckList = string[];
  declare type Route53$20130401$CloudWatchAlarmConfiguration = {
    EvaluationPeriods: number;
    Threshold: number;
    ComparisonOperator: 'GreaterThanOrEqualToThreshold' | 'GreaterThanThreshold' | 'LessThanThreshold' | 'LessThanOrEqualToThreshold';
    Period: number;
    MetricName: string;
    Namespace: string;
    Statistic: 'Average' | 'Sum' | 'SampleCount' | 'Maximum' | 'Minimum';
    Dimensions?: Route53$20130401$DimensionList;
  };
  declare type Route53$20130401$CloudWatchRegion = 'us-east-1' | 'us-west-1' | 'us-west-2' | 'eu-central-1' | 'eu-west-1' | 'ap-southeast-1' | 'ap-southeast-2' | 'ap-northeast-1' | 'ap-northeast-2' | 'sa-east-1';
  declare type Route53$20130401$ComparisonOperator = 'GreaterThanOrEqualToThreshold' | 'GreaterThanThreshold' | 'LessThanThreshold' | 'LessThanOrEqualToThreshold';
  declare type Route53$20130401$ConcurrentModification = {
    message?: string;
  };
  declare type Route53$20130401$ConflictingDomainExists = {
    message?: string;
  };
  declare type Route53$20130401$ConflictingTypes = {
    message?: string;
  };
  declare type Route53$20130401$CreateHealthCheckRequest = {
    CallerReference: string;
    HealthCheckConfig: Route53$20130401$HealthCheckConfig;
  };
  declare type Route53$20130401$CreateHealthCheckResponse = {
    HealthCheck: Route53$20130401$HealthCheck;
    Location: string;
  };
  declare type Route53$20130401$CreateHostedZoneRequest = {
    Name: string;
    VPC?: Route53$20130401$VPC;
    CallerReference: string;
    HostedZoneConfig?: Route53$20130401$HostedZoneConfig;
    DelegationSetId?: string;
  };
  declare type Route53$20130401$CreateHostedZoneResponse = {
    HostedZone: Route53$20130401$HostedZone;
    ChangeInfo: Route53$20130401$ChangeInfo;
    DelegationSet: Route53$20130401$DelegationSet;
    VPC?: Route53$20130401$VPC;
    Location: string;
  };
  declare type Route53$20130401$CreateReusableDelegationSetRequest = {
    CallerReference: string;
    HostedZoneId?: string;
  };
  declare type Route53$20130401$CreateReusableDelegationSetResponse = {
    DelegationSet: Route53$20130401$DelegationSet;
    Location: string;
  };
  declare type Route53$20130401$CreateTrafficPolicyInstanceRequest = {
    HostedZoneId: string;
    Name: string;
    TTL: number;
    TrafficPolicyId: string;
    TrafficPolicyVersion: number;
  };
  declare type Route53$20130401$CreateTrafficPolicyInstanceResponse = {
    TrafficPolicyInstance: Route53$20130401$TrafficPolicyInstance;
    Location: string;
  };
  declare type Route53$20130401$CreateTrafficPolicyRequest = {
    Name: string;
    Document: string;
    Comment?: string;
  };
  declare type Route53$20130401$CreateTrafficPolicyResponse = {
    TrafficPolicy: Route53$20130401$TrafficPolicy;
    Location: string;
  };
  declare type Route53$20130401$CreateTrafficPolicyVersionRequest = {
    Id: string;
    Document: string;
    Comment?: string;
  };
  declare type Route53$20130401$CreateTrafficPolicyVersionResponse = {
    TrafficPolicy: Route53$20130401$TrafficPolicy;
    Location: string;
  };
  declare type Route53$20130401$DelegationSet = {
    Id?: string;
    CallerReference?: string;
    NameServers: Route53$20130401$DelegationSetNameServers;
  };
  declare type Route53$20130401$DelegationSetAlreadyCreated = {
    message?: string;
  };
  declare type Route53$20130401$DelegationSetAlreadyReusable = {
    message?: string;
  };
  declare type Route53$20130401$DelegationSetInUse = {
    message?: string;
  };
  declare type Route53$20130401$DelegationSetNameServers = string[];
  declare type Route53$20130401$DelegationSetNotAvailable = {
    message?: string;
  };
  declare type Route53$20130401$DelegationSetNotReusable = {
    message?: string;
  };
  declare type Route53$20130401$DelegationSets = Route53$20130401$DelegationSet[];
  declare type Route53$20130401$DeleteHealthCheckRequest = {
    HealthCheckId: string;
  };
  declare type Route53$20130401$DeleteHealthCheckResponse = {};
  declare type Route53$20130401$DeleteHostedZoneRequest = {
    Id: string;
  };
  declare type Route53$20130401$DeleteHostedZoneResponse = {
    ChangeInfo: Route53$20130401$ChangeInfo;
  };
  declare type Route53$20130401$DeleteReusableDelegationSetRequest = {
    Id: string;
  };
  declare type Route53$20130401$DeleteReusableDelegationSetResponse = {};
  declare type Route53$20130401$DeleteTrafficPolicyInstanceRequest = {
    Id: string;
  };
  declare type Route53$20130401$DeleteTrafficPolicyInstanceResponse = {};
  declare type Route53$20130401$DeleteTrafficPolicyRequest = {
    Id: string;
    Version: number;
  };
  declare type Route53$20130401$DeleteTrafficPolicyResponse = {};
  declare type Route53$20130401$Dimension = {
    Name: string;
    Value: string;
  };
  declare type Route53$20130401$DimensionList = Route53$20130401$Dimension[];
  declare type Route53$20130401$DisassociateVPCFromHostedZoneRequest = {
    HostedZoneId: string;
    VPC: Route53$20130401$VPC;
    Comment?: string;
  };
  declare type Route53$20130401$DisassociateVPCFromHostedZoneResponse = {
    ChangeInfo: Route53$20130401$ChangeInfo;
  };
  declare type Route53$20130401$ErrorMessages = string[];
  declare type Route53$20130401$GeoLocation = {
    ContinentCode?: string;
    CountryCode?: string;
    SubdivisionCode?: string;
  };
  declare type Route53$20130401$GeoLocationDetails = {
    ContinentCode?: string;
    ContinentName?: string;
    CountryCode?: string;
    CountryName?: string;
    SubdivisionCode?: string;
    SubdivisionName?: string;
  };
  declare type Route53$20130401$GeoLocationDetailsList = Route53$20130401$GeoLocationDetails[];
  declare type Route53$20130401$GetChangeDetailsRequest = {
    Id: string;
  };
  declare type Route53$20130401$GetChangeDetailsResponse = {
    ChangeBatchRecord: Route53$20130401$ChangeBatchRecord;
  };
  declare type Route53$20130401$GetChangeRequest = {
    Id: string;
  };
  declare type Route53$20130401$GetChangeResponse = {
    ChangeInfo: Route53$20130401$ChangeInfo;
  };
  declare type Route53$20130401$GetCheckerIpRangesRequest = {};
  declare type Route53$20130401$GetCheckerIpRangesResponse = {
    CheckerIpRanges: Route53$20130401$CheckerIpRanges;
  };
  declare type Route53$20130401$GetGeoLocationRequest = {
    ContinentCode?: string;
    CountryCode?: string;
    SubdivisionCode?: string;
  };
  declare type Route53$20130401$GetGeoLocationResponse = {
    GeoLocationDetails: Route53$20130401$GeoLocationDetails;
  };
  declare type Route53$20130401$GetHealthCheckCountRequest = {};
  declare type Route53$20130401$GetHealthCheckCountResponse = {
    HealthCheckCount: number;
  };
  declare type Route53$20130401$GetHealthCheckLastFailureReasonRequest = {
    HealthCheckId: string;
  };
  declare type Route53$20130401$GetHealthCheckLastFailureReasonResponse = {
    HealthCheckObservations: Route53$20130401$HealthCheckObservations;
  };
  declare type Route53$20130401$GetHealthCheckRequest = {
    HealthCheckId: string;
  };
  declare type Route53$20130401$GetHealthCheckResponse = {
    HealthCheck: Route53$20130401$HealthCheck;
  };
  declare type Route53$20130401$GetHealthCheckStatusRequest = {
    HealthCheckId: string;
  };
  declare type Route53$20130401$GetHealthCheckStatusResponse = {
    HealthCheckObservations: Route53$20130401$HealthCheckObservations;
  };
  declare type Route53$20130401$GetHostedZoneCountRequest = {};
  declare type Route53$20130401$GetHostedZoneCountResponse = {
    HostedZoneCount: number;
  };
  declare type Route53$20130401$GetHostedZoneRequest = {
    Id: string;
  };
  declare type Route53$20130401$GetHostedZoneResponse = {
    HostedZone: Route53$20130401$HostedZone;
    DelegationSet?: Route53$20130401$DelegationSet;
    VPCs?: Route53$20130401$VPCs;
  };
  declare type Route53$20130401$GetReusableDelegationSetRequest = {
    Id: string;
  };
  declare type Route53$20130401$GetReusableDelegationSetResponse = {
    DelegationSet: Route53$20130401$DelegationSet;
  };
  declare type Route53$20130401$GetTrafficPolicyInstanceCountRequest = {};
  declare type Route53$20130401$GetTrafficPolicyInstanceCountResponse = {
    TrafficPolicyInstanceCount: number;
  };
  declare type Route53$20130401$GetTrafficPolicyInstanceRequest = {
    Id: string;
  };
  declare type Route53$20130401$GetTrafficPolicyInstanceResponse = {
    TrafficPolicyInstance: Route53$20130401$TrafficPolicyInstance;
  };
  declare type Route53$20130401$GetTrafficPolicyRequest = {
    Id: string;
    Version: number;
  };
  declare type Route53$20130401$GetTrafficPolicyResponse = {
    TrafficPolicy: Route53$20130401$TrafficPolicy;
  };
  declare type Route53$20130401$HealthCheck = {
    Id: string;
    CallerReference: string;
    HealthCheckConfig: Route53$20130401$HealthCheckConfig;
    HealthCheckVersion: number;
    CloudWatchAlarmConfiguration?: Route53$20130401$CloudWatchAlarmConfiguration;
  };
  declare type Route53$20130401$HealthCheckAlreadyExists = {
    message?: string;
  };
  declare type Route53$20130401$HealthCheckConfig = {
    IPAddress?: string;
    Port?: number;
    Type: 'HTTP' | 'HTTPS' | 'HTTP_STR_MATCH' | 'HTTPS_STR_MATCH' | 'TCP' | 'CALCULATED' | 'CLOUDWATCH_METRIC';
    ResourcePath?: string;
    FullyQualifiedDomainName?: string;
    SearchString?: string;
    RequestInterval?: number;
    FailureThreshold?: number;
    MeasureLatency?: boolean;
    Inverted?: boolean;
    HealthThreshold?: number;
    ChildHealthChecks?: Route53$20130401$ChildHealthCheckList;
    EnableSNI?: boolean;
    Regions?: Route53$20130401$HealthCheckRegionList;
    AlarmIdentifier?: Route53$20130401$AlarmIdentifier;
    InsufficientDataHealthStatus?: 'Healthy' | 'Unhealthy' | 'LastKnownStatus';
  };
  declare type Route53$20130401$HealthCheckInUse = {
    message?: string;
  };
  declare type Route53$20130401$HealthCheckObservation = {
    Region?: 'us-east-1' | 'us-west-1' | 'us-west-2' | 'eu-west-1' | 'ap-southeast-1' | 'ap-southeast-2' | 'ap-northeast-1' | 'sa-east-1';
    IPAddress?: string;
    StatusReport?: Route53$20130401$StatusReport;
  };
  declare type Route53$20130401$HealthCheckObservations = Route53$20130401$HealthCheckObservation[];
  declare type Route53$20130401$HealthCheckRegion = 'us-east-1' | 'us-west-1' | 'us-west-2' | 'eu-west-1' | 'ap-southeast-1' | 'ap-southeast-2' | 'ap-northeast-1' | 'sa-east-1';
  declare type Route53$20130401$HealthCheckRegionList = ('us-east-1' | 'us-west-1' | 'us-west-2' | 'eu-west-1' | 'ap-southeast-1' | 'ap-southeast-2' | 'ap-northeast-1' | 'sa-east-1')[];
  declare type Route53$20130401$HealthCheckType = 'HTTP' | 'HTTPS' | 'HTTP_STR_MATCH' | 'HTTPS_STR_MATCH' | 'TCP' | 'CALCULATED' | 'CLOUDWATCH_METRIC';
  declare type Route53$20130401$HealthCheckVersionMismatch = {
    message?: string;
  };
  declare type Route53$20130401$HealthChecks = Route53$20130401$HealthCheck[];
  declare type Route53$20130401$HostedZone = {
    Id: string;
    Name: string;
    CallerReference: string;
    Config?: Route53$20130401$HostedZoneConfig;
    ResourceRecordSetCount?: number;
  };
  declare type Route53$20130401$HostedZoneAlreadyExists = {
    message?: string;
  };
  declare type Route53$20130401$HostedZoneConfig = {
    Comment?: string;
    PrivateZone?: boolean;
  };
  declare type Route53$20130401$HostedZoneNotEmpty = {
    message?: string;
  };
  declare type Route53$20130401$HostedZoneNotFound = {
    message?: string;
  };
  declare type Route53$20130401$HostedZones = Route53$20130401$HostedZone[];
  declare type Route53$20130401$IncompatibleVersion = {
    message?: string;
  };
  declare type Route53$20130401$InsufficientDataHealthStatus = 'Healthy' | 'Unhealthy' | 'LastKnownStatus';
  declare type Route53$20130401$InvalidArgument = {
    message?: string;
  };
  declare type Route53$20130401$InvalidChangeBatch = {
    messages?: Route53$20130401$ErrorMessages;
  };
  declare type Route53$20130401$InvalidDomainName = {
    message?: string;
  };
  declare type Route53$20130401$InvalidInput = {
    message?: string;
  };
  declare type Route53$20130401$InvalidTrafficPolicyDocument = {
    message?: string;
  };
  declare type Route53$20130401$InvalidVPCId = {
    message?: string;
  };
  declare type Route53$20130401$LastVPCAssociation = {
    message?: string;
  };
  declare type Route53$20130401$LimitsExceeded = {
    message?: string;
  };
  declare type Route53$20130401$ListChangeBatchesByHostedZoneRequest = {
    HostedZoneId: string;
    StartDate: string;
    EndDate: string;
    MaxItems?: string;
    Marker?: string;
  };
  declare type Route53$20130401$ListChangeBatchesByHostedZoneResponse = {
    MaxItems: string;
    Marker: string;
    IsTruncated?: boolean;
    ChangeBatchRecords: Route53$20130401$ChangeBatchRecords;
    NextMarker?: string;
  };
  declare type Route53$20130401$ListChangeBatchesByRRSetRequest = {
    HostedZoneId: string;
    Name: string;
    Type: 'SOA' | 'A' | 'TXT' | 'NS' | 'CNAME' | 'MX' | 'PTR' | 'SRV' | 'SPF' | 'AAAA';
    SetIdentifier?: string;
    StartDate: string;
    EndDate: string;
    MaxItems?: string;
    Marker?: string;
  };
  declare type Route53$20130401$ListChangeBatchesByRRSetResponse = {
    MaxItems: string;
    Marker: string;
    IsTruncated?: boolean;
    ChangeBatchRecords: Route53$20130401$ChangeBatchRecords;
    NextMarker?: string;
  };
  declare type Route53$20130401$ListGeoLocationsRequest = {
    StartContinentCode?: string;
    StartCountryCode?: string;
    StartSubdivisionCode?: string;
    MaxItems?: string;
  };
  declare type Route53$20130401$ListGeoLocationsResponse = {
    GeoLocationDetailsList: Route53$20130401$GeoLocationDetailsList;
    IsTruncated: boolean;
    NextContinentCode?: string;
    NextCountryCode?: string;
    NextSubdivisionCode?: string;
    MaxItems: string;
  };
  declare type Route53$20130401$ListHealthChecksRequest = {
    Marker?: string;
    MaxItems?: string;
  };
  declare type Route53$20130401$ListHealthChecksResponse = {
    HealthChecks: Route53$20130401$HealthChecks;
    Marker: string;
    IsTruncated: boolean;
    NextMarker?: string;
    MaxItems: string;
  };
  declare type Route53$20130401$ListHostedZonesByNameRequest = {
    DNSName?: string;
    HostedZoneId?: string;
    MaxItems?: string;
  };
  declare type Route53$20130401$ListHostedZonesByNameResponse = {
    HostedZones: Route53$20130401$HostedZones;
    DNSName?: string;
    HostedZoneId?: string;
    IsTruncated: boolean;
    NextDNSName?: string;
    NextHostedZoneId?: string;
    MaxItems: string;
  };
  declare type Route53$20130401$ListHostedZonesRequest = {
    Marker?: string;
    MaxItems?: string;
    DelegationSetId?: string;
  };
  declare type Route53$20130401$ListHostedZonesResponse = {
    HostedZones: Route53$20130401$HostedZones;
    Marker: string;
    IsTruncated: boolean;
    NextMarker?: string;
    MaxItems: string;
  };
  declare type Route53$20130401$ListResourceRecordSetsRequest = {
    HostedZoneId: string;
    StartRecordName?: string;
    StartRecordType?: 'SOA' | 'A' | 'TXT' | 'NS' | 'CNAME' | 'MX' | 'PTR' | 'SRV' | 'SPF' | 'AAAA';
    StartRecordIdentifier?: string;
    MaxItems?: string;
  };
  declare type Route53$20130401$ListResourceRecordSetsResponse = {
    ResourceRecordSets: Route53$20130401$ResourceRecordSets;
    IsTruncated: boolean;
    NextRecordName?: string;
    NextRecordType?: 'SOA' | 'A' | 'TXT' | 'NS' | 'CNAME' | 'MX' | 'PTR' | 'SRV' | 'SPF' | 'AAAA';
    NextRecordIdentifier?: string;
    MaxItems: string;
  };
  declare type Route53$20130401$ListReusableDelegationSetsRequest = {
    Marker?: string;
    MaxItems?: string;
  };
  declare type Route53$20130401$ListReusableDelegationSetsResponse = {
    DelegationSets: Route53$20130401$DelegationSets;
    Marker: string;
    IsTruncated: boolean;
    NextMarker?: string;
    MaxItems: string;
  };
  declare type Route53$20130401$ListTagsForResourceRequest = {
    ResourceType: 'healthcheck' | 'hostedzone';
    ResourceId: string;
  };
  declare type Route53$20130401$ListTagsForResourceResponse = {
    ResourceTagSet: Route53$20130401$ResourceTagSet;
  };
  declare type Route53$20130401$ListTagsForResourcesRequest = {
    ResourceType: 'healthcheck' | 'hostedzone';
    ResourceIds: Route53$20130401$TagResourceIdList;
  };
  declare type Route53$20130401$ListTagsForResourcesResponse = {
    ResourceTagSets: Route53$20130401$ResourceTagSetList;
  };
  declare type Route53$20130401$ListTrafficPoliciesRequest = {
    TrafficPolicyIdMarker?: string;
    MaxItems?: string;
  };
  declare type Route53$20130401$ListTrafficPoliciesResponse = {
    TrafficPolicySummaries: Route53$20130401$TrafficPolicySummaries;
    IsTruncated: boolean;
    TrafficPolicyIdMarker: string;
    MaxItems: string;
  };
  declare type Route53$20130401$ListTrafficPolicyInstancesByHostedZoneRequest = {
    HostedZoneId: string;
    TrafficPolicyInstanceNameMarker?: string;
    TrafficPolicyInstanceTypeMarker?: 'SOA' | 'A' | 'TXT' | 'NS' | 'CNAME' | 'MX' | 'PTR' | 'SRV' | 'SPF' | 'AAAA';
    MaxItems?: string;
  };
  declare type Route53$20130401$ListTrafficPolicyInstancesByHostedZoneResponse = {
    TrafficPolicyInstances: Route53$20130401$TrafficPolicyInstances;
    TrafficPolicyInstanceNameMarker?: string;
    TrafficPolicyInstanceTypeMarker?: 'SOA' | 'A' | 'TXT' | 'NS' | 'CNAME' | 'MX' | 'PTR' | 'SRV' | 'SPF' | 'AAAA';
    IsTruncated: boolean;
    MaxItems: string;
  };
  declare type Route53$20130401$ListTrafficPolicyInstancesByPolicyRequest = {
    TrafficPolicyId: string;
    TrafficPolicyVersion: number;
    HostedZoneIdMarker?: string;
    TrafficPolicyInstanceNameMarker?: string;
    TrafficPolicyInstanceTypeMarker?: 'SOA' | 'A' | 'TXT' | 'NS' | 'CNAME' | 'MX' | 'PTR' | 'SRV' | 'SPF' | 'AAAA';
    MaxItems?: string;
  };
  declare type Route53$20130401$ListTrafficPolicyInstancesByPolicyResponse = {
    TrafficPolicyInstances: Route53$20130401$TrafficPolicyInstances;
    HostedZoneIdMarker?: string;
    TrafficPolicyInstanceNameMarker?: string;
    TrafficPolicyInstanceTypeMarker?: 'SOA' | 'A' | 'TXT' | 'NS' | 'CNAME' | 'MX' | 'PTR' | 'SRV' | 'SPF' | 'AAAA';
    IsTruncated: boolean;
    MaxItems: string;
  };
  declare type Route53$20130401$ListTrafficPolicyInstancesRequest = {
    HostedZoneIdMarker?: string;
    TrafficPolicyInstanceNameMarker?: string;
    TrafficPolicyInstanceTypeMarker?: 'SOA' | 'A' | 'TXT' | 'NS' | 'CNAME' | 'MX' | 'PTR' | 'SRV' | 'SPF' | 'AAAA';
    MaxItems?: string;
  };
  declare type Route53$20130401$ListTrafficPolicyInstancesResponse = {
    TrafficPolicyInstances: Route53$20130401$TrafficPolicyInstances;
    HostedZoneIdMarker?: string;
    TrafficPolicyInstanceNameMarker?: string;
    TrafficPolicyInstanceTypeMarker?: 'SOA' | 'A' | 'TXT' | 'NS' | 'CNAME' | 'MX' | 'PTR' | 'SRV' | 'SPF' | 'AAAA';
    IsTruncated: boolean;
    MaxItems: string;
  };
  declare type Route53$20130401$ListTrafficPolicyVersionsRequest = {
    Id: string;
    TrafficPolicyVersionMarker?: string;
    MaxItems?: string;
  };
  declare type Route53$20130401$ListTrafficPolicyVersionsResponse = {
    TrafficPolicies: Route53$20130401$TrafficPolicies;
    IsTruncated: boolean;
    TrafficPolicyVersionMarker: string;
    MaxItems: string;
  };
  declare type Route53$20130401$NoSuchChange = {
    message?: string;
  };
  declare type Route53$20130401$NoSuchDelegationSet = {
    message?: string;
  };
  declare type Route53$20130401$NoSuchGeoLocation = {
    message?: string;
  };
  declare type Route53$20130401$NoSuchHealthCheck = {
    message?: string;
  };
  declare type Route53$20130401$NoSuchHostedZone = {
    message?: string;
  };
  declare type Route53$20130401$NoSuchTrafficPolicy = {
    message?: string;
  };
  declare type Route53$20130401$NoSuchTrafficPolicyInstance = {
    message?: string;
  };
  declare type Route53$20130401$PriorRequestNotComplete = {
    message?: string;
  };
  declare type Route53$20130401$PublicZoneVPCAssociation = {
    message?: string;
  };
  declare type Route53$20130401$RRType = 'SOA' | 'A' | 'TXT' | 'NS' | 'CNAME' | 'MX' | 'PTR' | 'SRV' | 'SPF' | 'AAAA';
  declare type Route53$20130401$ResourceRecord = {
    Value: string;
  };
  declare type Route53$20130401$ResourceRecordSet = {
    Name: string;
    Type: 'SOA' | 'A' | 'TXT' | 'NS' | 'CNAME' | 'MX' | 'PTR' | 'SRV' | 'SPF' | 'AAAA';
    SetIdentifier?: string;
    Weight?: number;
    Region?: 'us-east-1' | 'us-west-1' | 'us-west-2' | 'eu-west-1' | 'eu-central-1' | 'ap-southeast-1' | 'ap-southeast-2' | 'ap-northeast-1' | 'ap-northeast-2' | 'sa-east-1' | 'cn-north-1' | 'ap-south-1';
    GeoLocation?: Route53$20130401$GeoLocation;
    Failover?: 'PRIMARY' | 'SECONDARY';
    TTL?: number;
    ResourceRecords?: Route53$20130401$ResourceRecords;
    AliasTarget?: Route53$20130401$AliasTarget;
    HealthCheckId?: string;
    TrafficPolicyInstanceId?: string;
  };
  declare type Route53$20130401$ResourceRecordSetFailover = 'PRIMARY' | 'SECONDARY';
  declare type Route53$20130401$ResourceRecordSetRegion = 'us-east-1' | 'us-west-1' | 'us-west-2' | 'eu-west-1' | 'eu-central-1' | 'ap-southeast-1' | 'ap-southeast-2' | 'ap-northeast-1' | 'ap-northeast-2' | 'sa-east-1' | 'cn-north-1' | 'ap-south-1';
  declare type Route53$20130401$ResourceRecordSets = Route53$20130401$ResourceRecordSet[];
  declare type Route53$20130401$ResourceRecords = Route53$20130401$ResourceRecord[];
  declare type Route53$20130401$ResourceTagSet = {
    ResourceType?: 'healthcheck' | 'hostedzone';
    ResourceId?: string;
    Tags?: Route53$20130401$TagList;
  };
  declare type Route53$20130401$ResourceTagSetList = Route53$20130401$ResourceTagSet[];
  declare type Route53$20130401$Statistic = 'Average' | 'Sum' | 'SampleCount' | 'Maximum' | 'Minimum';
  declare type Route53$20130401$StatusReport = {
    Status?: string;
    CheckedTime?: Date;
  };
  declare type Route53$20130401$Tag = {
    Key?: string;
    Value?: string;
  };
  declare type Route53$20130401$TagKeyList = string[];
  declare type Route53$20130401$TagList = Route53$20130401$Tag[];
  declare type Route53$20130401$TagResourceIdList = string[];
  declare type Route53$20130401$TagResourceType = 'healthcheck' | 'hostedzone';
  declare type Route53$20130401$ThrottlingException = {
    message?: string;
  };
  declare type Route53$20130401$TimeStamp = Date;
  declare type Route53$20130401$TooManyHealthChecks = {
    message?: string;
  };
  declare type Route53$20130401$TooManyHostedZones = {
    message?: string;
  };
  declare type Route53$20130401$TooManyTrafficPolicies = {
    message?: string;
  };
  declare type Route53$20130401$TooManyTrafficPolicyInstances = {
    message?: string;
  };
  declare type Route53$20130401$TrafficPolicies = Route53$20130401$TrafficPolicy[];
  declare type Route53$20130401$TrafficPolicy = {
    Id: string;
    Version: number;
    Name: string;
    Type: 'SOA' | 'A' | 'TXT' | 'NS' | 'CNAME' | 'MX' | 'PTR' | 'SRV' | 'SPF' | 'AAAA';
    Document: string;
    Comment?: string;
  };
  declare type Route53$20130401$TrafficPolicyAlreadyExists = {
    message?: string;
  };
  declare type Route53$20130401$TrafficPolicyInUse = {
    message?: string;
  };
  declare type Route53$20130401$TrafficPolicyInstance = {
    Id: string;
    HostedZoneId: string;
    Name: string;
    TTL: number;
    State: string;
    Message: string;
    TrafficPolicyId: string;
    TrafficPolicyVersion: number;
    TrafficPolicyType: 'SOA' | 'A' | 'TXT' | 'NS' | 'CNAME' | 'MX' | 'PTR' | 'SRV' | 'SPF' | 'AAAA';
  };
  declare type Route53$20130401$TrafficPolicyInstanceAlreadyExists = {
    message?: string;
  };
  declare type Route53$20130401$TrafficPolicyInstances = Route53$20130401$TrafficPolicyInstance[];
  declare type Route53$20130401$TrafficPolicySummaries = Route53$20130401$TrafficPolicySummary[];
  declare type Route53$20130401$TrafficPolicySummary = {
    Id: string;
    Name: string;
    Type: 'SOA' | 'A' | 'TXT' | 'NS' | 'CNAME' | 'MX' | 'PTR' | 'SRV' | 'SPF' | 'AAAA';
    LatestVersion: number;
    TrafficPolicyCount: number;
  };
  declare type Route53$20130401$UpdateHealthCheckRequest = {
    HealthCheckId: string;
    HealthCheckVersion?: number;
    IPAddress?: string;
    Port?: number;
    ResourcePath?: string;
    FullyQualifiedDomainName?: string;
    SearchString?: string;
    FailureThreshold?: number;
    Inverted?: boolean;
    HealthThreshold?: number;
    ChildHealthChecks?: Route53$20130401$ChildHealthCheckList;
    EnableSNI?: boolean;
    Regions?: Route53$20130401$HealthCheckRegionList;
    AlarmIdentifier?: Route53$20130401$AlarmIdentifier;
    InsufficientDataHealthStatus?: 'Healthy' | 'Unhealthy' | 'LastKnownStatus';
  };
  declare type Route53$20130401$UpdateHealthCheckResponse = {
    HealthCheck: Route53$20130401$HealthCheck;
  };
  declare type Route53$20130401$UpdateHostedZoneCommentRequest = {
    Id: string;
    Comment?: string;
  };
  declare type Route53$20130401$UpdateHostedZoneCommentResponse = {
    HostedZone: Route53$20130401$HostedZone;
  };
  declare type Route53$20130401$UpdateTrafficPolicyCommentRequest = {
    Id: string;
    Version: number;
    Comment: string;
  };
  declare type Route53$20130401$UpdateTrafficPolicyCommentResponse = {
    TrafficPolicy: Route53$20130401$TrafficPolicy;
  };
  declare type Route53$20130401$UpdateTrafficPolicyInstanceRequest = {
    Id: string;
    TTL: number;
    TrafficPolicyId: string;
    TrafficPolicyVersion: number;
  };
  declare type Route53$20130401$UpdateTrafficPolicyInstanceResponse = {
    TrafficPolicyInstance: Route53$20130401$TrafficPolicyInstance;
  };
  declare type Route53$20130401$VPC = {
    VPCRegion?: 'us-east-1' | 'us-west-1' | 'us-west-2' | 'eu-west-1' | 'eu-central-1' | 'ap-southeast-1' | 'ap-southeast-2' | 'ap-south-1' | 'ap-northeast-1' | 'ap-northeast-2' | 'sa-east-1' | 'cn-north-1';
    VPCId?: string;
  };
  declare type Route53$20130401$VPCAssociationNotFound = {
    message?: string;
  };
  declare type Route53$20130401$VPCRegion = 'us-east-1' | 'us-west-1' | 'us-west-2' | 'eu-west-1' | 'eu-central-1' | 'ap-southeast-1' | 'ap-southeast-2' | 'ap-south-1' | 'ap-northeast-1' | 'ap-northeast-2' | 'sa-east-1' | 'cn-north-1';
  declare type Route53$20130401$VPCs = Route53$20130401$VPC[];
  declare type Route53Domains$20140515$BillingRecord = {
    DomainName?: string;
    Operation?: 'REGISTER_DOMAIN' | 'DELETE_DOMAIN' | 'TRANSFER_IN_DOMAIN' | 'UPDATE_DOMAIN_CONTACT' | 'UPDATE_NAMESERVER' | 'CHANGE_PRIVACY_PROTECTION' | 'DOMAIN_LOCK';
    InvoiceId?: string;
    BillDate?: Date;
    Price?: number;
  };
  declare type Route53Domains$20140515$BillingRecords = Route53Domains$20140515$BillingRecord[];
  declare type Route53Domains$20140515$CheckDomainAvailabilityRequest = {
    DomainName: string;
    IdnLangCode?: string;
  };
  declare type Route53Domains$20140515$CheckDomainAvailabilityResponse = {
    Availability: 'AVAILABLE' | 'AVAILABLE_RESERVED' | 'AVAILABLE_PREORDER' | 'UNAVAILABLE' | 'UNAVAILABLE_PREMIUM' | 'UNAVAILABLE_RESTRICTED' | 'RESERVED' | 'DONT_KNOW';
  };
  declare type Route53Domains$20140515$ContactDetail = {
    FirstName?: string;
    LastName?: string;
    ContactType?: 'PERSON' | 'COMPANY' | 'ASSOCIATION' | 'PUBLIC_BODY' | 'RESELLER';
    OrganizationName?: string;
    AddressLine1?: string;
    AddressLine2?: string;
    City?: string;
    State?: string;
    CountryCode?: 'AD' | 'AE' | 'AF' | 'AG' | 'AI' | 'AL' | 'AM' | 'AN' | 'AO' | 'AQ' | 'AR' | 'AS' | 'AT' | 'AU' | 'AW' | 'AZ' | 'BA' | 'BB' | 'BD' | 'BE' | 'BF' | 'BG' | 'BH' | 'BI' | 'BJ' | 'BL' | 'BM' | 'BN' | 'BO' | 'BR' | 'BS' | 'BT' | 'BW' | 'BY' | 'BZ' | 'CA' | 'CC' | 'CD' | 'CF' | 'CG' | 'CH' | 'CI' | 'CK' | 'CL' | 'CM' | 'CN' | 'CO' | 'CR' | 'CU' | 'CV' | 'CX' | 'CY' | 'CZ' | 'DE' | 'DJ' | 'DK' | 'DM' | 'DO' | 'DZ' | 'EC' | 'EE' | 'EG' | 'ER' | 'ES' | 'ET' | 'FI' | 'FJ' | 'FK' | 'FM' | 'FO' | 'FR' | 'GA' | 'GB' | 'GD' | 'GE' | 'GH' | 'GI' | 'GL' | 'GM' | 'GN' | 'GQ' | 'GR' | 'GT' | 'GU' | 'GW' | 'GY' | 'HK' | 'HN' | 'HR' | 'HT' | 'HU' | 'ID' | 'IE' | 'IL' | 'IM' | 'IN' | 'IQ' | 'IR' | 'IS' | 'IT' | 'JM' | 'JO' | 'JP' | 'KE' | 'KG' | 'KH' | 'KI' | 'KM' | 'KN' | 'KP' | 'KR' | 'KW' | 'KY' | 'KZ' | 'LA' | 'LB' | 'LC' | 'LI' | 'LK' | 'LR' | 'LS' | 'LT' | 'LU' | 'LV' | 'LY' | 'MA' | 'MC' | 'MD' | 'ME' | 'MF' | 'MG' | 'MH' | 'MK' | 'ML' | 'MM' | 'MN' | 'MO' | 'MP' | 'MR' | 'MS' | 'MT' | 'MU' | 'MV' | 'MW' | 'MX' | 'MY' | 'MZ' | 'NA' | 'NC' | 'NE' | 'NG' | 'NI' | 'NL' | 'NO' | 'NP' | 'NR' | 'NU' | 'NZ' | 'OM' | 'PA' | 'PE' | 'PF' | 'PG' | 'PH' | 'PK' | 'PL' | 'PM' | 'PN' | 'PR' | 'PT' | 'PW' | 'PY' | 'QA' | 'RO' | 'RS' | 'RU' | 'RW' | 'SA' | 'SB' | 'SC' | 'SD' | 'SE' | 'SG' | 'SH' | 'SI' | 'SK' | 'SL' | 'SM' | 'SN' | 'SO' | 'SR' | 'ST' | 'SV' | 'SY' | 'SZ' | 'TC' | 'TD' | 'TG' | 'TH' | 'TJ' | 'TK' | 'TL' | 'TM' | 'TN' | 'TO' | 'TR' | 'TT' | 'TV' | 'TW' | 'TZ' | 'UA' | 'UG' | 'US' | 'UY' | 'UZ' | 'VA' | 'VC' | 'VE' | 'VG' | 'VI' | 'VN' | 'VU' | 'WF' | 'WS' | 'YE' | 'YT' | 'ZA' | 'ZM' | 'ZW';
    ZipCode?: string;
    PhoneNumber?: string;
    Email?: string;
    Fax?: string;
    ExtraParams?: Route53Domains$20140515$ExtraParamList;
  };
  declare type Route53Domains$20140515$ContactType = 'PERSON' | 'COMPANY' | 'ASSOCIATION' | 'PUBLIC_BODY' | 'RESELLER';
  declare type Route53Domains$20140515$CountryCode = 'AD' | 'AE' | 'AF' | 'AG' | 'AI' | 'AL' | 'AM' | 'AN' | 'AO' | 'AQ' | 'AR' | 'AS' | 'AT' | 'AU' | 'AW' | 'AZ' | 'BA' | 'BB' | 'BD' | 'BE' | 'BF' | 'BG' | 'BH' | 'BI' | 'BJ' | 'BL' | 'BM' | 'BN' | 'BO' | 'BR' | 'BS' | 'BT' | 'BW' | 'BY' | 'BZ' | 'CA' | 'CC' | 'CD' | 'CF' | 'CG' | 'CH' | 'CI' | 'CK' | 'CL' | 'CM' | 'CN' | 'CO' | 'CR' | 'CU' | 'CV' | 'CX' | 'CY' | 'CZ' | 'DE' | 'DJ' | 'DK' | 'DM' | 'DO' | 'DZ' | 'EC' | 'EE' | 'EG' | 'ER' | 'ES' | 'ET' | 'FI' | 'FJ' | 'FK' | 'FM' | 'FO' | 'FR' | 'GA' | 'GB' | 'GD' | 'GE' | 'GH' | 'GI' | 'GL' | 'GM' | 'GN' | 'GQ' | 'GR' | 'GT' | 'GU' | 'GW' | 'GY' | 'HK' | 'HN' | 'HR' | 'HT' | 'HU' | 'ID' | 'IE' | 'IL' | 'IM' | 'IN' | 'IQ' | 'IR' | 'IS' | 'IT' | 'JM' | 'JO' | 'JP' | 'KE' | 'KG' | 'KH' | 'KI' | 'KM' | 'KN' | 'KP' | 'KR' | 'KW' | 'KY' | 'KZ' | 'LA' | 'LB' | 'LC' | 'LI' | 'LK' | 'LR' | 'LS' | 'LT' | 'LU' | 'LV' | 'LY' | 'MA' | 'MC' | 'MD' | 'ME' | 'MF' | 'MG' | 'MH' | 'MK' | 'ML' | 'MM' | 'MN' | 'MO' | 'MP' | 'MR' | 'MS' | 'MT' | 'MU' | 'MV' | 'MW' | 'MX' | 'MY' | 'MZ' | 'NA' | 'NC' | 'NE' | 'NG' | 'NI' | 'NL' | 'NO' | 'NP' | 'NR' | 'NU' | 'NZ' | 'OM' | 'PA' | 'PE' | 'PF' | 'PG' | 'PH' | 'PK' | 'PL' | 'PM' | 'PN' | 'PR' | 'PT' | 'PW' | 'PY' | 'QA' | 'RO' | 'RS' | 'RU' | 'RW' | 'SA' | 'SB' | 'SC' | 'SD' | 'SE' | 'SG' | 'SH' | 'SI' | 'SK' | 'SL' | 'SM' | 'SN' | 'SO' | 'SR' | 'ST' | 'SV' | 'SY' | 'SZ' | 'TC' | 'TD' | 'TG' | 'TH' | 'TJ' | 'TK' | 'TL' | 'TM' | 'TN' | 'TO' | 'TR' | 'TT' | 'TV' | 'TW' | 'TZ' | 'UA' | 'UG' | 'US' | 'UY' | 'UZ' | 'VA' | 'VC' | 'VE' | 'VG' | 'VI' | 'VN' | 'VU' | 'WF' | 'WS' | 'YE' | 'YT' | 'ZA' | 'ZM' | 'ZW';
  declare type Route53Domains$20140515$DeleteTagsForDomainRequest = {
    DomainName: string;
    TagsToDelete: Route53Domains$20140515$TagKeyList;
  };
  declare type Route53Domains$20140515$DeleteTagsForDomainResponse = {};
  declare type Route53Domains$20140515$DisableDomainAutoRenewRequest = {
    DomainName: string;
  };
  declare type Route53Domains$20140515$DisableDomainAutoRenewResponse = {};
  declare type Route53Domains$20140515$DisableDomainTransferLockRequest = {
    DomainName: string;
  };
  declare type Route53Domains$20140515$DisableDomainTransferLockResponse = {
    OperationId: string;
  };
  declare type Route53Domains$20140515$DomainAvailability = 'AVAILABLE' | 'AVAILABLE_RESERVED' | 'AVAILABLE_PREORDER' | 'UNAVAILABLE' | 'UNAVAILABLE_PREMIUM' | 'UNAVAILABLE_RESTRICTED' | 'RESERVED' | 'DONT_KNOW';
  declare type Route53Domains$20140515$DomainLimitExceeded = {
    message?: string;
  };
  declare type Route53Domains$20140515$DomainStatusList = string[];
  declare type Route53Domains$20140515$DomainSuggestion = {
    DomainName?: string;
    Availability?: string;
  };
  declare type Route53Domains$20140515$DomainSuggestionsList = Route53Domains$20140515$DomainSuggestion[];
  declare type Route53Domains$20140515$DomainSummary = {
    DomainName: string;
    AutoRenew?: boolean;
    TransferLock?: boolean;
    Expiry?: Date;
  };
  declare type Route53Domains$20140515$DomainSummaryList = Route53Domains$20140515$DomainSummary[];
  declare type Route53Domains$20140515$DuplicateRequest = {
    message?: string;
  };
  declare type Route53Domains$20140515$EnableDomainAutoRenewRequest = {
    DomainName: string;
  };
  declare type Route53Domains$20140515$EnableDomainAutoRenewResponse = {};
  declare type Route53Domains$20140515$EnableDomainTransferLockRequest = {
    DomainName: string;
  };
  declare type Route53Domains$20140515$EnableDomainTransferLockResponse = {
    OperationId: string;
  };
  declare type Route53Domains$20140515$ExtraParam = {
    Name: 'DUNS_NUMBER' | 'BRAND_NUMBER' | 'BIRTH_DEPARTMENT' | 'BIRTH_DATE_IN_YYYY_MM_DD' | 'BIRTH_COUNTRY' | 'BIRTH_CITY' | 'DOCUMENT_NUMBER' | 'AU_ID_NUMBER' | 'AU_ID_TYPE' | 'CA_LEGAL_TYPE' | 'CA_BUSINESS_ENTITY_TYPE' | 'ES_IDENTIFICATION' | 'ES_IDENTIFICATION_TYPE' | 'ES_LEGAL_FORM' | 'FI_BUSINESS_NUMBER' | 'FI_ID_NUMBER' | 'IT_PIN' | 'RU_PASSPORT_DATA' | 'SE_ID_NUMBER' | 'SG_ID_NUMBER' | 'VAT_NUMBER';
    Value: string;
  };
  declare type Route53Domains$20140515$ExtraParamList = Route53Domains$20140515$ExtraParam[];
  declare type Route53Domains$20140515$ExtraParamName = 'DUNS_NUMBER' | 'BRAND_NUMBER' | 'BIRTH_DEPARTMENT' | 'BIRTH_DATE_IN_YYYY_MM_DD' | 'BIRTH_COUNTRY' | 'BIRTH_CITY' | 'DOCUMENT_NUMBER' | 'AU_ID_NUMBER' | 'AU_ID_TYPE' | 'CA_LEGAL_TYPE' | 'CA_BUSINESS_ENTITY_TYPE' | 'ES_IDENTIFICATION' | 'ES_IDENTIFICATION_TYPE' | 'ES_LEGAL_FORM' | 'FI_BUSINESS_NUMBER' | 'FI_ID_NUMBER' | 'IT_PIN' | 'RU_PASSPORT_DATA' | 'SE_ID_NUMBER' | 'SG_ID_NUMBER' | 'VAT_NUMBER';
  declare type Route53Domains$20140515$GetContactReachabilityStatusRequest = {
    domainName?: string;
  };
  declare type Route53Domains$20140515$GetContactReachabilityStatusResponse = {
    domainName?: string;
    status?: 'PENDING' | 'DONE' | 'EXPIRED';
  };
  declare type Route53Domains$20140515$GetDomainDetailRequest = {
    DomainName: string;
  };
  declare type Route53Domains$20140515$GetDomainDetailResponse = {
    DomainName: string;
    Nameservers: Route53Domains$20140515$NameserverList;
    AutoRenew?: boolean;
    AdminContact: Route53Domains$20140515$ContactDetail;
    RegistrantContact: Route53Domains$20140515$ContactDetail;
    TechContact: Route53Domains$20140515$ContactDetail;
    AdminPrivacy?: boolean;
    RegistrantPrivacy?: boolean;
    TechPrivacy?: boolean;
    RegistrarName?: string;
    WhoIsServer?: string;
    RegistrarUrl?: string;
    AbuseContactEmail?: string;
    AbuseContactPhone?: string;
    RegistryDomainId?: string;
    CreationDate?: Date;
    UpdatedDate?: Date;
    ExpirationDate?: Date;
    Reseller?: string;
    DnsSec?: string;
    StatusList?: Route53Domains$20140515$DomainStatusList;
  };
  declare type Route53Domains$20140515$GetDomainSuggestionsRequest = {
    DomainName: string;
    SuggestionCount: number;
    OnlyAvailable: boolean;
  };
  declare type Route53Domains$20140515$GetDomainSuggestionsResponse = {
    SuggestionsList?: Route53Domains$20140515$DomainSuggestionsList;
  };
  declare type Route53Domains$20140515$GetOperationDetailRequest = {
    OperationId: string;
  };
  declare type Route53Domains$20140515$GetOperationDetailResponse = {
    OperationId?: string;
    Status?: 'SUBMITTED' | 'IN_PROGRESS' | 'ERROR' | 'SUCCESSFUL' | 'FAILED';
    Message?: string;
    DomainName?: string;
    Type?: 'REGISTER_DOMAIN' | 'DELETE_DOMAIN' | 'TRANSFER_IN_DOMAIN' | 'UPDATE_DOMAIN_CONTACT' | 'UPDATE_NAMESERVER' | 'CHANGE_PRIVACY_PROTECTION' | 'DOMAIN_LOCK';
    SubmittedDate?: Date;
  };
  declare type Route53Domains$20140515$GlueIpList = string[];
  declare type Route53Domains$20140515$InvalidInput = {
    message?: string;
  };
  declare type Route53Domains$20140515$ListDomainsRequest = {
    Marker?: string;
    MaxItems?: number;
  };
  declare type Route53Domains$20140515$ListDomainsResponse = {
    Domains: Route53Domains$20140515$DomainSummaryList;
    NextPageMarker?: string;
  };
  declare type Route53Domains$20140515$ListOperationsRequest = {
    Marker?: string;
    MaxItems?: number;
  };
  declare type Route53Domains$20140515$ListOperationsResponse = {
    Operations: Route53Domains$20140515$OperationSummaryList;
    NextPageMarker?: string;
  };
  declare type Route53Domains$20140515$ListTagsForDomainRequest = {
    DomainName: string;
  };
  declare type Route53Domains$20140515$ListTagsForDomainResponse = {
    TagList: Route53Domains$20140515$TagList;
  };
  declare type Route53Domains$20140515$Nameserver = {
    Name: string;
    GlueIps?: Route53Domains$20140515$GlueIpList;
  };
  declare type Route53Domains$20140515$NameserverList = Route53Domains$20140515$Nameserver[];
  declare type Route53Domains$20140515$OperationLimitExceeded = {
    message?: string;
  };
  declare type Route53Domains$20140515$OperationStatus = 'SUBMITTED' | 'IN_PROGRESS' | 'ERROR' | 'SUCCESSFUL' | 'FAILED';
  declare type Route53Domains$20140515$OperationSummary = {
    OperationId: string;
    Status: 'SUBMITTED' | 'IN_PROGRESS' | 'ERROR' | 'SUCCESSFUL' | 'FAILED';
    Type: 'REGISTER_DOMAIN' | 'DELETE_DOMAIN' | 'TRANSFER_IN_DOMAIN' | 'UPDATE_DOMAIN_CONTACT' | 'UPDATE_NAMESERVER' | 'CHANGE_PRIVACY_PROTECTION' | 'DOMAIN_LOCK';
    SubmittedDate: Date;
  };
  declare type Route53Domains$20140515$OperationSummaryList = Route53Domains$20140515$OperationSummary[];
  declare type Route53Domains$20140515$OperationType = 'REGISTER_DOMAIN' | 'DELETE_DOMAIN' | 'TRANSFER_IN_DOMAIN' | 'UPDATE_DOMAIN_CONTACT' | 'UPDATE_NAMESERVER' | 'CHANGE_PRIVACY_PROTECTION' | 'DOMAIN_LOCK';
  declare type Route53Domains$20140515$ReachabilityStatus = 'PENDING' | 'DONE' | 'EXPIRED';
  declare type Route53Domains$20140515$RegisterDomainRequest = {
    DomainName: string;
    IdnLangCode?: string;
    DurationInYears: number;
    AutoRenew?: boolean;
    AdminContact: Route53Domains$20140515$ContactDetail;
    RegistrantContact: Route53Domains$20140515$ContactDetail;
    TechContact: Route53Domains$20140515$ContactDetail;
    PrivacyProtectAdminContact?: boolean;
    PrivacyProtectRegistrantContact?: boolean;
    PrivacyProtectTechContact?: boolean;
  };
  declare type Route53Domains$20140515$RegisterDomainResponse = {
    OperationId: string;
  };
  declare type Route53Domains$20140515$RenewDomainRequest = {
    DomainName: string;
    DurationInYears?: number;
    CurrentExpiryYear: number;
  };
  declare type Route53Domains$20140515$RenewDomainResponse = {
    OperationId: string;
  };
  declare type Route53Domains$20140515$ResendContactReachabilityEmailRequest = {
    domainName?: string;
  };
  declare type Route53Domains$20140515$ResendContactReachabilityEmailResponse = {
    domainName?: string;
    emailAddress?: string;
    isAlreadyVerified?: boolean;
  };
  declare type Route53Domains$20140515$RetrieveDomainAuthCodeRequest = {
    DomainName: string;
  };
  declare type Route53Domains$20140515$RetrieveDomainAuthCodeResponse = {
    AuthCode: string;
  };
  declare type Route53Domains$20140515$TLDRulesViolation = {
    message?: string;
  };
  declare type Route53Domains$20140515$Tag = {
    Key?: string;
    Value?: string;
  };
  declare type Route53Domains$20140515$TagKeyList = string[];
  declare type Route53Domains$20140515$TagList = Route53Domains$20140515$Tag[];
  declare type Route53Domains$20140515$Timestamp = Date;
  declare type Route53Domains$20140515$TransferDomainRequest = {
    DomainName: string;
    IdnLangCode?: string;
    DurationInYears: number;
    Nameservers?: Route53Domains$20140515$NameserverList;
    AuthCode?: string;
    AutoRenew?: boolean;
    AdminContact: Route53Domains$20140515$ContactDetail;
    RegistrantContact: Route53Domains$20140515$ContactDetail;
    TechContact: Route53Domains$20140515$ContactDetail;
    PrivacyProtectAdminContact?: boolean;
    PrivacyProtectRegistrantContact?: boolean;
    PrivacyProtectTechContact?: boolean;
  };
  declare type Route53Domains$20140515$TransferDomainResponse = {
    OperationId: string;
  };
  declare type Route53Domains$20140515$UnsupportedTLD = {
    message?: string;
  };
  declare type Route53Domains$20140515$UpdateDomainContactPrivacyRequest = {
    DomainName: string;
    AdminPrivacy?: boolean;
    RegistrantPrivacy?: boolean;
    TechPrivacy?: boolean;
  };
  declare type Route53Domains$20140515$UpdateDomainContactPrivacyResponse = {
    OperationId: string;
  };
  declare type Route53Domains$20140515$UpdateDomainContactRequest = {
    DomainName: string;
    AdminContact?: Route53Domains$20140515$ContactDetail;
    RegistrantContact?: Route53Domains$20140515$ContactDetail;
    TechContact?: Route53Domains$20140515$ContactDetail;
  };
  declare type Route53Domains$20140515$UpdateDomainContactResponse = {
    OperationId: string;
  };
  declare type Route53Domains$20140515$UpdateDomainNameserversRequest = {
    DomainName: string;
    FIAuthKey?: string;
    Nameservers: Route53Domains$20140515$NameserverList;
  };
  declare type Route53Domains$20140515$UpdateDomainNameserversResponse = {
    OperationId: string;
  };
  declare type Route53Domains$20140515$UpdateTagsForDomainRequest = {
    DomainName: string;
    TagsToUpdate?: Route53Domains$20140515$TagList;
  };
  declare type Route53Domains$20140515$UpdateTagsForDomainResponse = {};
  declare type Route53Domains$20140515$ViewBillingRequest = {
    Start?: Date;
    End?: Date;
    Marker?: string;
    MaxItems?: number;
  };
  declare type Route53Domains$20140515$ViewBillingResponse = {
    NextPageMarker?: string;
    BillingRecords?: Route53Domains$20140515$BillingRecords;
  };
  declare type S3$20060301$AbortDate = Date;
  declare type S3$20060301$AbortIncompleteMultipartUpload = {
    DaysAfterInitiation?: number;
  };
  declare type S3$20060301$AbortMultipartUploadOutput = {
    RequestCharged?: 'requester';
  };
  declare type S3$20060301$AbortMultipartUploadRequest = {
    Bucket: string;
    Key: string;
    UploadId: string;
    RequestPayer?: 'requester';
  };
  declare type S3$20060301$AccelerateConfiguration = {
    Status?: 'Enabled' | 'Suspended';
  };
  declare type S3$20060301$AccessControlPolicy = {
    Grants?: S3$20060301$Grants;
    Owner?: S3$20060301$Owner;
  };
  declare type S3$20060301$AllowedHeaders = string[];
  declare type S3$20060301$AllowedMethods = string[];
  declare type S3$20060301$AllowedOrigins = string[];
  declare type S3$20060301$Body = Buffer | $TypedArray | Blob | string;
  declare type S3$20060301$Bucket = {
    Name?: string;
    CreationDate?: Date;
  };
  declare type S3$20060301$BucketAccelerateStatus = 'Enabled' | 'Suspended';
  declare type S3$20060301$BucketAlreadyExists = {};
  declare type S3$20060301$BucketAlreadyOwnedByYou = {};
  declare type S3$20060301$BucketCannedACL = 'private' | 'public-read' | 'public-read-write' | 'authenticated-read';
  declare type S3$20060301$BucketLifecycleConfiguration = {
    Rules: S3$20060301$LifecycleRules;
  };
  declare type S3$20060301$BucketLocationConstraint = 'EU' | 'eu-west-1' | 'us-west-1' | 'us-west-2' | 'ap-south-1' | 'ap-southeast-1' | 'ap-southeast-2' | 'ap-northeast-1' | 'sa-east-1' | 'cn-north-1' | 'eu-central-1';
  declare type S3$20060301$BucketLoggingStatus = {
    LoggingEnabled?: S3$20060301$LoggingEnabled;
  };
  declare type S3$20060301$BucketLogsPermission = 'FULL_CONTROL' | 'READ' | 'WRITE';
  declare type S3$20060301$BucketVersioningStatus = 'Enabled' | 'Suspended';
  declare type S3$20060301$Buckets = S3$20060301$Bucket[];
  declare type S3$20060301$CORSConfiguration = {
    CORSRules: S3$20060301$CORSRules;
  };
  declare type S3$20060301$CORSRule = {
    AllowedHeaders?: S3$20060301$AllowedHeaders;
    AllowedMethods: S3$20060301$AllowedMethods;
    AllowedOrigins: S3$20060301$AllowedOrigins;
    ExposeHeaders?: S3$20060301$ExposeHeaders;
    MaxAgeSeconds?: number;
  };
  declare type S3$20060301$CORSRules = S3$20060301$CORSRule[];
  declare type S3$20060301$CloudFunctionConfiguration = {
    Id?: string;
    Event?: 's3:ReducedRedundancyLostObject' | 's3:ObjectCreated:*' | 's3:ObjectCreated:Put' | 's3:ObjectCreated:Post' | 's3:ObjectCreated:Copy' | 's3:ObjectCreated:CompleteMultipartUpload' | 's3:ObjectRemoved:*' | 's3:ObjectRemoved:Delete' | 's3:ObjectRemoved:DeleteMarkerCreated';
    Events?: S3$20060301$EventList;
    CloudFunction?: string;
    InvocationRole?: string;
  };
  declare type S3$20060301$CommonPrefix = {
    Prefix?: string;
  };
  declare type S3$20060301$CommonPrefixList = S3$20060301$CommonPrefix[];
  declare type S3$20060301$CompleteMultipartUploadOutput = {
    Location?: string;
    Bucket?: string;
    Key?: string;
    Expiration?: string;
    ETag?: string;
    ServerSideEncryption?: 'AES256' | 'aws:kms';
    VersionId?: string;
    SSEKMSKeyId?: string;
    RequestCharged?: 'requester';
  };
  declare type S3$20060301$CompleteMultipartUploadRequest = {
    Bucket: string;
    Key: string;
    MultipartUpload?: S3$20060301$CompletedMultipartUpload;
    UploadId: string;
    RequestPayer?: 'requester';
  };
  declare type S3$20060301$CompletedMultipartUpload = {
    Parts?: S3$20060301$CompletedPartList;
  };
  declare type S3$20060301$CompletedPart = {
    ETag?: string;
    PartNumber?: number;
  };
  declare type S3$20060301$CompletedPartList = S3$20060301$CompletedPart[];
  declare type S3$20060301$Condition = {
    HttpErrorCodeReturnedEquals?: string;
    KeyPrefixEquals?: string;
  };
  declare type S3$20060301$CopyObjectOutput = {
    CopyObjectResult?: S3$20060301$CopyObjectResult;
    Expiration?: string;
    CopySourceVersionId?: string;
    VersionId?: string;
    ServerSideEncryption?: 'AES256' | 'aws:kms';
    SSECustomerAlgorithm?: string;
    SSECustomerKeyMD5?: string;
    SSEKMSKeyId?: string;
    RequestCharged?: 'requester';
  };
  declare type S3$20060301$CopyObjectRequest = {
    ACL?: 'private' | 'public-read' | 'public-read-write' | 'authenticated-read' | 'aws-exec-read' | 'bucket-owner-read' | 'bucket-owner-full-control';
    Bucket: string;
    CacheControl?: string;
    ContentDisposition?: string;
    ContentEncoding?: string;
    ContentLanguage?: string;
    ContentType?: string;
    CopySource: string;
    CopySourceIfMatch?: string;
    CopySourceIfModifiedSince?: Date;
    CopySourceIfNoneMatch?: string;
    CopySourceIfUnmodifiedSince?: Date;
    Expires?: Date;
    GrantFullControl?: string;
    GrantRead?: string;
    GrantReadACP?: string;
    GrantWriteACP?: string;
    Key: string;
    Metadata?: {
      [key: string]: string;
    };
    MetadataDirective?: 'COPY' | 'REPLACE';
    ServerSideEncryption?: 'AES256' | 'aws:kms';
    StorageClass?: 'STANDARD' | 'REDUCED_REDUNDANCY' | 'STANDARD_IA';
    WebsiteRedirectLocation?: string;
    SSECustomerAlgorithm?: string;
    SSECustomerKey?: Buffer | $TypedArray | Blob | string;
    SSECustomerKeyMD5?: string;
    SSEKMSKeyId?: string;
    CopySourceSSECustomerAlgorithm?: string;
    CopySourceSSECustomerKey?: Buffer | $TypedArray | Blob | string;
    CopySourceSSECustomerKeyMD5?: string;
    RequestPayer?: 'requester';
  };
  declare type S3$20060301$CopyObjectResult = {
    ETag?: string;
    LastModified?: Date;
  };
  declare type S3$20060301$CopyPartResult = {
    ETag?: string;
    LastModified?: Date;
  };
  declare type S3$20060301$CopySourceIfModifiedSince = Date;
  declare type S3$20060301$CopySourceIfUnmodifiedSince = Date;
  declare type S3$20060301$CopySourceSSECustomerKey = Buffer | $TypedArray | Blob | string;
  declare type S3$20060301$CreateBucketConfiguration = {
    LocationConstraint?: 'EU' | 'eu-west-1' | 'us-west-1' | 'us-west-2' | 'ap-south-1' | 'ap-southeast-1' | 'ap-southeast-2' | 'ap-northeast-1' | 'sa-east-1' | 'cn-north-1' | 'eu-central-1';
  };
  declare type S3$20060301$CreateBucketOutput = {
    Location?: string;
  };
  declare type S3$20060301$CreateBucketRequest = {
    ACL?: 'private' | 'public-read' | 'public-read-write' | 'authenticated-read';
    Bucket: string;
    CreateBucketConfiguration?: S3$20060301$CreateBucketConfiguration;
    GrantFullControl?: string;
    GrantRead?: string;
    GrantReadACP?: string;
    GrantWrite?: string;
    GrantWriteACP?: string;
  };
  declare type S3$20060301$CreateMultipartUploadOutput = {
    AbortDate?: Date;
    AbortRuleId?: string;
    Bucket?: string;
    Key?: string;
    UploadId?: string;
    ServerSideEncryption?: 'AES256' | 'aws:kms';
    SSECustomerAlgorithm?: string;
    SSECustomerKeyMD5?: string;
    SSEKMSKeyId?: string;
    RequestCharged?: 'requester';
  };
  declare type S3$20060301$CreateMultipartUploadRequest = {
    ACL?: 'private' | 'public-read' | 'public-read-write' | 'authenticated-read' | 'aws-exec-read' | 'bucket-owner-read' | 'bucket-owner-full-control';
    Bucket: string;
    CacheControl?: string;
    ContentDisposition?: string;
    ContentEncoding?: string;
    ContentLanguage?: string;
    ContentType?: string;
    Expires?: Date;
    GrantFullControl?: string;
    GrantRead?: string;
    GrantReadACP?: string;
    GrantWriteACP?: string;
    Key: string;
    Metadata?: {
      [key: string]: string;
    };
    ServerSideEncryption?: 'AES256' | 'aws:kms';
    StorageClass?: 'STANDARD' | 'REDUCED_REDUNDANCY' | 'STANDARD_IA';
    WebsiteRedirectLocation?: string;
    SSECustomerAlgorithm?: string;
    SSECustomerKey?: Buffer | $TypedArray | Blob | string;
    SSECustomerKeyMD5?: string;
    SSEKMSKeyId?: string;
    RequestPayer?: 'requester';
  };
  declare type S3$20060301$CreationDate = Date;
  declare type S3$20060301$Date = Date;
  declare type S3$20060301$Delete = {
    Objects: S3$20060301$ObjectIdentifierList;
    Quiet?: boolean;
  };
  declare type S3$20060301$DeleteBucketCorsRequest = {
    Bucket: string;
  };
  declare type S3$20060301$DeleteBucketLifecycleRequest = {
    Bucket: string;
  };
  declare type S3$20060301$DeleteBucketPolicyRequest = {
    Bucket: string;
  };
  declare type S3$20060301$DeleteBucketReplicationRequest = {
    Bucket: string;
  };
  declare type S3$20060301$DeleteBucketRequest = {
    Bucket: string;
  };
  declare type S3$20060301$DeleteBucketTaggingRequest = {
    Bucket: string;
  };
  declare type S3$20060301$DeleteBucketWebsiteRequest = {
    Bucket: string;
  };
  declare type S3$20060301$DeleteMarkerEntry = {
    Owner?: S3$20060301$Owner;
    Key?: string;
    VersionId?: string;
    IsLatest?: boolean;
    LastModified?: Date;
  };
  declare type S3$20060301$DeleteMarkers = S3$20060301$DeleteMarkerEntry[];
  declare type S3$20060301$DeleteObjectOutput = {
    DeleteMarker?: boolean;
    VersionId?: string;
    RequestCharged?: 'requester';
  };
  declare type S3$20060301$DeleteObjectRequest = {
    Bucket: string;
    Key: string;
    MFA?: string;
    VersionId?: string;
    RequestPayer?: 'requester';
  };
  declare type S3$20060301$DeleteObjectsOutput = {
    Deleted?: S3$20060301$DeletedObjects;
    RequestCharged?: 'requester';
    Errors?: S3$20060301$Errors;
  };
  declare type S3$20060301$DeleteObjectsRequest = {
    Bucket: string;
    Delete: S3$20060301$Delete;
    MFA?: string;
    RequestPayer?: 'requester';
  };
  declare type S3$20060301$DeletedObject = {
    Key?: string;
    VersionId?: string;
    DeleteMarker?: boolean;
    DeleteMarkerVersionId?: string;
  };
  declare type S3$20060301$DeletedObjects = S3$20060301$DeletedObject[];
  declare type S3$20060301$Destination = {
    Bucket: string;
    StorageClass?: 'STANDARD' | 'REDUCED_REDUNDANCY' | 'STANDARD_IA';
  };
  declare type S3$20060301$EncodingType = 'url';
  declare type S3$20060301$Error = {
    Key?: string;
    VersionId?: string;
    Code?: string;
    Message?: string;
  };
  declare type S3$20060301$ErrorDocument = {
    Key: string;
  };
  declare type S3$20060301$Errors = S3$20060301$Error[];
  declare type S3$20060301$Event = 's3:ReducedRedundancyLostObject' | 's3:ObjectCreated:*' | 's3:ObjectCreated:Put' | 's3:ObjectCreated:Post' | 's3:ObjectCreated:Copy' | 's3:ObjectCreated:CompleteMultipartUpload' | 's3:ObjectRemoved:*' | 's3:ObjectRemoved:Delete' | 's3:ObjectRemoved:DeleteMarkerCreated';
  declare type S3$20060301$EventList = ('s3:ReducedRedundancyLostObject' | 's3:ObjectCreated:*' | 's3:ObjectCreated:Put' | 's3:ObjectCreated:Post' | 's3:ObjectCreated:Copy' | 's3:ObjectCreated:CompleteMultipartUpload' | 's3:ObjectRemoved:*' | 's3:ObjectRemoved:Delete' | 's3:ObjectRemoved:DeleteMarkerCreated')[];
  declare type S3$20060301$ExpirationStatus = 'Enabled' | 'Disabled';
  declare type S3$20060301$Expires = Date;
  declare type S3$20060301$ExposeHeaders = string[];
  declare type S3$20060301$FilterRule = {
    Name?: 'prefix' | 'suffix';
    Value?: string;
  };
  declare type S3$20060301$FilterRuleList = S3$20060301$FilterRule[];
  declare type S3$20060301$FilterRuleName = 'prefix' | 'suffix';
  declare type S3$20060301$GetBucketAccelerateConfigurationOutput = {
    Status?: 'Enabled' | 'Suspended';
  };
  declare type S3$20060301$GetBucketAccelerateConfigurationRequest = {
    Bucket: string;
  };
  declare type S3$20060301$GetBucketAclOutput = {
    Owner?: S3$20060301$Owner;
    Grants?: S3$20060301$Grants;
  };
  declare type S3$20060301$GetBucketAclRequest = {
    Bucket: string;
  };
  declare type S3$20060301$GetBucketCorsOutput = {
    CORSRules?: S3$20060301$CORSRules;
  };
  declare type S3$20060301$GetBucketCorsRequest = {
    Bucket: string;
  };
  declare type S3$20060301$GetBucketLifecycleConfigurationOutput = {
    Rules?: S3$20060301$LifecycleRules;
  };
  declare type S3$20060301$GetBucketLifecycleConfigurationRequest = {
    Bucket: string;
  };
  declare type S3$20060301$GetBucketLifecycleOutput = {
    Rules?: S3$20060301$Rules;
  };
  declare type S3$20060301$GetBucketLifecycleRequest = {
    Bucket: string;
  };
  declare type S3$20060301$GetBucketLocationOutput = {
    LocationConstraint?: 'EU' | 'eu-west-1' | 'us-west-1' | 'us-west-2' | 'ap-south-1' | 'ap-southeast-1' | 'ap-southeast-2' | 'ap-northeast-1' | 'sa-east-1' | 'cn-north-1' | 'eu-central-1';
  };
  declare type S3$20060301$GetBucketLocationRequest = {
    Bucket: string;
  };
  declare type S3$20060301$GetBucketLoggingOutput = {
    LoggingEnabled?: S3$20060301$LoggingEnabled;
  };
  declare type S3$20060301$GetBucketLoggingRequest = {
    Bucket: string;
  };
  declare type S3$20060301$GetBucketNotificationConfigurationRequest = {
    Bucket: string;
  };
  declare type S3$20060301$GetBucketPolicyOutput = {
    Policy?: string;
  };
  declare type S3$20060301$GetBucketPolicyRequest = {
    Bucket: string;
  };
  declare type S3$20060301$GetBucketReplicationOutput = {
    ReplicationConfiguration?: S3$20060301$ReplicationConfiguration;
  };
  declare type S3$20060301$GetBucketReplicationRequest = {
    Bucket: string;
  };
  declare type S3$20060301$GetBucketRequestPaymentOutput = {
    Payer?: 'Requester' | 'BucketOwner';
  };
  declare type S3$20060301$GetBucketRequestPaymentRequest = {
    Bucket: string;
  };
  declare type S3$20060301$GetBucketTaggingOutput = {
    TagSet: S3$20060301$TagSet;
  };
  declare type S3$20060301$GetBucketTaggingRequest = {
    Bucket: string;
  };
  declare type S3$20060301$GetBucketVersioningOutput = {
    Status?: 'Enabled' | 'Suspended';
    MFADelete?: 'Enabled' | 'Disabled';
  };
  declare type S3$20060301$GetBucketVersioningRequest = {
    Bucket: string;
  };
  declare type S3$20060301$GetBucketWebsiteOutput = {
    RedirectAllRequestsTo?: S3$20060301$RedirectAllRequestsTo;
    IndexDocument?: S3$20060301$IndexDocument;
    ErrorDocument?: S3$20060301$ErrorDocument;
    RoutingRules?: S3$20060301$RoutingRules;
  };
  declare type S3$20060301$GetBucketWebsiteRequest = {
    Bucket: string;
  };
  declare type S3$20060301$GetObjectAclOutput = {
    Owner?: S3$20060301$Owner;
    Grants?: S3$20060301$Grants;
    RequestCharged?: 'requester';
  };
  declare type S3$20060301$GetObjectAclRequest = {
    Bucket: string;
    Key: string;
    VersionId?: string;
    RequestPayer?: 'requester';
  };
  declare type S3$20060301$GetObjectOutput = {
    Body?: Buffer | $TypedArray | Blob | string;
    DeleteMarker?: boolean;
    AcceptRanges?: string;
    Expiration?: string;
    Restore?: string;
    LastModified?: Date;
    ContentLength?: number;
    ETag?: string;
    MissingMeta?: number;
    VersionId?: string;
    CacheControl?: string;
    ContentDisposition?: string;
    ContentEncoding?: string;
    ContentLanguage?: string;
    ContentRange?: string;
    ContentType?: string;
    Expires?: Date;
    WebsiteRedirectLocation?: string;
    ServerSideEncryption?: 'AES256' | 'aws:kms';
    Metadata?: {
      [key: string]: string;
    };
    SSECustomerAlgorithm?: string;
    SSECustomerKeyMD5?: string;
    SSEKMSKeyId?: string;
    StorageClass?: 'STANDARD' | 'REDUCED_REDUNDANCY' | 'STANDARD_IA';
    RequestCharged?: 'requester';
    ReplicationStatus?: 'COMPLETE' | 'PENDING' | 'FAILED' | 'REPLICA';
  };
  declare type S3$20060301$GetObjectRequest = {
    Bucket: string;
    IfMatch?: string;
    IfModifiedSince?: Date;
    IfNoneMatch?: string;
    IfUnmodifiedSince?: Date;
    Key: string;
    Range?: string;
    ResponseCacheControl?: string;
    ResponseContentDisposition?: string;
    ResponseContentEncoding?: string;
    ResponseContentLanguage?: string;
    ResponseContentType?: string;
    ResponseExpires?: Date;
    VersionId?: string;
    SSECustomerAlgorithm?: string;
    SSECustomerKey?: Buffer | $TypedArray | Blob | string;
    SSECustomerKeyMD5?: string;
    RequestPayer?: 'requester';
  };
  declare type S3$20060301$GetObjectTorrentOutput = {
    Body?: Buffer | $TypedArray | Blob | string;
    RequestCharged?: 'requester';
  };
  declare type S3$20060301$GetObjectTorrentRequest = {
    Bucket: string;
    Key: string;
    RequestPayer?: 'requester';
  };
  declare type S3$20060301$Grant = {
    Grantee?: S3$20060301$Grantee;
    Permission?: 'FULL_CONTROL' | 'WRITE' | 'WRITE_ACP' | 'READ' | 'READ_ACP';
  };
  declare type S3$20060301$Grantee = {
    DisplayName?: string;
    EmailAddress?: string;
    ID?: string;
    Type: 'CanonicalUser' | 'AmazonCustomerByEmail' | 'Group';
    URI?: string;
  };
  declare type S3$20060301$Grants = S3$20060301$Grant[];
  declare type S3$20060301$HeadBucketRequest = {
    Bucket: string;
  };
  declare type S3$20060301$HeadObjectOutput = {
    DeleteMarker?: boolean;
    AcceptRanges?: string;
    Expiration?: string;
    Restore?: string;
    LastModified?: Date;
    ContentLength?: number;
    ETag?: string;
    MissingMeta?: number;
    VersionId?: string;
    CacheControl?: string;
    ContentDisposition?: string;
    ContentEncoding?: string;
    ContentLanguage?: string;
    ContentType?: string;
    Expires?: Date;
    WebsiteRedirectLocation?: string;
    ServerSideEncryption?: 'AES256' | 'aws:kms';
    Metadata?: {
      [key: string]: string;
    };
    SSECustomerAlgorithm?: string;
    SSECustomerKeyMD5?: string;
    SSEKMSKeyId?: string;
    StorageClass?: 'STANDARD' | 'REDUCED_REDUNDANCY' | 'STANDARD_IA';
    RequestCharged?: 'requester';
    ReplicationStatus?: 'COMPLETE' | 'PENDING' | 'FAILED' | 'REPLICA';
  };
  declare type S3$20060301$HeadObjectRequest = {
    Bucket: string;
    IfMatch?: string;
    IfModifiedSince?: Date;
    IfNoneMatch?: string;
    IfUnmodifiedSince?: Date;
    Key: string;
    Range?: string;
    VersionId?: string;
    SSECustomerAlgorithm?: string;
    SSECustomerKey?: Buffer | $TypedArray | Blob | string;
    SSECustomerKeyMD5?: string;
    RequestPayer?: 'requester';
  };
  declare type S3$20060301$IfModifiedSince = Date;
  declare type S3$20060301$IfUnmodifiedSince = Date;
  declare type S3$20060301$IndexDocument = {
    Suffix: string;
  };
  declare type S3$20060301$Initiated = Date;
  declare type S3$20060301$Initiator = {
    ID?: string;
    DisplayName?: string;
  };
  declare type S3$20060301$LambdaFunctionConfiguration = {
    Id?: string;
    LambdaFunctionArn: string;
    Events: S3$20060301$EventList;
    Filter?: S3$20060301$NotificationConfigurationFilter;
  };
  declare type S3$20060301$LambdaFunctionConfigurationList = S3$20060301$LambdaFunctionConfiguration[];
  declare type S3$20060301$LastModified = Date;
  declare type S3$20060301$LifecycleConfiguration = {
    Rules: S3$20060301$Rules;
  };
  declare type S3$20060301$LifecycleExpiration = {
    Date?: Date;
    Days?: number;
    ExpiredObjectDeleteMarker?: boolean;
  };
  declare type S3$20060301$LifecycleRule = {
    Expiration?: S3$20060301$LifecycleExpiration;
    ID?: string;
    Prefix: string;
    Status: 'Enabled' | 'Disabled';
    Transitions?: S3$20060301$TransitionList;
    NoncurrentVersionTransitions?: S3$20060301$NoncurrentVersionTransitionList;
    NoncurrentVersionExpiration?: S3$20060301$NoncurrentVersionExpiration;
    AbortIncompleteMultipartUpload?: S3$20060301$AbortIncompleteMultipartUpload;
  };
  declare type S3$20060301$LifecycleRules = S3$20060301$LifecycleRule[];
  declare type S3$20060301$ListBucketsOutput = {
    Buckets?: S3$20060301$Buckets;
    Owner?: S3$20060301$Owner;
  };
  declare type S3$20060301$ListMultipartUploadsOutput = {
    Bucket?: string;
    KeyMarker?: string;
    UploadIdMarker?: string;
    NextKeyMarker?: string;
    Prefix?: string;
    Delimiter?: string;
    NextUploadIdMarker?: string;
    MaxUploads?: number;
    IsTruncated?: boolean;
    Uploads?: S3$20060301$MultipartUploadList;
    CommonPrefixes?: S3$20060301$CommonPrefixList;
    EncodingType?: 'url';
  };
  declare type S3$20060301$ListMultipartUploadsRequest = {
    Bucket: string;
    Delimiter?: string;
    EncodingType?: 'url';
    KeyMarker?: string;
    MaxUploads?: number;
    Prefix?: string;
    UploadIdMarker?: string;
  };
  declare type S3$20060301$ListObjectVersionsOutput = {
    IsTruncated?: boolean;
    KeyMarker?: string;
    VersionIdMarker?: string;
    NextKeyMarker?: string;
    NextVersionIdMarker?: string;
    Versions?: S3$20060301$ObjectVersionList;
    DeleteMarkers?: S3$20060301$DeleteMarkers;
    Name?: string;
    Prefix?: string;
    Delimiter?: string;
    MaxKeys?: number;
    CommonPrefixes?: S3$20060301$CommonPrefixList;
    EncodingType?: 'url';
  };
  declare type S3$20060301$ListObjectVersionsRequest = {
    Bucket: string;
    Delimiter?: string;
    EncodingType?: 'url';
    KeyMarker?: string;
    MaxKeys?: number;
    Prefix?: string;
    VersionIdMarker?: string;
  };
  declare type S3$20060301$ListObjectsOutput = {
    IsTruncated?: boolean;
    Marker?: string;
    NextMarker?: string;
    Contents?: S3$20060301$ObjectList;
    Name?: string;
    Prefix?: string;
    Delimiter?: string;
    MaxKeys?: number;
    CommonPrefixes?: S3$20060301$CommonPrefixList;
    EncodingType?: 'url';
  };
  declare type S3$20060301$ListObjectsRequest = {
    Bucket: string;
    Delimiter?: string;
    EncodingType?: 'url';
    Marker?: string;
    MaxKeys?: number;
    Prefix?: string;
  };
  declare type S3$20060301$ListObjectsV2Output = {
    IsTruncated?: boolean;
    Contents?: S3$20060301$ObjectList;
    Name?: string;
    Prefix?: string;
    Delimiter?: string;
    MaxKeys?: number;
    CommonPrefixes?: S3$20060301$CommonPrefixList;
    EncodingType?: 'url';
    KeyCount?: number;
    ContinuationToken?: string;
    NextContinuationToken?: string;
    StartAfter?: string;
  };
  declare type S3$20060301$ListObjectsV2Request = {
    Bucket: string;
    Delimiter?: string;
    EncodingType?: 'url';
    MaxKeys?: number;
    Prefix?: string;
    ContinuationToken?: string;
    FetchOwner?: boolean;
    StartAfter?: string;
  };
  declare type S3$20060301$ListPartsOutput = {
    AbortDate?: Date;
    AbortRuleId?: string;
    Bucket?: string;
    Key?: string;
    UploadId?: string;
    PartNumberMarker?: number;
    NextPartNumberMarker?: number;
    MaxParts?: number;
    IsTruncated?: boolean;
    Parts?: S3$20060301$Parts;
    Initiator?: S3$20060301$Initiator;
    Owner?: S3$20060301$Owner;
    StorageClass?: 'STANDARD' | 'REDUCED_REDUNDANCY' | 'STANDARD_IA';
    RequestCharged?: 'requester';
  };
  declare type S3$20060301$ListPartsRequest = {
    Bucket: string;
    Key: string;
    MaxParts?: number;
    PartNumberMarker?: number;
    UploadId: string;
    RequestPayer?: 'requester';
  };
  declare type S3$20060301$LoggingEnabled = {
    TargetBucket?: string;
    TargetGrants?: S3$20060301$TargetGrants;
    TargetPrefix?: string;
  };
  declare type S3$20060301$MFADelete = 'Enabled' | 'Disabled';
  declare type S3$20060301$MFADeleteStatus = 'Enabled' | 'Disabled';
  declare type S3$20060301$Metadata = {
    [key: string]: string;
  };
  declare type S3$20060301$MetadataDirective = 'COPY' | 'REPLACE';
  declare type S3$20060301$MultipartUpload = {
    UploadId?: string;
    Key?: string;
    Initiated?: Date;
    StorageClass?: 'STANDARD' | 'REDUCED_REDUNDANCY' | 'STANDARD_IA';
    Owner?: S3$20060301$Owner;
    Initiator?: S3$20060301$Initiator;
  };
  declare type S3$20060301$MultipartUploadList = S3$20060301$MultipartUpload[];
  declare type S3$20060301$NoSuchBucket = {};
  declare type S3$20060301$NoSuchKey = {};
  declare type S3$20060301$NoSuchUpload = {};
  declare type S3$20060301$NoncurrentVersionExpiration = {
    NoncurrentDays?: number;
  };
  declare type S3$20060301$NoncurrentVersionTransition = {
    NoncurrentDays?: number;
    StorageClass?: 'GLACIER' | 'STANDARD_IA';
  };
  declare type S3$20060301$NoncurrentVersionTransitionList = S3$20060301$NoncurrentVersionTransition[];
  declare type S3$20060301$NotificationConfiguration = {
    TopicConfigurations?: S3$20060301$TopicConfigurationList;
    QueueConfigurations?: S3$20060301$QueueConfigurationList;
    LambdaFunctionConfigurations?: S3$20060301$LambdaFunctionConfigurationList;
  };
  declare type S3$20060301$NotificationConfigurationDeprecated = {
    TopicConfiguration?: S3$20060301$TopicConfigurationDeprecated;
    QueueConfiguration?: S3$20060301$QueueConfigurationDeprecated;
    CloudFunctionConfiguration?: S3$20060301$CloudFunctionConfiguration;
  };
  declare type S3$20060301$NotificationConfigurationFilter = {
    Key?: S3$20060301$S3KeyFilter;
  };
  declare type S3$20060301$Object = {
    Key?: string;
    LastModified?: Date;
    ETag?: string;
    Size?: number;
    StorageClass?: 'STANDARD' | 'REDUCED_REDUNDANCY' | 'GLACIER';
    Owner?: S3$20060301$Owner;
  };
  declare type S3$20060301$ObjectAlreadyInActiveTierError = {};
  declare type S3$20060301$ObjectCannedACL = 'private' | 'public-read' | 'public-read-write' | 'authenticated-read' | 'aws-exec-read' | 'bucket-owner-read' | 'bucket-owner-full-control';
  declare type S3$20060301$ObjectIdentifier = {
    Key: string;
    VersionId?: string;
  };
  declare type S3$20060301$ObjectIdentifierList = S3$20060301$ObjectIdentifier[];
  declare type S3$20060301$ObjectList = S3$20060301$Object[];
  declare type S3$20060301$ObjectNotInActiveTierError = {};
  declare type S3$20060301$ObjectStorageClass = 'STANDARD' | 'REDUCED_REDUNDANCY' | 'GLACIER';
  declare type S3$20060301$ObjectVersion = {
    ETag?: string;
    Size?: number;
    StorageClass?: 'STANDARD';
    Key?: string;
    VersionId?: string;
    IsLatest?: boolean;
    LastModified?: Date;
    Owner?: S3$20060301$Owner;
  };
  declare type S3$20060301$ObjectVersionList = S3$20060301$ObjectVersion[];
  declare type S3$20060301$ObjectVersionStorageClass = 'STANDARD';
  declare type S3$20060301$Owner = {
    DisplayName?: string;
    ID?: string;
  };
  declare type S3$20060301$Part = {
    PartNumber?: number;
    LastModified?: Date;
    ETag?: string;
    Size?: number;
  };
  declare type S3$20060301$Parts = S3$20060301$Part[];
  declare type S3$20060301$Payer = 'Requester' | 'BucketOwner';
  declare type S3$20060301$Permission = 'FULL_CONTROL' | 'WRITE' | 'WRITE_ACP' | 'READ' | 'READ_ACP';
  declare type S3$20060301$Protocol = 'http' | 'https';
  declare type S3$20060301$PutBucketAccelerateConfigurationRequest = {
    Bucket: string;
    AccelerateConfiguration: S3$20060301$AccelerateConfiguration;
  };
  declare type S3$20060301$PutBucketAclRequest = {
    ACL?: 'private' | 'public-read' | 'public-read-write' | 'authenticated-read';
    AccessControlPolicy?: S3$20060301$AccessControlPolicy;
    Bucket: string;
    ContentMD5?: string;
    GrantFullControl?: string;
    GrantRead?: string;
    GrantReadACP?: string;
    GrantWrite?: string;
    GrantWriteACP?: string;
  };
  declare type S3$20060301$PutBucketCorsRequest = {
    Bucket: string;
    CORSConfiguration: S3$20060301$CORSConfiguration;
    ContentMD5?: string;
  };
  declare type S3$20060301$PutBucketLifecycleConfigurationRequest = {
    Bucket: string;
    LifecycleConfiguration?: S3$20060301$BucketLifecycleConfiguration;
  };
  declare type S3$20060301$PutBucketLifecycleRequest = {
    Bucket: string;
    ContentMD5?: string;
    LifecycleConfiguration?: S3$20060301$LifecycleConfiguration;
  };
  declare type S3$20060301$PutBucketLoggingRequest = {
    Bucket: string;
    BucketLoggingStatus: S3$20060301$BucketLoggingStatus;
    ContentMD5?: string;
  };
  declare type S3$20060301$PutBucketNotificationConfigurationRequest = {
    Bucket: string;
    NotificationConfiguration: S3$20060301$NotificationConfiguration;
  };
  declare type S3$20060301$PutBucketNotificationRequest = {
    Bucket: string;
    ContentMD5?: string;
    NotificationConfiguration: S3$20060301$NotificationConfigurationDeprecated;
  };
  declare type S3$20060301$PutBucketPolicyRequest = {
    Bucket: string;
    ContentMD5?: string;
    Policy: string;
  };
  declare type S3$20060301$PutBucketReplicationRequest = {
    Bucket: string;
    ContentMD5?: string;
    ReplicationConfiguration: S3$20060301$ReplicationConfiguration;
  };
  declare type S3$20060301$PutBucketRequestPaymentRequest = {
    Bucket: string;
    ContentMD5?: string;
    RequestPaymentConfiguration: S3$20060301$RequestPaymentConfiguration;
  };
  declare type S3$20060301$PutBucketTaggingRequest = {
    Bucket: string;
    ContentMD5?: string;
    Tagging: S3$20060301$Tagging;
  };
  declare type S3$20060301$PutBucketVersioningRequest = {
    Bucket: string;
    ContentMD5?: string;
    MFA?: string;
    VersioningConfiguration: S3$20060301$VersioningConfiguration;
  };
  declare type S3$20060301$PutBucketWebsiteRequest = {
    Bucket: string;
    ContentMD5?: string;
    WebsiteConfiguration: S3$20060301$WebsiteConfiguration;
  };
  declare type S3$20060301$PutObjectAclOutput = {
    RequestCharged?: 'requester';
  };
  declare type S3$20060301$PutObjectAclRequest = {
    ACL?: 'private' | 'public-read' | 'public-read-write' | 'authenticated-read' | 'aws-exec-read' | 'bucket-owner-read' | 'bucket-owner-full-control';
    AccessControlPolicy?: S3$20060301$AccessControlPolicy;
    Bucket: string;
    ContentMD5?: string;
    GrantFullControl?: string;
    GrantRead?: string;
    GrantReadACP?: string;
    GrantWrite?: string;
    GrantWriteACP?: string;
    Key: string;
    RequestPayer?: 'requester';
    VersionId?: string;
  };
  declare type S3$20060301$PutObjectOutput = {
    Expiration?: string;
    ETag?: string;
    ServerSideEncryption?: 'AES256' | 'aws:kms';
    VersionId?: string;
    SSECustomerAlgorithm?: string;
    SSECustomerKeyMD5?: string;
    SSEKMSKeyId?: string;
    RequestCharged?: 'requester';
  };
  declare type S3$20060301$PutObjectRequest = {
    ACL?: 'private' | 'public-read' | 'public-read-write' | 'authenticated-read' | 'aws-exec-read' | 'bucket-owner-read' | 'bucket-owner-full-control';
    Body?: Buffer | $TypedArray | Blob | string;
    Bucket: string;
    CacheControl?: string;
    ContentDisposition?: string;
    ContentEncoding?: string;
    ContentLanguage?: string;
    ContentLength?: number;
    ContentMD5?: string;
    ContentType?: string;
    Expires?: Date;
    GrantFullControl?: string;
    GrantRead?: string;
    GrantReadACP?: string;
    GrantWriteACP?: string;
    Key: string;
    Metadata?: {
      [key: string]: string;
    };
    ServerSideEncryption?: 'AES256' | 'aws:kms';
    StorageClass?: 'STANDARD' | 'REDUCED_REDUNDANCY' | 'STANDARD_IA';
    WebsiteRedirectLocation?: string;
    SSECustomerAlgorithm?: string;
    SSECustomerKey?: Buffer | $TypedArray | Blob | string;
    SSECustomerKeyMD5?: string;
    SSEKMSKeyId?: string;
    RequestPayer?: 'requester';
  };
  declare type S3$20060301$QueueConfiguration = {
    Id?: string;
    QueueArn: string;
    Events: S3$20060301$EventList;
    Filter?: S3$20060301$NotificationConfigurationFilter;
  };
  declare type S3$20060301$QueueConfigurationDeprecated = {
    Id?: string;
    Event?: 's3:ReducedRedundancyLostObject' | 's3:ObjectCreated:*' | 's3:ObjectCreated:Put' | 's3:ObjectCreated:Post' | 's3:ObjectCreated:Copy' | 's3:ObjectCreated:CompleteMultipartUpload' | 's3:ObjectRemoved:*' | 's3:ObjectRemoved:Delete' | 's3:ObjectRemoved:DeleteMarkerCreated';
    Events?: S3$20060301$EventList;
    Queue?: string;
  };
  declare type S3$20060301$QueueConfigurationList = S3$20060301$QueueConfiguration[];
  declare type S3$20060301$Redirect = {
    HostName?: string;
    HttpRedirectCode?: string;
    Protocol?: 'http' | 'https';
    ReplaceKeyPrefixWith?: string;
    ReplaceKeyWith?: string;
  };
  declare type S3$20060301$RedirectAllRequestsTo = {
    HostName: string;
    Protocol?: 'http' | 'https';
  };
  declare type S3$20060301$ReplicationConfiguration = {
    Role: string;
    Rules: S3$20060301$ReplicationRules;
  };
  declare type S3$20060301$ReplicationRule = {
    ID?: string;
    Prefix: string;
    Status: 'Enabled' | 'Disabled';
    Destination: S3$20060301$Destination;
  };
  declare type S3$20060301$ReplicationRuleStatus = 'Enabled' | 'Disabled';
  declare type S3$20060301$ReplicationRules = S3$20060301$ReplicationRule[];
  declare type S3$20060301$ReplicationStatus = 'COMPLETE' | 'PENDING' | 'FAILED' | 'REPLICA';
  declare type S3$20060301$RequestCharged = 'requester';
  declare type S3$20060301$RequestPayer = 'requester';
  declare type S3$20060301$RequestPaymentConfiguration = {
    Payer: 'Requester' | 'BucketOwner';
  };
  declare type S3$20060301$ResponseExpires = Date;
  declare type S3$20060301$RestoreObjectOutput = {
    RequestCharged?: 'requester';
  };
  declare type S3$20060301$RestoreObjectRequest = {
    Bucket: string;
    Key: string;
    VersionId?: string;
    RestoreRequest?: S3$20060301$RestoreRequest;
    RequestPayer?: 'requester';
  };
  declare type S3$20060301$RestoreRequest = {
    Days: number;
  };
  declare type S3$20060301$RoutingRule = {
    Condition?: S3$20060301$Condition;
    Redirect: S3$20060301$Redirect;
  };
  declare type S3$20060301$RoutingRules = S3$20060301$RoutingRule[];
  declare type S3$20060301$Rule = {
    Expiration?: S3$20060301$LifecycleExpiration;
    ID?: string;
    Prefix: string;
    Status: 'Enabled' | 'Disabled';
    Transition?: S3$20060301$Transition;
    NoncurrentVersionTransition?: S3$20060301$NoncurrentVersionTransition;
    NoncurrentVersionExpiration?: S3$20060301$NoncurrentVersionExpiration;
    AbortIncompleteMultipartUpload?: S3$20060301$AbortIncompleteMultipartUpload;
  };
  declare type S3$20060301$Rules = S3$20060301$Rule[];
  declare type S3$20060301$S3KeyFilter = {
    FilterRules?: S3$20060301$FilterRuleList;
  };
  declare type S3$20060301$SSECustomerKey = Buffer | $TypedArray | Blob | string;
  declare type S3$20060301$ServerSideEncryption = 'AES256' | 'aws:kms';
  declare type S3$20060301$StorageClass = 'STANDARD' | 'REDUCED_REDUNDANCY' | 'STANDARD_IA';
  declare type S3$20060301$Tag = {
    Key: string;
    Value: string;
  };
  declare type S3$20060301$TagSet = S3$20060301$Tag[];
  declare type S3$20060301$Tagging = {
    TagSet: S3$20060301$TagSet;
  };
  declare type S3$20060301$TargetGrant = {
    Grantee?: S3$20060301$Grantee;
    Permission?: 'FULL_CONTROL' | 'READ' | 'WRITE';
  };
  declare type S3$20060301$TargetGrants = S3$20060301$TargetGrant[];
  declare type S3$20060301$TopicConfiguration = {
    Id?: string;
    TopicArn: string;
    Events: S3$20060301$EventList;
    Filter?: S3$20060301$NotificationConfigurationFilter;
  };
  declare type S3$20060301$TopicConfigurationDeprecated = {
    Id?: string;
    Events?: S3$20060301$EventList;
    Event?: 's3:ReducedRedundancyLostObject' | 's3:ObjectCreated:*' | 's3:ObjectCreated:Put' | 's3:ObjectCreated:Post' | 's3:ObjectCreated:Copy' | 's3:ObjectCreated:CompleteMultipartUpload' | 's3:ObjectRemoved:*' | 's3:ObjectRemoved:Delete' | 's3:ObjectRemoved:DeleteMarkerCreated';
    Topic?: string;
  };
  declare type S3$20060301$TopicConfigurationList = S3$20060301$TopicConfiguration[];
  declare type S3$20060301$Transition = {
    Date?: Date;
    Days?: number;
    StorageClass?: 'GLACIER' | 'STANDARD_IA';
  };
  declare type S3$20060301$TransitionList = S3$20060301$Transition[];
  declare type S3$20060301$TransitionStorageClass = 'GLACIER' | 'STANDARD_IA';
  declare type S3$20060301$Type = 'CanonicalUser' | 'AmazonCustomerByEmail' | 'Group';
  declare type S3$20060301$UploadPartCopyOutput = {
    CopySourceVersionId?: string;
    CopyPartResult?: S3$20060301$CopyPartResult;
    ServerSideEncryption?: 'AES256' | 'aws:kms';
    SSECustomerAlgorithm?: string;
    SSECustomerKeyMD5?: string;
    SSEKMSKeyId?: string;
    RequestCharged?: 'requester';
  };
  declare type S3$20060301$UploadPartCopyRequest = {
    Bucket: string;
    CopySource: string;
    CopySourceIfMatch?: string;
    CopySourceIfModifiedSince?: Date;
    CopySourceIfNoneMatch?: string;
    CopySourceIfUnmodifiedSince?: Date;
    CopySourceRange?: string;
    Key: string;
    PartNumber: number;
    UploadId: string;
    SSECustomerAlgorithm?: string;
    SSECustomerKey?: Buffer | $TypedArray | Blob | string;
    SSECustomerKeyMD5?: string;
    CopySourceSSECustomerAlgorithm?: string;
    CopySourceSSECustomerKey?: Buffer | $TypedArray | Blob | string;
    CopySourceSSECustomerKeyMD5?: string;
    RequestPayer?: 'requester';
  };
  declare type S3$20060301$UploadPartOutput = {
    ServerSideEncryption?: 'AES256' | 'aws:kms';
    ETag?: string;
    SSECustomerAlgorithm?: string;
    SSECustomerKeyMD5?: string;
    SSEKMSKeyId?: string;
    RequestCharged?: 'requester';
  };
  declare type S3$20060301$UploadPartRequest = {
    Body?: Buffer | $TypedArray | Blob | string;
    Bucket: string;
    ContentLength?: number;
    ContentMD5?: string;
    Key: string;
    PartNumber: number;
    UploadId: string;
    SSECustomerAlgorithm?: string;
    SSECustomerKey?: Buffer | $TypedArray | Blob | string;
    SSECustomerKeyMD5?: string;
    RequestPayer?: 'requester';
  };
  declare type S3$20060301$VersioningConfiguration = {
    MFADelete?: 'Enabled' | 'Disabled';
    Status?: 'Enabled' | 'Suspended';
  };
  declare type S3$20060301$WebsiteConfiguration = {
    ErrorDocument?: S3$20060301$ErrorDocument;
    IndexDocument?: S3$20060301$IndexDocument;
    RedirectAllRequestsTo?: S3$20060301$RedirectAllRequestsTo;
    RoutingRules?: S3$20060301$RoutingRules;
  };
  declare type ServiceCatalog$20151210$AllowedValues = string[];
  declare type ServiceCatalog$20151210$ConstraintSummaries = ServiceCatalog$20151210$ConstraintSummary[];
  declare type ServiceCatalog$20151210$ConstraintSummary = {
    Type?: string;
    Description?: string;
  };
  declare type ServiceCatalog$20151210$CreatedTime = Date;
  declare type ServiceCatalog$20151210$DescribeProductInput = {
    AcceptLanguage?: string;
    Id: string;
  };
  declare type ServiceCatalog$20151210$DescribeProductOutput = {
    ProductViewSummary?: ServiceCatalog$20151210$ProductViewSummary;
    ProvisioningArtifacts?: ServiceCatalog$20151210$ProvisioningArtifacts;
  };
  declare type ServiceCatalog$20151210$DescribeProductViewInput = {
    AcceptLanguage?: string;
    Id: string;
  };
  declare type ServiceCatalog$20151210$DescribeProductViewOutput = {
    ProductViewSummary?: ServiceCatalog$20151210$ProductViewSummary;
    ProvisioningArtifacts?: ServiceCatalog$20151210$ProvisioningArtifacts;
  };
  declare type ServiceCatalog$20151210$DescribeProvisioningParametersInput = {
    AcceptLanguage?: string;
    ProductId: string;
    ProvisioningArtifactId: string;
    PathId?: string;
  };
  declare type ServiceCatalog$20151210$DescribeProvisioningParametersOutput = {
    ProvisioningArtifactParameters?: ServiceCatalog$20151210$ProvisioningArtifactParameters;
    ConstraintSummaries?: ServiceCatalog$20151210$ConstraintSummaries;
    UsageInstructions?: ServiceCatalog$20151210$UsageInstructions;
  };
  declare type ServiceCatalog$20151210$DescribeRecordInput = {
    AcceptLanguage?: string;
    Id: string;
    PageToken?: string;
    PageSize?: number;
  };
  declare type ServiceCatalog$20151210$DescribeRecordOutput = {
    RecordDetail?: ServiceCatalog$20151210$RecordDetail;
    RecordOutputs?: ServiceCatalog$20151210$RecordOutputs;
    NextPageToken?: string;
  };
  declare type ServiceCatalog$20151210$DuplicateResourceException = {};
  declare type ServiceCatalog$20151210$InvalidParametersException = {};
  declare type ServiceCatalog$20151210$LaunchPathSummaries = ServiceCatalog$20151210$LaunchPathSummary[];
  declare type ServiceCatalog$20151210$LaunchPathSummary = {
    Id?: string;
    ConstraintSummaries?: ServiceCatalog$20151210$ConstraintSummaries;
    Tags?: ServiceCatalog$20151210$Tags;
    Name?: string;
  };
  declare type ServiceCatalog$20151210$ListLaunchPathsInput = {
    AcceptLanguage?: string;
    ProductId: string;
    PageSize?: number;
    PageToken?: string;
  };
  declare type ServiceCatalog$20151210$ListLaunchPathsOutput = {
    LaunchPathSummaries?: ServiceCatalog$20151210$LaunchPathSummaries;
    NextPageToken?: string;
  };
  declare type ServiceCatalog$20151210$ListRecordHistoryInput = {
    AcceptLanguage?: string;
    SearchFilter?: ServiceCatalog$20151210$ListRecordHistorySearchFilter;
    PageSize?: number;
    PageToken?: string;
  };
  declare type ServiceCatalog$20151210$ListRecordHistoryOutput = {
    RecordDetails?: ServiceCatalog$20151210$RecordDetails;
    NextPageToken?: string;
  };
  declare type ServiceCatalog$20151210$ListRecordHistorySearchFilter = {
    Key?: string;
    Value?: string;
  };
  declare type ServiceCatalog$20151210$NotificationArns = string[];
  declare type ServiceCatalog$20151210$ParameterConstraints = {
    AllowedValues?: ServiceCatalog$20151210$AllowedValues;
  };
  declare type ServiceCatalog$20151210$ProductViewAggregationValue = {
    Value?: string;
    ApproximateCount?: number;
  };
  declare type ServiceCatalog$20151210$ProductViewAggregationValues = ServiceCatalog$20151210$ProductViewAggregationValue[];
  declare type ServiceCatalog$20151210$ProductViewAggregations = {
    [key: string]: ServiceCatalog$20151210$ProductViewAggregationValues;
  };
  declare type ServiceCatalog$20151210$ProductViewFilterBy = 'FullTextSearch' | 'Owner' | 'ProductType';
  declare type ServiceCatalog$20151210$ProductViewFilterValues = string[];
  declare type ServiceCatalog$20151210$ProductViewFilters = {
    [key: 'FullTextSearch' | 'Owner' | 'ProductType']: ServiceCatalog$20151210$ProductViewFilterValues;
  };
  declare type ServiceCatalog$20151210$ProductViewSortBy = 'Title' | 'VersionCount' | 'CreationDate';
  declare type ServiceCatalog$20151210$ProductViewSummaries = ServiceCatalog$20151210$ProductViewSummary[];
  declare type ServiceCatalog$20151210$ProductViewSummary = {
    Id?: string;
    ProductId?: string;
    Name?: string;
    Owner?: string;
    ShortDescription?: string;
    Type?: string;
    Distributor?: string;
    HasDefaultPath?: boolean;
    SupportEmail?: string;
    SupportDescription?: string;
    SupportUrl?: string;
  };
  declare type ServiceCatalog$20151210$ProvisionProductInput = {
    AcceptLanguage?: string;
    ProductId: string;
    ProvisioningArtifactId: string;
    PathId?: string;
    ProvisionedProductName: string;
    ProvisioningParameters?: ServiceCatalog$20151210$ProvisioningParameters;
    Tags?: ServiceCatalog$20151210$Tags;
    NotificationArns?: ServiceCatalog$20151210$NotificationArns;
    ProvisionToken: string;
  };
  declare type ServiceCatalog$20151210$ProvisionProductOutput = {
    RecordDetail?: ServiceCatalog$20151210$RecordDetail;
  };
  declare type ServiceCatalog$20151210$ProvisionedProductDetail = {
    Name?: string;
    Arn?: string;
    Type?: string;
    Id?: string;
    Status?: 'IN_PROGRESS' | 'SUCCEEDED' | 'ERROR';
    StatusMessage?: string;
    CreatedTime?: Date;
    IdempotencyToken?: string;
    LastRecordId?: string;
  };
  declare type ServiceCatalog$20151210$ProvisionedProductDetails = ServiceCatalog$20151210$ProvisionedProductDetail[];
  declare type ServiceCatalog$20151210$ProvisioningArtifact = {
    Id?: string;
    Name?: string;
    Description?: string;
    CreatedTime?: Date;
  };
  declare type ServiceCatalog$20151210$ProvisioningArtifactCreatedTime = Date;
  declare type ServiceCatalog$20151210$ProvisioningArtifactParameter = {
    ParameterKey?: string;
    DefaultValue?: string;
    ParameterType?: string;
    IsNoEcho?: boolean;
    Description?: string;
    ParameterConstraints?: ServiceCatalog$20151210$ParameterConstraints;
  };
  declare type ServiceCatalog$20151210$ProvisioningArtifactParameters = ServiceCatalog$20151210$ProvisioningArtifactParameter[];
  declare type ServiceCatalog$20151210$ProvisioningArtifacts = ServiceCatalog$20151210$ProvisioningArtifact[];
  declare type ServiceCatalog$20151210$ProvisioningParameter = {
    Key?: string;
    Value?: string;
  };
  declare type ServiceCatalog$20151210$ProvisioningParameters = ServiceCatalog$20151210$ProvisioningParameter[];
  declare type ServiceCatalog$20151210$RecordDetail = {
    RecordId?: string;
    ProvisionedProductName?: string;
    Status?: 'IN_PROGRESS' | 'SUCCEEDED' | 'ERROR';
    CreatedTime?: Date;
    UpdatedTime?: Date;
    ProvisionedProductType?: string;
    RecordType?: string;
    ProvisionedProductId?: string;
    ProductId?: string;
    ProvisioningArtifactId?: string;
    PathId?: string;
    RecordErrors?: ServiceCatalog$20151210$RecordErrors;
    RecordTags?: ServiceCatalog$20151210$RecordTags;
  };
  declare type ServiceCatalog$20151210$RecordDetails = ServiceCatalog$20151210$RecordDetail[];
  declare type ServiceCatalog$20151210$RecordError = {
    Code?: string;
    Description?: string;
  };
  declare type ServiceCatalog$20151210$RecordErrors = ServiceCatalog$20151210$RecordError[];
  declare type ServiceCatalog$20151210$RecordOutput = {
    OutputKey?: string;
    OutputValue?: string;
    Description?: string;
  };
  declare type ServiceCatalog$20151210$RecordOutputs = ServiceCatalog$20151210$RecordOutput[];
  declare type ServiceCatalog$20151210$RecordStatus = 'IN_PROGRESS' | 'SUCCEEDED' | 'ERROR';
  declare type ServiceCatalog$20151210$RecordTag = {
    Key?: string;
    Value?: string;
  };
  declare type ServiceCatalog$20151210$RecordTags = ServiceCatalog$20151210$RecordTag[];
  declare type ServiceCatalog$20151210$ResourceNotFoundException = {};
  declare type ServiceCatalog$20151210$ScanProvisionedProductsInput = {
    AcceptLanguage?: string;
    PageSize?: number;
    PageToken?: string;
  };
  declare type ServiceCatalog$20151210$ScanProvisionedProductsOutput = {
    ProvisionedProducts?: ServiceCatalog$20151210$ProvisionedProductDetails;
    NextPageToken?: string;
  };
  declare type ServiceCatalog$20151210$SearchProductsInput = {
    AcceptLanguage?: string;
    Filters?: {
      [key: 'FullTextSearch' | 'Owner' | 'ProductType']: ServiceCatalog$20151210$ProductViewFilterValues;
    };
    PageSize?: number;
    SortBy?: 'Title' | 'VersionCount' | 'CreationDate';
    SortOrder?: 'ASCENDING' | 'DESCENDING';
    PageToken?: string;
  };
  declare type ServiceCatalog$20151210$SearchProductsOutput = {
    ProductViewSummaries?: ServiceCatalog$20151210$ProductViewSummaries;
    ProductViewAggregations?: {
      [key: string]: ServiceCatalog$20151210$ProductViewAggregationValues;
    };
    NextPageToken?: string;
  };
  declare type ServiceCatalog$20151210$SortOrder = 'ASCENDING' | 'DESCENDING';
  declare type ServiceCatalog$20151210$Tag = {
    Key?: string;
    Value?: string;
  };
  declare type ServiceCatalog$20151210$Tags = ServiceCatalog$20151210$Tag[];
  declare type ServiceCatalog$20151210$TerminateProvisionedProductInput = {
    ProvisionedProductName?: string;
    ProvisionedProductId?: string;
    TerminateToken: string;
    IgnoreErrors?: boolean;
    AcceptLanguage?: string;
  };
  declare type ServiceCatalog$20151210$TerminateProvisionedProductOutput = {
    RecordDetail?: ServiceCatalog$20151210$RecordDetail;
  };
  declare type ServiceCatalog$20151210$UpdateProvisionedProductInput = {
    AcceptLanguage?: string;
    ProvisionedProductName?: string;
    ProvisionedProductId?: string;
    ProductId?: string;
    ProvisioningArtifactId?: string;
    PathId?: string;
    ProvisioningParameters?: ServiceCatalog$20151210$UpdateProvisioningParameters;
    UpdateToken: string;
  };
  declare type ServiceCatalog$20151210$UpdateProvisionedProductOutput = {
    RecordDetail?: ServiceCatalog$20151210$RecordDetail;
  };
  declare type ServiceCatalog$20151210$UpdateProvisioningParameter = {
    Key?: string;
    Value?: string;
    UsePreviousValue?: boolean;
  };
  declare type ServiceCatalog$20151210$UpdateProvisioningParameters = ServiceCatalog$20151210$UpdateProvisioningParameter[];
  declare type ServiceCatalog$20151210$UpdatedTime = Date;
  declare type ServiceCatalog$20151210$UsageInstruction = {
    Type?: string;
    Value?: string;
  };
  declare type ServiceCatalog$20151210$UsageInstructions = ServiceCatalog$20151210$UsageInstruction[];
  declare type SES$20101201$AddHeaderAction = {
    HeaderName: string;
    HeaderValue: string;
  };
  declare type SES$20101201$AddressList = string[];
  declare type SES$20101201$AlreadyExistsException = {
    Name?: string;
  };
  declare type SES$20101201$ArrivalDate = Date;
  declare type SES$20101201$BehaviorOnMXFailure = 'UseDefaultValue' | 'RejectMessage';
  declare type SES$20101201$Body = {
    Text?: SES$20101201$Content;
    Html?: SES$20101201$Content;
  };
  declare type SES$20101201$BounceAction = {
    TopicArn?: string;
    SmtpReplyCode: string;
    StatusCode?: string;
    Message: string;
    Sender: string;
  };
  declare type SES$20101201$BounceType = 'DoesNotExist' | 'MessageTooLarge' | 'ExceededQuota' | 'ContentRejected' | 'Undefined' | 'TemporaryFailure';
  declare type SES$20101201$BouncedRecipientInfo = {
    Recipient: string;
    RecipientArn?: string;
    BounceType?: 'DoesNotExist' | 'MessageTooLarge' | 'ExceededQuota' | 'ContentRejected' | 'Undefined' | 'TemporaryFailure';
    RecipientDsnFields?: SES$20101201$RecipientDsnFields;
  };
  declare type SES$20101201$BouncedRecipientInfoList = SES$20101201$BouncedRecipientInfo[];
  declare type SES$20101201$CannotDeleteException = {
    Name?: string;
  };
  declare type SES$20101201$CloneReceiptRuleSetRequest = {
    RuleSetName: string;
    OriginalRuleSetName: string;
  };
  declare type SES$20101201$CloneReceiptRuleSetResponse = {};
  declare type SES$20101201$Content = {
    Data: string;
    Charset?: string;
  };
  declare type SES$20101201$CreateReceiptFilterRequest = {
    Filter: SES$20101201$ReceiptFilter;
  };
  declare type SES$20101201$CreateReceiptFilterResponse = {};
  declare type SES$20101201$CreateReceiptRuleRequest = {
    RuleSetName: string;
    After?: string;
    Rule: SES$20101201$ReceiptRule;
  };
  declare type SES$20101201$CreateReceiptRuleResponse = {};
  declare type SES$20101201$CreateReceiptRuleSetRequest = {
    RuleSetName: string;
  };
  declare type SES$20101201$CreateReceiptRuleSetResponse = {};
  declare type SES$20101201$CustomMailFromStatus = 'Pending' | 'Success' | 'Failed' | 'TemporaryFailure';
  declare type SES$20101201$DeleteIdentityPolicyRequest = {
    Identity: string;
    PolicyName: string;
  };
  declare type SES$20101201$DeleteIdentityPolicyResponse = {};
  declare type SES$20101201$DeleteIdentityRequest = {
    Identity: string;
  };
  declare type SES$20101201$DeleteIdentityResponse = {};
  declare type SES$20101201$DeleteReceiptFilterRequest = {
    FilterName: string;
  };
  declare type SES$20101201$DeleteReceiptFilterResponse = {};
  declare type SES$20101201$DeleteReceiptRuleRequest = {
    RuleSetName: string;
    RuleName: string;
  };
  declare type SES$20101201$DeleteReceiptRuleResponse = {};
  declare type SES$20101201$DeleteReceiptRuleSetRequest = {
    RuleSetName: string;
  };
  declare type SES$20101201$DeleteReceiptRuleSetResponse = {};
  declare type SES$20101201$DeleteVerifiedEmailAddressRequest = {
    EmailAddress: string;
  };
  declare type SES$20101201$DescribeActiveReceiptRuleSetRequest = {};
  declare type SES$20101201$DescribeActiveReceiptRuleSetResponse = {
    Metadata?: SES$20101201$ReceiptRuleSetMetadata;
    Rules?: SES$20101201$ReceiptRulesList;
  };
  declare type SES$20101201$DescribeReceiptRuleRequest = {
    RuleSetName: string;
    RuleName: string;
  };
  declare type SES$20101201$DescribeReceiptRuleResponse = {
    Rule?: SES$20101201$ReceiptRule;
  };
  declare type SES$20101201$DescribeReceiptRuleSetRequest = {
    RuleSetName: string;
  };
  declare type SES$20101201$DescribeReceiptRuleSetResponse = {
    Metadata?: SES$20101201$ReceiptRuleSetMetadata;
    Rules?: SES$20101201$ReceiptRulesList;
  };
  declare type SES$20101201$Destination = {
    ToAddresses?: SES$20101201$AddressList;
    CcAddresses?: SES$20101201$AddressList;
    BccAddresses?: SES$20101201$AddressList;
  };
  declare type SES$20101201$DkimAttributes = {
    [key: string]: SES$20101201$IdentityDkimAttributes;
  };
  declare type SES$20101201$DsnAction = 'failed' | 'delayed' | 'delivered' | 'relayed' | 'expanded';
  declare type SES$20101201$ExtensionField = {
    Name: string;
    Value: string;
  };
  declare type SES$20101201$ExtensionFieldList = SES$20101201$ExtensionField[];
  declare type SES$20101201$GetIdentityDkimAttributesRequest = {
    Identities: SES$20101201$IdentityList;
  };
  declare type SES$20101201$GetIdentityDkimAttributesResponse = {
    DkimAttributes: {
      [key: string]: SES$20101201$IdentityDkimAttributes;
    };
  };
  declare type SES$20101201$GetIdentityMailFromDomainAttributesRequest = {
    Identities: SES$20101201$IdentityList;
  };
  declare type SES$20101201$GetIdentityMailFromDomainAttributesResponse = {
    MailFromDomainAttributes: {
      [key: string]: SES$20101201$IdentityMailFromDomainAttributes;
    };
  };
  declare type SES$20101201$GetIdentityNotificationAttributesRequest = {
    Identities: SES$20101201$IdentityList;
  };
  declare type SES$20101201$GetIdentityNotificationAttributesResponse = {
    NotificationAttributes: {
      [key: string]: SES$20101201$IdentityNotificationAttributes;
    };
  };
  declare type SES$20101201$GetIdentityPoliciesRequest = {
    Identity: string;
    PolicyNames: SES$20101201$PolicyNameList;
  };
  declare type SES$20101201$GetIdentityPoliciesResponse = {
    Policies: {
      [key: string]: string;
    };
  };
  declare type SES$20101201$GetIdentityVerificationAttributesRequest = {
    Identities: SES$20101201$IdentityList;
  };
  declare type SES$20101201$GetIdentityVerificationAttributesResponse = {
    VerificationAttributes: {
      [key: string]: SES$20101201$IdentityVerificationAttributes;
    };
  };
  declare type SES$20101201$GetSendQuotaResponse = {
    Max24HourSend?: number;
    MaxSendRate?: number;
    SentLast24Hours?: number;
  };
  declare type SES$20101201$GetSendStatisticsResponse = {
    SendDataPoints?: SES$20101201$SendDataPointList;
  };
  declare type SES$20101201$IdentityDkimAttributes = {
    DkimEnabled: boolean;
    DkimVerificationStatus: 'Pending' | 'Success' | 'Failed' | 'TemporaryFailure' | 'NotStarted';
    DkimTokens?: SES$20101201$VerificationTokenList;
  };
  declare type SES$20101201$IdentityList = string[];
  declare type SES$20101201$IdentityMailFromDomainAttributes = {
    MailFromDomain: string;
    MailFromDomainStatus: 'Pending' | 'Success' | 'Failed' | 'TemporaryFailure';
    BehaviorOnMXFailure: 'UseDefaultValue' | 'RejectMessage';
  };
  declare type SES$20101201$IdentityNotificationAttributes = {
    BounceTopic: string;
    ComplaintTopic: string;
    DeliveryTopic: string;
    ForwardingEnabled: boolean;
    HeadersInBounceNotificationsEnabled?: boolean;
    HeadersInComplaintNotificationsEnabled?: boolean;
    HeadersInDeliveryNotificationsEnabled?: boolean;
  };
  declare type SES$20101201$IdentityType = 'EmailAddress' | 'Domain';
  declare type SES$20101201$IdentityVerificationAttributes = {
    VerificationStatus: 'Pending' | 'Success' | 'Failed' | 'TemporaryFailure' | 'NotStarted';
    VerificationToken?: string;
  };
  declare type SES$20101201$InvalidLambdaFunctionException = {
    FunctionArn?: string;
  };
  declare type SES$20101201$InvalidPolicyException = {};
  declare type SES$20101201$InvalidS3ConfigurationException = {
    Bucket?: string;
  };
  declare type SES$20101201$InvalidSnsTopicException = {
    Topic?: string;
  };
  declare type SES$20101201$InvocationType = 'Event' | 'RequestResponse';
  declare type SES$20101201$LambdaAction = {
    TopicArn?: string;
    FunctionArn: string;
    InvocationType?: 'Event' | 'RequestResponse';
  };
  declare type SES$20101201$LastAttemptDate = Date;
  declare type SES$20101201$LimitExceededException = {};
  declare type SES$20101201$ListIdentitiesRequest = {
    IdentityType?: 'EmailAddress' | 'Domain';
    NextToken?: string;
    MaxItems?: number;
  };
  declare type SES$20101201$ListIdentitiesResponse = {
    Identities: SES$20101201$IdentityList;
    NextToken?: string;
  };
  declare type SES$20101201$ListIdentityPoliciesRequest = {
    Identity: string;
  };
  declare type SES$20101201$ListIdentityPoliciesResponse = {
    PolicyNames: SES$20101201$PolicyNameList;
  };
  declare type SES$20101201$ListReceiptFiltersRequest = {};
  declare type SES$20101201$ListReceiptFiltersResponse = {
    Filters?: SES$20101201$ReceiptFilterList;
  };
  declare type SES$20101201$ListReceiptRuleSetsRequest = {
    NextToken?: string;
  };
  declare type SES$20101201$ListReceiptRuleSetsResponse = {
    RuleSets?: SES$20101201$ReceiptRuleSetsLists;
    NextToken?: string;
  };
  declare type SES$20101201$ListVerifiedEmailAddressesResponse = {
    VerifiedEmailAddresses?: SES$20101201$AddressList;
  };
  declare type SES$20101201$MailFromDomainAttributes = {
    [key: string]: SES$20101201$IdentityMailFromDomainAttributes;
  };
  declare type SES$20101201$MailFromDomainNotVerifiedException = {};
  declare type SES$20101201$Message = {
    Subject: SES$20101201$Content;
    Body: SES$20101201$Body;
  };
  declare type SES$20101201$MessageDsn = {
    ReportingMta: string;
    ArrivalDate?: Date;
    ExtensionFields?: SES$20101201$ExtensionFieldList;
  };
  declare type SES$20101201$MessageRejected = {};
  declare type SES$20101201$NotificationAttributes = {
    [key: string]: SES$20101201$IdentityNotificationAttributes;
  };
  declare type SES$20101201$NotificationType = 'Bounce' | 'Complaint' | 'Delivery';
  declare type SES$20101201$PolicyMap = {
    [key: string]: string;
  };
  declare type SES$20101201$PolicyNameList = string[];
  declare type SES$20101201$PutIdentityPolicyRequest = {
    Identity: string;
    PolicyName: string;
    Policy: string;
  };
  declare type SES$20101201$PutIdentityPolicyResponse = {};
  declare type SES$20101201$RawMessage = {
    Data: Buffer | $TypedArray | Blob | string;
  };
  declare type SES$20101201$RawMessageData = Buffer | $TypedArray | Blob | string;
  declare type SES$20101201$ReceiptAction = {
    S3Action?: SES$20101201$S3Action;
    BounceAction?: SES$20101201$BounceAction;
    WorkmailAction?: SES$20101201$WorkmailAction;
    LambdaAction?: SES$20101201$LambdaAction;
    StopAction?: SES$20101201$StopAction;
    AddHeaderAction?: SES$20101201$AddHeaderAction;
    SNSAction?: SES$20101201$SNSAction;
  };
  declare type SES$20101201$ReceiptActionsList = SES$20101201$ReceiptAction[];
  declare type SES$20101201$ReceiptFilter = {
    Name: string;
    IpFilter: SES$20101201$ReceiptIpFilter;
  };
  declare type SES$20101201$ReceiptFilterList = SES$20101201$ReceiptFilter[];
  declare type SES$20101201$ReceiptFilterPolicy = 'Block' | 'Allow';
  declare type SES$20101201$ReceiptIpFilter = {
    Policy: 'Block' | 'Allow';
    Cidr: string;
  };
  declare type SES$20101201$ReceiptRule = {
    Name: string;
    Enabled?: boolean;
    TlsPolicy?: 'Require' | 'Optional';
    Recipients?: SES$20101201$RecipientsList;
    Actions?: SES$20101201$ReceiptActionsList;
    ScanEnabled?: boolean;
  };
  declare type SES$20101201$ReceiptRuleNamesList = string[];
  declare type SES$20101201$ReceiptRuleSetMetadata = {
    Name?: string;
    CreatedTimestamp?: Date;
  };
  declare type SES$20101201$ReceiptRuleSetsLists = SES$20101201$ReceiptRuleSetMetadata[];
  declare type SES$20101201$ReceiptRulesList = SES$20101201$ReceiptRule[];
  declare type SES$20101201$RecipientDsnFields = {
    FinalRecipient?: string;
    Action: 'failed' | 'delayed' | 'delivered' | 'relayed' | 'expanded';
    RemoteMta?: string;
    Status: string;
    DiagnosticCode?: string;
    LastAttemptDate?: Date;
    ExtensionFields?: SES$20101201$ExtensionFieldList;
  };
  declare type SES$20101201$RecipientsList = string[];
  declare type SES$20101201$ReorderReceiptRuleSetRequest = {
    RuleSetName: string;
    RuleNames: SES$20101201$ReceiptRuleNamesList;
  };
  declare type SES$20101201$ReorderReceiptRuleSetResponse = {};
  declare type SES$20101201$RuleDoesNotExistException = {
    Name?: string;
  };
  declare type SES$20101201$RuleSetDoesNotExistException = {
    Name?: string;
  };
  declare type SES$20101201$S3Action = {
    TopicArn?: string;
    BucketName: string;
    ObjectKeyPrefix?: string;
    KmsKeyArn?: string;
  };
  declare type SES$20101201$SNSAction = {
    TopicArn: string;
    Encoding?: 'UTF-8' | 'Base64';
  };
  declare type SES$20101201$SNSActionEncoding = 'UTF-8' | 'Base64';
  declare type SES$20101201$SendBounceRequest = {
    OriginalMessageId: string;
    BounceSender: string;
    Explanation?: string;
    MessageDsn?: SES$20101201$MessageDsn;
    BouncedRecipientInfoList: SES$20101201$BouncedRecipientInfoList;
    BounceSenderArn?: string;
  };
  declare type SES$20101201$SendBounceResponse = {
    MessageId?: string;
  };
  declare type SES$20101201$SendDataPoint = {
    Timestamp?: Date;
    DeliveryAttempts?: number;
    Bounces?: number;
    Complaints?: number;
    Rejects?: number;
  };
  declare type SES$20101201$SendDataPointList = SES$20101201$SendDataPoint[];
  declare type SES$20101201$SendEmailRequest = {
    Source: string;
    Destination: SES$20101201$Destination;
    Message: SES$20101201$Message;
    ReplyToAddresses?: SES$20101201$AddressList;
    ReturnPath?: string;
    SourceArn?: string;
    ReturnPathArn?: string;
  };
  declare type SES$20101201$SendEmailResponse = {
    MessageId: string;
  };
  declare type SES$20101201$SendRawEmailRequest = {
    Source?: string;
    Destinations?: SES$20101201$AddressList;
    RawMessage: SES$20101201$RawMessage;
    FromArn?: string;
    SourceArn?: string;
    ReturnPathArn?: string;
  };
  declare type SES$20101201$SendRawEmailResponse = {
    MessageId: string;
  };
  declare type SES$20101201$SetActiveReceiptRuleSetRequest = {
    RuleSetName?: string;
  };
  declare type SES$20101201$SetActiveReceiptRuleSetResponse = {};
  declare type SES$20101201$SetIdentityDkimEnabledRequest = {
    Identity: string;
    DkimEnabled: boolean;
  };
  declare type SES$20101201$SetIdentityDkimEnabledResponse = {};
  declare type SES$20101201$SetIdentityFeedbackForwardingEnabledRequest = {
    Identity: string;
    ForwardingEnabled: boolean;
  };
  declare type SES$20101201$SetIdentityFeedbackForwardingEnabledResponse = {};
  declare type SES$20101201$SetIdentityHeadersInNotificationsEnabledRequest = {
    Identity: string;
    NotificationType: 'Bounce' | 'Complaint' | 'Delivery';
    Enabled: boolean;
  };
  declare type SES$20101201$SetIdentityHeadersInNotificationsEnabledResponse = {};
  declare type SES$20101201$SetIdentityMailFromDomainRequest = {
    Identity: string;
    MailFromDomain?: string;
    BehaviorOnMXFailure?: 'UseDefaultValue' | 'RejectMessage';
  };
  declare type SES$20101201$SetIdentityMailFromDomainResponse = {};
  declare type SES$20101201$SetIdentityNotificationTopicRequest = {
    Identity: string;
    NotificationType: 'Bounce' | 'Complaint' | 'Delivery';
    SnsTopic?: string;
  };
  declare type SES$20101201$SetIdentityNotificationTopicResponse = {};
  declare type SES$20101201$SetReceiptRulePositionRequest = {
    RuleSetName: string;
    RuleName: string;
    After?: string;
  };
  declare type SES$20101201$SetReceiptRulePositionResponse = {};
  declare type SES$20101201$StopAction = {
    Scope: 'RuleSet';
    TopicArn?: string;
  };
  declare type SES$20101201$StopScope = 'RuleSet';
  declare type SES$20101201$Timestamp = Date;
  declare type SES$20101201$TlsPolicy = 'Require' | 'Optional';
  declare type SES$20101201$UpdateReceiptRuleRequest = {
    RuleSetName: string;
    Rule: SES$20101201$ReceiptRule;
  };
  declare type SES$20101201$UpdateReceiptRuleResponse = {};
  declare type SES$20101201$VerificationAttributes = {
    [key: string]: SES$20101201$IdentityVerificationAttributes;
  };
  declare type SES$20101201$VerificationStatus = 'Pending' | 'Success' | 'Failed' | 'TemporaryFailure' | 'NotStarted';
  declare type SES$20101201$VerificationTokenList = string[];
  declare type SES$20101201$VerifyDomainDkimRequest = {
    Domain: string;
  };
  declare type SES$20101201$VerifyDomainDkimResponse = {
    DkimTokens: SES$20101201$VerificationTokenList;
  };
  declare type SES$20101201$VerifyDomainIdentityRequest = {
    Domain: string;
  };
  declare type SES$20101201$VerifyDomainIdentityResponse = {
    VerificationToken: string;
  };
  declare type SES$20101201$VerifyEmailAddressRequest = {
    EmailAddress: string;
  };
  declare type SES$20101201$VerifyEmailIdentityRequest = {
    EmailAddress: string;
  };
  declare type SES$20101201$VerifyEmailIdentityResponse = {};
  declare type SES$20101201$WorkmailAction = {
    TopicArn?: string;
    OrganizationArn: string;
  };
  declare type SimpleDB$20090415$Attribute = {
    Name: string;
    AlternateNameEncoding?: string;
    Value: string;
    AlternateValueEncoding?: string;
  };
  declare type SimpleDB$20090415$AttributeDoesNotExist = {
    BoxUsage?: number;
  };
  declare type SimpleDB$20090415$AttributeList = SimpleDB$20090415$Attribute[];
  declare type SimpleDB$20090415$AttributeNameList = string[];
  declare type SimpleDB$20090415$BatchDeleteAttributesRequest = {
    DomainName: string;
    Items: SimpleDB$20090415$DeletableItemList;
  };
  declare type SimpleDB$20090415$BatchPutAttributesRequest = {
    DomainName: string;
    Items: SimpleDB$20090415$ReplaceableItemList;
  };
  declare type SimpleDB$20090415$CreateDomainRequest = {
    DomainName: string;
  };
  declare type SimpleDB$20090415$DeletableAttribute = {
    Name: string;
    Value?: string;
  };
  declare type SimpleDB$20090415$DeletableAttributeList = SimpleDB$20090415$DeletableAttribute[];
  declare type SimpleDB$20090415$DeletableItem = {
    Name: string;
    Attributes?: SimpleDB$20090415$DeletableAttributeList;
  };
  declare type SimpleDB$20090415$DeletableItemList = SimpleDB$20090415$DeletableItem[];
  declare type SimpleDB$20090415$DeleteAttributesRequest = {
    DomainName: string;
    ItemName: string;
    Attributes?: SimpleDB$20090415$DeletableAttributeList;
    Expected?: SimpleDB$20090415$UpdateCondition;
  };
  declare type SimpleDB$20090415$DeleteDomainRequest = {
    DomainName: string;
  };
  declare type SimpleDB$20090415$DomainMetadataRequest = {
    DomainName: string;
  };
  declare type SimpleDB$20090415$DomainMetadataResult = {
    ItemCount?: number;
    ItemNamesSizeBytes?: number;
    AttributeNameCount?: number;
    AttributeNamesSizeBytes?: number;
    AttributeValueCount?: number;
    AttributeValuesSizeBytes?: number;
    Timestamp?: number;
  };
  declare type SimpleDB$20090415$DomainNameList = string[];
  declare type SimpleDB$20090415$DuplicateItemName = {
    BoxUsage?: number;
  };
  declare type SimpleDB$20090415$GetAttributesRequest = {
    DomainName: string;
    ItemName: string;
    AttributeNames?: SimpleDB$20090415$AttributeNameList;
    ConsistentRead?: boolean;
  };
  declare type SimpleDB$20090415$GetAttributesResult = {
    Attributes?: SimpleDB$20090415$AttributeList;
  };
  declare type SimpleDB$20090415$InvalidNextToken = {
    BoxUsage?: number;
  };
  declare type SimpleDB$20090415$InvalidNumberPredicates = {
    BoxUsage?: number;
  };
  declare type SimpleDB$20090415$InvalidNumberValueTests = {
    BoxUsage?: number;
  };
  declare type SimpleDB$20090415$InvalidParameterValue = {
    BoxUsage?: number;
  };
  declare type SimpleDB$20090415$InvalidQueryExpression = {
    BoxUsage?: number;
  };
  declare type SimpleDB$20090415$Item = {
    Name: string;
    AlternateNameEncoding?: string;
    Attributes: SimpleDB$20090415$AttributeList;
  };
  declare type SimpleDB$20090415$ItemList = SimpleDB$20090415$Item[];
  declare type SimpleDB$20090415$ListDomainsRequest = {
    MaxNumberOfDomains?: number;
    NextToken?: string;
  };
  declare type SimpleDB$20090415$ListDomainsResult = {
    DomainNames?: SimpleDB$20090415$DomainNameList;
    NextToken?: string;
  };
  declare type SimpleDB$20090415$MissingParameter = {
    BoxUsage?: number;
  };
  declare type SimpleDB$20090415$NoSuchDomain = {
    BoxUsage?: number;
  };
  declare type SimpleDB$20090415$NumberDomainAttributesExceeded = {
    BoxUsage?: number;
  };
  declare type SimpleDB$20090415$NumberDomainBytesExceeded = {
    BoxUsage?: number;
  };
  declare type SimpleDB$20090415$NumberDomainsExceeded = {
    BoxUsage?: number;
  };
  declare type SimpleDB$20090415$NumberItemAttributesExceeded = {
    BoxUsage?: number;
  };
  declare type SimpleDB$20090415$NumberSubmittedAttributesExceeded = {
    BoxUsage?: number;
  };
  declare type SimpleDB$20090415$NumberSubmittedItemsExceeded = {
    BoxUsage?: number;
  };
  declare type SimpleDB$20090415$PutAttributesRequest = {
    DomainName: string;
    ItemName: string;
    Attributes: SimpleDB$20090415$ReplaceableAttributeList;
    Expected?: SimpleDB$20090415$UpdateCondition;
  };
  declare type SimpleDB$20090415$ReplaceableAttribute = {
    Name: string;
    Value: string;
    Replace?: boolean;
  };
  declare type SimpleDB$20090415$ReplaceableAttributeList = SimpleDB$20090415$ReplaceableAttribute[];
  declare type SimpleDB$20090415$ReplaceableItem = {
    Name: string;
    Attributes: SimpleDB$20090415$ReplaceableAttributeList;
  };
  declare type SimpleDB$20090415$ReplaceableItemList = SimpleDB$20090415$ReplaceableItem[];
  declare type SimpleDB$20090415$RequestTimeout = {
    BoxUsage?: number;
  };
  declare type SimpleDB$20090415$SelectRequest = {
    SelectExpression: string;
    NextToken?: string;
    ConsistentRead?: boolean;
  };
  declare type SimpleDB$20090415$SelectResult = {
    Items?: SimpleDB$20090415$ItemList;
    NextToken?: string;
  };
  declare type SimpleDB$20090415$TooManyRequestedAttributes = {
    BoxUsage?: number;
  };
  declare type SimpleDB$20090415$UpdateCondition = {
    Name?: string;
    Value?: string;
    Exists?: boolean;
  };
  declare type Snowball$20160630$Address = {
    AddressId?: string;
    Name?: string;
    Company?: string;
    Street1?: string;
    Street2?: string;
    Street3?: string;
    City?: string;
    StateOrProvince?: string;
    PrefectureOrDistrict?: string;
    Landmark?: string;
    Country?: string;
    PostalCode?: string;
    PhoneNumber?: string;
  };
  declare type Snowball$20160630$AddressList = Snowball$20160630$Address[];
  declare type Snowball$20160630$CancelJobRequest = {
    JobId: string;
  };
  declare type Snowball$20160630$CancelJobResult = {};
  declare type Snowball$20160630$CreateAddressRequest = {
    Address: Snowball$20160630$Address;
  };
  declare type Snowball$20160630$CreateAddressResult = {
    AddressId?: string;
  };
  declare type Snowball$20160630$CreateJobRequest = {
    JobType: 'IMPORT' | 'EXPORT';
    Resources: Snowball$20160630$JobResource;
    Description?: string;
    AddressId: string;
    KmsKeyARN?: string;
    RoleARN: string;
    SnowballCapacityPreference?: 'T50' | 'T80' | 'NoPreference';
    ShippingOption: 'SECOND_DAY' | 'NEXT_DAY' | 'EXPRESS' | 'STANDARD';
    Notification?: Snowball$20160630$Notification;
  };
  declare type Snowball$20160630$CreateJobResult = {
    JobId?: string;
  };
  declare type Snowball$20160630$DataTransfer = {
    BytesTransferred?: number;
    ObjectsTransferred?: number;
    TotalBytes?: number;
    TotalObjects?: number;
  };
  declare type Snowball$20160630$DescribeAddressRequest = {
    AddressId: string;
  };
  declare type Snowball$20160630$DescribeAddressResult = {
    Address?: Snowball$20160630$Address;
  };
  declare type Snowball$20160630$DescribeAddressesRequest = {
    MaxResults?: number;
    NextToken?: string;
  };
  declare type Snowball$20160630$DescribeAddressesResult = {
    Addresses?: Snowball$20160630$AddressList;
    NextToken?: string;
  };
  declare type Snowball$20160630$DescribeJobRequest = {
    JobId: string;
  };
  declare type Snowball$20160630$DescribeJobResult = {
    JobMetadata?: Snowball$20160630$JobMetadata;
    SubJobMetadata?: Snowball$20160630$JobMetadataList;
  };
  declare type Snowball$20160630$GetJobManifestRequest = {
    JobId: string;
  };
  declare type Snowball$20160630$GetJobManifestResult = {
    ManifestURI?: string;
  };
  declare type Snowball$20160630$GetJobUnlockCodeRequest = {
    JobId: string;
  };
  declare type Snowball$20160630$GetJobUnlockCodeResult = {
    UnlockCode?: string;
  };
  declare type Snowball$20160630$GetSnowballUsageRequest = {};
  declare type Snowball$20160630$GetSnowballUsageResult = {
    SnowballLimit?: number;
    SnowballsInUse?: number;
  };
  declare type Snowball$20160630$InvalidAddressException = {
    Message?: string;
  };
  declare type Snowball$20160630$InvalidJobStateException = {
    Message?: string;
  };
  declare type Snowball$20160630$InvalidResourceException = {
    Message?: string;
  };
  declare type Snowball$20160630$JobListEntry = {
    JobId?: string;
    JobState?: 'New' | 'PreparingAppliance' | 'PreparingShipment' | 'InTransitToCustomer' | 'WithCustomer' | 'InTransitToAWS' | 'WithAWS' | 'InProgress' | 'Complete' | 'Cancelled' | 'Listing' | 'Pending';
    IsMaster?: boolean;
  };
  declare type Snowball$20160630$JobListEntryList = Snowball$20160630$JobListEntry[];
  declare type Snowball$20160630$JobLogs = {
    JobCompletionReportURI?: string;
    JobSuccessLogURI?: string;
    JobFailureLogURI?: string;
  };
  declare type Snowball$20160630$JobMetadata = {
    JobId?: string;
    JobState?: 'New' | 'PreparingAppliance' | 'PreparingShipment' | 'InTransitToCustomer' | 'WithCustomer' | 'InTransitToAWS' | 'WithAWS' | 'InProgress' | 'Complete' | 'Cancelled' | 'Listing' | 'Pending';
    JobType?: 'IMPORT' | 'EXPORT';
    CreationDate?: Date;
    Resources?: Snowball$20160630$JobResource;
    Description?: string;
    KmsKeyARN?: string;
    RoleARN?: string;
    AddressId?: string;
    ShippingDetails?: Snowball$20160630$ShippingDetails;
    SnowballCapacityPreference?: 'T50' | 'T80' | 'NoPreference';
    Notification?: Snowball$20160630$Notification;
    DataTransferProgress?: Snowball$20160630$DataTransfer;
    JobLogInfo?: Snowball$20160630$JobLogs;
  };
  declare type Snowball$20160630$JobMetadataList = Snowball$20160630$JobMetadata[];
  declare type Snowball$20160630$JobResource = {
    S3Resources?: Snowball$20160630$S3ResourceList;
  };
  declare type Snowball$20160630$JobState = 'New' | 'PreparingAppliance' | 'PreparingShipment' | 'InTransitToCustomer' | 'WithCustomer' | 'InTransitToAWS' | 'WithAWS' | 'InProgress' | 'Complete' | 'Cancelled' | 'Listing' | 'Pending';
  declare type Snowball$20160630$JobStateList = ('New' | 'PreparingAppliance' | 'PreparingShipment' | 'InTransitToCustomer' | 'WithCustomer' | 'InTransitToAWS' | 'WithAWS' | 'InProgress' | 'Complete' | 'Cancelled' | 'Listing' | 'Pending')[];
  declare type Snowball$20160630$JobType = 'IMPORT' | 'EXPORT';
  declare type Snowball$20160630$KMSRequestFailedException = {
    Message?: string;
  };
  declare type Snowball$20160630$KeyRange = {
    BeginMarker?: string;
    EndMarker?: string;
  };
  declare type Snowball$20160630$ListJobsRequest = {
    MaxResults?: number;
    NextToken?: string;
  };
  declare type Snowball$20160630$ListJobsResult = {
    JobListEntries?: Snowball$20160630$JobListEntryList;
    NextToken?: string;
  };
  declare type Snowball$20160630$Notification = {
    SnsTopicARN?: string;
    JobStatesToNotify?: Snowball$20160630$JobStateList;
    NotifyAll?: boolean;
  };
  declare type Snowball$20160630$S3Resource = {
    BucketArn?: string;
    KeyRange?: Snowball$20160630$KeyRange;
  };
  declare type Snowball$20160630$S3ResourceList = Snowball$20160630$S3Resource[];
  declare type Snowball$20160630$Shipment = {
    Status?: string;
    TrackingNumber?: string;
  };
  declare type Snowball$20160630$ShippingDetails = {
    ShippingOption?: 'SECOND_DAY' | 'NEXT_DAY' | 'EXPRESS' | 'STANDARD';
    InboundShipment?: Snowball$20160630$Shipment;
    OutboundShipment?: Snowball$20160630$Shipment;
  };
  declare type Snowball$20160630$ShippingOption = 'SECOND_DAY' | 'NEXT_DAY' | 'EXPRESS' | 'STANDARD';
  declare type Snowball$20160630$SnowballCapacity = 'T50' | 'T80' | 'NoPreference';
  declare type Snowball$20160630$Timestamp = Date;
  declare type Snowball$20160630$UnsupportedAddressException = {
    Message?: string;
  };
  declare type Snowball$20160630$UpdateJobRequest = {
    JobId: string;
    RoleARN?: string;
    Notification?: Snowball$20160630$Notification;
    Resources?: Snowball$20160630$JobResource;
    AddressId?: string;
    ShippingOption?: 'SECOND_DAY' | 'NEXT_DAY' | 'EXPRESS' | 'STANDARD';
    Description?: string;
    SnowballCapacityPreference?: 'T50' | 'T80' | 'NoPreference';
  };
  declare type Snowball$20160630$UpdateJobResult = {};
  declare type SNS$20100331$ActionsList = string[];
  declare type SNS$20100331$AddPermissionInput = {
    TopicArn: string;
    Label: string;
    AWSAccountId: SNS$20100331$DelegatesList;
    ActionName: SNS$20100331$ActionsList;
  };
  declare type SNS$20100331$AuthorizationErrorException = {
    message?: string;
  };
  declare type SNS$20100331$Binary = Buffer | $TypedArray | Blob | string;
  declare type SNS$20100331$CheckIfPhoneNumberIsOptedOutInput = {
    phoneNumber: string;
  };
  declare type SNS$20100331$CheckIfPhoneNumberIsOptedOutResponse = {
    isOptedOut?: boolean;
  };
  declare type SNS$20100331$ConfirmSubscriptionInput = {
    TopicArn: string;
    Token: string;
    AuthenticateOnUnsubscribe?: string;
  };
  declare type SNS$20100331$ConfirmSubscriptionResponse = {
    SubscriptionArn?: string;
  };
  declare type SNS$20100331$CreateEndpointResponse = {
    EndpointArn?: string;
  };
  declare type SNS$20100331$CreatePlatformApplicationInput = {
    Name: string;
    Platform: string;
    Attributes: {
      [key: string]: string;
    };
  };
  declare type SNS$20100331$CreatePlatformApplicationResponse = {
    PlatformApplicationArn?: string;
  };
  declare type SNS$20100331$CreatePlatformEndpointInput = {
    PlatformApplicationArn: string;
    Token: string;
    CustomUserData?: string;
    Attributes?: {
      [key: string]: string;
    };
  };
  declare type SNS$20100331$CreateTopicInput = {
    Name: string;
  };
  declare type SNS$20100331$CreateTopicResponse = {
    TopicArn?: string;
  };
  declare type SNS$20100331$DelegatesList = string[];
  declare type SNS$20100331$DeleteEndpointInput = {
    EndpointArn: string;
  };
  declare type SNS$20100331$DeletePlatformApplicationInput = {
    PlatformApplicationArn: string;
  };
  declare type SNS$20100331$DeleteTopicInput = {
    TopicArn: string;
  };
  declare type SNS$20100331$Endpoint = {
    EndpointArn?: string;
    Attributes?: {
      [key: string]: string;
    };
  };
  declare type SNS$20100331$EndpointDisabledException = {
    message?: string;
  };
  declare type SNS$20100331$GetEndpointAttributesInput = {
    EndpointArn: string;
  };
  declare type SNS$20100331$GetEndpointAttributesResponse = {
    Attributes?: {
      [key: string]: string;
    };
  };
  declare type SNS$20100331$GetPlatformApplicationAttributesInput = {
    PlatformApplicationArn: string;
  };
  declare type SNS$20100331$GetPlatformApplicationAttributesResponse = {
    Attributes?: {
      [key: string]: string;
    };
  };
  declare type SNS$20100331$GetSMSAttributesInput = {
    attributes?: SNS$20100331$ListString;
  };
  declare type SNS$20100331$GetSMSAttributesResponse = {
    attributes?: {
      [key: string]: string;
    };
  };
  declare type SNS$20100331$GetSubscriptionAttributesInput = {
    SubscriptionArn: string;
  };
  declare type SNS$20100331$GetSubscriptionAttributesResponse = {
    Attributes?: {
      [key: string]: string;
    };
  };
  declare type SNS$20100331$GetTopicAttributesInput = {
    TopicArn: string;
  };
  declare type SNS$20100331$GetTopicAttributesResponse = {
    Attributes?: {
      [key: string]: string;
    };
  };
  declare type SNS$20100331$InternalErrorException = {
    message?: string;
  };
  declare type SNS$20100331$InvalidParameterException = {
    message?: string;
  };
  declare type SNS$20100331$InvalidParameterValueException = {
    message?: string;
  };
  declare type SNS$20100331$ListEndpointsByPlatformApplicationInput = {
    PlatformApplicationArn: string;
    NextToken?: string;
  };
  declare type SNS$20100331$ListEndpointsByPlatformApplicationResponse = {
    Endpoints?: SNS$20100331$ListOfEndpoints;
    NextToken?: string;
  };
  declare type SNS$20100331$ListOfEndpoints = SNS$20100331$Endpoint[];
  declare type SNS$20100331$ListOfPlatformApplications = SNS$20100331$PlatformApplication[];
  declare type SNS$20100331$ListPhoneNumbersOptedOutInput = {
    nextToken?: string;
  };
  declare type SNS$20100331$ListPhoneNumbersOptedOutResponse = {
    phoneNumbers?: SNS$20100331$PhoneNumberList;
    nextToken?: string;
  };
  declare type SNS$20100331$ListPlatformApplicationsInput = {
    NextToken?: string;
  };
  declare type SNS$20100331$ListPlatformApplicationsResponse = {
    PlatformApplications?: SNS$20100331$ListOfPlatformApplications;
    NextToken?: string;
  };
  declare type SNS$20100331$ListString = string[];
  declare type SNS$20100331$ListSubscriptionsByTopicInput = {
    TopicArn: string;
    NextToken?: string;
  };
  declare type SNS$20100331$ListSubscriptionsByTopicResponse = {
    Subscriptions?: SNS$20100331$SubscriptionsList;
    NextToken?: string;
  };
  declare type SNS$20100331$ListSubscriptionsInput = {
    NextToken?: string;
  };
  declare type SNS$20100331$ListSubscriptionsResponse = {
    Subscriptions?: SNS$20100331$SubscriptionsList;
    NextToken?: string;
  };
  declare type SNS$20100331$ListTopicsInput = {
    NextToken?: string;
  };
  declare type SNS$20100331$ListTopicsResponse = {
    Topics?: SNS$20100331$TopicsList;
    NextToken?: string;
  };
  declare type SNS$20100331$MapStringToString = {
    [key: string]: string;
  };
  declare type SNS$20100331$MessageAttributeMap = {
    [key: string]: SNS$20100331$MessageAttributeValue;
  };
  declare type SNS$20100331$MessageAttributeValue = {
    DataType: string;
    StringValue?: string;
    BinaryValue?: Buffer | $TypedArray | Blob | string;
  };
  declare type SNS$20100331$NotFoundException = {
    message?: string;
  };
  declare type SNS$20100331$OptInPhoneNumberInput = {
    phoneNumber: string;
  };
  declare type SNS$20100331$OptInPhoneNumberResponse = {};
  declare type SNS$20100331$PhoneNumberList = string[];
  declare type SNS$20100331$PlatformApplication = {
    PlatformApplicationArn?: string;
    Attributes?: {
      [key: string]: string;
    };
  };
  declare type SNS$20100331$PlatformApplicationDisabledException = {
    message?: string;
  };
  declare type SNS$20100331$PublishInput = {
    TopicArn?: string;
    TargetArn?: string;
    PhoneNumber?: string;
    Message: string;
    Subject?: string;
    MessageStructure?: string;
    MessageAttributes?: {
      [key: string]: SNS$20100331$MessageAttributeValue;
    };
  };
  declare type SNS$20100331$PublishResponse = {
    MessageId?: string;
  };
  declare type SNS$20100331$RemovePermissionInput = {
    TopicArn: string;
    Label: string;
  };
  declare type SNS$20100331$SetEndpointAttributesInput = {
    EndpointArn: string;
    Attributes: {
      [key: string]: string;
    };
  };
  declare type SNS$20100331$SetPlatformApplicationAttributesInput = {
    PlatformApplicationArn: string;
    Attributes: {
      [key: string]: string;
    };
  };
  declare type SNS$20100331$SetSMSAttributesInput = {
    attributes: {
      [key: string]: string;
    };
  };
  declare type SNS$20100331$SetSMSAttributesResponse = {};
  declare type SNS$20100331$SetSubscriptionAttributesInput = {
    SubscriptionArn: string;
    AttributeName: string;
    AttributeValue?: string;
  };
  declare type SNS$20100331$SetTopicAttributesInput = {
    TopicArn: string;
    AttributeName: string;
    AttributeValue?: string;
  };
  declare type SNS$20100331$SubscribeInput = {
    TopicArn: string;
    Protocol: string;
    Endpoint?: string;
  };
  declare type SNS$20100331$SubscribeResponse = {
    SubscriptionArn?: string;
  };
  declare type SNS$20100331$Subscription = {
    SubscriptionArn?: string;
    Owner?: string;
    Protocol?: string;
    Endpoint?: string;
    TopicArn?: string;
  };
  declare type SNS$20100331$SubscriptionAttributesMap = {
    [key: string]: string;
  };
  declare type SNS$20100331$SubscriptionLimitExceededException = {
    message?: string;
  };
  declare type SNS$20100331$SubscriptionsList = SNS$20100331$Subscription[];
  declare type SNS$20100331$ThrottledException = {
    message?: string;
  };
  declare type SNS$20100331$Topic = {
    TopicArn?: string;
  };
  declare type SNS$20100331$TopicAttributesMap = {
    [key: string]: string;
  };
  declare type SNS$20100331$TopicLimitExceededException = {
    message?: string;
  };
  declare type SNS$20100331$TopicsList = SNS$20100331$Topic[];
  declare type SNS$20100331$UnsubscribeInput = {
    SubscriptionArn: string;
  };
  declare type SQS$20121105$AWSAccountIdList = string[];
  declare type SQS$20121105$ActionNameList = string[];
  declare type SQS$20121105$AddPermissionRequest = {
    QueueUrl: string;
    Label: string;
    AWSAccountIds: SQS$20121105$AWSAccountIdList;
    Actions: SQS$20121105$ActionNameList;
  };
  declare type SQS$20121105$AttributeMap = {
    [key: 'Policy' | 'VisibilityTimeout' | 'MaximumMessageSize' | 'MessageRetentionPeriod' | 'ApproximateNumberOfMessages' | 'ApproximateNumberOfMessagesNotVisible' | 'CreatedTimestamp' | 'LastModifiedTimestamp' | 'QueueArn' | 'ApproximateNumberOfMessagesDelayed' | 'DelaySeconds' | 'ReceiveMessageWaitTimeSeconds' | 'RedrivePolicy']: string;
  };
  declare type SQS$20121105$AttributeNameList = ('Policy' | 'VisibilityTimeout' | 'MaximumMessageSize' | 'MessageRetentionPeriod' | 'ApproximateNumberOfMessages' | 'ApproximateNumberOfMessagesNotVisible' | 'CreatedTimestamp' | 'LastModifiedTimestamp' | 'QueueArn' | 'ApproximateNumberOfMessagesDelayed' | 'DelaySeconds' | 'ReceiveMessageWaitTimeSeconds' | 'RedrivePolicy')[];
  declare type SQS$20121105$BatchEntryIdsNotDistinct = {};
  declare type SQS$20121105$BatchRequestTooLong = {};
  declare type SQS$20121105$BatchResultErrorEntry = {
    Id: string;
    SenderFault: boolean;
    Code: string;
    Message?: string;
  };
  declare type SQS$20121105$BatchResultErrorEntryList = SQS$20121105$BatchResultErrorEntry[];
  declare type SQS$20121105$Binary = Buffer | $TypedArray | Blob | string;
  declare type SQS$20121105$BinaryList = (Buffer | $TypedArray | Blob | string)[];
  declare type SQS$20121105$ChangeMessageVisibilityBatchRequest = {
    QueueUrl: string;
    Entries: SQS$20121105$ChangeMessageVisibilityBatchRequestEntryList;
  };
  declare type SQS$20121105$ChangeMessageVisibilityBatchRequestEntry = {
    Id: string;
    ReceiptHandle: string;
    VisibilityTimeout?: number;
  };
  declare type SQS$20121105$ChangeMessageVisibilityBatchRequestEntryList = SQS$20121105$ChangeMessageVisibilityBatchRequestEntry[];
  declare type SQS$20121105$ChangeMessageVisibilityBatchResult = {
    Successful: SQS$20121105$ChangeMessageVisibilityBatchResultEntryList;
    Failed: SQS$20121105$BatchResultErrorEntryList;
  };
  declare type SQS$20121105$ChangeMessageVisibilityBatchResultEntry = {
    Id: string;
  };
  declare type SQS$20121105$ChangeMessageVisibilityBatchResultEntryList = SQS$20121105$ChangeMessageVisibilityBatchResultEntry[];
  declare type SQS$20121105$ChangeMessageVisibilityRequest = {
    QueueUrl: string;
    ReceiptHandle: string;
    VisibilityTimeout: number;
  };
  declare type SQS$20121105$CreateQueueRequest = {
    QueueName: string;
    Attributes?: {
      [key: 'Policy' | 'VisibilityTimeout' | 'MaximumMessageSize' | 'MessageRetentionPeriod' | 'ApproximateNumberOfMessages' | 'ApproximateNumberOfMessagesNotVisible' | 'CreatedTimestamp' | 'LastModifiedTimestamp' | 'QueueArn' | 'ApproximateNumberOfMessagesDelayed' | 'DelaySeconds' | 'ReceiveMessageWaitTimeSeconds' | 'RedrivePolicy']: string;
    };
  };
  declare type SQS$20121105$CreateQueueResult = {
    QueueUrl?: string;
  };
  declare type SQS$20121105$DeleteMessageBatchRequest = {
    QueueUrl: string;
    Entries: SQS$20121105$DeleteMessageBatchRequestEntryList;
  };
  declare type SQS$20121105$DeleteMessageBatchRequestEntry = {
    Id: string;
    ReceiptHandle: string;
  };
  declare type SQS$20121105$DeleteMessageBatchRequestEntryList = SQS$20121105$DeleteMessageBatchRequestEntry[];
  declare type SQS$20121105$DeleteMessageBatchResult = {
    Successful: SQS$20121105$DeleteMessageBatchResultEntryList;
    Failed: SQS$20121105$BatchResultErrorEntryList;
  };
  declare type SQS$20121105$DeleteMessageBatchResultEntry = {
    Id: string;
  };
  declare type SQS$20121105$DeleteMessageBatchResultEntryList = SQS$20121105$DeleteMessageBatchResultEntry[];
  declare type SQS$20121105$DeleteMessageRequest = {
    QueueUrl: string;
    ReceiptHandle: string;
  };
  declare type SQS$20121105$DeleteQueueRequest = {
    QueueUrl: string;
  };
  declare type SQS$20121105$EmptyBatchRequest = {};
  declare type SQS$20121105$GetQueueAttributesRequest = {
    QueueUrl: string;
    AttributeNames?: SQS$20121105$AttributeNameList;
  };
  declare type SQS$20121105$GetQueueAttributesResult = {
    Attributes?: {
      [key: 'Policy' | 'VisibilityTimeout' | 'MaximumMessageSize' | 'MessageRetentionPeriod' | 'ApproximateNumberOfMessages' | 'ApproximateNumberOfMessagesNotVisible' | 'CreatedTimestamp' | 'LastModifiedTimestamp' | 'QueueArn' | 'ApproximateNumberOfMessagesDelayed' | 'DelaySeconds' | 'ReceiveMessageWaitTimeSeconds' | 'RedrivePolicy']: string;
    };
  };
  declare type SQS$20121105$GetQueueUrlRequest = {
    QueueName: string;
    QueueOwnerAWSAccountId?: string;
  };
  declare type SQS$20121105$GetQueueUrlResult = {
    QueueUrl?: string;
  };
  declare type SQS$20121105$InvalidAttributeName = {};
  declare type SQS$20121105$InvalidBatchEntryId = {};
  declare type SQS$20121105$InvalidIdFormat = {};
  declare type SQS$20121105$InvalidMessageContents = {};
  declare type SQS$20121105$ListDeadLetterSourceQueuesRequest = {
    QueueUrl: string;
  };
  declare type SQS$20121105$ListDeadLetterSourceQueuesResult = {
    queueUrls: SQS$20121105$QueueUrlList;
  };
  declare type SQS$20121105$ListQueuesRequest = {
    QueueNamePrefix?: string;
  };
  declare type SQS$20121105$ListQueuesResult = {
    QueueUrls?: SQS$20121105$QueueUrlList;
  };
  declare type SQS$20121105$Message = {
    MessageId?: string;
    ReceiptHandle?: string;
    MD5OfBody?: string;
    Body?: string;
    Attributes?: {
      [key: 'Policy' | 'VisibilityTimeout' | 'MaximumMessageSize' | 'MessageRetentionPeriod' | 'ApproximateNumberOfMessages' | 'ApproximateNumberOfMessagesNotVisible' | 'CreatedTimestamp' | 'LastModifiedTimestamp' | 'QueueArn' | 'ApproximateNumberOfMessagesDelayed' | 'DelaySeconds' | 'ReceiveMessageWaitTimeSeconds' | 'RedrivePolicy']: string;
    };
    MD5OfMessageAttributes?: string;
    MessageAttributes?: {
      [key: string]: SQS$20121105$MessageAttributeValue;
    };
  };
  declare type SQS$20121105$MessageAttributeMap = {
    [key: string]: SQS$20121105$MessageAttributeValue;
  };
  declare type SQS$20121105$MessageAttributeNameList = string[];
  declare type SQS$20121105$MessageAttributeValue = {
    StringValue?: string;
    BinaryValue?: Buffer | $TypedArray | Blob | string;
    StringListValues?: SQS$20121105$StringList;
    BinaryListValues?: SQS$20121105$BinaryList;
    DataType: string;
  };
  declare type SQS$20121105$MessageList = SQS$20121105$Message[];
  declare type SQS$20121105$MessageNotInflight = {};
  declare type SQS$20121105$OverLimit = {};
  declare type SQS$20121105$PurgeQueueInProgress = {};
  declare type SQS$20121105$PurgeQueueRequest = {
    QueueUrl: string;
  };
  declare type SQS$20121105$QueueAttributeName = 'Policy' | 'VisibilityTimeout' | 'MaximumMessageSize' | 'MessageRetentionPeriod' | 'ApproximateNumberOfMessages' | 'ApproximateNumberOfMessagesNotVisible' | 'CreatedTimestamp' | 'LastModifiedTimestamp' | 'QueueArn' | 'ApproximateNumberOfMessagesDelayed' | 'DelaySeconds' | 'ReceiveMessageWaitTimeSeconds' | 'RedrivePolicy';
  declare type SQS$20121105$QueueDeletedRecently = {};
  declare type SQS$20121105$QueueDoesNotExist = {};
  declare type SQS$20121105$QueueNameExists = {};
  declare type SQS$20121105$QueueUrlList = string[];
  declare type SQS$20121105$ReceiptHandleIsInvalid = {};
  declare type SQS$20121105$ReceiveMessageRequest = {
    QueueUrl: string;
    AttributeNames?: SQS$20121105$AttributeNameList;
    MessageAttributeNames?: SQS$20121105$MessageAttributeNameList;
    MaxNumberOfMessages?: number;
    VisibilityTimeout?: number;
    WaitTimeSeconds?: number;
  };
  declare type SQS$20121105$ReceiveMessageResult = {
    Messages?: SQS$20121105$MessageList;
  };
  declare type SQS$20121105$RemovePermissionRequest = {
    QueueUrl: string;
    Label: string;
  };
  declare type SQS$20121105$SendMessageBatchRequest = {
    QueueUrl: string;
    Entries: SQS$20121105$SendMessageBatchRequestEntryList;
  };
  declare type SQS$20121105$SendMessageBatchRequestEntry = {
    Id: string;
    MessageBody: string;
    DelaySeconds?: number;
    MessageAttributes?: {
      [key: string]: SQS$20121105$MessageAttributeValue;
    };
  };
  declare type SQS$20121105$SendMessageBatchRequestEntryList = SQS$20121105$SendMessageBatchRequestEntry[];
  declare type SQS$20121105$SendMessageBatchResult = {
    Successful: SQS$20121105$SendMessageBatchResultEntryList;
    Failed: SQS$20121105$BatchResultErrorEntryList;
  };
  declare type SQS$20121105$SendMessageBatchResultEntry = {
    Id: string;
    MessageId: string;
    MD5OfMessageBody: string;
    MD5OfMessageAttributes?: string;
  };
  declare type SQS$20121105$SendMessageBatchResultEntryList = SQS$20121105$SendMessageBatchResultEntry[];
  declare type SQS$20121105$SendMessageRequest = {
    QueueUrl: string;
    MessageBody: string;
    DelaySeconds?: number;
    MessageAttributes?: {
      [key: string]: SQS$20121105$MessageAttributeValue;
    };
  };
  declare type SQS$20121105$SendMessageResult = {
    MD5OfMessageBody?: string;
    MD5OfMessageAttributes?: string;
    MessageId?: string;
  };
  declare type SQS$20121105$SetQueueAttributesRequest = {
    QueueUrl: string;
    Attributes: {
      [key: 'Policy' | 'VisibilityTimeout' | 'MaximumMessageSize' | 'MessageRetentionPeriod' | 'ApproximateNumberOfMessages' | 'ApproximateNumberOfMessagesNotVisible' | 'CreatedTimestamp' | 'LastModifiedTimestamp' | 'QueueArn' | 'ApproximateNumberOfMessagesDelayed' | 'DelaySeconds' | 'ReceiveMessageWaitTimeSeconds' | 'RedrivePolicy']: string;
    };
  };
  declare type SQS$20121105$StringList = string[];
  declare type SQS$20121105$TooManyEntriesInBatchRequest = {};
  declare type SQS$20121105$UnsupportedOperation = {};
  declare type SSM$20141106$AccountIdList = string[];
  declare type SSM$20141106$Activation = {
    ActivationId?: string;
    Description?: string;
    DefaultInstanceName?: string;
    IamRole?: string;
    RegistrationLimit?: number;
    RegistrationsCount?: number;
    ExpirationDate?: Date;
    Expired?: boolean;
    CreatedDate?: Date;
  };
  declare type SSM$20141106$ActivationList = SSM$20141106$Activation[];
  declare type SSM$20141106$AddTagsToResourceRequest = {
    ResourceType: 'ManagedInstance';
    ResourceId: string;
    Tags: SSM$20141106$TagList;
  };
  declare type SSM$20141106$AddTagsToResourceResult = {};
  declare type SSM$20141106$AssociatedInstances = {};
  declare type SSM$20141106$Association = {
    Name?: string;
    InstanceId?: string;
  };
  declare type SSM$20141106$AssociationAlreadyExists = {};
  declare type SSM$20141106$AssociationDescription = {
    Name?: string;
    InstanceId?: string;
    Date?: Date;
    Status?: SSM$20141106$AssociationStatus;
    Parameters?: {
      [key: string]: SSM$20141106$ParameterValueList;
    };
  };
  declare type SSM$20141106$AssociationDescriptionList = SSM$20141106$AssociationDescription[];
  declare type SSM$20141106$AssociationDoesNotExist = {};
  declare type SSM$20141106$AssociationFilter = {
    key: 'InstanceId' | 'Name';
    value: string;
  };
  declare type SSM$20141106$AssociationFilterKey = 'InstanceId' | 'Name';
  declare type SSM$20141106$AssociationFilterList = SSM$20141106$AssociationFilter[];
  declare type SSM$20141106$AssociationLimitExceeded = {};
  declare type SSM$20141106$AssociationList = SSM$20141106$Association[];
  declare type SSM$20141106$AssociationStatus = {
    Date: Date;
    Name: 'Pending' | 'Success' | 'Failed';
    Message: string;
    AdditionalInfo?: string;
  };
  declare type SSM$20141106$AssociationStatusName = 'Pending' | 'Success' | 'Failed';
  declare type SSM$20141106$CancelCommandRequest = {
    CommandId: string;
    InstanceIds?: SSM$20141106$InstanceIdList;
  };
  declare type SSM$20141106$CancelCommandResult = {};
  declare type SSM$20141106$Command = {
    CommandId?: string;
    DocumentName?: string;
    Comment?: string;
    ExpiresAfter?: Date;
    Parameters?: {
      [key: string]: SSM$20141106$ParameterValueList;
    };
    InstanceIds?: SSM$20141106$InstanceIdList;
    RequestedDateTime?: Date;
    Status?: 'Pending' | 'InProgress' | 'Cancelling' | 'Success' | 'TimedOut' | 'Cancelled' | 'Failed';
    OutputS3BucketName?: string;
    OutputS3KeyPrefix?: string;
    ServiceRole?: string;
    NotificationConfig?: SSM$20141106$NotificationConfig;
  };
  declare type SSM$20141106$CommandFilter = {
    key: 'InvokedAfter' | 'InvokedBefore' | 'Status';
    value: string;
  };
  declare type SSM$20141106$CommandFilterKey = 'InvokedAfter' | 'InvokedBefore' | 'Status';
  declare type SSM$20141106$CommandFilterList = SSM$20141106$CommandFilter[];
  declare type SSM$20141106$CommandInvocation = {
    CommandId?: string;
    InstanceId?: string;
    Comment?: string;
    DocumentName?: string;
    RequestedDateTime?: Date;
    Status?: 'Pending' | 'InProgress' | 'Cancelling' | 'Success' | 'TimedOut' | 'Cancelled' | 'Failed';
    TraceOutput?: string;
    CommandPlugins?: SSM$20141106$CommandPluginList;
    ServiceRole?: string;
    NotificationConfig?: SSM$20141106$NotificationConfig;
  };
  declare type SSM$20141106$CommandInvocationList = SSM$20141106$CommandInvocation[];
  declare type SSM$20141106$CommandInvocationStatus = 'Pending' | 'InProgress' | 'Cancelling' | 'Success' | 'TimedOut' | 'Cancelled' | 'Failed';
  declare type SSM$20141106$CommandList = SSM$20141106$Command[];
  declare type SSM$20141106$CommandPlugin = {
    Name?: string;
    Status?: 'Pending' | 'InProgress' | 'Success' | 'TimedOut' | 'Cancelled' | 'Failed';
    ResponseCode?: number;
    ResponseStartDateTime?: Date;
    ResponseFinishDateTime?: Date;
    Output?: string;
    OutputS3BucketName?: string;
    OutputS3KeyPrefix?: string;
  };
  declare type SSM$20141106$CommandPluginList = SSM$20141106$CommandPlugin[];
  declare type SSM$20141106$CommandPluginStatus = 'Pending' | 'InProgress' | 'Success' | 'TimedOut' | 'Cancelled' | 'Failed';
  declare type SSM$20141106$CommandStatus = 'Pending' | 'InProgress' | 'Cancelling' | 'Success' | 'TimedOut' | 'Cancelled' | 'Failed';
  declare type SSM$20141106$CreateActivationRequest = {
    Description?: string;
    DefaultInstanceName?: string;
    IamRole: string;
    RegistrationLimit?: number;
    ExpirationDate?: Date;
  };
  declare type SSM$20141106$CreateActivationResult = {
    ActivationId?: string;
    ActivationCode?: string;
  };
  declare type SSM$20141106$CreateAssociationBatchRequest = {
    Entries: SSM$20141106$CreateAssociationBatchRequestEntries;
  };
  declare type SSM$20141106$CreateAssociationBatchRequestEntries = SSM$20141106$CreateAssociationBatchRequestEntry[];
  declare type SSM$20141106$CreateAssociationBatchRequestEntry = {
    Name?: string;
    InstanceId?: string;
    Parameters?: {
      [key: string]: SSM$20141106$ParameterValueList;
    };
  };
  declare type SSM$20141106$CreateAssociationBatchResult = {
    Successful?: SSM$20141106$AssociationDescriptionList;
    Failed?: SSM$20141106$FailedCreateAssociationList;
  };
  declare type SSM$20141106$CreateAssociationRequest = {
    Name: string;
    InstanceId: string;
    Parameters?: {
      [key: string]: SSM$20141106$ParameterValueList;
    };
  };
  declare type SSM$20141106$CreateAssociationResult = {
    AssociationDescription?: SSM$20141106$AssociationDescription;
  };
  declare type SSM$20141106$CreateDocumentRequest = {
    Content: string;
    Name: string;
  };
  declare type SSM$20141106$CreateDocumentResult = {
    DocumentDescription?: SSM$20141106$DocumentDescription;
  };
  declare type SSM$20141106$CreatedDate = Date;
  declare type SSM$20141106$DateTime = Date;
  declare type SSM$20141106$DeleteActivationRequest = {
    ActivationId: string;
  };
  declare type SSM$20141106$DeleteActivationResult = {};
  declare type SSM$20141106$DeleteAssociationRequest = {
    Name: string;
    InstanceId: string;
  };
  declare type SSM$20141106$DeleteAssociationResult = {};
  declare type SSM$20141106$DeleteDocumentRequest = {
    Name: string;
  };
  declare type SSM$20141106$DeleteDocumentResult = {};
  declare type SSM$20141106$DeregisterManagedInstanceRequest = {
    InstanceId: string;
  };
  declare type SSM$20141106$DeregisterManagedInstanceResult = {};
  declare type SSM$20141106$DescribeActivationsFilter = {
    FilterKey?: 'ActivationIds' | 'DefaultInstanceName' | 'IamRole';
    FilterValues?: SSM$20141106$StringList;
  };
  declare type SSM$20141106$DescribeActivationsFilterKeys = 'ActivationIds' | 'DefaultInstanceName' | 'IamRole';
  declare type SSM$20141106$DescribeActivationsFilterList = SSM$20141106$DescribeActivationsFilter[];
  declare type SSM$20141106$DescribeActivationsRequest = {
    Filters?: SSM$20141106$DescribeActivationsFilterList;
    MaxResults?: number;
    NextToken?: string;
  };
  declare type SSM$20141106$DescribeActivationsResult = {
    ActivationList?: SSM$20141106$ActivationList;
    NextToken?: string;
  };
  declare type SSM$20141106$DescribeAssociationRequest = {
    Name: string;
    InstanceId: string;
  };
  declare type SSM$20141106$DescribeAssociationResult = {
    AssociationDescription?: SSM$20141106$AssociationDescription;
  };
  declare type SSM$20141106$DescribeDocumentPermissionRequest = {
    Name: string;
    PermissionType: 'Share';
  };
  declare type SSM$20141106$DescribeDocumentPermissionResponse = {
    AccountIds?: SSM$20141106$AccountIdList;
  };
  declare type SSM$20141106$DescribeDocumentRequest = {
    Name: string;
  };
  declare type SSM$20141106$DescribeDocumentResult = {
    Document?: SSM$20141106$DocumentDescription;
  };
  declare type SSM$20141106$DescribeInstanceInformationRequest = {
    InstanceInformationFilterList?: SSM$20141106$InstanceInformationFilterList;
    MaxResults?: number;
    NextToken?: string;
  };
  declare type SSM$20141106$DescribeInstanceInformationResult = {
    InstanceInformationList?: SSM$20141106$InstanceInformationList;
    NextToken?: string;
  };
  declare type SSM$20141106$DocumentAlreadyExists = {
    Message?: string;
  };
  declare type SSM$20141106$DocumentDescription = {
    Sha1?: string;
    Hash?: string;
    HashType?: 'Sha256' | 'Sha1';
    Name?: string;
    Owner?: string;
    CreatedDate?: Date;
    Status?: 'Creating' | 'Active' | 'Deleting';
    Description?: string;
    Parameters?: SSM$20141106$DocumentParameterList;
    PlatformTypes?: SSM$20141106$PlatformTypeList;
  };
  declare type SSM$20141106$DocumentFilter = {
    key: 'Name' | 'Owner' | 'PlatformTypes';
    value: string;
  };
  declare type SSM$20141106$DocumentFilterKey = 'Name' | 'Owner' | 'PlatformTypes';
  declare type SSM$20141106$DocumentFilterList = SSM$20141106$DocumentFilter[];
  declare type SSM$20141106$DocumentHashType = 'Sha256' | 'Sha1';
  declare type SSM$20141106$DocumentIdentifier = {
    Name?: string;
    Owner?: string;
    PlatformTypes?: SSM$20141106$PlatformTypeList;
  };
  declare type SSM$20141106$DocumentIdentifierList = SSM$20141106$DocumentIdentifier[];
  declare type SSM$20141106$DocumentLimitExceeded = {
    Message?: string;
  };
  declare type SSM$20141106$DocumentParameter = {
    Name?: string;
    Type?: 'String' | 'StringList';
    Description?: string;
    DefaultValue?: string;
  };
  declare type SSM$20141106$DocumentParameterList = SSM$20141106$DocumentParameter[];
  declare type SSM$20141106$DocumentParameterType = 'String' | 'StringList';
  declare type SSM$20141106$DocumentPermissionLimit = {
    Message?: string;
  };
  declare type SSM$20141106$DocumentPermissionType = 'Share';
  declare type SSM$20141106$DocumentStatus = 'Creating' | 'Active' | 'Deleting';
  declare type SSM$20141106$DuplicateInstanceId = {};
  declare type SSM$20141106$ExpirationDate = Date;
  declare type SSM$20141106$FailedCreateAssociation = {
    Entry?: SSM$20141106$CreateAssociationBatchRequestEntry;
    Message?: string;
    Fault?: 'Client' | 'Server' | 'Unknown';
  };
  declare type SSM$20141106$FailedCreateAssociationList = SSM$20141106$FailedCreateAssociation[];
  declare type SSM$20141106$Fault = 'Client' | 'Server' | 'Unknown';
  declare type SSM$20141106$GetDocumentRequest = {
    Name: string;
  };
  declare type SSM$20141106$GetDocumentResult = {
    Name?: string;
    Content?: string;
  };
  declare type SSM$20141106$InstanceIdList = string[];
  declare type SSM$20141106$InstanceInformation = {
    InstanceId?: string;
    PingStatus?: 'Online' | 'ConnectionLost' | 'Inactive';
    LastPingDateTime?: Date;
    AgentVersion?: string;
    IsLatestVersion?: boolean;
    PlatformType?: 'Windows' | 'Linux';
    PlatformName?: string;
    PlatformVersion?: string;
    ActivationId?: string;
    IamRole?: string;
    RegistrationDate?: Date;
    ResourceType?: 'ManagedInstance' | 'Document' | 'EC2Instance';
    Name?: string;
    IPAddress?: string;
    ComputerName?: string;
  };
  declare type SSM$20141106$InstanceInformationFilter = {
    key: 'InstanceIds' | 'AgentVersion' | 'PingStatus' | 'PlatformTypes' | 'ActivationIds' | 'IamRole' | 'ResourceType';
    valueSet: SSM$20141106$InstanceInformationFilterValueSet;
  };
  declare type SSM$20141106$InstanceInformationFilterKey = 'InstanceIds' | 'AgentVersion' | 'PingStatus' | 'PlatformTypes' | 'ActivationIds' | 'IamRole' | 'ResourceType';
  declare type SSM$20141106$InstanceInformationFilterList = SSM$20141106$InstanceInformationFilter[];
  declare type SSM$20141106$InstanceInformationFilterValueSet = string[];
  declare type SSM$20141106$InstanceInformationList = SSM$20141106$InstanceInformation[];
  declare type SSM$20141106$InternalServerError = {
    Message?: string;
  };
  declare type SSM$20141106$InvalidActivation = {
    Message?: string;
  };
  declare type SSM$20141106$InvalidActivationId = {
    Message?: string;
  };
  declare type SSM$20141106$InvalidCommandId = {};
  declare type SSM$20141106$InvalidDocument = {
    Message?: string;
  };
  declare type SSM$20141106$InvalidDocumentContent = {
    Message?: string;
  };
  declare type SSM$20141106$InvalidDocumentOperation = {
    Message?: string;
  };
  declare type SSM$20141106$InvalidFilter = {
    Message?: string;
  };
  declare type SSM$20141106$InvalidFilterKey = {};
  declare type SSM$20141106$InvalidInstanceId = {
    Message?: string;
  };
  declare type SSM$20141106$InvalidInstanceInformationFilterValue = {
    message?: string;
  };
  declare type SSM$20141106$InvalidNextToken = {};
  declare type SSM$20141106$InvalidNotificationConfig = {
    Message?: string;
  };
  declare type SSM$20141106$InvalidOutputFolder = {};
  declare type SSM$20141106$InvalidParameters = {
    Message?: string;
  };
  declare type SSM$20141106$InvalidPermissionType = {
    Message?: string;
  };
  declare type SSM$20141106$InvalidResourceId = {};
  declare type SSM$20141106$InvalidResourceType = {};
  declare type SSM$20141106$InvalidRole = {
    Message?: string;
  };
  declare type SSM$20141106$KeyList = string[];
  declare type SSM$20141106$ListAssociationsRequest = {
    AssociationFilterList: SSM$20141106$AssociationFilterList;
    MaxResults?: number;
    NextToken?: string;
  };
  declare type SSM$20141106$ListAssociationsResult = {
    Associations?: SSM$20141106$AssociationList;
    NextToken?: string;
  };
  declare type SSM$20141106$ListCommandInvocationsRequest = {
    CommandId?: string;
    InstanceId?: string;
    MaxResults?: number;
    NextToken?: string;
    Filters?: SSM$20141106$CommandFilterList;
    Details?: boolean;
  };
  declare type SSM$20141106$ListCommandInvocationsResult = {
    CommandInvocations?: SSM$20141106$CommandInvocationList;
    NextToken?: string;
  };
  declare type SSM$20141106$ListCommandsRequest = {
    CommandId?: string;
    InstanceId?: string;
    MaxResults?: number;
    NextToken?: string;
    Filters?: SSM$20141106$CommandFilterList;
  };
  declare type SSM$20141106$ListCommandsResult = {
    Commands?: SSM$20141106$CommandList;
    NextToken?: string;
  };
  declare type SSM$20141106$ListDocumentsRequest = {
    DocumentFilterList?: SSM$20141106$DocumentFilterList;
    MaxResults?: number;
    NextToken?: string;
  };
  declare type SSM$20141106$ListDocumentsResult = {
    DocumentIdentifiers?: SSM$20141106$DocumentIdentifierList;
    NextToken?: string;
  };
  declare type SSM$20141106$ListTagsForResourceRequest = {
    ResourceType: 'ManagedInstance';
    ResourceId: string;
  };
  declare type SSM$20141106$ListTagsForResourceResult = {
    TagList?: SSM$20141106$TagList;
  };
  declare type SSM$20141106$MaxDocumentSizeExceeded = {
    Message?: string;
  };
  declare type SSM$20141106$ModifyDocumentPermissionRequest = {
    Name: string;
    PermissionType: 'Share';
    AccountIdsToAdd?: SSM$20141106$AccountIdList;
    AccountIdsToRemove?: SSM$20141106$AccountIdList;
  };
  declare type SSM$20141106$ModifyDocumentPermissionResponse = {};
  declare type SSM$20141106$NotificationConfig = {
    NotificationArn?: string;
    NotificationEvents?: SSM$20141106$NotificationEventList;
    NotificationType?: 'Command' | 'Invocation';
  };
  declare type SSM$20141106$NotificationEvent = 'All' | 'InProgress' | 'Success' | 'TimedOut' | 'Cancelled' | 'Failed';
  declare type SSM$20141106$NotificationEventList = ('All' | 'InProgress' | 'Success' | 'TimedOut' | 'Cancelled' | 'Failed')[];
  declare type SSM$20141106$NotificationType = 'Command' | 'Invocation';
  declare type SSM$20141106$ParameterValueList = string[];
  declare type SSM$20141106$Parameters = {
    [key: string]: SSM$20141106$ParameterValueList;
  };
  declare type SSM$20141106$PingStatus = 'Online' | 'ConnectionLost' | 'Inactive';
  declare type SSM$20141106$PlatformType = 'Windows' | 'Linux';
  declare type SSM$20141106$PlatformTypeList = ('Windows' | 'Linux')[];
  declare type SSM$20141106$RemoveTagsFromResourceRequest = {
    ResourceType: 'ManagedInstance';
    ResourceId: string;
    TagKeys: SSM$20141106$KeyList;
  };
  declare type SSM$20141106$RemoveTagsFromResourceResult = {};
  declare type SSM$20141106$ResourceType = 'ManagedInstance' | 'Document' | 'EC2Instance';
  declare type SSM$20141106$ResourceTypeForTagging = 'ManagedInstance';
  declare type SSM$20141106$SendCommandRequest = {
    InstanceIds: SSM$20141106$InstanceIdList;
    DocumentName: string;
    DocumentHash?: string;
    DocumentHashType?: 'Sha256' | 'Sha1';
    TimeoutSeconds?: number;
    Comment?: string;
    Parameters?: {
      [key: string]: SSM$20141106$ParameterValueList;
    };
    OutputS3BucketName?: string;
    OutputS3KeyPrefix?: string;
    ServiceRoleArn?: string;
    NotificationConfig?: SSM$20141106$NotificationConfig;
  };
  declare type SSM$20141106$SendCommandResult = {
    Command?: SSM$20141106$Command;
  };
  declare type SSM$20141106$StatusUnchanged = {};
  declare type SSM$20141106$StringList = string[];
  declare type SSM$20141106$Tag = {
    Key: string;
    Value: string;
  };
  declare type SSM$20141106$TagList = SSM$20141106$Tag[];
  declare type SSM$20141106$TooManyUpdates = {};
  declare type SSM$20141106$UnsupportedPlatformType = {
    Message?: string;
  };
  declare type SSM$20141106$UpdateAssociationStatusRequest = {
    Name: string;
    InstanceId: string;
    AssociationStatus: SSM$20141106$AssociationStatus;
  };
  declare type SSM$20141106$UpdateAssociationStatusResult = {
    AssociationDescription?: SSM$20141106$AssociationDescription;
  };
  declare type SSM$20141106$UpdateManagedInstanceRoleRequest = {
    InstanceId: string;
    IamRole: string;
  };
  declare type SSM$20141106$UpdateManagedInstanceRoleResult = {};
  declare type StorageGateway$20130630$ActivateGatewayInput = {
    ActivationKey: string;
    GatewayName: string;
    GatewayTimezone: string;
    GatewayRegion: string;
    GatewayType?: string;
    TapeDriveType?: string;
    MediumChangerType?: string;
  };
  declare type StorageGateway$20130630$ActivateGatewayOutput = {
    GatewayARN?: string;
  };
  declare type StorageGateway$20130630$AddCacheInput = {
    GatewayARN: string;
    DiskIds: StorageGateway$20130630$DiskIds;
  };
  declare type StorageGateway$20130630$AddCacheOutput = {
    GatewayARN?: string;
  };
  declare type StorageGateway$20130630$AddTagsToResourceInput = {
    ResourceARN: string;
    Tags: StorageGateway$20130630$Tags;
  };
  declare type StorageGateway$20130630$AddTagsToResourceOutput = {
    ResourceARN?: string;
  };
  declare type StorageGateway$20130630$AddUploadBufferInput = {
    GatewayARN: string;
    DiskIds: StorageGateway$20130630$DiskIds;
  };
  declare type StorageGateway$20130630$AddUploadBufferOutput = {
    GatewayARN?: string;
  };
  declare type StorageGateway$20130630$AddWorkingStorageInput = {
    GatewayARN: string;
    DiskIds: StorageGateway$20130630$DiskIds;
  };
  declare type StorageGateway$20130630$AddWorkingStorageOutput = {
    GatewayARN?: string;
  };
  declare type StorageGateway$20130630$CachediSCSIVolume = {
    VolumeARN?: string;
    VolumeId?: string;
    VolumeType?: string;
    VolumeStatus?: string;
    VolumeSizeInBytes?: number;
    VolumeProgress?: number;
    SourceSnapshotId?: string;
    VolumeiSCSIAttributes?: StorageGateway$20130630$VolumeiSCSIAttributes;
  };
  declare type StorageGateway$20130630$CachediSCSIVolumes = StorageGateway$20130630$CachediSCSIVolume[];
  declare type StorageGateway$20130630$CancelArchivalInput = {
    GatewayARN: string;
    TapeARN: string;
  };
  declare type StorageGateway$20130630$CancelArchivalOutput = {
    TapeARN?: string;
  };
  declare type StorageGateway$20130630$CancelRetrievalInput = {
    GatewayARN: string;
    TapeARN: string;
  };
  declare type StorageGateway$20130630$CancelRetrievalOutput = {
    TapeARN?: string;
  };
  declare type StorageGateway$20130630$ChapCredentials = StorageGateway$20130630$ChapInfo[];
  declare type StorageGateway$20130630$ChapInfo = {
    TargetARN?: string;
    SecretToAuthenticateInitiator?: string;
    InitiatorName?: string;
    SecretToAuthenticateTarget?: string;
  };
  declare type StorageGateway$20130630$CreateCachediSCSIVolumeInput = {
    GatewayARN: string;
    VolumeSizeInBytes: number;
    SnapshotId?: string;
    TargetName: string;
    NetworkInterfaceId: string;
    ClientToken: string;
  };
  declare type StorageGateway$20130630$CreateCachediSCSIVolumeOutput = {
    VolumeARN?: string;
    TargetARN?: string;
  };
  declare type StorageGateway$20130630$CreateSnapshotFromVolumeRecoveryPointInput = {
    VolumeARN: string;
    SnapshotDescription: string;
  };
  declare type StorageGateway$20130630$CreateSnapshotFromVolumeRecoveryPointOutput = {
    SnapshotId?: string;
    VolumeARN?: string;
    VolumeRecoveryPointTime?: string;
  };
  declare type StorageGateway$20130630$CreateSnapshotInput = {
    VolumeARN: string;
    SnapshotDescription: string;
  };
  declare type StorageGateway$20130630$CreateSnapshotOutput = {
    VolumeARN?: string;
    SnapshotId?: string;
  };
  declare type StorageGateway$20130630$CreateStorediSCSIVolumeInput = {
    GatewayARN: string;
    DiskId: string;
    SnapshotId?: string;
    PreserveExistingData: boolean;
    TargetName: string;
    NetworkInterfaceId: string;
  };
  declare type StorageGateway$20130630$CreateStorediSCSIVolumeOutput = {
    VolumeARN?: string;
    VolumeSizeInBytes?: number;
    TargetARN?: string;
  };
  declare type StorageGateway$20130630$CreateTapeWithBarcodeInput = {
    GatewayARN: string;
    TapeSizeInBytes: number;
    TapeBarcode: string;
  };
  declare type StorageGateway$20130630$CreateTapeWithBarcodeOutput = {
    TapeARN?: string;
  };
  declare type StorageGateway$20130630$CreateTapesInput = {
    GatewayARN: string;
    TapeSizeInBytes: number;
    ClientToken: string;
    NumTapesToCreate: number;
    TapeBarcodePrefix: string;
  };
  declare type StorageGateway$20130630$CreateTapesOutput = {
    TapeARNs?: StorageGateway$20130630$TapeARNs;
  };
  declare type StorageGateway$20130630$DeleteBandwidthRateLimitInput = {
    GatewayARN: string;
    BandwidthType: string;
  };
  declare type StorageGateway$20130630$DeleteBandwidthRateLimitOutput = {
    GatewayARN?: string;
  };
  declare type StorageGateway$20130630$DeleteChapCredentialsInput = {
    TargetARN: string;
    InitiatorName: string;
  };
  declare type StorageGateway$20130630$DeleteChapCredentialsOutput = {
    TargetARN?: string;
    InitiatorName?: string;
  };
  declare type StorageGateway$20130630$DeleteGatewayInput = {
    GatewayARN: string;
  };
  declare type StorageGateway$20130630$DeleteGatewayOutput = {
    GatewayARN?: string;
  };
  declare type StorageGateway$20130630$DeleteSnapshotScheduleInput = {
    VolumeARN: string;
  };
  declare type StorageGateway$20130630$DeleteSnapshotScheduleOutput = {
    VolumeARN?: string;
  };
  declare type StorageGateway$20130630$DeleteTapeArchiveInput = {
    TapeARN: string;
  };
  declare type StorageGateway$20130630$DeleteTapeArchiveOutput = {
    TapeARN?: string;
  };
  declare type StorageGateway$20130630$DeleteTapeInput = {
    GatewayARN: string;
    TapeARN: string;
  };
  declare type StorageGateway$20130630$DeleteTapeOutput = {
    TapeARN?: string;
  };
  declare type StorageGateway$20130630$DeleteVolumeInput = {
    VolumeARN: string;
  };
  declare type StorageGateway$20130630$DeleteVolumeOutput = {
    VolumeARN?: string;
  };
  declare type StorageGateway$20130630$DescribeBandwidthRateLimitInput = {
    GatewayARN: string;
  };
  declare type StorageGateway$20130630$DescribeBandwidthRateLimitOutput = {
    GatewayARN?: string;
    AverageUploadRateLimitInBitsPerSec?: number;
    AverageDownloadRateLimitInBitsPerSec?: number;
  };
  declare type StorageGateway$20130630$DescribeCacheInput = {
    GatewayARN: string;
  };
  declare type StorageGateway$20130630$DescribeCacheOutput = {
    GatewayARN?: string;
    DiskIds?: StorageGateway$20130630$DiskIds;
    CacheAllocatedInBytes?: number;
    CacheUsedPercentage?: number;
    CacheDirtyPercentage?: number;
    CacheHitPercentage?: number;
    CacheMissPercentage?: number;
  };
  declare type StorageGateway$20130630$DescribeCachediSCSIVolumesInput = {
    VolumeARNs: StorageGateway$20130630$VolumeARNs;
  };
  declare type StorageGateway$20130630$DescribeCachediSCSIVolumesOutput = {
    CachediSCSIVolumes?: StorageGateway$20130630$CachediSCSIVolumes;
  };
  declare type StorageGateway$20130630$DescribeChapCredentialsInput = {
    TargetARN: string;
  };
  declare type StorageGateway$20130630$DescribeChapCredentialsOutput = {
    ChapCredentials?: StorageGateway$20130630$ChapCredentials;
  };
  declare type StorageGateway$20130630$DescribeGatewayInformationInput = {
    GatewayARN: string;
  };
  declare type StorageGateway$20130630$DescribeGatewayInformationOutput = {
    GatewayARN?: string;
    GatewayId?: string;
    GatewayName?: string;
    GatewayTimezone?: string;
    GatewayState?: string;
    GatewayNetworkInterfaces?: StorageGateway$20130630$GatewayNetworkInterfaces;
    GatewayType?: string;
    NextUpdateAvailabilityDate?: string;
    LastSoftwareUpdate?: string;
  };
  declare type StorageGateway$20130630$DescribeMaintenanceStartTimeInput = {
    GatewayARN: string;
  };
  declare type StorageGateway$20130630$DescribeMaintenanceStartTimeOutput = {
    GatewayARN?: string;
    HourOfDay?: number;
    MinuteOfHour?: number;
    DayOfWeek?: number;
    Timezone?: string;
  };
  declare type StorageGateway$20130630$DescribeSnapshotScheduleInput = {
    VolumeARN: string;
  };
  declare type StorageGateway$20130630$DescribeSnapshotScheduleOutput = {
    VolumeARN?: string;
    StartAt?: number;
    RecurrenceInHours?: number;
    Description?: string;
    Timezone?: string;
  };
  declare type StorageGateway$20130630$DescribeStorediSCSIVolumesInput = {
    VolumeARNs: StorageGateway$20130630$VolumeARNs;
  };
  declare type StorageGateway$20130630$DescribeStorediSCSIVolumesOutput = {
    StorediSCSIVolumes?: StorageGateway$20130630$StorediSCSIVolumes;
  };
  declare type StorageGateway$20130630$DescribeTapeArchivesInput = {
    TapeARNs?: StorageGateway$20130630$TapeARNs;
    Marker?: string;
    Limit?: number;
  };
  declare type StorageGateway$20130630$DescribeTapeArchivesOutput = {
    TapeArchives?: StorageGateway$20130630$TapeArchives;
    Marker?: string;
  };
  declare type StorageGateway$20130630$DescribeTapeRecoveryPointsInput = {
    GatewayARN: string;
    Marker?: string;
    Limit?: number;
  };
  declare type StorageGateway$20130630$DescribeTapeRecoveryPointsOutput = {
    GatewayARN?: string;
    TapeRecoveryPointInfos?: StorageGateway$20130630$TapeRecoveryPointInfos;
    Marker?: string;
  };
  declare type StorageGateway$20130630$DescribeTapesInput = {
    GatewayARN: string;
    TapeARNs?: StorageGateway$20130630$TapeARNs;
    Marker?: string;
    Limit?: number;
  };
  declare type StorageGateway$20130630$DescribeTapesOutput = {
    Tapes?: StorageGateway$20130630$Tapes;
    Marker?: string;
  };
  declare type StorageGateway$20130630$DescribeUploadBufferInput = {
    GatewayARN: string;
  };
  declare type StorageGateway$20130630$DescribeUploadBufferOutput = {
    GatewayARN?: string;
    DiskIds?: StorageGateway$20130630$DiskIds;
    UploadBufferUsedInBytes?: number;
    UploadBufferAllocatedInBytes?: number;
  };
  declare type StorageGateway$20130630$DescribeVTLDevicesInput = {
    GatewayARN: string;
    VTLDeviceARNs?: StorageGateway$20130630$VTLDeviceARNs;
    Marker?: string;
    Limit?: number;
  };
  declare type StorageGateway$20130630$DescribeVTLDevicesOutput = {
    GatewayARN?: string;
    VTLDevices?: StorageGateway$20130630$VTLDevices;
    Marker?: string;
  };
  declare type StorageGateway$20130630$DescribeWorkingStorageInput = {
    GatewayARN: string;
  };
  declare type StorageGateway$20130630$DescribeWorkingStorageOutput = {
    GatewayARN?: string;
    DiskIds?: StorageGateway$20130630$DiskIds;
    WorkingStorageUsedInBytes?: number;
    WorkingStorageAllocatedInBytes?: number;
  };
  declare type StorageGateway$20130630$DeviceiSCSIAttributes = {
    TargetARN?: string;
    NetworkInterfaceId?: string;
    NetworkInterfacePort?: number;
    ChapEnabled?: boolean;
  };
  declare type StorageGateway$20130630$DisableGatewayInput = {
    GatewayARN: string;
  };
  declare type StorageGateway$20130630$DisableGatewayOutput = {
    GatewayARN?: string;
  };
  declare type StorageGateway$20130630$Disk = {
    DiskId?: string;
    DiskPath?: string;
    DiskNode?: string;
    DiskStatus?: string;
    DiskSizeInBytes?: number;
    DiskAllocationType?: string;
    DiskAllocationResource?: string;
  };
  declare type StorageGateway$20130630$DiskIds = string[];
  declare type StorageGateway$20130630$Disks = StorageGateway$20130630$Disk[];
  declare type StorageGateway$20130630$ErrorCode = 'ActivationKeyExpired' | 'ActivationKeyInvalid' | 'ActivationKeyNotFound' | 'GatewayInternalError' | 'GatewayNotConnected' | 'GatewayNotFound' | 'GatewayProxyNetworkConnectionBusy' | 'AuthenticationFailure' | 'BandwidthThrottleScheduleNotFound' | 'Blocked' | 'CannotExportSnapshot' | 'ChapCredentialNotFound' | 'DiskAlreadyAllocated' | 'DiskDoesNotExist' | 'DiskSizeGreaterThanVolumeMaxSize' | 'DiskSizeLessThanVolumeSize' | 'DiskSizeNotGigAligned' | 'DuplicateCertificateInfo' | 'DuplicateSchedule' | 'EndpointNotFound' | 'IAMNotSupported' | 'InitiatorInvalid' | 'InitiatorNotFound' | 'InternalError' | 'InvalidGateway' | 'InvalidEndpoint' | 'InvalidParameters' | 'InvalidSchedule' | 'LocalStorageLimitExceeded' | 'LunAlreadyAllocated ' | 'LunInvalid' | 'MaximumContentLengthExceeded' | 'MaximumTapeCartridgeCountExceeded' | 'MaximumVolumeCountExceeded' | 'NetworkConfigurationChanged' | 'NoDisksAvailable' | 'NotImplemented' | 'NotSupported' | 'OperationAborted' | 'OutdatedGateway' | 'ParametersNotImplemented' | 'RegionInvalid' | 'RequestTimeout' | 'ServiceUnavailable' | 'SnapshotDeleted' | 'SnapshotIdInvalid' | 'SnapshotInProgress' | 'SnapshotNotFound' | 'SnapshotScheduleNotFound' | 'StagingAreaFull' | 'StorageFailure' | 'TapeCartridgeNotFound' | 'TargetAlreadyExists' | 'TargetInvalid' | 'TargetNotFound' | 'UnauthorizedOperation' | 'VolumeAlreadyExists' | 'VolumeIdInvalid' | 'VolumeInUse' | 'VolumeNotFound' | 'VolumeNotReady';
  declare type StorageGateway$20130630$GatewayInfo = {
    GatewayId?: string;
    GatewayARN?: string;
    GatewayType?: string;
    GatewayOperationalState?: string;
    GatewayName?: string;
  };
  declare type StorageGateway$20130630$GatewayNetworkInterfaces = StorageGateway$20130630$NetworkInterface[];
  declare type StorageGateway$20130630$Gateways = StorageGateway$20130630$GatewayInfo[];
  declare type StorageGateway$20130630$Initiators = string[];
  declare type StorageGateway$20130630$InternalServerError = {
    message?: string;
    error?: StorageGateway$20130630$StorageGatewayError;
  };
  declare type StorageGateway$20130630$InvalidGatewayRequestException = {
    message?: string;
    error?: StorageGateway$20130630$StorageGatewayError;
  };
  declare type StorageGateway$20130630$ListGatewaysInput = {
    Marker?: string;
    Limit?: number;
  };
  declare type StorageGateway$20130630$ListGatewaysOutput = {
    Gateways?: StorageGateway$20130630$Gateways;
    Marker?: string;
  };
  declare type StorageGateway$20130630$ListLocalDisksInput = {
    GatewayARN: string;
  };
  declare type StorageGateway$20130630$ListLocalDisksOutput = {
    GatewayARN?: string;
    Disks?: StorageGateway$20130630$Disks;
  };
  declare type StorageGateway$20130630$ListTagsForResourceInput = {
    ResourceARN: string;
    Marker?: string;
    Limit?: number;
  };
  declare type StorageGateway$20130630$ListTagsForResourceOutput = {
    ResourceARN?: string;
    Marker?: string;
    Tags?: StorageGateway$20130630$Tags;
  };
  declare type StorageGateway$20130630$ListTapesInput = {
    TapeARNs?: StorageGateway$20130630$TapeARNs;
    Marker?: string;
    Limit?: number;
  };
  declare type StorageGateway$20130630$ListTapesOutput = {
    TapeInfos?: StorageGateway$20130630$TapeInfos;
    Marker?: string;
  };
  declare type StorageGateway$20130630$ListVolumeInitiatorsInput = {
    VolumeARN: string;
  };
  declare type StorageGateway$20130630$ListVolumeInitiatorsOutput = {
    Initiators?: StorageGateway$20130630$Initiators;
  };
  declare type StorageGateway$20130630$ListVolumeRecoveryPointsInput = {
    GatewayARN: string;
  };
  declare type StorageGateway$20130630$ListVolumeRecoveryPointsOutput = {
    GatewayARN?: string;
    VolumeRecoveryPointInfos?: StorageGateway$20130630$VolumeRecoveryPointInfos;
  };
  declare type StorageGateway$20130630$ListVolumesInput = {
    GatewayARN?: string;
    Marker?: string;
    Limit?: number;
  };
  declare type StorageGateway$20130630$ListVolumesOutput = {
    GatewayARN?: string;
    Marker?: string;
    VolumeInfos?: StorageGateway$20130630$VolumeInfos;
  };
  declare type StorageGateway$20130630$NetworkInterface = {
    Ipv4Address?: string;
    MacAddress?: string;
    Ipv6Address?: string;
  };
  declare type StorageGateway$20130630$RemoveTagsFromResourceInput = {
    ResourceARN: string;
    TagKeys: StorageGateway$20130630$TagKeys;
  };
  declare type StorageGateway$20130630$RemoveTagsFromResourceOutput = {
    ResourceARN?: string;
  };
  declare type StorageGateway$20130630$ResetCacheInput = {
    GatewayARN: string;
  };
  declare type StorageGateway$20130630$ResetCacheOutput = {
    GatewayARN?: string;
  };
  declare type StorageGateway$20130630$RetrieveTapeArchiveInput = {
    TapeARN: string;
    GatewayARN: string;
  };
  declare type StorageGateway$20130630$RetrieveTapeArchiveOutput = {
    TapeARN?: string;
  };
  declare type StorageGateway$20130630$RetrieveTapeRecoveryPointInput = {
    TapeARN: string;
    GatewayARN: string;
  };
  declare type StorageGateway$20130630$RetrieveTapeRecoveryPointOutput = {
    TapeARN?: string;
  };
  declare type StorageGateway$20130630$SetLocalConsolePasswordInput = {
    GatewayARN: string;
    LocalConsolePassword: string;
  };
  declare type StorageGateway$20130630$SetLocalConsolePasswordOutput = {
    GatewayARN?: string;
  };
  declare type StorageGateway$20130630$ShutdownGatewayInput = {
    GatewayARN: string;
  };
  declare type StorageGateway$20130630$ShutdownGatewayOutput = {
    GatewayARN?: string;
  };
  declare type StorageGateway$20130630$StartGatewayInput = {
    GatewayARN: string;
  };
  declare type StorageGateway$20130630$StartGatewayOutput = {
    GatewayARN?: string;
  };
  declare type StorageGateway$20130630$StorageGatewayError = {
    errorCode?: 'ActivationKeyExpired' | 'ActivationKeyInvalid' | 'ActivationKeyNotFound' | 'GatewayInternalError' | 'GatewayNotConnected' | 'GatewayNotFound' | 'GatewayProxyNetworkConnectionBusy' | 'AuthenticationFailure' | 'BandwidthThrottleScheduleNotFound' | 'Blocked' | 'CannotExportSnapshot' | 'ChapCredentialNotFound' | 'DiskAlreadyAllocated' | 'DiskDoesNotExist' | 'DiskSizeGreaterThanVolumeMaxSize' | 'DiskSizeLessThanVolumeSize' | 'DiskSizeNotGigAligned' | 'DuplicateCertificateInfo' | 'DuplicateSchedule' | 'EndpointNotFound' | 'IAMNotSupported' | 'InitiatorInvalid' | 'InitiatorNotFound' | 'InternalError' | 'InvalidGateway' | 'InvalidEndpoint' | 'InvalidParameters' | 'InvalidSchedule' | 'LocalStorageLimitExceeded' | 'LunAlreadyAllocated ' | 'LunInvalid' | 'MaximumContentLengthExceeded' | 'MaximumTapeCartridgeCountExceeded' | 'MaximumVolumeCountExceeded' | 'NetworkConfigurationChanged' | 'NoDisksAvailable' | 'NotImplemented' | 'NotSupported' | 'OperationAborted' | 'OutdatedGateway' | 'ParametersNotImplemented' | 'RegionInvalid' | 'RequestTimeout' | 'ServiceUnavailable' | 'SnapshotDeleted' | 'SnapshotIdInvalid' | 'SnapshotInProgress' | 'SnapshotNotFound' | 'SnapshotScheduleNotFound' | 'StagingAreaFull' | 'StorageFailure' | 'TapeCartridgeNotFound' | 'TargetAlreadyExists' | 'TargetInvalid' | 'TargetNotFound' | 'UnauthorizedOperation' | 'VolumeAlreadyExists' | 'VolumeIdInvalid' | 'VolumeInUse' | 'VolumeNotFound' | 'VolumeNotReady';
    errorDetails?: {
      [key: string]: string;
    };
  };
  declare type StorageGateway$20130630$StorediSCSIVolume = {
    VolumeARN?: string;
    VolumeId?: string;
    VolumeType?: string;
    VolumeStatus?: string;
    VolumeSizeInBytes?: number;
    VolumeProgress?: number;
    VolumeDiskId?: string;
    SourceSnapshotId?: string;
    PreservedExistingData?: boolean;
    VolumeiSCSIAttributes?: StorageGateway$20130630$VolumeiSCSIAttributes;
  };
  declare type StorageGateway$20130630$StorediSCSIVolumes = StorageGateway$20130630$StorediSCSIVolume[];
  declare type StorageGateway$20130630$Tag = {
    Key: string;
    Value: string;
  };
  declare type StorageGateway$20130630$TagKeys = string[];
  declare type StorageGateway$20130630$Tags = StorageGateway$20130630$Tag[];
  declare type StorageGateway$20130630$Tape = {
    TapeARN?: string;
    TapeBarcode?: string;
    TapeSizeInBytes?: number;
    TapeStatus?: string;
    VTLDevice?: string;
    Progress?: number;
  };
  declare type StorageGateway$20130630$TapeARNs = string[];
  declare type StorageGateway$20130630$TapeArchive = {
    TapeARN?: string;
    TapeBarcode?: string;
    TapeSizeInBytes?: number;
    CompletionTime?: Date;
    RetrievedTo?: string;
    TapeStatus?: string;
  };
  declare type StorageGateway$20130630$TapeArchives = StorageGateway$20130630$TapeArchive[];
  declare type StorageGateway$20130630$TapeInfo = {
    TapeARN?: string;
    TapeBarcode?: string;
    TapeSizeInBytes?: number;
    TapeStatus?: string;
    GatewayARN?: string;
  };
  declare type StorageGateway$20130630$TapeInfos = StorageGateway$20130630$TapeInfo[];
  declare type StorageGateway$20130630$TapeRecoveryPointInfo = {
    TapeARN?: string;
    TapeRecoveryPointTime?: Date;
    TapeSizeInBytes?: number;
    TapeStatus?: string;
  };
  declare type StorageGateway$20130630$TapeRecoveryPointInfos = StorageGateway$20130630$TapeRecoveryPointInfo[];
  declare type StorageGateway$20130630$Tapes = StorageGateway$20130630$Tape[];
  declare type StorageGateway$20130630$Time = Date;
  declare type StorageGateway$20130630$UpdateBandwidthRateLimitInput = {
    GatewayARN: string;
    AverageUploadRateLimitInBitsPerSec?: number;
    AverageDownloadRateLimitInBitsPerSec?: number;
  };
  declare type StorageGateway$20130630$UpdateBandwidthRateLimitOutput = {
    GatewayARN?: string;
  };
  declare type StorageGateway$20130630$UpdateChapCredentialsInput = {
    TargetARN: string;
    SecretToAuthenticateInitiator: string;
    InitiatorName: string;
    SecretToAuthenticateTarget?: string;
  };
  declare type StorageGateway$20130630$UpdateChapCredentialsOutput = {
    TargetARN?: string;
    InitiatorName?: string;
  };
  declare type StorageGateway$20130630$UpdateGatewayInformationInput = {
    GatewayARN: string;
    GatewayName?: string;
    GatewayTimezone?: string;
  };
  declare type StorageGateway$20130630$UpdateGatewayInformationOutput = {
    GatewayARN?: string;
    GatewayName?: string;
  };
  declare type StorageGateway$20130630$UpdateGatewaySoftwareNowInput = {
    GatewayARN: string;
  };
  declare type StorageGateway$20130630$UpdateGatewaySoftwareNowOutput = {
    GatewayARN?: string;
  };
  declare type StorageGateway$20130630$UpdateMaintenanceStartTimeInput = {
    GatewayARN: string;
    HourOfDay: number;
    MinuteOfHour: number;
    DayOfWeek: number;
  };
  declare type StorageGateway$20130630$UpdateMaintenanceStartTimeOutput = {
    GatewayARN?: string;
  };
  declare type StorageGateway$20130630$UpdateSnapshotScheduleInput = {
    VolumeARN: string;
    StartAt: number;
    RecurrenceInHours: number;
    Description?: string;
  };
  declare type StorageGateway$20130630$UpdateSnapshotScheduleOutput = {
    VolumeARN?: string;
  };
  declare type StorageGateway$20130630$UpdateVTLDeviceTypeInput = {
    VTLDeviceARN: string;
    DeviceType: string;
  };
  declare type StorageGateway$20130630$UpdateVTLDeviceTypeOutput = {
    VTLDeviceARN?: string;
  };
  declare type StorageGateway$20130630$VTLDevice = {
    VTLDeviceARN?: string;
    VTLDeviceType?: string;
    VTLDeviceVendor?: string;
    VTLDeviceProductIdentifier?: string;
    DeviceiSCSIAttributes?: StorageGateway$20130630$DeviceiSCSIAttributes;
  };
  declare type StorageGateway$20130630$VTLDeviceARNs = string[];
  declare type StorageGateway$20130630$VTLDevices = StorageGateway$20130630$VTLDevice[];
  declare type StorageGateway$20130630$VolumeARNs = string[];
  declare type StorageGateway$20130630$VolumeInfo = {
    VolumeARN?: string;
    VolumeId?: string;
    GatewayARN?: string;
    GatewayId?: string;
    VolumeType?: string;
    VolumeSizeInBytes?: number;
  };
  declare type StorageGateway$20130630$VolumeInfos = StorageGateway$20130630$VolumeInfo[];
  declare type StorageGateway$20130630$VolumeRecoveryPointInfo = {
    VolumeARN?: string;
    VolumeSizeInBytes?: number;
    VolumeUsageInBytes?: number;
    VolumeRecoveryPointTime?: string;
  };
  declare type StorageGateway$20130630$VolumeRecoveryPointInfos = StorageGateway$20130630$VolumeRecoveryPointInfo[];
  declare type StorageGateway$20130630$VolumeiSCSIAttributes = {
    TargetARN?: string;
    NetworkInterfaceId?: string;
    NetworkInterfacePort?: number;
    LunNumber?: number;
    ChapEnabled?: boolean;
  };
  declare type StorageGateway$20130630$errorDetails = {
    [key: string]: string;
  };
  declare type STS$20110615$AssumeRoleRequest = {
    RoleArn: string;
    RoleSessionName: string;
    Policy?: string;
    DurationSeconds?: number;
    ExternalId?: string;
    SerialNumber?: string;
    TokenCode?: string;
  };
  declare type STS$20110615$AssumeRoleResponse = {
    Credentials?: STS$20110615$Credentials;
    AssumedRoleUser?: STS$20110615$AssumedRoleUser;
    PackedPolicySize?: number;
  };
  declare type STS$20110615$AssumeRoleWithSAMLRequest = {
    RoleArn: string;
    PrincipalArn: string;
    SAMLAssertion: string;
    Policy?: string;
    DurationSeconds?: number;
  };
  declare type STS$20110615$AssumeRoleWithSAMLResponse = {
    Credentials?: STS$20110615$Credentials;
    AssumedRoleUser?: STS$20110615$AssumedRoleUser;
    PackedPolicySize?: number;
    Subject?: string;
    SubjectType?: string;
    Issuer?: string;
    Audience?: string;
    NameQualifier?: string;
  };
  declare type STS$20110615$AssumeRoleWithWebIdentityRequest = {
    RoleArn: string;
    RoleSessionName: string;
    WebIdentityToken: string;
    ProviderId?: string;
    Policy?: string;
    DurationSeconds?: number;
  };
  declare type STS$20110615$AssumeRoleWithWebIdentityResponse = {
    Credentials?: STS$20110615$Credentials;
    SubjectFromWebIdentityToken?: string;
    AssumedRoleUser?: STS$20110615$AssumedRoleUser;
    PackedPolicySize?: number;
    Provider?: string;
    Audience?: string;
  };
  declare type STS$20110615$AssumedRoleUser = {
    AssumedRoleId: string;
    Arn: string;
  };
  declare type STS$20110615$Credentials = {
    AccessKeyId: string;
    SecretAccessKey: string;
    SessionToken: string;
    Expiration: Date;
  };
  declare type STS$20110615$DecodeAuthorizationMessageRequest = {
    EncodedMessage: string;
  };
  declare type STS$20110615$DecodeAuthorizationMessageResponse = {
    DecodedMessage?: string;
  };
  declare type STS$20110615$ExpiredTokenException = {
    message?: string;
  };
  declare type STS$20110615$FederatedUser = {
    FederatedUserId: string;
    Arn: string;
  };
  declare type STS$20110615$GetCallerIdentityRequest = {};
  declare type STS$20110615$GetCallerIdentityResponse = {
    UserId?: string;
    Account?: string;
    Arn?: string;
  };
  declare type STS$20110615$GetFederationTokenRequest = {
    Name: string;
    Policy?: string;
    DurationSeconds?: number;
  };
  declare type STS$20110615$GetFederationTokenResponse = {
    Credentials?: STS$20110615$Credentials;
    FederatedUser?: STS$20110615$FederatedUser;
    PackedPolicySize?: number;
  };
  declare type STS$20110615$GetSessionTokenRequest = {
    DurationSeconds?: number;
    SerialNumber?: string;
    TokenCode?: string;
  };
  declare type STS$20110615$GetSessionTokenResponse = {
    Credentials?: STS$20110615$Credentials;
  };
  declare type STS$20110615$IDPCommunicationErrorException = {
    message?: string;
  };
  declare type STS$20110615$IDPRejectedClaimException = {
    message?: string;
  };
  declare type STS$20110615$InvalidAuthorizationMessageException = {
    message?: string;
  };
  declare type STS$20110615$InvalidIdentityTokenException = {
    message?: string;
  };
  declare type STS$20110615$MalformedPolicyDocumentException = {
    message?: string;
  };
  declare type STS$20110615$PackedPolicyTooLargeException = {
    message?: string;
  };
  declare type STS$20110615$RegionDisabledException = {
    message?: string;
  };
  declare type STS$20110615$dateType = Date;
  declare type Support$20130415$AddAttachmentsToSetRequest = {
    attachmentSetId?: string;
    attachments: Support$20130415$Attachments;
  };
  declare type Support$20130415$AddAttachmentsToSetResponse = {
    attachmentSetId?: string;
    expiryTime?: string;
  };
  declare type Support$20130415$AddCommunicationToCaseRequest = {
    caseId?: string;
    communicationBody: string;
    ccEmailAddresses?: Support$20130415$CcEmailAddressList;
    attachmentSetId?: string;
  };
  declare type Support$20130415$AddCommunicationToCaseResponse = {
    result?: boolean;
  };
  declare type Support$20130415$Attachment = {
    fileName?: string;
    data?: Buffer | $TypedArray | Blob | string;
  };
  declare type Support$20130415$AttachmentDetails = {
    attachmentId?: string;
    fileName?: string;
  };
  declare type Support$20130415$AttachmentIdNotFound = {
    message?: string;
  };
  declare type Support$20130415$AttachmentLimitExceeded = {
    message?: string;
  };
  declare type Support$20130415$AttachmentSet = Support$20130415$AttachmentDetails[];
  declare type Support$20130415$AttachmentSetExpired = {
    message?: string;
  };
  declare type Support$20130415$AttachmentSetIdNotFound = {
    message?: string;
  };
  declare type Support$20130415$AttachmentSetSizeLimitExceeded = {
    message?: string;
  };
  declare type Support$20130415$Attachments = Support$20130415$Attachment[];
  declare type Support$20130415$CaseCreationLimitExceeded = {
    message?: string;
  };
  declare type Support$20130415$CaseDetails = {
    caseId?: string;
    displayId?: string;
    subject?: string;
    status?: string;
    serviceCode?: string;
    categoryCode?: string;
    severityCode?: string;
    submittedBy?: string;
    timeCreated?: string;
    recentCommunications?: Support$20130415$RecentCaseCommunications;
    ccEmailAddresses?: Support$20130415$CcEmailAddressList;
    language?: string;
  };
  declare type Support$20130415$CaseIdList = string[];
  declare type Support$20130415$CaseIdNotFound = {
    message?: string;
  };
  declare type Support$20130415$CaseList = Support$20130415$CaseDetails[];
  declare type Support$20130415$Category = {
    code?: string;
    name?: string;
  };
  declare type Support$20130415$CategoryList = Support$20130415$Category[];
  declare type Support$20130415$CcEmailAddressList = string[];
  declare type Support$20130415$Communication = {
    caseId?: string;
    body?: string;
    submittedBy?: string;
    timeCreated?: string;
    attachmentSet?: Support$20130415$AttachmentSet;
  };
  declare type Support$20130415$CommunicationList = Support$20130415$Communication[];
  declare type Support$20130415$CreateCaseRequest = {
    subject: string;
    serviceCode?: string;
    severityCode?: string;
    categoryCode?: string;
    communicationBody: string;
    ccEmailAddresses?: Support$20130415$CcEmailAddressList;
    language?: string;
    issueType?: string;
    attachmentSetId?: string;
  };
  declare type Support$20130415$CreateCaseResponse = {
    caseId?: string;
  };
  declare type Support$20130415$Data = Buffer | $TypedArray | Blob | string;
  declare type Support$20130415$DescribeAttachmentLimitExceeded = {
    message?: string;
  };
  declare type Support$20130415$DescribeAttachmentRequest = {
    attachmentId: string;
  };
  declare type Support$20130415$DescribeAttachmentResponse = {
    attachment?: Support$20130415$Attachment;
  };
  declare type Support$20130415$DescribeCasesRequest = {
    caseIdList?: Support$20130415$CaseIdList;
    displayId?: string;
    afterTime?: string;
    beforeTime?: string;
    includeResolvedCases?: boolean;
    nextToken?: string;
    maxResults?: number;
    language?: string;
    includeCommunications?: boolean;
  };
  declare type Support$20130415$DescribeCasesResponse = {
    cases?: Support$20130415$CaseList;
    nextToken?: string;
  };
  declare type Support$20130415$DescribeCommunicationsRequest = {
    caseId: string;
    beforeTime?: string;
    afterTime?: string;
    nextToken?: string;
    maxResults?: number;
  };
  declare type Support$20130415$DescribeCommunicationsResponse = {
    communications?: Support$20130415$CommunicationList;
    nextToken?: string;
  };
  declare type Support$20130415$DescribeServicesRequest = {
    serviceCodeList?: Support$20130415$ServiceCodeList;
    language?: string;
  };
  declare type Support$20130415$DescribeServicesResponse = {
    services?: Support$20130415$ServiceList;
  };
  declare type Support$20130415$DescribeSeverityLevelsRequest = {
    language?: string;
  };
  declare type Support$20130415$DescribeSeverityLevelsResponse = {
    severityLevels?: Support$20130415$SeverityLevelsList;
  };
  declare type Support$20130415$DescribeTrustedAdvisorCheckRefreshStatusesRequest = {
    checkIds: Support$20130415$StringList;
  };
  declare type Support$20130415$DescribeTrustedAdvisorCheckRefreshStatusesResponse = {
    statuses: Support$20130415$TrustedAdvisorCheckRefreshStatusList;
  };
  declare type Support$20130415$DescribeTrustedAdvisorCheckResultRequest = {
    checkId: string;
    language?: string;
  };
  declare type Support$20130415$DescribeTrustedAdvisorCheckResultResponse = {
    result?: Support$20130415$TrustedAdvisorCheckResult;
  };
  declare type Support$20130415$DescribeTrustedAdvisorCheckSummariesRequest = {
    checkIds: Support$20130415$StringList;
  };
  declare type Support$20130415$DescribeTrustedAdvisorCheckSummariesResponse = {
    summaries: Support$20130415$TrustedAdvisorCheckSummaryList;
  };
  declare type Support$20130415$DescribeTrustedAdvisorChecksRequest = {
    language: string;
  };
  declare type Support$20130415$DescribeTrustedAdvisorChecksResponse = {
    checks: Support$20130415$TrustedAdvisorCheckList;
  };
  declare type Support$20130415$InternalServerError = {
    message?: string;
  };
  declare type Support$20130415$RecentCaseCommunications = {
    communications?: Support$20130415$CommunicationList;
    nextToken?: string;
  };
  declare type Support$20130415$RefreshTrustedAdvisorCheckRequest = {
    checkId: string;
  };
  declare type Support$20130415$RefreshTrustedAdvisorCheckResponse = {
    status: Support$20130415$TrustedAdvisorCheckRefreshStatus;
  };
  declare type Support$20130415$ResolveCaseRequest = {
    caseId?: string;
  };
  declare type Support$20130415$ResolveCaseResponse = {
    initialCaseStatus?: string;
    finalCaseStatus?: string;
  };
  declare type Support$20130415$Service = {
    code?: string;
    name?: string;
    categories?: Support$20130415$CategoryList;
  };
  declare type Support$20130415$ServiceCodeList = string[];
  declare type Support$20130415$ServiceList = Support$20130415$Service[];
  declare type Support$20130415$SeverityLevel = {
    code?: string;
    name?: string;
  };
  declare type Support$20130415$SeverityLevelsList = Support$20130415$SeverityLevel[];
  declare type Support$20130415$StringList = string[];
  declare type Support$20130415$TrustedAdvisorCategorySpecificSummary = {
    costOptimizing?: Support$20130415$TrustedAdvisorCostOptimizingSummary;
  };
  declare type Support$20130415$TrustedAdvisorCheckDescription = {
    id: string;
    name: string;
    description: string;
    category: string;
    metadata: Support$20130415$StringList;
  };
  declare type Support$20130415$TrustedAdvisorCheckList = Support$20130415$TrustedAdvisorCheckDescription[];
  declare type Support$20130415$TrustedAdvisorCheckRefreshStatus = {
    checkId: string;
    status: string;
    millisUntilNextRefreshable: number;
  };
  declare type Support$20130415$TrustedAdvisorCheckRefreshStatusList = Support$20130415$TrustedAdvisorCheckRefreshStatus[];
  declare type Support$20130415$TrustedAdvisorCheckResult = {
    checkId: string;
    timestamp: string;
    status: string;
    resourcesSummary: Support$20130415$TrustedAdvisorResourcesSummary;
    categorySpecificSummary: Support$20130415$TrustedAdvisorCategorySpecificSummary;
    flaggedResources: Support$20130415$TrustedAdvisorResourceDetailList;
  };
  declare type Support$20130415$TrustedAdvisorCheckSummary = {
    checkId: string;
    timestamp: string;
    status: string;
    hasFlaggedResources?: boolean;
    resourcesSummary: Support$20130415$TrustedAdvisorResourcesSummary;
    categorySpecificSummary: Support$20130415$TrustedAdvisorCategorySpecificSummary;
  };
  declare type Support$20130415$TrustedAdvisorCheckSummaryList = Support$20130415$TrustedAdvisorCheckSummary[];
  declare type Support$20130415$TrustedAdvisorCostOptimizingSummary = {
    estimatedMonthlySavings: number;
    estimatedPercentMonthlySavings: number;
  };
  declare type Support$20130415$TrustedAdvisorResourceDetail = {
    status: string;
    region: string;
    resourceId: string;
    isSuppressed?: boolean;
    metadata: Support$20130415$StringList;
  };
  declare type Support$20130415$TrustedAdvisorResourceDetailList = Support$20130415$TrustedAdvisorResourceDetail[];
  declare type Support$20130415$TrustedAdvisorResourcesSummary = {
    resourcesProcessed: number;
    resourcesFlagged: number;
    resourcesIgnored: number;
    resourcesSuppressed: number;
  };
  declare type SWF$20120125$ActivityTask = {
    taskToken: string;
    activityId: string;
    startedEventId: number;
    workflowExecution: SWF$20120125$WorkflowExecution;
    activityType: SWF$20120125$ActivityType;
    input?: string;
  };
  declare type SWF$20120125$ActivityTaskCancelRequestedEventAttributes = {
    decisionTaskCompletedEventId: number;
    activityId: string;
  };
  declare type SWF$20120125$ActivityTaskCanceledEventAttributes = {
    details?: string;
    scheduledEventId: number;
    startedEventId: number;
    latestCancelRequestedEventId?: number;
  };
  declare type SWF$20120125$ActivityTaskCompletedEventAttributes = {
    result?: string;
    scheduledEventId: number;
    startedEventId: number;
  };
  declare type SWF$20120125$ActivityTaskFailedEventAttributes = {
    reason?: string;
    details?: string;
    scheduledEventId: number;
    startedEventId: number;
  };
  declare type SWF$20120125$ActivityTaskScheduledEventAttributes = {
    activityType: SWF$20120125$ActivityType;
    activityId: string;
    input?: string;
    control?: string;
    scheduleToStartTimeout?: string;
    scheduleToCloseTimeout?: string;
    startToCloseTimeout?: string;
    taskList: SWF$20120125$TaskList;
    taskPriority?: string;
    decisionTaskCompletedEventId: number;
    heartbeatTimeout?: string;
  };
  declare type SWF$20120125$ActivityTaskStartedEventAttributes = {
    identity?: string;
    scheduledEventId: number;
  };
  declare type SWF$20120125$ActivityTaskStatus = {
    cancelRequested: boolean;
  };
  declare type SWF$20120125$ActivityTaskTimedOutEventAttributes = {
    timeoutType: 'START_TO_CLOSE' | 'SCHEDULE_TO_START' | 'SCHEDULE_TO_CLOSE' | 'HEARTBEAT';
    scheduledEventId: number;
    startedEventId: number;
    details?: string;
  };
  declare type SWF$20120125$ActivityTaskTimeoutType = 'START_TO_CLOSE' | 'SCHEDULE_TO_START' | 'SCHEDULE_TO_CLOSE' | 'HEARTBEAT';
  declare type SWF$20120125$ActivityType = {
    name: string;
    version: string;
  };
  declare type SWF$20120125$ActivityTypeConfiguration = {
    defaultTaskStartToCloseTimeout?: string;
    defaultTaskHeartbeatTimeout?: string;
    defaultTaskList?: SWF$20120125$TaskList;
    defaultTaskPriority?: string;
    defaultTaskScheduleToStartTimeout?: string;
    defaultTaskScheduleToCloseTimeout?: string;
  };
  declare type SWF$20120125$ActivityTypeDetail = {
    typeInfo: SWF$20120125$ActivityTypeInfo;
    configuration: SWF$20120125$ActivityTypeConfiguration;
  };
  declare type SWF$20120125$ActivityTypeInfo = {
    activityType: SWF$20120125$ActivityType;
    status: 'REGISTERED' | 'DEPRECATED';
    description?: string;
    creationDate: Date;
    deprecationDate?: Date;
  };
  declare type SWF$20120125$ActivityTypeInfoList = SWF$20120125$ActivityTypeInfo[];
  declare type SWF$20120125$ActivityTypeInfos = {
    typeInfos: SWF$20120125$ActivityTypeInfoList;
    nextPageToken?: string;
  };
  declare type SWF$20120125$CancelTimerDecisionAttributes = {
    timerId: string;
  };
  declare type SWF$20120125$CancelTimerFailedCause = 'TIMER_ID_UNKNOWN' | 'OPERATION_NOT_PERMITTED';
  declare type SWF$20120125$CancelTimerFailedEventAttributes = {
    timerId: string;
    cause: 'TIMER_ID_UNKNOWN' | 'OPERATION_NOT_PERMITTED';
    decisionTaskCompletedEventId: number;
  };
  declare type SWF$20120125$CancelWorkflowExecutionDecisionAttributes = {
    details?: string;
  };
  declare type SWF$20120125$CancelWorkflowExecutionFailedCause = 'UNHANDLED_DECISION' | 'OPERATION_NOT_PERMITTED';
  declare type SWF$20120125$CancelWorkflowExecutionFailedEventAttributes = {
    cause: 'UNHANDLED_DECISION' | 'OPERATION_NOT_PERMITTED';
    decisionTaskCompletedEventId: number;
  };
  declare type SWF$20120125$ChildPolicy = 'TERMINATE' | 'REQUEST_CANCEL' | 'ABANDON';
  declare type SWF$20120125$ChildWorkflowExecutionCanceledEventAttributes = {
    workflowExecution: SWF$20120125$WorkflowExecution;
    workflowType: SWF$20120125$WorkflowType;
    details?: string;
    initiatedEventId: number;
    startedEventId: number;
  };
  declare type SWF$20120125$ChildWorkflowExecutionCompletedEventAttributes = {
    workflowExecution: SWF$20120125$WorkflowExecution;
    workflowType: SWF$20120125$WorkflowType;
    result?: string;
    initiatedEventId: number;
    startedEventId: number;
  };
  declare type SWF$20120125$ChildWorkflowExecutionFailedEventAttributes = {
    workflowExecution: SWF$20120125$WorkflowExecution;
    workflowType: SWF$20120125$WorkflowType;
    reason?: string;
    details?: string;
    initiatedEventId: number;
    startedEventId: number;
  };
  declare type SWF$20120125$ChildWorkflowExecutionStartedEventAttributes = {
    workflowExecution: SWF$20120125$WorkflowExecution;
    workflowType: SWF$20120125$WorkflowType;
    initiatedEventId: number;
  };
  declare type SWF$20120125$ChildWorkflowExecutionTerminatedEventAttributes = {
    workflowExecution: SWF$20120125$WorkflowExecution;
    workflowType: SWF$20120125$WorkflowType;
    initiatedEventId: number;
    startedEventId: number;
  };
  declare type SWF$20120125$ChildWorkflowExecutionTimedOutEventAttributes = {
    workflowExecution: SWF$20120125$WorkflowExecution;
    workflowType: SWF$20120125$WorkflowType;
    timeoutType: 'START_TO_CLOSE';
    initiatedEventId: number;
    startedEventId: number;
  };
  declare type SWF$20120125$CloseStatus = 'COMPLETED' | 'FAILED' | 'CANCELED' | 'TERMINATED' | 'CONTINUED_AS_NEW' | 'TIMED_OUT';
  declare type SWF$20120125$CloseStatusFilter = {
    status: 'COMPLETED' | 'FAILED' | 'CANCELED' | 'TERMINATED' | 'CONTINUED_AS_NEW' | 'TIMED_OUT';
  };
  declare type SWF$20120125$CompleteWorkflowExecutionDecisionAttributes = {
    result?: string;
  };
  declare type SWF$20120125$CompleteWorkflowExecutionFailedCause = 'UNHANDLED_DECISION' | 'OPERATION_NOT_PERMITTED';
  declare type SWF$20120125$CompleteWorkflowExecutionFailedEventAttributes = {
    cause: 'UNHANDLED_DECISION' | 'OPERATION_NOT_PERMITTED';
    decisionTaskCompletedEventId: number;
  };
  declare type SWF$20120125$ContinueAsNewWorkflowExecutionDecisionAttributes = {
    input?: string;
    executionStartToCloseTimeout?: string;
    taskList?: SWF$20120125$TaskList;
    taskPriority?: string;
    taskStartToCloseTimeout?: string;
    childPolicy?: 'TERMINATE' | 'REQUEST_CANCEL' | 'ABANDON';
    tagList?: SWF$20120125$TagList;
    workflowTypeVersion?: string;
    lambdaRole?: string;
  };
  declare type SWF$20120125$ContinueAsNewWorkflowExecutionFailedCause = 'UNHANDLED_DECISION' | 'WORKFLOW_TYPE_DEPRECATED' | 'WORKFLOW_TYPE_DOES_NOT_EXIST' | 'DEFAULT_EXECUTION_START_TO_CLOSE_TIMEOUT_UNDEFINED' | 'DEFAULT_TASK_START_TO_CLOSE_TIMEOUT_UNDEFINED' | 'DEFAULT_TASK_LIST_UNDEFINED' | 'DEFAULT_CHILD_POLICY_UNDEFINED' | 'CONTINUE_AS_NEW_WORKFLOW_EXECUTION_RATE_EXCEEDED' | 'OPERATION_NOT_PERMITTED';
  declare type SWF$20120125$ContinueAsNewWorkflowExecutionFailedEventAttributes = {
    cause: 'UNHANDLED_DECISION' | 'WORKFLOW_TYPE_DEPRECATED' | 'WORKFLOW_TYPE_DOES_NOT_EXIST' | 'DEFAULT_EXECUTION_START_TO_CLOSE_TIMEOUT_UNDEFINED' | 'DEFAULT_TASK_START_TO_CLOSE_TIMEOUT_UNDEFINED' | 'DEFAULT_TASK_LIST_UNDEFINED' | 'DEFAULT_CHILD_POLICY_UNDEFINED' | 'CONTINUE_AS_NEW_WORKFLOW_EXECUTION_RATE_EXCEEDED' | 'OPERATION_NOT_PERMITTED';
    decisionTaskCompletedEventId: number;
  };
  declare type SWF$20120125$CountClosedWorkflowExecutionsInput = {
    domain: string;
    startTimeFilter?: SWF$20120125$ExecutionTimeFilter;
    closeTimeFilter?: SWF$20120125$ExecutionTimeFilter;
    executionFilter?: SWF$20120125$WorkflowExecutionFilter;
    typeFilter?: SWF$20120125$WorkflowTypeFilter;
    tagFilter?: SWF$20120125$TagFilter;
    closeStatusFilter?: SWF$20120125$CloseStatusFilter;
  };
  declare type SWF$20120125$CountOpenWorkflowExecutionsInput = {
    domain: string;
    startTimeFilter: SWF$20120125$ExecutionTimeFilter;
    typeFilter?: SWF$20120125$WorkflowTypeFilter;
    tagFilter?: SWF$20120125$TagFilter;
    executionFilter?: SWF$20120125$WorkflowExecutionFilter;
  };
  declare type SWF$20120125$CountPendingActivityTasksInput = {
    domain: string;
    taskList: SWF$20120125$TaskList;
  };
  declare type SWF$20120125$CountPendingDecisionTasksInput = {
    domain: string;
    taskList: SWF$20120125$TaskList;
  };
  declare type SWF$20120125$Decision = {
    decisionType: 'ScheduleActivityTask';
    scheduleActivityTaskDecisionAttributes: SWF$20120125$ScheduleActivityTaskDecisionAttributes;
  } | {
    decisionType: 'RequestCancelActivityTask';
    requestCancelActivityTaskDecisionAttributes: SWF$20120125$RequestCancelActivityTaskDecisionAttributes;
  } | {
    decisionType: 'CompleteWorkflowExecution';
    completeWorkflowExecutionDecisionAttributes: SWF$20120125$CompleteWorkflowExecutionDecisionAttributes;
  } | {
    decisionType: 'FailWorkflowExecution';
    failWorkflowExecutionDecisionAttributes: SWF$20120125$FailWorkflowExecutionDecisionAttributes;
  } | {
    decisionType: 'CancelWorkflowExecution';
    cancelWorkflowExecutionDecisionAttributes: SWF$20120125$CancelWorkflowExecutionDecisionAttributes;
  } | {
    decisionType: 'ContinueAsNewWorkflowExecution';
    continueAsNewWorkflowExecutionDecisionAttributes: SWF$20120125$ContinueAsNewWorkflowExecutionDecisionAttributes;
  } | {
    decisionType: 'RecordMarker';
    recordMarkerDecisionAttributes: SWF$20120125$RecordMarkerDecisionAttributes;
  } | {
    decisionType: 'StartTimer';
    startTimerDecisionAttributes: SWF$20120125$StartTimerDecisionAttributes;
  } | {
    decisionType: 'CancelTimer';
    cancelTimerDecisionAttributes: SWF$20120125$CancelTimerDecisionAttributes;
  } | {
    decisionType: 'SignalExternalWorkflowExecution';
    signalExternalWorkflowExecutionDecisionAttributes: SWF$20120125$SignalExternalWorkflowExecutionDecisionAttributes;
  } | {
    decisionType: 'RequestCancelExternalWorkflowExecution';
    requestCancelExternalWorkflowExecutionDecisionAttributes: SWF$20120125$RequestCancelExternalWorkflowExecutionDecisionAttributes;
  } | {
    decisionType: 'StartChildWorkflowExecution';
    startChildWorkflowExecutionDecisionAttributes: SWF$20120125$StartChildWorkflowExecutionDecisionAttributes;
  } | {
    decisionType: 'ScheduleLambdaFunction';
    scheduleLambdaFunctionDecisionAttributes: SWF$20120125$ScheduleLambdaFunctionDecisionAttributes;
  };
  declare type SWF$20120125$DecisionList = SWF$20120125$Decision[];
  declare type SWF$20120125$DecisionTask = {
    taskToken: string;
    startedEventId: number;
    workflowExecution: SWF$20120125$WorkflowExecution;
    workflowType: SWF$20120125$WorkflowType;
    events: SWF$20120125$HistoryEventList;
    nextPageToken?: string;
    previousStartedEventId?: number;
  };
  declare type SWF$20120125$DecisionTaskCompletedEventAttributes = {
    executionContext?: string;
    scheduledEventId: number;
    startedEventId: number;
  };
  declare type SWF$20120125$DecisionTaskScheduledEventAttributes = {
    taskList: SWF$20120125$TaskList;
    taskPriority?: string;
    startToCloseTimeout?: string;
  };
  declare type SWF$20120125$DecisionTaskStartedEventAttributes = {
    identity?: string;
    scheduledEventId: number;
  };
  declare type SWF$20120125$DecisionTaskTimedOutEventAttributes = {
    timeoutType: 'START_TO_CLOSE';
    scheduledEventId: number;
    startedEventId: number;
  };
  declare type SWF$20120125$DecisionTaskTimeoutType = 'START_TO_CLOSE';
  declare type SWF$20120125$DecisionType = 'ScheduleActivityTask' | 'RequestCancelActivityTask' | 'CompleteWorkflowExecution' | 'FailWorkflowExecution' | 'CancelWorkflowExecution' | 'ContinueAsNewWorkflowExecution' | 'RecordMarker' | 'StartTimer' | 'CancelTimer' | 'SignalExternalWorkflowExecution' | 'RequestCancelExternalWorkflowExecution' | 'StartChildWorkflowExecution' | 'ScheduleLambdaFunction';
  declare type SWF$20120125$DefaultUndefinedFault = {
    message?: string;
  };
  declare type SWF$20120125$DeprecateActivityTypeInput = {
    domain: string;
    activityType: SWF$20120125$ActivityType;
  };
  declare type SWF$20120125$DeprecateDomainInput = {
    name: string;
  };
  declare type SWF$20120125$DeprecateWorkflowTypeInput = {
    domain: string;
    workflowType: SWF$20120125$WorkflowType;
  };
  declare type SWF$20120125$DescribeActivityTypeInput = {
    domain: string;
    activityType: SWF$20120125$ActivityType;
  };
  declare type SWF$20120125$DescribeDomainInput = {
    name: string;
  };
  declare type SWF$20120125$DescribeWorkflowExecutionInput = {
    domain: string;
    execution: SWF$20120125$WorkflowExecution;
  };
  declare type SWF$20120125$DescribeWorkflowTypeInput = {
    domain: string;
    workflowType: SWF$20120125$WorkflowType;
  };
  declare type SWF$20120125$DomainAlreadyExistsFault = {
    message?: string;
  };
  declare type SWF$20120125$DomainConfiguration = {
    workflowExecutionRetentionPeriodInDays: string;
  };
  declare type SWF$20120125$DomainDeprecatedFault = {
    message?: string;
  };
  declare type SWF$20120125$DomainDetail = {
    domainInfo: SWF$20120125$DomainInfo;
    configuration: SWF$20120125$DomainConfiguration;
  };
  declare type SWF$20120125$DomainInfo = {
    name: string;
    status: 'REGISTERED' | 'DEPRECATED';
    description?: string;
  };
  declare type SWF$20120125$DomainInfoList = SWF$20120125$DomainInfo[];
  declare type SWF$20120125$DomainInfos = {
    domainInfos: SWF$20120125$DomainInfoList;
    nextPageToken?: string;
  };
  declare type SWF$20120125$EventType = 'WorkflowExecutionStarted' | 'WorkflowExecutionCancelRequested' | 'WorkflowExecutionCompleted' | 'CompleteWorkflowExecutionFailed' | 'WorkflowExecutionFailed' | 'FailWorkflowExecutionFailed' | 'WorkflowExecutionTimedOut' | 'WorkflowExecutionCanceled' | 'CancelWorkflowExecutionFailed' | 'WorkflowExecutionContinuedAsNew' | 'ContinueAsNewWorkflowExecutionFailed' | 'WorkflowExecutionTerminated' | 'DecisionTaskScheduled' | 'DecisionTaskStarted' | 'DecisionTaskCompleted' | 'DecisionTaskTimedOut' | 'ActivityTaskScheduled' | 'ScheduleActivityTaskFailed' | 'ActivityTaskStarted' | 'ActivityTaskCompleted' | 'ActivityTaskFailed' | 'ActivityTaskTimedOut' | 'ActivityTaskCanceled' | 'ActivityTaskCancelRequested' | 'RequestCancelActivityTaskFailed' | 'WorkflowExecutionSignaled' | 'MarkerRecorded' | 'RecordMarkerFailed' | 'TimerStarted' | 'StartTimerFailed' | 'TimerFired' | 'TimerCanceled' | 'CancelTimerFailed' | 'StartChildWorkflowExecutionInitiated' | 'StartChildWorkflowExecutionFailed' | 'ChildWorkflowExecutionStarted' | 'ChildWorkflowExecutionCompleted' | 'ChildWorkflowExecutionFailed' | 'ChildWorkflowExecutionTimedOut' | 'ChildWorkflowExecutionCanceled' | 'ChildWorkflowExecutionTerminated' | 'SignalExternalWorkflowExecutionInitiated' | 'SignalExternalWorkflowExecutionFailed' | 'ExternalWorkflowExecutionSignaled' | 'RequestCancelExternalWorkflowExecutionInitiated' | 'RequestCancelExternalWorkflowExecutionFailed' | 'ExternalWorkflowExecutionCancelRequested' | 'LambdaFunctionScheduled' | 'LambdaFunctionStarted' | 'LambdaFunctionCompleted' | 'LambdaFunctionFailed' | 'LambdaFunctionTimedOut' | 'ScheduleLambdaFunctionFailed' | 'StartLambdaFunctionFailed';
  declare type SWF$20120125$ExecutionStatus = 'OPEN' | 'CLOSED';
  declare type SWF$20120125$ExecutionTimeFilter = {
    oldestDate: Date;
    latestDate?: Date;
  };
  declare type SWF$20120125$ExternalWorkflowExecutionCancelRequestedEventAttributes = {
    workflowExecution: SWF$20120125$WorkflowExecution;
    initiatedEventId: number;
  };
  declare type SWF$20120125$ExternalWorkflowExecutionSignaledEventAttributes = {
    workflowExecution: SWF$20120125$WorkflowExecution;
    initiatedEventId: number;
  };
  declare type SWF$20120125$FailWorkflowExecutionDecisionAttributes = {
    reason?: string;
    details?: string;
  };
  declare type SWF$20120125$FailWorkflowExecutionFailedCause = 'UNHANDLED_DECISION' | 'OPERATION_NOT_PERMITTED';
  declare type SWF$20120125$FailWorkflowExecutionFailedEventAttributes = {
    cause: 'UNHANDLED_DECISION' | 'OPERATION_NOT_PERMITTED';
    decisionTaskCompletedEventId: number;
  };
  declare type SWF$20120125$GetWorkflowExecutionHistoryInput = {
    domain: string;
    execution: SWF$20120125$WorkflowExecution;
    nextPageToken?: string;
    maximumPageSize?: number;
    reverseOrder?: boolean;
  };
  declare type SWF$20120125$History = {
    events: SWF$20120125$HistoryEventList;
    nextPageToken?: string;
  };
  declare type SWF$20120125$HistoryEvent = {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'WorkflowExecutionStarted';
    workflowExecutionStartedEventAttributes: SWF$20120125$WorkflowExecutionStartedEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'WorkflowExecutionCancelRequested';
    workflowExecutionCancelRequestedEventAttributes: SWF$20120125$WorkflowExecutionCancelRequestedEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'WorkflowExecutionCompleted';
    workflowExecutionCompletedEventAttributes: SWF$20120125$WorkflowExecutionCompletedEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'CompleteWorkflowExecutionFailed';
    completeWorkflowExecutionFailedEventAttributes: SWF$20120125$CompleteWorkflowExecutionFailedEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'WorkflowExecutionFailed';
    workflowExecutionFailedEventAttributes: SWF$20120125$WorkflowExecutionFailedEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'FailWorkflowExecutionFailed';
    failWorkflowExecutionFailedEventAttributes: SWF$20120125$FailWorkflowExecutionFailedEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'WorkflowExecutionTimedOut';
    workflowExecutionTimedOutEventAttributes: SWF$20120125$WorkflowExecutionTimedOutEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'WorkflowExecutionCanceled';
    workflowExecutionCanceledEventAttributes: SWF$20120125$WorkflowExecutionCanceledEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'CancelWorkflowExecutionFailed';
    cancelWorkflowExecutionFailedEventAttributes: SWF$20120125$CancelWorkflowExecutionFailedEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'WorkflowExecutionContinuedAsNew';
    workflowExecutionContinuedAsNewEventAttributes: SWF$20120125$WorkflowExecutionContinuedAsNewEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'ContinueAsNewWorkflowExecutionFailed';
    continueAsNewWorkflowExecutionFailedEventAttributes: SWF$20120125$ContinueAsNewWorkflowExecutionFailedEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'WorkflowExecutionTerminated';
    workflowExecutionTerminatedEventAttributes: SWF$20120125$WorkflowExecutionTerminatedEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'DecisionTaskScheduled';
    decisionTaskScheduledEventAttributes: SWF$20120125$DecisionTaskScheduledEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'DecisionTaskStarted';
    decisionTaskStartedEventAttributes: SWF$20120125$DecisionTaskStartedEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'DecisionTaskCompleted';
    decisionTaskCompletedEventAttributes: SWF$20120125$DecisionTaskCompletedEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'DecisionTaskTimedOut';
    decisionTaskTimedOutEventAttributes: SWF$20120125$DecisionTaskTimedOutEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'ActivityTaskScheduled';
    activityTaskScheduledEventAttributes: SWF$20120125$ActivityTaskScheduledEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'ScheduleActivityTaskFailed';
    scheduleActivityTaskFailedEventAttributes: SWF$20120125$ScheduleActivityTaskFailedEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'ActivityTaskStarted';
    activityTaskStartedEventAttributes: SWF$20120125$ActivityTaskStartedEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'ActivityTaskCompleted';
    activityTaskCompletedEventAttributes: SWF$20120125$ActivityTaskCompletedEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'ActivityTaskFailed';
    activityTaskFailedEventAttributes: SWF$20120125$ActivityTaskFailedEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'ActivityTaskTimedOut';
    activityTaskTimedOutEventAttributes: SWF$20120125$ActivityTaskTimedOutEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'ActivityTaskCanceled';
    activityTaskCanceledEventAttributes: SWF$20120125$ActivityTaskCanceledEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'ActivityTaskCancelRequested';
    activityTaskCancelRequestedEventAttributes: SWF$20120125$ActivityTaskCancelRequestedEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'RequestCancelActivityTaskFailed';
    requestCancelActivityTaskFailedEventAttributes: SWF$20120125$RequestCancelActivityTaskFailedEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'WorkflowExecutionSignaled';
    workflowExecutionSignaledEventAttributes: SWF$20120125$WorkflowExecutionSignaledEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'MarkerRecorded';
    markerRecordedEventAttributes: SWF$20120125$MarkerRecordedEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'RecordMarkerFailed';
    recordMarkerFailedEventAttributes: SWF$20120125$RecordMarkerFailedEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'TimerStarted';
    timerStartedEventAttributes: SWF$20120125$TimerStartedEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'StartTimerFailed';
    startTimerFailedEventAttributes: SWF$20120125$StartTimerFailedEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'TimerFired';
    timerFiredEventAttributes: SWF$20120125$TimerFiredEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'TimerCanceled';
    timerCanceledEventAttributes: SWF$20120125$TimerCanceledEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'CancelTimerFailed';
    cancelTimerFailedEventAttributes: SWF$20120125$CancelTimerFailedEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'StartChildWorkflowExecutionInitiated';
    startChildWorkflowExecutionInitiatedEventAttributes: SWF$20120125$StartChildWorkflowExecutionInitiatedEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'StartChildWorkflowExecutionFailed';
    startChildWorkflowExecutionFailedEventAttributes: SWF$20120125$StartChildWorkflowExecutionFailedEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'ChildWorkflowExecutionStarted';
    childWorkflowExecutionStartedEventAttributes: SWF$20120125$ChildWorkflowExecutionStartedEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'ChildWorkflowExecutionCompleted';
    childWorkflowExecutionCompletedEventAttributes: SWF$20120125$ChildWorkflowExecutionCompletedEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'ChildWorkflowExecutionFailed';
    childWorkflowExecutionFailedEventAttributes: SWF$20120125$ChildWorkflowExecutionFailedEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'ChildWorkflowExecutionTimedOut';
    childWorkflowExecutionTimedOutEventAttributes: SWF$20120125$ChildWorkflowExecutionTimedOutEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'ChildWorkflowExecutionCanceled';
    childWorkflowExecutionCanceledEventAttributes: SWF$20120125$ChildWorkflowExecutionCanceledEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'ChildWorkflowExecutionTerminated';
    childWorkflowExecutionTerminatedEventAttributes: SWF$20120125$ChildWorkflowExecutionTerminatedEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'SignalExternalWorkflowExecutionInitiated';
    signalExternalWorkflowExecutionInitiatedEventAttributes: SWF$20120125$SignalExternalWorkflowExecutionInitiatedEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'SignalExternalWorkflowExecutionFailed';
    signalExternalWorkflowExecutionFailedEventAttributes: SWF$20120125$SignalExternalWorkflowExecutionFailedEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'ExternalWorkflowExecutionSignaled';
    externalWorkflowExecutionSignaledEventAttributes: SWF$20120125$ExternalWorkflowExecutionSignaledEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'RequestCancelExternalWorkflowExecutionInitiated';
    requestCancelExternalWorkflowExecutionInitiatedEventAttributes: SWF$20120125$RequestCancelExternalWorkflowExecutionInitiatedEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'RequestCancelExternalWorkflowExecutionFailed';
    requestCancelExternalWorkflowExecutionFailedEventAttributes: SWF$20120125$RequestCancelExternalWorkflowExecutionFailedEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'ExternalWorkflowExecutionCancelRequested';
    externalWorkflowExecutionCancelRequestedEventAttributes: SWF$20120125$ExternalWorkflowExecutionCancelRequestedEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'LambdaFunctionScheduled';
    lambdaFunctionScheduledEventAttributes: SWF$20120125$LambdaFunctionScheduledEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'LambdaFunctionStarted';
    lambdaFunctionStartedEventAttributes: SWF$20120125$LambdaFunctionStartedEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'LambdaFunctionCompleted';
    lambdaFunctionCompletedEventAttributes: SWF$20120125$LambdaFunctionCompletedEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'LambdaFunctionFailed';
    lambdaFunctionFailedEventAttributes: SWF$20120125$LambdaFunctionFailedEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'LambdaFunctionTimedOut';
    lambdaFunctionTimedOutEventAttributes: SWF$20120125$LambdaFunctionTimedOutEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'ScheduleLambdaFunctionFailed';
    scheduleLambdaFunctionFailedEventAttributes: SWF$20120125$ScheduleLambdaFunctionFailedEventAttributes;
  } | {
    eventTimestamp: Date;
    eventId: number;
    eventType: 'StartLambdaFunctionFailed';
    startLambdaFunctionFailedEventAttributes: SWF$20120125$StartLambdaFunctionFailedEventAttributes;
  };
  declare type SWF$20120125$HistoryEventList = SWF$20120125$HistoryEvent[];
  declare type SWF$20120125$LambdaFunctionCompletedEventAttributes = {
    scheduledEventId: number;
    startedEventId: number;
    result?: string;
  };
  declare type SWF$20120125$LambdaFunctionFailedEventAttributes = {
    scheduledEventId: number;
    startedEventId: number;
    reason?: string;
    details?: string;
  };
  declare type SWF$20120125$LambdaFunctionScheduledEventAttributes = {
    id: string;
    name: string;
    input?: string;
    startToCloseTimeout?: string;
    decisionTaskCompletedEventId: number;
  };
  declare type SWF$20120125$LambdaFunctionStartedEventAttributes = {
    scheduledEventId: number;
  };
  declare type SWF$20120125$LambdaFunctionTimedOutEventAttributes = {
    scheduledEventId: number;
    startedEventId: number;
    timeoutType?: 'START_TO_CLOSE';
  };
  declare type SWF$20120125$LambdaFunctionTimeoutType = 'START_TO_CLOSE';
  declare type SWF$20120125$LimitExceededFault = {
    message?: string;
  };
  declare type SWF$20120125$ListActivityTypesInput = {
    domain: string;
    name?: string;
    registrationStatus: 'REGISTERED' | 'DEPRECATED';
    nextPageToken?: string;
    maximumPageSize?: number;
    reverseOrder?: boolean;
  };
  declare type SWF$20120125$ListClosedWorkflowExecutionsInput = {
    domain: string;
    startTimeFilter?: SWF$20120125$ExecutionTimeFilter;
    closeTimeFilter?: SWF$20120125$ExecutionTimeFilter;
    executionFilter?: SWF$20120125$WorkflowExecutionFilter;
    closeStatusFilter?: SWF$20120125$CloseStatusFilter;
    typeFilter?: SWF$20120125$WorkflowTypeFilter;
    tagFilter?: SWF$20120125$TagFilter;
    nextPageToken?: string;
    maximumPageSize?: number;
    reverseOrder?: boolean;
  };
  declare type SWF$20120125$ListDomainsInput = {
    nextPageToken?: string;
    registrationStatus: 'REGISTERED' | 'DEPRECATED';
    maximumPageSize?: number;
    reverseOrder?: boolean;
  };
  declare type SWF$20120125$ListOpenWorkflowExecutionsInput = {
    domain: string;
    startTimeFilter: SWF$20120125$ExecutionTimeFilter;
    typeFilter?: SWF$20120125$WorkflowTypeFilter;
    tagFilter?: SWF$20120125$TagFilter;
    nextPageToken?: string;
    maximumPageSize?: number;
    reverseOrder?: boolean;
    executionFilter?: SWF$20120125$WorkflowExecutionFilter;
  };
  declare type SWF$20120125$ListWorkflowTypesInput = {
    domain: string;
    name?: string;
    registrationStatus: 'REGISTERED' | 'DEPRECATED';
    nextPageToken?: string;
    maximumPageSize?: number;
    reverseOrder?: boolean;
  };
  declare type SWF$20120125$MarkerRecordedEventAttributes = {
    markerName: string;
    details?: string;
    decisionTaskCompletedEventId: number;
  };
  declare type SWF$20120125$OperationNotPermittedFault = {
    message?: string;
  };
  declare type SWF$20120125$PendingTaskCount = {
    count: number;
    truncated?: boolean;
  };
  declare type SWF$20120125$PollForActivityTaskInput = {
    domain: string;
    taskList: SWF$20120125$TaskList;
    identity?: string;
  };
  declare type SWF$20120125$PollForDecisionTaskInput = {
    domain: string;
    taskList: SWF$20120125$TaskList;
    identity?: string;
    nextPageToken?: string;
    maximumPageSize?: number;
    reverseOrder?: boolean;
  };
  declare type SWF$20120125$RecordActivityTaskHeartbeatInput = {
    taskToken: string;
    details?: string;
  };
  declare type SWF$20120125$RecordMarkerDecisionAttributes = {
    markerName: string;
    details?: string;
  };
  declare type SWF$20120125$RecordMarkerFailedCause = 'OPERATION_NOT_PERMITTED';
  declare type SWF$20120125$RecordMarkerFailedEventAttributes = {
    markerName: string;
    cause: 'OPERATION_NOT_PERMITTED';
    decisionTaskCompletedEventId: number;
  };
  declare type SWF$20120125$RegisterActivityTypeInput = {
    domain: string;
    name: string;
    version: string;
    description?: string;
    defaultTaskStartToCloseTimeout?: string;
    defaultTaskHeartbeatTimeout?: string;
    defaultTaskList?: SWF$20120125$TaskList;
    defaultTaskPriority?: string;
    defaultTaskScheduleToStartTimeout?: string;
    defaultTaskScheduleToCloseTimeout?: string;
  };
  declare type SWF$20120125$RegisterDomainInput = {
    name: string;
    description?: string;
    workflowExecutionRetentionPeriodInDays: string;
  };
  declare type SWF$20120125$RegisterWorkflowTypeInput = {
    domain: string;
    name: string;
    version: string;
    description?: string;
    defaultTaskStartToCloseTimeout?: string;
    defaultExecutionStartToCloseTimeout?: string;
    defaultTaskList?: SWF$20120125$TaskList;
    defaultTaskPriority?: string;
    defaultChildPolicy?: 'TERMINATE' | 'REQUEST_CANCEL' | 'ABANDON';
    defaultLambdaRole?: string;
  };
  declare type SWF$20120125$RegistrationStatus = 'REGISTERED' | 'DEPRECATED';
  declare type SWF$20120125$RequestCancelActivityTaskDecisionAttributes = {
    activityId: string;
  };
  declare type SWF$20120125$RequestCancelActivityTaskFailedCause = 'ACTIVITY_ID_UNKNOWN' | 'OPERATION_NOT_PERMITTED';
  declare type SWF$20120125$RequestCancelActivityTaskFailedEventAttributes = {
    activityId: string;
    cause: 'ACTIVITY_ID_UNKNOWN' | 'OPERATION_NOT_PERMITTED';
    decisionTaskCompletedEventId: number;
  };
  declare type SWF$20120125$RequestCancelExternalWorkflowExecutionDecisionAttributes = {
    workflowId: string;
    runId?: string;
    control?: string;
  };
  declare type SWF$20120125$RequestCancelExternalWorkflowExecutionFailedCause = 'UNKNOWN_EXTERNAL_WORKFLOW_EXECUTION' | 'REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_RATE_EXCEEDED' | 'OPERATION_NOT_PERMITTED';
  declare type SWF$20120125$RequestCancelExternalWorkflowExecutionFailedEventAttributes = {
    workflowId: string;
    runId?: string;
    cause: 'UNKNOWN_EXTERNAL_WORKFLOW_EXECUTION' | 'REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_RATE_EXCEEDED' | 'OPERATION_NOT_PERMITTED';
    initiatedEventId: number;
    decisionTaskCompletedEventId: number;
    control?: string;
  };
  declare type SWF$20120125$RequestCancelExternalWorkflowExecutionInitiatedEventAttributes = {
    workflowId: string;
    runId?: string;
    decisionTaskCompletedEventId: number;
    control?: string;
  };
  declare type SWF$20120125$RequestCancelWorkflowExecutionInput = {
    domain: string;
    workflowId: string;
    runId?: string;
  };
  declare type SWF$20120125$RespondActivityTaskCanceledInput = {
    taskToken: string;
    details?: string;
  };
  declare type SWF$20120125$RespondActivityTaskCompletedInput = {
    taskToken: string;
    result?: string;
  };
  declare type SWF$20120125$RespondActivityTaskFailedInput = {
    taskToken: string;
    reason?: string;
    details?: string;
  };
  declare type SWF$20120125$RespondDecisionTaskCompletedInput = {
    taskToken: string;
    decisions?: SWF$20120125$DecisionList;
    executionContext?: string;
  };
  declare type SWF$20120125$Run = {
    runId?: string;
  };
  declare type SWF$20120125$ScheduleActivityTaskDecisionAttributes = {
    activityType: SWF$20120125$ActivityType;
    activityId: string;
    control?: string;
    input?: string;
    scheduleToCloseTimeout?: string;
    taskList?: SWF$20120125$TaskList;
    taskPriority?: string;
    scheduleToStartTimeout?: string;
    startToCloseTimeout?: string;
    heartbeatTimeout?: string;
  };
  declare type SWF$20120125$ScheduleActivityTaskFailedCause = 'ACTIVITY_TYPE_DEPRECATED' | 'ACTIVITY_TYPE_DOES_NOT_EXIST' | 'ACTIVITY_ID_ALREADY_IN_USE' | 'OPEN_ACTIVITIES_LIMIT_EXCEEDED' | 'ACTIVITY_CREATION_RATE_EXCEEDED' | 'DEFAULT_SCHEDULE_TO_CLOSE_TIMEOUT_UNDEFINED' | 'DEFAULT_TASK_LIST_UNDEFINED' | 'DEFAULT_SCHEDULE_TO_START_TIMEOUT_UNDEFINED' | 'DEFAULT_START_TO_CLOSE_TIMEOUT_UNDEFINED' | 'DEFAULT_HEARTBEAT_TIMEOUT_UNDEFINED' | 'OPERATION_NOT_PERMITTED';
  declare type SWF$20120125$ScheduleActivityTaskFailedEventAttributes = {
    activityType: SWF$20120125$ActivityType;
    activityId: string;
    cause: 'ACTIVITY_TYPE_DEPRECATED' | 'ACTIVITY_TYPE_DOES_NOT_EXIST' | 'ACTIVITY_ID_ALREADY_IN_USE' | 'OPEN_ACTIVITIES_LIMIT_EXCEEDED' | 'ACTIVITY_CREATION_RATE_EXCEEDED' | 'DEFAULT_SCHEDULE_TO_CLOSE_TIMEOUT_UNDEFINED' | 'DEFAULT_TASK_LIST_UNDEFINED' | 'DEFAULT_SCHEDULE_TO_START_TIMEOUT_UNDEFINED' | 'DEFAULT_START_TO_CLOSE_TIMEOUT_UNDEFINED' | 'DEFAULT_HEARTBEAT_TIMEOUT_UNDEFINED' | 'OPERATION_NOT_PERMITTED';
    decisionTaskCompletedEventId: number;
  };
  declare type SWF$20120125$ScheduleLambdaFunctionDecisionAttributes = {
    id: string;
    name: string;
    input?: string;
    startToCloseTimeout?: string;
  };
  declare type SWF$20120125$ScheduleLambdaFunctionFailedCause = 'ID_ALREADY_IN_USE' | 'OPEN_LAMBDA_FUNCTIONS_LIMIT_EXCEEDED' | 'LAMBDA_FUNCTION_CREATION_RATE_EXCEEDED' | 'LAMBDA_SERVICE_NOT_AVAILABLE_IN_REGION';
  declare type SWF$20120125$ScheduleLambdaFunctionFailedEventAttributes = {
    id: string;
    name: string;
    cause: 'ID_ALREADY_IN_USE' | 'OPEN_LAMBDA_FUNCTIONS_LIMIT_EXCEEDED' | 'LAMBDA_FUNCTION_CREATION_RATE_EXCEEDED' | 'LAMBDA_SERVICE_NOT_AVAILABLE_IN_REGION';
    decisionTaskCompletedEventId: number;
  };
  declare type SWF$20120125$SignalExternalWorkflowExecutionDecisionAttributes = {
    workflowId: string;
    runId?: string;
    signalName: string;
    input?: string;
    control?: string;
  };
  declare type SWF$20120125$SignalExternalWorkflowExecutionFailedCause = 'UNKNOWN_EXTERNAL_WORKFLOW_EXECUTION' | 'SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_RATE_EXCEEDED' | 'OPERATION_NOT_PERMITTED';
  declare type SWF$20120125$SignalExternalWorkflowExecutionFailedEventAttributes = {
    workflowId: string;
    runId?: string;
    cause: 'UNKNOWN_EXTERNAL_WORKFLOW_EXECUTION' | 'SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_RATE_EXCEEDED' | 'OPERATION_NOT_PERMITTED';
    initiatedEventId: number;
    decisionTaskCompletedEventId: number;
    control?: string;
  };
  declare type SWF$20120125$SignalExternalWorkflowExecutionInitiatedEventAttributes = {
    workflowId: string;
    runId?: string;
    signalName: string;
    input?: string;
    decisionTaskCompletedEventId: number;
    control?: string;
  };
  declare type SWF$20120125$SignalWorkflowExecutionInput = {
    domain: string;
    workflowId: string;
    runId?: string;
    signalName: string;
    input?: string;
  };
  declare type SWF$20120125$StartChildWorkflowExecutionDecisionAttributes = {
    workflowType: SWF$20120125$WorkflowType;
    workflowId: string;
    control?: string;
    input?: string;
    executionStartToCloseTimeout?: string;
    taskList?: SWF$20120125$TaskList;
    taskPriority?: string;
    taskStartToCloseTimeout?: string;
    childPolicy?: 'TERMINATE' | 'REQUEST_CANCEL' | 'ABANDON';
    tagList?: SWF$20120125$TagList;
    lambdaRole?: string;
  };
  declare type SWF$20120125$StartChildWorkflowExecutionFailedCause = 'WORKFLOW_TYPE_DOES_NOT_EXIST' | 'WORKFLOW_TYPE_DEPRECATED' | 'OPEN_CHILDREN_LIMIT_EXCEEDED' | 'OPEN_WORKFLOWS_LIMIT_EXCEEDED' | 'CHILD_CREATION_RATE_EXCEEDED' | 'WORKFLOW_ALREADY_RUNNING' | 'DEFAULT_EXECUTION_START_TO_CLOSE_TIMEOUT_UNDEFINED' | 'DEFAULT_TASK_LIST_UNDEFINED' | 'DEFAULT_TASK_START_TO_CLOSE_TIMEOUT_UNDEFINED' | 'DEFAULT_CHILD_POLICY_UNDEFINED' | 'OPERATION_NOT_PERMITTED';
  declare type SWF$20120125$StartChildWorkflowExecutionFailedEventAttributes = {
    workflowType: SWF$20120125$WorkflowType;
    cause: 'WORKFLOW_TYPE_DOES_NOT_EXIST' | 'WORKFLOW_TYPE_DEPRECATED' | 'OPEN_CHILDREN_LIMIT_EXCEEDED' | 'OPEN_WORKFLOWS_LIMIT_EXCEEDED' | 'CHILD_CREATION_RATE_EXCEEDED' | 'WORKFLOW_ALREADY_RUNNING' | 'DEFAULT_EXECUTION_START_TO_CLOSE_TIMEOUT_UNDEFINED' | 'DEFAULT_TASK_LIST_UNDEFINED' | 'DEFAULT_TASK_START_TO_CLOSE_TIMEOUT_UNDEFINED' | 'DEFAULT_CHILD_POLICY_UNDEFINED' | 'OPERATION_NOT_PERMITTED';
    workflowId: string;
    initiatedEventId: number;
    decisionTaskCompletedEventId: number;
    control?: string;
  };
  declare type SWF$20120125$StartChildWorkflowExecutionInitiatedEventAttributes = {
    workflowId: string;
    workflowType: SWF$20120125$WorkflowType;
    control?: string;
    input?: string;
    executionStartToCloseTimeout?: string;
    taskList: SWF$20120125$TaskList;
    taskPriority?: string;
    decisionTaskCompletedEventId: number;
    childPolicy: 'TERMINATE' | 'REQUEST_CANCEL' | 'ABANDON';
    taskStartToCloseTimeout?: string;
    tagList?: SWF$20120125$TagList;
    lambdaRole?: string;
  };
  declare type SWF$20120125$StartLambdaFunctionFailedCause = 'ASSUME_ROLE_FAILED';
  declare type SWF$20120125$StartLambdaFunctionFailedEventAttributes = {
    scheduledEventId?: number;
    cause?: 'ASSUME_ROLE_FAILED';
    message?: string;
  };
  declare type SWF$20120125$StartTimerDecisionAttributes = {
    timerId: string;
    control?: string;
    startToFireTimeout: string;
  };
  declare type SWF$20120125$StartTimerFailedCause = 'TIMER_ID_ALREADY_IN_USE' | 'OPEN_TIMERS_LIMIT_EXCEEDED' | 'TIMER_CREATION_RATE_EXCEEDED' | 'OPERATION_NOT_PERMITTED';
  declare type SWF$20120125$StartTimerFailedEventAttributes = {
    timerId: string;
    cause: 'TIMER_ID_ALREADY_IN_USE' | 'OPEN_TIMERS_LIMIT_EXCEEDED' | 'TIMER_CREATION_RATE_EXCEEDED' | 'OPERATION_NOT_PERMITTED';
    decisionTaskCompletedEventId: number;
  };
  declare type SWF$20120125$StartWorkflowExecutionInput = {
    domain: string;
    workflowId: string;
    workflowType: SWF$20120125$WorkflowType;
    taskList?: SWF$20120125$TaskList;
    taskPriority?: string;
    input?: string;
    executionStartToCloseTimeout?: string;
    tagList?: SWF$20120125$TagList;
    taskStartToCloseTimeout?: string;
    childPolicy?: 'TERMINATE' | 'REQUEST_CANCEL' | 'ABANDON';
    lambdaRole?: string;
  };
  declare type SWF$20120125$TagFilter = {
    tag: string;
  };
  declare type SWF$20120125$TagList = string[];
  declare type SWF$20120125$TaskList = {
    name: string;
  };
  declare type SWF$20120125$TerminateWorkflowExecutionInput = {
    domain: string;
    workflowId: string;
    runId?: string;
    reason?: string;
    details?: string;
    childPolicy?: 'TERMINATE' | 'REQUEST_CANCEL' | 'ABANDON';
  };
  declare type SWF$20120125$TimerCanceledEventAttributes = {
    timerId: string;
    startedEventId: number;
    decisionTaskCompletedEventId: number;
  };
  declare type SWF$20120125$TimerFiredEventAttributes = {
    timerId: string;
    startedEventId: number;
  };
  declare type SWF$20120125$TimerStartedEventAttributes = {
    timerId: string;
    control?: string;
    startToFireTimeout: string;
    decisionTaskCompletedEventId: number;
  };
  declare type SWF$20120125$Timestamp = Date;
  declare type SWF$20120125$TypeAlreadyExistsFault = {
    message?: string;
  };
  declare type SWF$20120125$TypeDeprecatedFault = {
    message?: string;
  };
  declare type SWF$20120125$UnknownResourceFault = {
    message?: string;
  };
  declare type SWF$20120125$WorkflowExecution = {
    workflowId: string;
    runId: string;
  };
  declare type SWF$20120125$WorkflowExecutionAlreadyStartedFault = {
    message?: string;
  };
  declare type SWF$20120125$WorkflowExecutionCancelRequestedCause = 'CHILD_POLICY_APPLIED';
  declare type SWF$20120125$WorkflowExecutionCancelRequestedEventAttributes = {
    externalWorkflowExecution?: SWF$20120125$WorkflowExecution;
    externalInitiatedEventId?: number;
    cause?: 'CHILD_POLICY_APPLIED';
  };
  declare type SWF$20120125$WorkflowExecutionCanceledEventAttributes = {
    details?: string;
    decisionTaskCompletedEventId: number;
  };
  declare type SWF$20120125$WorkflowExecutionCompletedEventAttributes = {
    result?: string;
    decisionTaskCompletedEventId: number;
  };
  declare type SWF$20120125$WorkflowExecutionConfiguration = {
    taskStartToCloseTimeout: string;
    executionStartToCloseTimeout: string;
    taskList: SWF$20120125$TaskList;
    taskPriority?: string;
    childPolicy: 'TERMINATE' | 'REQUEST_CANCEL' | 'ABANDON';
    lambdaRole?: string;
  };
  declare type SWF$20120125$WorkflowExecutionContinuedAsNewEventAttributes = {
    input?: string;
    decisionTaskCompletedEventId: number;
    newExecutionRunId: string;
    executionStartToCloseTimeout?: string;
    taskList: SWF$20120125$TaskList;
    taskPriority?: string;
    taskStartToCloseTimeout?: string;
    childPolicy: 'TERMINATE' | 'REQUEST_CANCEL' | 'ABANDON';
    tagList?: SWF$20120125$TagList;
    workflowType: SWF$20120125$WorkflowType;
    lambdaRole?: string;
  };
  declare type SWF$20120125$WorkflowExecutionCount = {
    count: number;
    truncated?: boolean;
  };
  declare type SWF$20120125$WorkflowExecutionDetail = {
    executionInfo: SWF$20120125$WorkflowExecutionInfo;
    executionConfiguration: SWF$20120125$WorkflowExecutionConfiguration;
    openCounts: SWF$20120125$WorkflowExecutionOpenCounts;
    latestActivityTaskTimestamp?: Date;
    latestExecutionContext?: string;
  };
  declare type SWF$20120125$WorkflowExecutionFailedEventAttributes = {
    reason?: string;
    details?: string;
    decisionTaskCompletedEventId: number;
  };
  declare type SWF$20120125$WorkflowExecutionFilter = {
    workflowId: string;
  };
  declare type SWF$20120125$WorkflowExecutionInfo = {
    execution: SWF$20120125$WorkflowExecution;
    workflowType: SWF$20120125$WorkflowType;
    startTimestamp: Date;
    closeTimestamp?: Date;
    executionStatus: 'OPEN' | 'CLOSED';
    closeStatus?: 'COMPLETED' | 'FAILED' | 'CANCELED' | 'TERMINATED' | 'CONTINUED_AS_NEW' | 'TIMED_OUT';
    parent?: SWF$20120125$WorkflowExecution;
    tagList?: SWF$20120125$TagList;
    cancelRequested?: boolean;
  };
  declare type SWF$20120125$WorkflowExecutionInfoList = SWF$20120125$WorkflowExecutionInfo[];
  declare type SWF$20120125$WorkflowExecutionInfos = {
    executionInfos: SWF$20120125$WorkflowExecutionInfoList;
    nextPageToken?: string;
  };
  declare type SWF$20120125$WorkflowExecutionOpenCounts = {
    openActivityTasks: number;
    openDecisionTasks: number;
    openTimers: number;
    openChildWorkflowExecutions: number;
    openLambdaFunctions?: number;
  };
  declare type SWF$20120125$WorkflowExecutionSignaledEventAttributes = {
    signalName: string;
    input?: string;
    externalWorkflowExecution?: SWF$20120125$WorkflowExecution;
    externalInitiatedEventId?: number;
  };
  declare type SWF$20120125$WorkflowExecutionStartedEventAttributes = {
    input?: string;
    executionStartToCloseTimeout?: string;
    taskStartToCloseTimeout?: string;
    childPolicy: 'TERMINATE' | 'REQUEST_CANCEL' | 'ABANDON';
    taskList: SWF$20120125$TaskList;
    workflowType: SWF$20120125$WorkflowType;
    tagList?: SWF$20120125$TagList;
    taskPriority?: string;
    continuedExecutionRunId?: string;
    parentWorkflowExecution?: SWF$20120125$WorkflowExecution;
    parentInitiatedEventId?: number;
    lambdaRole?: string;
  };
  declare type SWF$20120125$WorkflowExecutionTerminatedCause = 'CHILD_POLICY_APPLIED' | 'EVENT_LIMIT_EXCEEDED' | 'OPERATOR_INITIATED';
  declare type SWF$20120125$WorkflowExecutionTerminatedEventAttributes = {
    reason?: string;
    details?: string;
    childPolicy: 'TERMINATE' | 'REQUEST_CANCEL' | 'ABANDON';
    cause?: 'CHILD_POLICY_APPLIED' | 'EVENT_LIMIT_EXCEEDED' | 'OPERATOR_INITIATED';
  };
  declare type SWF$20120125$WorkflowExecutionTimedOutEventAttributes = {
    timeoutType: 'START_TO_CLOSE';
    childPolicy: 'TERMINATE' | 'REQUEST_CANCEL' | 'ABANDON';
  };
  declare type SWF$20120125$WorkflowExecutionTimeoutType = 'START_TO_CLOSE';
  declare type SWF$20120125$WorkflowType = {
    name: string;
    version: string;
  };
  declare type SWF$20120125$WorkflowTypeConfiguration = {
    defaultTaskStartToCloseTimeout?: string;
    defaultExecutionStartToCloseTimeout?: string;
    defaultTaskList?: SWF$20120125$TaskList;
    defaultTaskPriority?: string;
    defaultChildPolicy?: 'TERMINATE' | 'REQUEST_CANCEL' | 'ABANDON';
    defaultLambdaRole?: string;
  };
  declare type SWF$20120125$WorkflowTypeDetail = {
    typeInfo: SWF$20120125$WorkflowTypeInfo;
    configuration: SWF$20120125$WorkflowTypeConfiguration;
  };
  declare type SWF$20120125$WorkflowTypeFilter = {
    name: string;
    version?: string;
  };
  declare type SWF$20120125$WorkflowTypeInfo = {
    workflowType: SWF$20120125$WorkflowType;
    status: 'REGISTERED' | 'DEPRECATED';
    description?: string;
    creationDate: Date;
    deprecationDate?: Date;
  };
  declare type SWF$20120125$WorkflowTypeInfoList = SWF$20120125$WorkflowTypeInfo[];
  declare type SWF$20120125$WorkflowTypeInfos = {
    typeInfos: SWF$20120125$WorkflowTypeInfoList;
    nextPageToken?: string;
  };
  declare type WAF$20150824$ActivatedRule = {
    Priority: number;
    RuleId: string;
    Action: WAF$20150824$WafAction;
  };
  declare type WAF$20150824$ActivatedRules = WAF$20150824$ActivatedRule[];
  declare type WAF$20150824$ByteMatchSet = {
    ByteMatchSetId: string;
    Name?: string;
    ByteMatchTuples: WAF$20150824$ByteMatchTuples;
  };
  declare type WAF$20150824$ByteMatchSetSummaries = WAF$20150824$ByteMatchSetSummary[];
  declare type WAF$20150824$ByteMatchSetSummary = {
    ByteMatchSetId: string;
    Name: string;
  };
  declare type WAF$20150824$ByteMatchSetUpdate = {
    Action: 'INSERT' | 'DELETE';
    ByteMatchTuple: WAF$20150824$ByteMatchTuple;
  };
  declare type WAF$20150824$ByteMatchSetUpdates = WAF$20150824$ByteMatchSetUpdate[];
  declare type WAF$20150824$ByteMatchTargetString = Buffer | $TypedArray | Blob | string;
  declare type WAF$20150824$ByteMatchTuple = {
    FieldToMatch: WAF$20150824$FieldToMatch;
    TargetString: Buffer | $TypedArray | Blob | string;
    TextTransformation: 'NONE' | 'COMPRESS_WHITE_SPACE' | 'HTML_ENTITY_DECODE' | 'LOWERCASE' | 'CMD_LINE' | 'URL_DECODE';
    PositionalConstraint: 'EXACTLY' | 'STARTS_WITH' | 'ENDS_WITH' | 'CONTAINS' | 'CONTAINS_WORD';
  };
  declare type WAF$20150824$ByteMatchTuples = WAF$20150824$ByteMatchTuple[];
  declare type WAF$20150824$ChangeAction = 'INSERT' | 'DELETE';
  declare type WAF$20150824$ChangeTokenStatus = 'PROVISIONED' | 'PENDING' | 'INSYNC';
  declare type WAF$20150824$ComparisonOperator = 'EQ' | 'NE' | 'LE' | 'LT' | 'GE' | 'GT';
  declare type WAF$20150824$CreateByteMatchSetRequest = {
    Name: string;
    ChangeToken: string;
  };
  declare type WAF$20150824$CreateByteMatchSetResponse = {
    ByteMatchSet?: WAF$20150824$ByteMatchSet;
    ChangeToken?: string;
  };
  declare type WAF$20150824$CreateIPSetRequest = {
    Name: string;
    ChangeToken: string;
  };
  declare type WAF$20150824$CreateIPSetResponse = {
    IPSet?: WAF$20150824$IPSet;
    ChangeToken?: string;
  };
  declare type WAF$20150824$CreateRuleRequest = {
    Name: string;
    MetricName: string;
    ChangeToken: string;
  };
  declare type WAF$20150824$CreateRuleResponse = {
    Rule?: WAF$20150824$Rule;
    ChangeToken?: string;
  };
  declare type WAF$20150824$CreateSizeConstraintSetRequest = {
    Name: string;
    ChangeToken: string;
  };
  declare type WAF$20150824$CreateSizeConstraintSetResponse = {
    SizeConstraintSet?: WAF$20150824$SizeConstraintSet;
    ChangeToken?: string;
  };
  declare type WAF$20150824$CreateSqlInjectionMatchSetRequest = {
    Name: string;
    ChangeToken: string;
  };
  declare type WAF$20150824$CreateSqlInjectionMatchSetResponse = {
    SqlInjectionMatchSet?: WAF$20150824$SqlInjectionMatchSet;
    ChangeToken?: string;
  };
  declare type WAF$20150824$CreateWebACLRequest = {
    Name: string;
    MetricName: string;
    DefaultAction: WAF$20150824$WafAction;
    ChangeToken: string;
  };
  declare type WAF$20150824$CreateWebACLResponse = {
    WebACL?: WAF$20150824$WebACL;
    ChangeToken?: string;
  };
  declare type WAF$20150824$CreateXssMatchSetRequest = {
    Name: string;
    ChangeToken: string;
  };
  declare type WAF$20150824$CreateXssMatchSetResponse = {
    XssMatchSet?: WAF$20150824$XssMatchSet;
    ChangeToken?: string;
  };
  declare type WAF$20150824$DeleteByteMatchSetRequest = {
    ByteMatchSetId: string;
    ChangeToken: string;
  };
  declare type WAF$20150824$DeleteByteMatchSetResponse = {
    ChangeToken?: string;
  };
  declare type WAF$20150824$DeleteIPSetRequest = {
    IPSetId: string;
    ChangeToken: string;
  };
  declare type WAF$20150824$DeleteIPSetResponse = {
    ChangeToken?: string;
  };
  declare type WAF$20150824$DeleteRuleRequest = {
    RuleId: string;
    ChangeToken: string;
  };
  declare type WAF$20150824$DeleteRuleResponse = {
    ChangeToken?: string;
  };
  declare type WAF$20150824$DeleteSizeConstraintSetRequest = {
    SizeConstraintSetId: string;
    ChangeToken: string;
  };
  declare type WAF$20150824$DeleteSizeConstraintSetResponse = {
    ChangeToken?: string;
  };
  declare type WAF$20150824$DeleteSqlInjectionMatchSetRequest = {
    SqlInjectionMatchSetId: string;
    ChangeToken: string;
  };
  declare type WAF$20150824$DeleteSqlInjectionMatchSetResponse = {
    ChangeToken?: string;
  };
  declare type WAF$20150824$DeleteWebACLRequest = {
    WebACLId: string;
    ChangeToken: string;
  };
  declare type WAF$20150824$DeleteWebACLResponse = {
    ChangeToken?: string;
  };
  declare type WAF$20150824$DeleteXssMatchSetRequest = {
    XssMatchSetId: string;
    ChangeToken: string;
  };
  declare type WAF$20150824$DeleteXssMatchSetResponse = {
    ChangeToken?: string;
  };
  declare type WAF$20150824$FieldToMatch = {
    Type: 'URI' | 'QUERY_STRING' | 'HEADER' | 'METHOD' | 'BODY';
    Data?: string;
  };
  declare type WAF$20150824$GetByteMatchSetRequest = {
    ByteMatchSetId: string;
  };
  declare type WAF$20150824$GetByteMatchSetResponse = {
    ByteMatchSet?: WAF$20150824$ByteMatchSet;
  };
  declare type WAF$20150824$GetChangeTokenRequest = {};
  declare type WAF$20150824$GetChangeTokenResponse = {
    ChangeToken?: string;
  };
  declare type WAF$20150824$GetChangeTokenStatusRequest = {
    ChangeToken: string;
  };
  declare type WAF$20150824$GetChangeTokenStatusResponse = {
    ChangeTokenStatus?: 'PROVISIONED' | 'PENDING' | 'INSYNC';
  };
  declare type WAF$20150824$GetIPSetRequest = {
    IPSetId: string;
  };
  declare type WAF$20150824$GetIPSetResponse = {
    IPSet?: WAF$20150824$IPSet;
  };
  declare type WAF$20150824$GetRuleRequest = {
    RuleId: string;
  };
  declare type WAF$20150824$GetRuleResponse = {
    Rule?: WAF$20150824$Rule;
  };
  declare type WAF$20150824$GetSampledRequestsRequest = {
    WebAclId: string;
    RuleId: string;
    TimeWindow: WAF$20150824$TimeWindow;
    MaxItems: number;
  };
  declare type WAF$20150824$GetSampledRequestsResponse = {
    SampledRequests?: WAF$20150824$SampledHTTPRequests;
    PopulationSize?: number;
    TimeWindow?: WAF$20150824$TimeWindow;
  };
  declare type WAF$20150824$GetSizeConstraintSetRequest = {
    SizeConstraintSetId: string;
  };
  declare type WAF$20150824$GetSizeConstraintSetResponse = {
    SizeConstraintSet?: WAF$20150824$SizeConstraintSet;
  };
  declare type WAF$20150824$GetSqlInjectionMatchSetRequest = {
    SqlInjectionMatchSetId: string;
  };
  declare type WAF$20150824$GetSqlInjectionMatchSetResponse = {
    SqlInjectionMatchSet?: WAF$20150824$SqlInjectionMatchSet;
  };
  declare type WAF$20150824$GetWebACLRequest = {
    WebACLId: string;
  };
  declare type WAF$20150824$GetWebACLResponse = {
    WebACL?: WAF$20150824$WebACL;
  };
  declare type WAF$20150824$GetXssMatchSetRequest = {
    XssMatchSetId: string;
  };
  declare type WAF$20150824$GetXssMatchSetResponse = {
    XssMatchSet?: WAF$20150824$XssMatchSet;
  };
  declare type WAF$20150824$HTTPHeader = {
    Name?: string;
    Value?: string;
  };
  declare type WAF$20150824$HTTPHeaders = WAF$20150824$HTTPHeader[];
  declare type WAF$20150824$HTTPRequest = {
    ClientIP?: string;
    Country?: string;
    URI?: string;
    Method?: string;
    HTTPVersion?: string;
    Headers?: WAF$20150824$HTTPHeaders;
  };
  declare type WAF$20150824$IPSet = {
    IPSetId: string;
    Name?: string;
    IPSetDescriptors: WAF$20150824$IPSetDescriptors;
  };
  declare type WAF$20150824$IPSetDescriptor = {
    Type: 'IPV4';
    Value: string;
  };
  declare type WAF$20150824$IPSetDescriptorType = 'IPV4';
  declare type WAF$20150824$IPSetDescriptors = WAF$20150824$IPSetDescriptor[];
  declare type WAF$20150824$IPSetSummaries = WAF$20150824$IPSetSummary[];
  declare type WAF$20150824$IPSetSummary = {
    IPSetId: string;
    Name: string;
  };
  declare type WAF$20150824$IPSetUpdate = {
    Action: 'INSERT' | 'DELETE';
    IPSetDescriptor: WAF$20150824$IPSetDescriptor;
  };
  declare type WAF$20150824$IPSetUpdates = WAF$20150824$IPSetUpdate[];
  declare type WAF$20150824$ListByteMatchSetsRequest = {
    NextMarker?: string;
    Limit: number;
  };
  declare type WAF$20150824$ListByteMatchSetsResponse = {
    NextMarker?: string;
    ByteMatchSets?: WAF$20150824$ByteMatchSetSummaries;
  };
  declare type WAF$20150824$ListIPSetsRequest = {
    NextMarker?: string;
    Limit: number;
  };
  declare type WAF$20150824$ListIPSetsResponse = {
    NextMarker?: string;
    IPSets?: WAF$20150824$IPSetSummaries;
  };
  declare type WAF$20150824$ListRulesRequest = {
    NextMarker?: string;
    Limit: number;
  };
  declare type WAF$20150824$ListRulesResponse = {
    NextMarker?: string;
    Rules?: WAF$20150824$RuleSummaries;
  };
  declare type WAF$20150824$ListSizeConstraintSetsRequest = {
    NextMarker?: string;
    Limit: number;
  };
  declare type WAF$20150824$ListSizeConstraintSetsResponse = {
    NextMarker?: string;
    SizeConstraintSets?: WAF$20150824$SizeConstraintSetSummaries;
  };
  declare type WAF$20150824$ListSqlInjectionMatchSetsRequest = {
    NextMarker?: string;
    Limit: number;
  };
  declare type WAF$20150824$ListSqlInjectionMatchSetsResponse = {
    NextMarker?: string;
    SqlInjectionMatchSets?: WAF$20150824$SqlInjectionMatchSetSummaries;
  };
  declare type WAF$20150824$ListWebACLsRequest = {
    NextMarker?: string;
    Limit: number;
  };
  declare type WAF$20150824$ListWebACLsResponse = {
    NextMarker?: string;
    WebACLs?: WAF$20150824$WebACLSummaries;
  };
  declare type WAF$20150824$ListXssMatchSetsRequest = {
    NextMarker?: string;
    Limit: number;
  };
  declare type WAF$20150824$ListXssMatchSetsResponse = {
    NextMarker?: string;
    XssMatchSets?: WAF$20150824$XssMatchSetSummaries;
  };
  declare type WAF$20150824$MatchFieldType = 'URI' | 'QUERY_STRING' | 'HEADER' | 'METHOD' | 'BODY';
  declare type WAF$20150824$ParameterExceptionField = 'CHANGE_ACTION' | 'WAF_ACTION' | 'PREDICATE_TYPE' | 'IPSET_TYPE' | 'BYTE_MATCH_FIELD_TYPE' | 'SQL_INJECTION_MATCH_FIELD_TYPE' | 'BYTE_MATCH_TEXT_TRANSFORMATION' | 'BYTE_MATCH_POSITIONAL_CONSTRAINT' | 'SIZE_CONSTRAINT_COMPARISON_OPERATOR';
  declare type WAF$20150824$ParameterExceptionReason = 'INVALID_OPTION' | 'ILLEGAL_COMBINATION';
  declare type WAF$20150824$PositionalConstraint = 'EXACTLY' | 'STARTS_WITH' | 'ENDS_WITH' | 'CONTAINS' | 'CONTAINS_WORD';
  declare type WAF$20150824$Predicate = {
    Negated: boolean;
    Type: 'IPMatch' | 'ByteMatch' | 'SqlInjectionMatch' | 'SizeConstraint' | 'XssMatch';
    DataId: string;
  };
  declare type WAF$20150824$PredicateType = 'IPMatch' | 'ByteMatch' | 'SqlInjectionMatch' | 'SizeConstraint' | 'XssMatch';
  declare type WAF$20150824$Predicates = WAF$20150824$Predicate[];
  declare type WAF$20150824$Rule = {
    RuleId: string;
    Name?: string;
    MetricName?: string;
    Predicates: WAF$20150824$Predicates;
  };
  declare type WAF$20150824$RuleSummaries = WAF$20150824$RuleSummary[];
  declare type WAF$20150824$RuleSummary = {
    RuleId: string;
    Name: string;
  };
  declare type WAF$20150824$RuleUpdate = {
    Action: 'INSERT' | 'DELETE';
    Predicate: WAF$20150824$Predicate;
  };
  declare type WAF$20150824$RuleUpdates = WAF$20150824$RuleUpdate[];
  declare type WAF$20150824$SampledHTTPRequest = {
    Request: WAF$20150824$HTTPRequest;
    Weight: number;
    Timestamp?: Date;
    Action?: string;
  };
  declare type WAF$20150824$SampledHTTPRequests = WAF$20150824$SampledHTTPRequest[];
  declare type WAF$20150824$SizeConstraint = {
    FieldToMatch: WAF$20150824$FieldToMatch;
    TextTransformation: 'NONE' | 'COMPRESS_WHITE_SPACE' | 'HTML_ENTITY_DECODE' | 'LOWERCASE' | 'CMD_LINE' | 'URL_DECODE';
    ComparisonOperator: 'EQ' | 'NE' | 'LE' | 'LT' | 'GE' | 'GT';
    Size: number;
  };
  declare type WAF$20150824$SizeConstraintSet = {
    SizeConstraintSetId: string;
    Name?: string;
    SizeConstraints: WAF$20150824$SizeConstraints;
  };
  declare type WAF$20150824$SizeConstraintSetSummaries = WAF$20150824$SizeConstraintSetSummary[];
  declare type WAF$20150824$SizeConstraintSetSummary = {
    SizeConstraintSetId: string;
    Name: string;
  };
  declare type WAF$20150824$SizeConstraintSetUpdate = {
    Action: 'INSERT' | 'DELETE';
    SizeConstraint: WAF$20150824$SizeConstraint;
  };
  declare type WAF$20150824$SizeConstraintSetUpdates = WAF$20150824$SizeConstraintSetUpdate[];
  declare type WAF$20150824$SizeConstraints = WAF$20150824$SizeConstraint[];
  declare type WAF$20150824$SqlInjectionMatchSet = {
    SqlInjectionMatchSetId: string;
    Name?: string;
    SqlInjectionMatchTuples: WAF$20150824$SqlInjectionMatchTuples;
  };
  declare type WAF$20150824$SqlInjectionMatchSetSummaries = WAF$20150824$SqlInjectionMatchSetSummary[];
  declare type WAF$20150824$SqlInjectionMatchSetSummary = {
    SqlInjectionMatchSetId: string;
    Name: string;
  };
  declare type WAF$20150824$SqlInjectionMatchSetUpdate = {
    Action: 'INSERT' | 'DELETE';
    SqlInjectionMatchTuple: WAF$20150824$SqlInjectionMatchTuple;
  };
  declare type WAF$20150824$SqlInjectionMatchSetUpdates = WAF$20150824$SqlInjectionMatchSetUpdate[];
  declare type WAF$20150824$SqlInjectionMatchTuple = {
    FieldToMatch: WAF$20150824$FieldToMatch;
    TextTransformation: 'NONE' | 'COMPRESS_WHITE_SPACE' | 'HTML_ENTITY_DECODE' | 'LOWERCASE' | 'CMD_LINE' | 'URL_DECODE';
  };
  declare type WAF$20150824$SqlInjectionMatchTuples = WAF$20150824$SqlInjectionMatchTuple[];
  declare type WAF$20150824$TextTransformation = 'NONE' | 'COMPRESS_WHITE_SPACE' | 'HTML_ENTITY_DECODE' | 'LOWERCASE' | 'CMD_LINE' | 'URL_DECODE';
  declare type WAF$20150824$TimeWindow = {
    StartTime: Date;
    EndTime: Date;
  };
  declare type WAF$20150824$Timestamp = Date;
  declare type WAF$20150824$UpdateByteMatchSetRequest = {
    ByteMatchSetId: string;
    ChangeToken: string;
    Updates: WAF$20150824$ByteMatchSetUpdates;
  };
  declare type WAF$20150824$UpdateByteMatchSetResponse = {
    ChangeToken?: string;
  };
  declare type WAF$20150824$UpdateIPSetRequest = {
    IPSetId: string;
    ChangeToken: string;
    Updates: WAF$20150824$IPSetUpdates;
  };
  declare type WAF$20150824$UpdateIPSetResponse = {
    ChangeToken?: string;
  };
  declare type WAF$20150824$UpdateRuleRequest = {
    RuleId: string;
    ChangeToken: string;
    Updates: WAF$20150824$RuleUpdates;
  };
  declare type WAF$20150824$UpdateRuleResponse = {
    ChangeToken?: string;
  };
  declare type WAF$20150824$UpdateSizeConstraintSetRequest = {
    SizeConstraintSetId: string;
    ChangeToken: string;
    Updates: WAF$20150824$SizeConstraintSetUpdates;
  };
  declare type WAF$20150824$UpdateSizeConstraintSetResponse = {
    ChangeToken?: string;
  };
  declare type WAF$20150824$UpdateSqlInjectionMatchSetRequest = {
    SqlInjectionMatchSetId: string;
    ChangeToken: string;
    Updates: WAF$20150824$SqlInjectionMatchSetUpdates;
  };
  declare type WAF$20150824$UpdateSqlInjectionMatchSetResponse = {
    ChangeToken?: string;
  };
  declare type WAF$20150824$UpdateWebACLRequest = {
    WebACLId: string;
    ChangeToken: string;
    Updates?: WAF$20150824$WebACLUpdates;
    DefaultAction?: WAF$20150824$WafAction;
  };
  declare type WAF$20150824$UpdateWebACLResponse = {
    ChangeToken?: string;
  };
  declare type WAF$20150824$UpdateXssMatchSetRequest = {
    XssMatchSetId: string;
    ChangeToken: string;
    Updates: WAF$20150824$XssMatchSetUpdates;
  };
  declare type WAF$20150824$UpdateXssMatchSetResponse = {
    ChangeToken?: string;
  };
  declare type WAF$20150824$WAFDisallowedNameException = {
    message?: string;
  };
  declare type WAF$20150824$WAFInternalErrorException = {
    message?: string;
  };
  declare type WAF$20150824$WAFInvalidAccountException = {};
  declare type WAF$20150824$WAFInvalidOperationException = {
    message?: string;
  };
  declare type WAF$20150824$WAFInvalidParameterException = {
    field?: 'CHANGE_ACTION' | 'WAF_ACTION' | 'PREDICATE_TYPE' | 'IPSET_TYPE' | 'BYTE_MATCH_FIELD_TYPE' | 'SQL_INJECTION_MATCH_FIELD_TYPE' | 'BYTE_MATCH_TEXT_TRANSFORMATION' | 'BYTE_MATCH_POSITIONAL_CONSTRAINT' | 'SIZE_CONSTRAINT_COMPARISON_OPERATOR';
    parameter?: string;
    reason?: 'INVALID_OPTION' | 'ILLEGAL_COMBINATION';
  };
  declare type WAF$20150824$WAFLimitsExceededException = {
    message?: string;
  };
  declare type WAF$20150824$WAFNonEmptyEntityException = {
    message?: string;
  };
  declare type WAF$20150824$WAFNonexistentContainerException = {
    message?: string;
  };
  declare type WAF$20150824$WAFNonexistentItemException = {
    message?: string;
  };
  declare type WAF$20150824$WAFReferencedItemException = {
    message?: string;
  };
  declare type WAF$20150824$WAFStaleDataException = {
    message?: string;
  };
  declare type WAF$20150824$WafAction = {
    Type: 'BLOCK' | 'ALLOW' | 'COUNT';
  };
  declare type WAF$20150824$WafActionType = 'BLOCK' | 'ALLOW' | 'COUNT';
  declare type WAF$20150824$WebACL = {
    WebACLId: string;
    Name?: string;
    MetricName?: string;
    DefaultAction: WAF$20150824$WafAction;
    Rules: WAF$20150824$ActivatedRules;
  };
  declare type WAF$20150824$WebACLSummaries = WAF$20150824$WebACLSummary[];
  declare type WAF$20150824$WebACLSummary = {
    WebACLId: string;
    Name: string;
  };
  declare type WAF$20150824$WebACLUpdate = {
    Action: 'INSERT' | 'DELETE';
    ActivatedRule: WAF$20150824$ActivatedRule;
  };
  declare type WAF$20150824$WebACLUpdates = WAF$20150824$WebACLUpdate[];
  declare type WAF$20150824$XssMatchSet = {
    XssMatchSetId: string;
    Name?: string;
    XssMatchTuples: WAF$20150824$XssMatchTuples;
  };
  declare type WAF$20150824$XssMatchSetSummaries = WAF$20150824$XssMatchSetSummary[];
  declare type WAF$20150824$XssMatchSetSummary = {
    XssMatchSetId: string;
    Name: string;
  };
  declare type WAF$20150824$XssMatchSetUpdate = {
    Action: 'INSERT' | 'DELETE';
    XssMatchTuple: WAF$20150824$XssMatchTuple;
  };
  declare type WAF$20150824$XssMatchSetUpdates = WAF$20150824$XssMatchSetUpdate[];
  declare type WAF$20150824$XssMatchTuple = {
    FieldToMatch: WAF$20150824$FieldToMatch;
    TextTransformation: 'NONE' | 'COMPRESS_WHITE_SPACE' | 'HTML_ENTITY_DECODE' | 'LOWERCASE' | 'CMD_LINE' | 'URL_DECODE';
  };
  declare type WAF$20150824$XssMatchTuples = WAF$20150824$XssMatchTuple[];
  declare type WorkSpaces$20150408$BundleIdList = string[];
  declare type WorkSpaces$20150408$BundleList = WorkSpaces$20150408$WorkspaceBundle[];
  declare type WorkSpaces$20150408$Compute = 'VALUE' | 'STANDARD' | 'PERFORMANCE';
  declare type WorkSpaces$20150408$ComputeType = {
    Name?: 'VALUE' | 'STANDARD' | 'PERFORMANCE';
  };
  declare type WorkSpaces$20150408$CreateTagsRequest = {
    ResourceId: string;
    Tags: WorkSpaces$20150408$TagList;
  };
  declare type WorkSpaces$20150408$CreateTagsResult = {};
  declare type WorkSpaces$20150408$CreateWorkspacesRequest = {
    Workspaces: WorkSpaces$20150408$WorkspaceRequestList;
  };
  declare type WorkSpaces$20150408$CreateWorkspacesResult = {
    FailedRequests?: WorkSpaces$20150408$FailedCreateWorkspaceRequests;
    PendingRequests?: WorkSpaces$20150408$WorkspaceList;
  };
  declare type WorkSpaces$20150408$DefaultWorkspaceCreationProperties = {
    EnableWorkDocs?: boolean;
    EnableInternetAccess?: boolean;
    DefaultOu?: string;
    CustomSecurityGroupId?: string;
    UserEnabledAsLocalAdministrator?: boolean;
  };
  declare type WorkSpaces$20150408$DeleteTagsRequest = {
    ResourceId: string;
    TagKeys: WorkSpaces$20150408$TagKeyList;
  };
  declare type WorkSpaces$20150408$DeleteTagsResult = {};
  declare type WorkSpaces$20150408$DescribeTagsRequest = {
    ResourceId: string;
  };
  declare type WorkSpaces$20150408$DescribeTagsResult = {
    TagList?: WorkSpaces$20150408$TagList;
  };
  declare type WorkSpaces$20150408$DescribeWorkspaceBundlesRequest = {
    BundleIds?: WorkSpaces$20150408$BundleIdList;
    Owner?: string;
    NextToken?: string;
  };
  declare type WorkSpaces$20150408$DescribeWorkspaceBundlesResult = {
    Bundles?: WorkSpaces$20150408$BundleList;
    NextToken?: string;
  };
  declare type WorkSpaces$20150408$DescribeWorkspaceDirectoriesRequest = {
    DirectoryIds?: WorkSpaces$20150408$DirectoryIdList;
    NextToken?: string;
  };
  declare type WorkSpaces$20150408$DescribeWorkspaceDirectoriesResult = {
    Directories?: WorkSpaces$20150408$DirectoryList;
    NextToken?: string;
  };
  declare type WorkSpaces$20150408$DescribeWorkspacesRequest = {
    WorkspaceIds?: WorkSpaces$20150408$WorkspaceIdList;
    DirectoryId?: string;
    UserName?: string;
    BundleId?: string;
    Limit?: number;
    NextToken?: string;
  };
  declare type WorkSpaces$20150408$DescribeWorkspacesResult = {
    Workspaces?: WorkSpaces$20150408$WorkspaceList;
    NextToken?: string;
  };
  declare type WorkSpaces$20150408$DirectoryIdList = string[];
  declare type WorkSpaces$20150408$DirectoryList = WorkSpaces$20150408$WorkspaceDirectory[];
  declare type WorkSpaces$20150408$DnsIpAddresses = string[];
  declare type WorkSpaces$20150408$FailedCreateWorkspaceRequest = {
    WorkspaceRequest?: WorkSpaces$20150408$WorkspaceRequest;
    ErrorCode?: string;
    ErrorMessage?: string;
  };
  declare type WorkSpaces$20150408$FailedCreateWorkspaceRequests = WorkSpaces$20150408$FailedCreateWorkspaceRequest[];
  declare type WorkSpaces$20150408$FailedRebootWorkspaceRequests = WorkSpaces$20150408$FailedWorkspaceChangeRequest[];
  declare type WorkSpaces$20150408$FailedRebuildWorkspaceRequests = WorkSpaces$20150408$FailedWorkspaceChangeRequest[];
  declare type WorkSpaces$20150408$FailedTerminateWorkspaceRequests = WorkSpaces$20150408$FailedWorkspaceChangeRequest[];
  declare type WorkSpaces$20150408$FailedWorkspaceChangeRequest = {
    WorkspaceId?: string;
    ErrorCode?: string;
    ErrorMessage?: string;
  };
  declare type WorkSpaces$20150408$InvalidParameterValuesException = {
    message?: string;
  };
  declare type WorkSpaces$20150408$RebootRequest = {
    WorkspaceId: string;
  };
  declare type WorkSpaces$20150408$RebootWorkspaceRequests = WorkSpaces$20150408$RebootRequest[];
  declare type WorkSpaces$20150408$RebootWorkspacesRequest = {
    RebootWorkspaceRequests: WorkSpaces$20150408$RebootWorkspaceRequests;
  };
  declare type WorkSpaces$20150408$RebootWorkspacesResult = {
    FailedRequests?: WorkSpaces$20150408$FailedRebootWorkspaceRequests;
  };
  declare type WorkSpaces$20150408$RebuildRequest = {
    WorkspaceId: string;
  };
  declare type WorkSpaces$20150408$RebuildWorkspaceRequests = WorkSpaces$20150408$RebuildRequest[];
  declare type WorkSpaces$20150408$RebuildWorkspacesRequest = {
    RebuildWorkspaceRequests: WorkSpaces$20150408$RebuildWorkspaceRequests;
  };
  declare type WorkSpaces$20150408$RebuildWorkspacesResult = {
    FailedRequests?: WorkSpaces$20150408$FailedRebuildWorkspaceRequests;
  };
  declare type WorkSpaces$20150408$ResourceLimitExceededException = {
    message?: string;
  };
  declare type WorkSpaces$20150408$ResourceNotFoundException = {
    message?: string;
    ResourceId?: string;
  };
  declare type WorkSpaces$20150408$ResourceUnavailableException = {
    message?: string;
    ResourceId?: string;
  };
  declare type WorkSpaces$20150408$SubnetIds = string[];
  declare type WorkSpaces$20150408$Tag = {
    Key: string;
    Value?: string;
  };
  declare type WorkSpaces$20150408$TagKeyList = string[];
  declare type WorkSpaces$20150408$TagList = WorkSpaces$20150408$Tag[];
  declare type WorkSpaces$20150408$TerminateRequest = {
    WorkspaceId: string;
  };
  declare type WorkSpaces$20150408$TerminateWorkspaceRequests = WorkSpaces$20150408$TerminateRequest[];
  declare type WorkSpaces$20150408$TerminateWorkspacesRequest = {
    TerminateWorkspaceRequests: WorkSpaces$20150408$TerminateWorkspaceRequests;
  };
  declare type WorkSpaces$20150408$TerminateWorkspacesResult = {
    FailedRequests?: WorkSpaces$20150408$FailedTerminateWorkspaceRequests;
  };
  declare type WorkSpaces$20150408$UserStorage = {
    Capacity?: string;
  };
  declare type WorkSpaces$20150408$Workspace = {
    WorkspaceId?: string;
    DirectoryId?: string;
    UserName?: string;
    IpAddress?: string;
    State?: 'PENDING' | 'AVAILABLE' | 'IMPAIRED' | 'UNHEALTHY' | 'REBOOTING' | 'REBUILDING' | 'TERMINATING' | 'TERMINATED' | 'SUSPENDED' | 'ERROR';
    BundleId?: string;
    SubnetId?: string;
    ErrorMessage?: string;
    ErrorCode?: string;
    ComputerName?: string;
    VolumeEncryptionKey?: string;
    UserVolumeEncryptionEnabled?: boolean;
    RootVolumeEncryptionEnabled?: boolean;
  };
  declare type WorkSpaces$20150408$WorkspaceBundle = {
    BundleId?: string;
    Name?: string;
    Owner?: string;
    Description?: string;
    UserStorage?: WorkSpaces$20150408$UserStorage;
    ComputeType?: WorkSpaces$20150408$ComputeType;
  };
  declare type WorkSpaces$20150408$WorkspaceDirectory = {
    DirectoryId?: string;
    Alias?: string;
    DirectoryName?: string;
    RegistrationCode?: string;
    SubnetIds?: WorkSpaces$20150408$SubnetIds;
    DnsIpAddresses?: WorkSpaces$20150408$DnsIpAddresses;
    CustomerUserName?: string;
    IamRoleId?: string;
    DirectoryType?: 'SIMPLE_AD' | 'AD_CONNECTOR';
    WorkspaceSecurityGroupId?: string;
    State?: 'REGISTERING' | 'REGISTERED' | 'DEREGISTERING' | 'DEREGISTERED' | 'ERROR';
    WorkspaceCreationProperties?: WorkSpaces$20150408$DefaultWorkspaceCreationProperties;
  };
  declare type WorkSpaces$20150408$WorkspaceDirectoryState = 'REGISTERING' | 'REGISTERED' | 'DEREGISTERING' | 'DEREGISTERED' | 'ERROR';
  declare type WorkSpaces$20150408$WorkspaceDirectoryType = 'SIMPLE_AD' | 'AD_CONNECTOR';
  declare type WorkSpaces$20150408$WorkspaceIdList = string[];
  declare type WorkSpaces$20150408$WorkspaceList = WorkSpaces$20150408$Workspace[];
  declare type WorkSpaces$20150408$WorkspaceRequest = {
    DirectoryId: string;
    UserName: string;
    BundleId: string;
    VolumeEncryptionKey?: string;
    UserVolumeEncryptionEnabled?: boolean;
    RootVolumeEncryptionEnabled?: boolean;
    Tags?: WorkSpaces$20150408$TagList;
  };
  declare type WorkSpaces$20150408$WorkspaceRequestList = WorkSpaces$20150408$WorkspaceRequest[];
  declare type WorkSpaces$20150408$WorkspaceState = 'PENDING' | 'AVAILABLE' | 'IMPAIRED' | 'UNHEALTHY' | 'REBOOTING' | 'REBUILDING' | 'TERMINATING' | 'TERMINATED' | 'SUSPENDED' | 'ERROR';
  declare class ACM$20151208 {
    addTagsToCertificate: $APIMethod<ACM$20151208$AddTagsToCertificateRequest, void>;
    deleteCertificate: $APIMethod<ACM$20151208$DeleteCertificateRequest, void>;
    describeCertificate: $APIMethod<ACM$20151208$DescribeCertificateRequest, ACM$20151208$DescribeCertificateResponse>;
    getCertificate: $APIMethod<ACM$20151208$GetCertificateRequest, ACM$20151208$GetCertificateResponse>;
    listCertificates: $APIMethod<ACM$20151208$ListCertificatesRequest, ACM$20151208$ListCertificatesResponse>;
    listTagsForCertificate: $APIMethod<ACM$20151208$ListTagsForCertificateRequest, ACM$20151208$ListTagsForCertificateResponse>;
    removeTagsFromCertificate: $APIMethod<ACM$20151208$RemoveTagsFromCertificateRequest, void>;
    requestCertificate: $APIMethod<ACM$20151208$RequestCertificateRequest, ACM$20151208$RequestCertificateResponse>;
    resendValidationEmail: $APIMethod<ACM$20151208$ResendValidationEmailRequest, void>;
  }
  declare class ACM {
    constructor(config: $ConfigOptions & {
      apiVersion: '2015-12-08';
    }): ACM$20151208;
    constructor(): ACM$20151208;
  }
  declare class APIGateway$20150709 {
    createApiKey: $APIMethod<APIGateway$20150709$CreateApiKeyRequest, APIGateway$20150709$ApiKey>;
    createAuthorizer: $APIMethod<APIGateway$20150709$CreateAuthorizerRequest, APIGateway$20150709$Authorizer>;
    createBasePathMapping: $APIMethod<APIGateway$20150709$CreateBasePathMappingRequest, APIGateway$20150709$BasePathMapping>;
    createDeployment: $APIMethod<APIGateway$20150709$CreateDeploymentRequest, APIGateway$20150709$Deployment>;
    createDomainName: $APIMethod<APIGateway$20150709$CreateDomainNameRequest, APIGateway$20150709$DomainName>;
    createModel: $APIMethod<APIGateway$20150709$CreateModelRequest, APIGateway$20150709$Model>;
    createResource: $APIMethod<APIGateway$20150709$CreateResourceRequest, APIGateway$20150709$Resource>;
    createRestApi: $APIMethod<APIGateway$20150709$CreateRestApiRequest, APIGateway$20150709$RestApi>;
    createStage: $APIMethod<APIGateway$20150709$CreateStageRequest, APIGateway$20150709$Stage>;
    deleteApiKey: $APIMethod<APIGateway$20150709$DeleteApiKeyRequest, void>;
    deleteAuthorizer: $APIMethod<APIGateway$20150709$DeleteAuthorizerRequest, void>;
    deleteBasePathMapping: $APIMethod<APIGateway$20150709$DeleteBasePathMappingRequest, void>;
    deleteClientCertificate: $APIMethod<APIGateway$20150709$DeleteClientCertificateRequest, void>;
    deleteDeployment: $APIMethod<APIGateway$20150709$DeleteDeploymentRequest, void>;
    deleteDomainName: $APIMethod<APIGateway$20150709$DeleteDomainNameRequest, void>;
    deleteIntegration: $APIMethod<APIGateway$20150709$DeleteIntegrationRequest, void>;
    deleteIntegrationResponse: $APIMethod<APIGateway$20150709$DeleteIntegrationResponseRequest, void>;
    deleteMethod: $APIMethod<APIGateway$20150709$DeleteMethodRequest, void>;
    deleteMethodResponse: $APIMethod<APIGateway$20150709$DeleteMethodResponseRequest, void>;
    deleteModel: $APIMethod<APIGateway$20150709$DeleteModelRequest, void>;
    deleteResource: $APIMethod<APIGateway$20150709$DeleteResourceRequest, void>;
    deleteRestApi: $APIMethod<APIGateway$20150709$DeleteRestApiRequest, void>;
    deleteStage: $APIMethod<APIGateway$20150709$DeleteStageRequest, void>;
    flushStageAuthorizersCache: $APIMethod<APIGateway$20150709$FlushStageAuthorizersCacheRequest, void>;
    flushStageCache: $APIMethod<APIGateway$20150709$FlushStageCacheRequest, void>;
    generateClientCertificate: $APIMethod<APIGateway$20150709$GenerateClientCertificateRequest, APIGateway$20150709$ClientCertificate>;
    getAccount: $APIMethod<APIGateway$20150709$GetAccountRequest, APIGateway$20150709$Account>;
    getApiKey: $APIMethod<APIGateway$20150709$GetApiKeyRequest, APIGateway$20150709$ApiKey>;
    getApiKeys: $APIMethod<APIGateway$20150709$GetApiKeysRequest, APIGateway$20150709$ApiKeys>;
    getAuthorizer: $APIMethod<APIGateway$20150709$GetAuthorizerRequest, APIGateway$20150709$Authorizer>;
    getAuthorizers: $APIMethod<APIGateway$20150709$GetAuthorizersRequest, APIGateway$20150709$Authorizers>;
    getBasePathMapping: $APIMethod<APIGateway$20150709$GetBasePathMappingRequest, APIGateway$20150709$BasePathMapping>;
    getBasePathMappings: $APIMethod<APIGateway$20150709$GetBasePathMappingsRequest, APIGateway$20150709$BasePathMappings>;
    getClientCertificate: $APIMethod<APIGateway$20150709$GetClientCertificateRequest, APIGateway$20150709$ClientCertificate>;
    getClientCertificates: $APIMethod<APIGateway$20150709$GetClientCertificatesRequest, APIGateway$20150709$ClientCertificates>;
    getDeployment: $APIMethod<APIGateway$20150709$GetDeploymentRequest, APIGateway$20150709$Deployment>;
    getDeployments: $APIMethod<APIGateway$20150709$GetDeploymentsRequest, APIGateway$20150709$Deployments>;
    getDomainName: $APIMethod<APIGateway$20150709$GetDomainNameRequest, APIGateway$20150709$DomainName>;
    getDomainNames: $APIMethod<APIGateway$20150709$GetDomainNamesRequest, APIGateway$20150709$DomainNames>;
    getExport: $APIMethod<APIGateway$20150709$GetExportRequest, APIGateway$20150709$ExportResponse>;
    getIntegration: $APIMethod<APIGateway$20150709$GetIntegrationRequest, APIGateway$20150709$Integration>;
    getIntegrationResponse: $APIMethod<APIGateway$20150709$GetIntegrationResponseRequest, APIGateway$20150709$IntegrationResponse>;
    getMethod: $APIMethod<APIGateway$20150709$GetMethodRequest, APIGateway$20150709$Method>;
    getMethodResponse: $APIMethod<APIGateway$20150709$GetMethodResponseRequest, APIGateway$20150709$MethodResponse>;
    getModel: $APIMethod<APIGateway$20150709$GetModelRequest, APIGateway$20150709$Model>;
    getModelTemplate: $APIMethod<APIGateway$20150709$GetModelTemplateRequest, APIGateway$20150709$Template>;
    getModels: $APIMethod<APIGateway$20150709$GetModelsRequest, APIGateway$20150709$Models>;
    getResource: $APIMethod<APIGateway$20150709$GetResourceRequest, APIGateway$20150709$Resource>;
    getResources: $APIMethod<APIGateway$20150709$GetResourcesRequest, APIGateway$20150709$Resources>;
    getRestApi: $APIMethod<APIGateway$20150709$GetRestApiRequest, APIGateway$20150709$RestApi>;
    getRestApis: $APIMethod<APIGateway$20150709$GetRestApisRequest, APIGateway$20150709$RestApis>;
    getSdk: $APIMethod<APIGateway$20150709$GetSdkRequest, APIGateway$20150709$SdkResponse>;
    getStage: $APIMethod<APIGateway$20150709$GetStageRequest, APIGateway$20150709$Stage>;
    getStages: $APIMethod<APIGateway$20150709$GetStagesRequest, APIGateway$20150709$Stages>;
    importRestApi: $APIMethod<APIGateway$20150709$ImportRestApiRequest, APIGateway$20150709$RestApi>;
    putIntegration: $APIMethod<APIGateway$20150709$PutIntegrationRequest, APIGateway$20150709$Integration>;
    putIntegrationResponse: $APIMethod<APIGateway$20150709$PutIntegrationResponseRequest, APIGateway$20150709$IntegrationResponse>;
    putMethod: $APIMethod<APIGateway$20150709$PutMethodRequest, APIGateway$20150709$Method>;
    putMethodResponse: $APIMethod<APIGateway$20150709$PutMethodResponseRequest, APIGateway$20150709$MethodResponse>;
    putRestApi: $APIMethod<APIGateway$20150709$PutRestApiRequest, APIGateway$20150709$RestApi>;
    testInvokeAuthorizer: $APIMethod<APIGateway$20150709$TestInvokeAuthorizerRequest, APIGateway$20150709$TestInvokeAuthorizerResponse>;
    testInvokeMethod: $APIMethod<APIGateway$20150709$TestInvokeMethodRequest, APIGateway$20150709$TestInvokeMethodResponse>;
    updateAccount: $APIMethod<APIGateway$20150709$UpdateAccountRequest, APIGateway$20150709$Account>;
    updateApiKey: $APIMethod<APIGateway$20150709$UpdateApiKeyRequest, APIGateway$20150709$ApiKey>;
    updateAuthorizer: $APIMethod<APIGateway$20150709$UpdateAuthorizerRequest, APIGateway$20150709$Authorizer>;
    updateBasePathMapping: $APIMethod<APIGateway$20150709$UpdateBasePathMappingRequest, APIGateway$20150709$BasePathMapping>;
    updateClientCertificate: $APIMethod<APIGateway$20150709$UpdateClientCertificateRequest, APIGateway$20150709$ClientCertificate>;
    updateDeployment: $APIMethod<APIGateway$20150709$UpdateDeploymentRequest, APIGateway$20150709$Deployment>;
    updateDomainName: $APIMethod<APIGateway$20150709$UpdateDomainNameRequest, APIGateway$20150709$DomainName>;
    updateIntegration: $APIMethod<APIGateway$20150709$UpdateIntegrationRequest, APIGateway$20150709$Integration>;
    updateIntegrationResponse: $APIMethod<APIGateway$20150709$UpdateIntegrationResponseRequest, APIGateway$20150709$IntegrationResponse>;
    updateMethod: $APIMethod<APIGateway$20150709$UpdateMethodRequest, APIGateway$20150709$Method>;
    updateMethodResponse: $APIMethod<APIGateway$20150709$UpdateMethodResponseRequest, APIGateway$20150709$MethodResponse>;
    updateModel: $APIMethod<APIGateway$20150709$UpdateModelRequest, APIGateway$20150709$Model>;
    updateResource: $APIMethod<APIGateway$20150709$UpdateResourceRequest, APIGateway$20150709$Resource>;
    updateRestApi: $APIMethod<APIGateway$20150709$UpdateRestApiRequest, APIGateway$20150709$RestApi>;
    updateStage: $APIMethod<APIGateway$20150709$UpdateStageRequest, APIGateway$20150709$Stage>;
  }
  declare class APIGateway {
    constructor(config: $ConfigOptions & {
      apiVersion: '2015-07-09';
    }): APIGateway$20150709;
    constructor(): APIGateway$20150709;
  }
  declare class ApplicationAutoScaling$20160206 {
    deleteScalingPolicy: $APIMethod<ApplicationAutoScaling$20160206$DeleteScalingPolicyRequest, ApplicationAutoScaling$20160206$DeleteScalingPolicyResponse>;
    deregisterScalableTarget: $APIMethod<ApplicationAutoScaling$20160206$DeregisterScalableTargetRequest, ApplicationAutoScaling$20160206$DeregisterScalableTargetResponse>;
    describeScalableTargets: $APIMethod<ApplicationAutoScaling$20160206$DescribeScalableTargetsRequest, ApplicationAutoScaling$20160206$DescribeScalableTargetsResponse>;
    describeScalingActivities: $APIMethod<ApplicationAutoScaling$20160206$DescribeScalingActivitiesRequest, ApplicationAutoScaling$20160206$DescribeScalingActivitiesResponse>;
    describeScalingPolicies: $APIMethod<ApplicationAutoScaling$20160206$DescribeScalingPoliciesRequest, ApplicationAutoScaling$20160206$DescribeScalingPoliciesResponse>;
    putScalingPolicy: $APIMethod<ApplicationAutoScaling$20160206$PutScalingPolicyRequest, ApplicationAutoScaling$20160206$PutScalingPolicyResponse>;
    registerScalableTarget: $APIMethod<ApplicationAutoScaling$20160206$RegisterScalableTargetRequest, ApplicationAutoScaling$20160206$RegisterScalableTargetResponse>;
  }
  declare class ApplicationAutoScaling {
    constructor(config: $ConfigOptions & {
      apiVersion: '2016-02-06';
    }): ApplicationAutoScaling$20160206;
    constructor(): ApplicationAutoScaling$20160206;
  }
  declare class AutoScaling$20110101 {
    attachInstances: $APIMethod<AutoScaling$20110101$AttachInstancesQuery, void>;
    attachLoadBalancerTargetGroups: $APIMethod<AutoScaling$20110101$AttachLoadBalancerTargetGroupsType, AutoScaling$20110101$AttachLoadBalancerTargetGroupsResultType>;
    attachLoadBalancers: $APIMethod<AutoScaling$20110101$AttachLoadBalancersType, AutoScaling$20110101$AttachLoadBalancersResultType>;
    completeLifecycleAction: $APIMethod<AutoScaling$20110101$CompleteLifecycleActionType, AutoScaling$20110101$CompleteLifecycleActionAnswer>;
    createAutoScalingGroup: $APIMethod<AutoScaling$20110101$CreateAutoScalingGroupType, void>;
    createLaunchConfiguration: $APIMethod<AutoScaling$20110101$CreateLaunchConfigurationType, void>;
    createOrUpdateTags: $APIMethod<AutoScaling$20110101$CreateOrUpdateTagsType, void>;
    deleteAutoScalingGroup: $APIMethod<AutoScaling$20110101$DeleteAutoScalingGroupType, void>;
    deleteLaunchConfiguration: $APIMethod<AutoScaling$20110101$LaunchConfigurationNameType, void>;
    deleteLifecycleHook: $APIMethod<AutoScaling$20110101$DeleteLifecycleHookType, AutoScaling$20110101$DeleteLifecycleHookAnswer>;
    deleteNotificationConfiguration: $APIMethod<AutoScaling$20110101$DeleteNotificationConfigurationType, void>;
    deletePolicy: $APIMethod<AutoScaling$20110101$DeletePolicyType, void>;
    deleteScheduledAction: $APIMethod<AutoScaling$20110101$DeleteScheduledActionType, void>;
    deleteTags: $APIMethod<AutoScaling$20110101$DeleteTagsType, void>;
    describeAccountLimits: $APIMethod<void, AutoScaling$20110101$DescribeAccountLimitsAnswer>;
    describeAdjustmentTypes: $APIMethod<void, AutoScaling$20110101$DescribeAdjustmentTypesAnswer>;
    describeAutoScalingGroups: $APIMethod<AutoScaling$20110101$AutoScalingGroupNamesType, AutoScaling$20110101$AutoScalingGroupsType>;
    describeAutoScalingInstances: $APIMethod<AutoScaling$20110101$DescribeAutoScalingInstancesType, AutoScaling$20110101$AutoScalingInstancesType>;
    describeAutoScalingNotificationTypes: $APIMethod<void, AutoScaling$20110101$DescribeAutoScalingNotificationTypesAnswer>;
    describeLaunchConfigurations: $APIMethod<AutoScaling$20110101$LaunchConfigurationNamesType, AutoScaling$20110101$LaunchConfigurationsType>;
    describeLifecycleHookTypes: $APIMethod<void, AutoScaling$20110101$DescribeLifecycleHookTypesAnswer>;
    describeLifecycleHooks: $APIMethod<AutoScaling$20110101$DescribeLifecycleHooksType, AutoScaling$20110101$DescribeLifecycleHooksAnswer>;
    describeLoadBalancerTargetGroups: $APIMethod<AutoScaling$20110101$DescribeLoadBalancerTargetGroupsRequest, AutoScaling$20110101$DescribeLoadBalancerTargetGroupsResponse>;
    describeLoadBalancers: $APIMethod<AutoScaling$20110101$DescribeLoadBalancersRequest, AutoScaling$20110101$DescribeLoadBalancersResponse>;
    describeMetricCollectionTypes: $APIMethod<void, AutoScaling$20110101$DescribeMetricCollectionTypesAnswer>;
    describeNotificationConfigurations: $APIMethod<AutoScaling$20110101$DescribeNotificationConfigurationsType, AutoScaling$20110101$DescribeNotificationConfigurationsAnswer>;
    describePolicies: $APIMethod<AutoScaling$20110101$DescribePoliciesType, AutoScaling$20110101$PoliciesType>;
    describeScalingActivities: $APIMethod<AutoScaling$20110101$DescribeScalingActivitiesType, AutoScaling$20110101$ActivitiesType>;
    describeScalingProcessTypes: $APIMethod<void, AutoScaling$20110101$ProcessesType>;
    describeScheduledActions: $APIMethod<AutoScaling$20110101$DescribeScheduledActionsType, AutoScaling$20110101$ScheduledActionsType>;
    describeTags: $APIMethod<AutoScaling$20110101$DescribeTagsType, AutoScaling$20110101$TagsType>;
    describeTerminationPolicyTypes: $APIMethod<void, AutoScaling$20110101$DescribeTerminationPolicyTypesAnswer>;
    detachInstances: $APIMethod<AutoScaling$20110101$DetachInstancesQuery, AutoScaling$20110101$DetachInstancesAnswer>;
    detachLoadBalancerTargetGroups: $APIMethod<AutoScaling$20110101$DetachLoadBalancerTargetGroupsType, AutoScaling$20110101$DetachLoadBalancerTargetGroupsResultType>;
    detachLoadBalancers: $APIMethod<AutoScaling$20110101$DetachLoadBalancersType, AutoScaling$20110101$DetachLoadBalancersResultType>;
    disableMetricsCollection: $APIMethod<AutoScaling$20110101$DisableMetricsCollectionQuery, void>;
    enableMetricsCollection: $APIMethod<AutoScaling$20110101$EnableMetricsCollectionQuery, void>;
    enterStandby: $APIMethod<AutoScaling$20110101$EnterStandbyQuery, AutoScaling$20110101$EnterStandbyAnswer>;
    executePolicy: $APIMethod<AutoScaling$20110101$ExecutePolicyType, void>;
    exitStandby: $APIMethod<AutoScaling$20110101$ExitStandbyQuery, AutoScaling$20110101$ExitStandbyAnswer>;
    putLifecycleHook: $APIMethod<AutoScaling$20110101$PutLifecycleHookType, AutoScaling$20110101$PutLifecycleHookAnswer>;
    putNotificationConfiguration: $APIMethod<AutoScaling$20110101$PutNotificationConfigurationType, void>;
    putScalingPolicy: $APIMethod<AutoScaling$20110101$PutScalingPolicyType, AutoScaling$20110101$PolicyARNType>;
    putScheduledUpdateGroupAction: $APIMethod<AutoScaling$20110101$PutScheduledUpdateGroupActionType, void>;
    recordLifecycleActionHeartbeat: $APIMethod<AutoScaling$20110101$RecordLifecycleActionHeartbeatType, AutoScaling$20110101$RecordLifecycleActionHeartbeatAnswer>;
    resumeProcesses: $APIMethod<AutoScaling$20110101$ScalingProcessQuery, void>;
    setDesiredCapacity: $APIMethod<AutoScaling$20110101$SetDesiredCapacityType, void>;
    setInstanceHealth: $APIMethod<AutoScaling$20110101$SetInstanceHealthQuery, void>;
    setInstanceProtection: $APIMethod<AutoScaling$20110101$SetInstanceProtectionQuery, AutoScaling$20110101$SetInstanceProtectionAnswer>;
    suspendProcesses: $APIMethod<AutoScaling$20110101$ScalingProcessQuery, void>;
    terminateInstanceInAutoScalingGroup: $APIMethod<AutoScaling$20110101$TerminateInstanceInAutoScalingGroupType, AutoScaling$20110101$ActivityType>;
    updateAutoScalingGroup: $APIMethod<AutoScaling$20110101$UpdateAutoScalingGroupType, void>;
  }
  declare class AutoScaling {
    constructor(config: $ConfigOptions & {
      apiVersion: '2011-01-01';
    }): AutoScaling$20110101;
    constructor(): AutoScaling$20110101;
  }
  declare class CloudFormation$20100515 {
    cancelUpdateStack: $APIMethod<CloudFormation$20100515$CancelUpdateStackInput, void>;
    continueUpdateRollback: $APIMethod<CloudFormation$20100515$ContinueUpdateRollbackInput, CloudFormation$20100515$ContinueUpdateRollbackOutput>;
    createChangeSet: $APIMethod<CloudFormation$20100515$CreateChangeSetInput, CloudFormation$20100515$CreateChangeSetOutput>;
    createStack: $APIMethod<CloudFormation$20100515$CreateStackInput, CloudFormation$20100515$CreateStackOutput>;
    deleteChangeSet: $APIMethod<CloudFormation$20100515$DeleteChangeSetInput, CloudFormation$20100515$DeleteChangeSetOutput>;
    deleteStack: $APIMethod<CloudFormation$20100515$DeleteStackInput, void>;
    describeAccountLimits: $APIMethod<CloudFormation$20100515$DescribeAccountLimitsInput, CloudFormation$20100515$DescribeAccountLimitsOutput>;
    describeChangeSet: $APIMethod<CloudFormation$20100515$DescribeChangeSetInput, CloudFormation$20100515$DescribeChangeSetOutput>;
    describeStackEvents: $APIMethod<CloudFormation$20100515$DescribeStackEventsInput, CloudFormation$20100515$DescribeStackEventsOutput>;
    describeStackResource: $APIMethod<CloudFormation$20100515$DescribeStackResourceInput, CloudFormation$20100515$DescribeStackResourceOutput>;
    describeStackResources: $APIMethod<CloudFormation$20100515$DescribeStackResourcesInput, CloudFormation$20100515$DescribeStackResourcesOutput>;
    describeStacks: $APIMethod<CloudFormation$20100515$DescribeStacksInput, CloudFormation$20100515$DescribeStacksOutput>;
    estimateTemplateCost: $APIMethod<CloudFormation$20100515$EstimateTemplateCostInput, CloudFormation$20100515$EstimateTemplateCostOutput>;
    executeChangeSet: $APIMethod<CloudFormation$20100515$ExecuteChangeSetInput, CloudFormation$20100515$ExecuteChangeSetOutput>;
    getStackPolicy: $APIMethod<CloudFormation$20100515$GetStackPolicyInput, CloudFormation$20100515$GetStackPolicyOutput>;
    getTemplate: $APIMethod<CloudFormation$20100515$GetTemplateInput, CloudFormation$20100515$GetTemplateOutput>;
    getTemplateSummary: $APIMethod<CloudFormation$20100515$GetTemplateSummaryInput, CloudFormation$20100515$GetTemplateSummaryOutput>;
    listChangeSets: $APIMethod<CloudFormation$20100515$ListChangeSetsInput, CloudFormation$20100515$ListChangeSetsOutput>;
    listStackResources: $APIMethod<CloudFormation$20100515$ListStackResourcesInput, CloudFormation$20100515$ListStackResourcesOutput>;
    listStacks: $APIMethod<CloudFormation$20100515$ListStacksInput, CloudFormation$20100515$ListStacksOutput>;
    setStackPolicy: $APIMethod<CloudFormation$20100515$SetStackPolicyInput, void>;
    signalResource: $APIMethod<CloudFormation$20100515$SignalResourceInput, void>;
    updateStack: $APIMethod<CloudFormation$20100515$UpdateStackInput, CloudFormation$20100515$UpdateStackOutput>;
    validateTemplate: $APIMethod<CloudFormation$20100515$ValidateTemplateInput, CloudFormation$20100515$ValidateTemplateOutput>;
  }
  declare class CloudFormation {
    constructor(config: $ConfigOptions & {
      apiVersion: '2010-05-15';
    }): CloudFormation$20100515;
    constructor(): CloudFormation$20100515;
  }
  declare class CloudFront$20160801 {
    createCloudFrontOriginAccessIdentity: $APIMethod<CloudFront$20160801$CreateCloudFrontOriginAccessIdentityRequest, CloudFront$20160801$CreateCloudFrontOriginAccessIdentityResult>;
    createDistribution: $APIMethod<CloudFront$20160801$CreateDistributionRequest, CloudFront$20160801$CreateDistributionResult>;
    createDistributionWithTags: $APIMethod<CloudFront$20160801$CreateDistributionWithTagsRequest, CloudFront$20160801$CreateDistributionWithTagsResult>;
    createInvalidation: $APIMethod<CloudFront$20160801$CreateInvalidationRequest, CloudFront$20160801$CreateInvalidationResult>;
    createStreamingDistribution: $APIMethod<CloudFront$20160801$CreateStreamingDistributionRequest, CloudFront$20160801$CreateStreamingDistributionResult>;
    createStreamingDistributionWithTags: $APIMethod<CloudFront$20160801$CreateStreamingDistributionWithTagsRequest, CloudFront$20160801$CreateStreamingDistributionWithTagsResult>;
    deleteCloudFrontOriginAccessIdentity: $APIMethod<CloudFront$20160801$DeleteCloudFrontOriginAccessIdentityRequest, void>;
    deleteDistribution: $APIMethod<CloudFront$20160801$DeleteDistributionRequest, void>;
    deleteStreamingDistribution: $APIMethod<CloudFront$20160801$DeleteStreamingDistributionRequest, void>;
    getCloudFrontOriginAccessIdentity: $APIMethod<CloudFront$20160801$GetCloudFrontOriginAccessIdentityRequest, CloudFront$20160801$GetCloudFrontOriginAccessIdentityResult>;
    getCloudFrontOriginAccessIdentityConfig: $APIMethod<CloudFront$20160801$GetCloudFrontOriginAccessIdentityConfigRequest, CloudFront$20160801$GetCloudFrontOriginAccessIdentityConfigResult>;
    getDistribution: $APIMethod<CloudFront$20160801$GetDistributionRequest, CloudFront$20160801$GetDistributionResult>;
    getDistributionConfig: $APIMethod<CloudFront$20160801$GetDistributionConfigRequest, CloudFront$20160801$GetDistributionConfigResult>;
    getInvalidation: $APIMethod<CloudFront$20160801$GetInvalidationRequest, CloudFront$20160801$GetInvalidationResult>;
    getStreamingDistribution: $APIMethod<CloudFront$20160801$GetStreamingDistributionRequest, CloudFront$20160801$GetStreamingDistributionResult>;
    getStreamingDistributionConfig: $APIMethod<CloudFront$20160801$GetStreamingDistributionConfigRequest, CloudFront$20160801$GetStreamingDistributionConfigResult>;
    listCloudFrontOriginAccessIdentities: $APIMethod<CloudFront$20160801$ListCloudFrontOriginAccessIdentitiesRequest, CloudFront$20160801$ListCloudFrontOriginAccessIdentitiesResult>;
    listDistributions: $APIMethod<CloudFront$20160801$ListDistributionsRequest, CloudFront$20160801$ListDistributionsResult>;
    listDistributionsByWebACLId: $APIMethod<CloudFront$20160801$ListDistributionsByWebACLIdRequest, CloudFront$20160801$ListDistributionsByWebACLIdResult>;
    listInvalidations: $APIMethod<CloudFront$20160801$ListInvalidationsRequest, CloudFront$20160801$ListInvalidationsResult>;
    listStreamingDistributions: $APIMethod<CloudFront$20160801$ListStreamingDistributionsRequest, CloudFront$20160801$ListStreamingDistributionsResult>;
    listTagsForResource: $APIMethod<CloudFront$20160801$ListTagsForResourceRequest, CloudFront$20160801$ListTagsForResourceResult>;
    tagResource: $APIMethod<CloudFront$20160801$TagResourceRequest, void>;
    untagResource: $APIMethod<CloudFront$20160801$UntagResourceRequest, void>;
    updateCloudFrontOriginAccessIdentity: $APIMethod<CloudFront$20160801$UpdateCloudFrontOriginAccessIdentityRequest, CloudFront$20160801$UpdateCloudFrontOriginAccessIdentityResult>;
    updateDistribution: $APIMethod<CloudFront$20160801$UpdateDistributionRequest, CloudFront$20160801$UpdateDistributionResult>;
    updateStreamingDistribution: $APIMethod<CloudFront$20160801$UpdateStreamingDistributionRequest, CloudFront$20160801$UpdateStreamingDistributionResult>;
  }
  declare class CloudFront {
    constructor(config: $ConfigOptions & {
      apiVersion: '2016-08-01';
    }): CloudFront$20160801;
    constructor(): CloudFront$20160801;
  }
  declare class CloudHSM$20140530 {
    addTagsToResource: $APIMethod<CloudHSM$20140530$AddTagsToResourceRequest, CloudHSM$20140530$AddTagsToResourceResponse>;
    createHapg: $APIMethod<CloudHSM$20140530$CreateHapgRequest, CloudHSM$20140530$CreateHapgResponse>;
    createHsm: $APIMethod<CloudHSM$20140530$CreateHsmRequest, CloudHSM$20140530$CreateHsmResponse>;
    createLunaClient: $APIMethod<CloudHSM$20140530$CreateLunaClientRequest, CloudHSM$20140530$CreateLunaClientResponse>;
    deleteHapg: $APIMethod<CloudHSM$20140530$DeleteHapgRequest, CloudHSM$20140530$DeleteHapgResponse>;
    deleteHsm: $APIMethod<CloudHSM$20140530$DeleteHsmRequest, CloudHSM$20140530$DeleteHsmResponse>;
    deleteLunaClient: $APIMethod<CloudHSM$20140530$DeleteLunaClientRequest, CloudHSM$20140530$DeleteLunaClientResponse>;
    describeHapg: $APIMethod<CloudHSM$20140530$DescribeHapgRequest, CloudHSM$20140530$DescribeHapgResponse>;
    describeHsm: $APIMethod<CloudHSM$20140530$DescribeHsmRequest, CloudHSM$20140530$DescribeHsmResponse>;
    describeLunaClient: $APIMethod<CloudHSM$20140530$DescribeLunaClientRequest, CloudHSM$20140530$DescribeLunaClientResponse>;
    getConfig: $APIMethod<CloudHSM$20140530$GetConfigRequest, CloudHSM$20140530$GetConfigResponse>;
    listAvailableZones: $APIMethod<CloudHSM$20140530$ListAvailableZonesRequest, CloudHSM$20140530$ListAvailableZonesResponse>;
    listHapgs: $APIMethod<CloudHSM$20140530$ListHapgsRequest, CloudHSM$20140530$ListHapgsResponse>;
    listHsms: $APIMethod<CloudHSM$20140530$ListHsmsRequest, CloudHSM$20140530$ListHsmsResponse>;
    listLunaClients: $APIMethod<CloudHSM$20140530$ListLunaClientsRequest, CloudHSM$20140530$ListLunaClientsResponse>;
    listTagsForResource: $APIMethod<CloudHSM$20140530$ListTagsForResourceRequest, CloudHSM$20140530$ListTagsForResourceResponse>;
    modifyHapg: $APIMethod<CloudHSM$20140530$ModifyHapgRequest, CloudHSM$20140530$ModifyHapgResponse>;
    modifyHsm: $APIMethod<CloudHSM$20140530$ModifyHsmRequest, CloudHSM$20140530$ModifyHsmResponse>;
    modifyLunaClient: $APIMethod<CloudHSM$20140530$ModifyLunaClientRequest, CloudHSM$20140530$ModifyLunaClientResponse>;
    removeTagsFromResource: $APIMethod<CloudHSM$20140530$RemoveTagsFromResourceRequest, CloudHSM$20140530$RemoveTagsFromResourceResponse>;
  }
  declare class CloudHSM {
    constructor(config: $ConfigOptions & {
      apiVersion: '2014-05-30';
    }): CloudHSM$20140530;
    constructor(): CloudHSM$20140530;
  }
  declare class CloudSearch$20110201 {
    createDomain: $APIMethod<CloudSearch$20110201$CreateDomainRequest, CloudSearch$20110201$CreateDomainResponse>;
    defineIndexField: $APIMethod<CloudSearch$20110201$DefineIndexFieldRequest, CloudSearch$20110201$DefineIndexFieldResponse>;
    defineRankExpression: $APIMethod<CloudSearch$20110201$DefineRankExpressionRequest, CloudSearch$20110201$DefineRankExpressionResponse>;
    deleteDomain: $APIMethod<CloudSearch$20110201$DeleteDomainRequest, CloudSearch$20110201$DeleteDomainResponse>;
    deleteIndexField: $APIMethod<CloudSearch$20110201$DeleteIndexFieldRequest, CloudSearch$20110201$DeleteIndexFieldResponse>;
    deleteRankExpression: $APIMethod<CloudSearch$20110201$DeleteRankExpressionRequest, CloudSearch$20110201$DeleteRankExpressionResponse>;
    describeAvailabilityOptions: $APIMethod<CloudSearch$20110201$DescribeAvailabilityOptionsRequest, CloudSearch$20110201$DescribeAvailabilityOptionsResponse>;
    describeDefaultSearchField: $APIMethod<CloudSearch$20110201$DescribeDefaultSearchFieldRequest, CloudSearch$20110201$DescribeDefaultSearchFieldResponse>;
    describeDomains: $APIMethod<CloudSearch$20110201$DescribeDomainsRequest, CloudSearch$20110201$DescribeDomainsResponse>;
    describeIndexFields: $APIMethod<CloudSearch$20110201$DescribeIndexFieldsRequest, CloudSearch$20110201$DescribeIndexFieldsResponse>;
    describeRankExpressions: $APIMethod<CloudSearch$20110201$DescribeRankExpressionsRequest, CloudSearch$20110201$DescribeRankExpressionsResponse>;
    describeServiceAccessPolicies: $APIMethod<CloudSearch$20110201$DescribeServiceAccessPoliciesRequest, CloudSearch$20110201$DescribeServiceAccessPoliciesResponse>;
    describeStemmingOptions: $APIMethod<CloudSearch$20110201$DescribeStemmingOptionsRequest, CloudSearch$20110201$DescribeStemmingOptionsResponse>;
    describeStopwordOptions: $APIMethod<CloudSearch$20110201$DescribeStopwordOptionsRequest, CloudSearch$20110201$DescribeStopwordOptionsResponse>;
    describeSynonymOptions: $APIMethod<CloudSearch$20110201$DescribeSynonymOptionsRequest, CloudSearch$20110201$DescribeSynonymOptionsResponse>;
    indexDocuments: $APIMethod<CloudSearch$20110201$IndexDocumentsRequest, CloudSearch$20110201$IndexDocumentsResponse>;
    updateAvailabilityOptions: $APIMethod<CloudSearch$20110201$UpdateAvailabilityOptionsRequest, CloudSearch$20110201$UpdateAvailabilityOptionsResponse>;
    updateDefaultSearchField: $APIMethod<CloudSearch$20110201$UpdateDefaultSearchFieldRequest, CloudSearch$20110201$UpdateDefaultSearchFieldResponse>;
    updateServiceAccessPolicies: $APIMethod<CloudSearch$20110201$UpdateServiceAccessPoliciesRequest, CloudSearch$20110201$UpdateServiceAccessPoliciesResponse>;
    updateStemmingOptions: $APIMethod<CloudSearch$20110201$UpdateStemmingOptionsRequest, CloudSearch$20110201$UpdateStemmingOptionsResponse>;
    updateStopwordOptions: $APIMethod<CloudSearch$20110201$UpdateStopwordOptionsRequest, CloudSearch$20110201$UpdateStopwordOptionsResponse>;
    updateSynonymOptions: $APIMethod<CloudSearch$20110201$UpdateSynonymOptionsRequest, CloudSearch$20110201$UpdateSynonymOptionsResponse>;
  }
  declare class CloudSearch$20130101 {
    buildSuggesters: $APIMethod<CloudSearch$20130101$BuildSuggestersRequest, CloudSearch$20130101$BuildSuggestersResponse>;
    createDomain: $APIMethod<CloudSearch$20130101$CreateDomainRequest, CloudSearch$20130101$CreateDomainResponse>;
    defineAnalysisScheme: $APIMethod<CloudSearch$20130101$DefineAnalysisSchemeRequest, CloudSearch$20130101$DefineAnalysisSchemeResponse>;
    defineExpression: $APIMethod<CloudSearch$20130101$DefineExpressionRequest, CloudSearch$20130101$DefineExpressionResponse>;
    defineIndexField: $APIMethod<CloudSearch$20130101$DefineIndexFieldRequest, CloudSearch$20130101$DefineIndexFieldResponse>;
    defineSuggester: $APIMethod<CloudSearch$20130101$DefineSuggesterRequest, CloudSearch$20130101$DefineSuggesterResponse>;
    deleteAnalysisScheme: $APIMethod<CloudSearch$20130101$DeleteAnalysisSchemeRequest, CloudSearch$20130101$DeleteAnalysisSchemeResponse>;
    deleteDomain: $APIMethod<CloudSearch$20130101$DeleteDomainRequest, CloudSearch$20130101$DeleteDomainResponse>;
    deleteExpression: $APIMethod<CloudSearch$20130101$DeleteExpressionRequest, CloudSearch$20130101$DeleteExpressionResponse>;
    deleteIndexField: $APIMethod<CloudSearch$20130101$DeleteIndexFieldRequest, CloudSearch$20130101$DeleteIndexFieldResponse>;
    deleteSuggester: $APIMethod<CloudSearch$20130101$DeleteSuggesterRequest, CloudSearch$20130101$DeleteSuggesterResponse>;
    describeAnalysisSchemes: $APIMethod<CloudSearch$20130101$DescribeAnalysisSchemesRequest, CloudSearch$20130101$DescribeAnalysisSchemesResponse>;
    describeAvailabilityOptions: $APIMethod<CloudSearch$20130101$DescribeAvailabilityOptionsRequest, CloudSearch$20130101$DescribeAvailabilityOptionsResponse>;
    describeDomains: $APIMethod<CloudSearch$20130101$DescribeDomainsRequest, CloudSearch$20130101$DescribeDomainsResponse>;
    describeExpressions: $APIMethod<CloudSearch$20130101$DescribeExpressionsRequest, CloudSearch$20130101$DescribeExpressionsResponse>;
    describeIndexFields: $APIMethod<CloudSearch$20130101$DescribeIndexFieldsRequest, CloudSearch$20130101$DescribeIndexFieldsResponse>;
    describeScalingParameters: $APIMethod<CloudSearch$20130101$DescribeScalingParametersRequest, CloudSearch$20130101$DescribeScalingParametersResponse>;
    describeServiceAccessPolicies: $APIMethod<CloudSearch$20130101$DescribeServiceAccessPoliciesRequest, CloudSearch$20130101$DescribeServiceAccessPoliciesResponse>;
    describeSuggesters: $APIMethod<CloudSearch$20130101$DescribeSuggestersRequest, CloudSearch$20130101$DescribeSuggestersResponse>;
    indexDocuments: $APIMethod<CloudSearch$20130101$IndexDocumentsRequest, CloudSearch$20130101$IndexDocumentsResponse>;
    listDomainNames: $APIMethod<void, CloudSearch$20130101$ListDomainNamesResponse>;
    updateAvailabilityOptions: $APIMethod<CloudSearch$20130101$UpdateAvailabilityOptionsRequest, CloudSearch$20130101$UpdateAvailabilityOptionsResponse>;
    updateScalingParameters: $APIMethod<CloudSearch$20130101$UpdateScalingParametersRequest, CloudSearch$20130101$UpdateScalingParametersResponse>;
    updateServiceAccessPolicies: $APIMethod<CloudSearch$20130101$UpdateServiceAccessPoliciesRequest, CloudSearch$20130101$UpdateServiceAccessPoliciesResponse>;
  }
  declare class CloudSearch {
    constructor(config: $ConfigOptions & {
      apiVersion: '2011-02-01';
    }): CloudSearch$20110201;
    constructor(config: $ConfigOptions & {
      apiVersion: '2013-01-01';
    }): CloudSearch$20130101;
    constructor(): CloudSearch$20130101;
  }
  declare class CloudSearchDomain$20130101 {
    search: $APIMethod<CloudSearchDomain$20130101$SearchRequest, CloudSearchDomain$20130101$SearchResponse>;
    suggest: $APIMethod<CloudSearchDomain$20130101$SuggestRequest, CloudSearchDomain$20130101$SuggestResponse>;
    uploadDocuments: $APIMethod<CloudSearchDomain$20130101$UploadDocumentsRequest, CloudSearchDomain$20130101$UploadDocumentsResponse>;
  }
  declare class CloudSearchDomain {
    constructor(config: $ConfigOptions & {
      apiVersion: '2013-01-01';
    }): CloudSearchDomain$20130101;
    constructor(): CloudSearchDomain$20130101;
  }
  declare class CloudTrail$20131101 {
    addTags: $APIMethod<CloudTrail$20131101$AddTagsRequest, CloudTrail$20131101$AddTagsResponse>;
    createTrail: $APIMethod<CloudTrail$20131101$CreateTrailRequest, CloudTrail$20131101$CreateTrailResponse>;
    deleteTrail: $APIMethod<CloudTrail$20131101$DeleteTrailRequest, CloudTrail$20131101$DeleteTrailResponse>;
    describeTrails: $APIMethod<CloudTrail$20131101$DescribeTrailsRequest, CloudTrail$20131101$DescribeTrailsResponse>;
    getTrailStatus: $APIMethod<CloudTrail$20131101$GetTrailStatusRequest, CloudTrail$20131101$GetTrailStatusResponse>;
    listPublicKeys: $APIMethod<CloudTrail$20131101$ListPublicKeysRequest, CloudTrail$20131101$ListPublicKeysResponse>;
    listTags: $APIMethod<CloudTrail$20131101$ListTagsRequest, CloudTrail$20131101$ListTagsResponse>;
    lookupEvents: $APIMethod<CloudTrail$20131101$LookupEventsRequest, CloudTrail$20131101$LookupEventsResponse>;
    removeTags: $APIMethod<CloudTrail$20131101$RemoveTagsRequest, CloudTrail$20131101$RemoveTagsResponse>;
    startLogging: $APIMethod<CloudTrail$20131101$StartLoggingRequest, CloudTrail$20131101$StartLoggingResponse>;
    stopLogging: $APIMethod<CloudTrail$20131101$StopLoggingRequest, CloudTrail$20131101$StopLoggingResponse>;
    updateTrail: $APIMethod<CloudTrail$20131101$UpdateTrailRequest, CloudTrail$20131101$UpdateTrailResponse>;
  }
  declare class CloudTrail {
    constructor(config: $ConfigOptions & {
      apiVersion: '2013-11-01';
    }): CloudTrail$20131101;
    constructor(): CloudTrail$20131101;
  }
  declare class CloudWatch$20100801 {
    deleteAlarms: $APIMethod<CloudWatch$20100801$DeleteAlarmsInput, void>;
    describeAlarmHistory: $APIMethod<CloudWatch$20100801$DescribeAlarmHistoryInput, CloudWatch$20100801$DescribeAlarmHistoryOutput>;
    describeAlarms: $APIMethod<CloudWatch$20100801$DescribeAlarmsInput, CloudWatch$20100801$DescribeAlarmsOutput>;
    describeAlarmsForMetric: $APIMethod<CloudWatch$20100801$DescribeAlarmsForMetricInput, CloudWatch$20100801$DescribeAlarmsForMetricOutput>;
    disableAlarmActions: $APIMethod<CloudWatch$20100801$DisableAlarmActionsInput, void>;
    enableAlarmActions: $APIMethod<CloudWatch$20100801$EnableAlarmActionsInput, void>;
    getMetricStatistics: $APIMethod<CloudWatch$20100801$GetMetricStatisticsInput, CloudWatch$20100801$GetMetricStatisticsOutput>;
    listMetrics: $APIMethod<CloudWatch$20100801$ListMetricsInput, CloudWatch$20100801$ListMetricsOutput>;
    putMetricAlarm: $APIMethod<CloudWatch$20100801$PutMetricAlarmInput, void>;
    putMetricData: $APIMethod<CloudWatch$20100801$PutMetricDataInput, void>;
    setAlarmState: $APIMethod<CloudWatch$20100801$SetAlarmStateInput, void>;
  }
  declare class CloudWatch {
    constructor(config: $ConfigOptions & {
      apiVersion: '2010-08-01';
    }): CloudWatch$20100801;
    constructor(): CloudWatch$20100801;
  }
  declare class CloudWatchEvents$20151007 {
    deleteRule: $APIMethod<CloudWatchEvents$20151007$DeleteRuleRequest, void>;
    describeRule: $APIMethod<CloudWatchEvents$20151007$DescribeRuleRequest, CloudWatchEvents$20151007$DescribeRuleResponse>;
    disableRule: $APIMethod<CloudWatchEvents$20151007$DisableRuleRequest, void>;
    enableRule: $APIMethod<CloudWatchEvents$20151007$EnableRuleRequest, void>;
    listRuleNamesByTarget: $APIMethod<CloudWatchEvents$20151007$ListRuleNamesByTargetRequest, CloudWatchEvents$20151007$ListRuleNamesByTargetResponse>;
    listRules: $APIMethod<CloudWatchEvents$20151007$ListRulesRequest, CloudWatchEvents$20151007$ListRulesResponse>;
    listTargetsByRule: $APIMethod<CloudWatchEvents$20151007$ListTargetsByRuleRequest, CloudWatchEvents$20151007$ListTargetsByRuleResponse>;
    putEvents: $APIMethod<CloudWatchEvents$20151007$PutEventsRequest, CloudWatchEvents$20151007$PutEventsResponse>;
    putRule: $APIMethod<CloudWatchEvents$20151007$PutRuleRequest, CloudWatchEvents$20151007$PutRuleResponse>;
    putTargets: $APIMethod<CloudWatchEvents$20151007$PutTargetsRequest, CloudWatchEvents$20151007$PutTargetsResponse>;
    removeTargets: $APIMethod<CloudWatchEvents$20151007$RemoveTargetsRequest, CloudWatchEvents$20151007$RemoveTargetsResponse>;
    testEventPattern: $APIMethod<CloudWatchEvents$20151007$TestEventPatternRequest, CloudWatchEvents$20151007$TestEventPatternResponse>;
  }
  declare class CloudWatchEvents {
    constructor(config: $ConfigOptions & {
      apiVersion: '2015-10-07';
    }): CloudWatchEvents$20151007;
    constructor(): CloudWatchEvents$20151007;
  }
  declare class CloudWatchLogs$20140328 {
    cancelExportTask: $APIMethod<CloudWatchLogs$20140328$CancelExportTaskRequest, void>;
    createExportTask: $APIMethod<CloudWatchLogs$20140328$CreateExportTaskRequest, CloudWatchLogs$20140328$CreateExportTaskResponse>;
    createLogGroup: $APIMethod<CloudWatchLogs$20140328$CreateLogGroupRequest, void>;
    createLogStream: $APIMethod<CloudWatchLogs$20140328$CreateLogStreamRequest, void>;
    deleteDestination: $APIMethod<CloudWatchLogs$20140328$DeleteDestinationRequest, void>;
    deleteLogGroup: $APIMethod<CloudWatchLogs$20140328$DeleteLogGroupRequest, void>;
    deleteLogStream: $APIMethod<CloudWatchLogs$20140328$DeleteLogStreamRequest, void>;
    deleteMetricFilter: $APIMethod<CloudWatchLogs$20140328$DeleteMetricFilterRequest, void>;
    deleteRetentionPolicy: $APIMethod<CloudWatchLogs$20140328$DeleteRetentionPolicyRequest, void>;
    deleteSubscriptionFilter: $APIMethod<CloudWatchLogs$20140328$DeleteSubscriptionFilterRequest, void>;
    describeDestinations: $APIMethod<CloudWatchLogs$20140328$DescribeDestinationsRequest, CloudWatchLogs$20140328$DescribeDestinationsResponse>;
    describeExportTasks: $APIMethod<CloudWatchLogs$20140328$DescribeExportTasksRequest, CloudWatchLogs$20140328$DescribeExportTasksResponse>;
    describeLogGroups: $APIMethod<CloudWatchLogs$20140328$DescribeLogGroupsRequest, CloudWatchLogs$20140328$DescribeLogGroupsResponse>;
    describeLogStreams: $APIMethod<CloudWatchLogs$20140328$DescribeLogStreamsRequest, CloudWatchLogs$20140328$DescribeLogStreamsResponse>;
    describeMetricFilters: $APIMethod<CloudWatchLogs$20140328$DescribeMetricFiltersRequest, CloudWatchLogs$20140328$DescribeMetricFiltersResponse>;
    describeSubscriptionFilters: $APIMethod<CloudWatchLogs$20140328$DescribeSubscriptionFiltersRequest, CloudWatchLogs$20140328$DescribeSubscriptionFiltersResponse>;
    filterLogEvents: $APIMethod<CloudWatchLogs$20140328$FilterLogEventsRequest, CloudWatchLogs$20140328$FilterLogEventsResponse>;
    getLogEvents: $APIMethod<CloudWatchLogs$20140328$GetLogEventsRequest, CloudWatchLogs$20140328$GetLogEventsResponse>;
    putDestination: $APIMethod<CloudWatchLogs$20140328$PutDestinationRequest, CloudWatchLogs$20140328$PutDestinationResponse>;
    putDestinationPolicy: $APIMethod<CloudWatchLogs$20140328$PutDestinationPolicyRequest, void>;
    putLogEvents: $APIMethod<CloudWatchLogs$20140328$PutLogEventsRequest, CloudWatchLogs$20140328$PutLogEventsResponse>;
    putMetricFilter: $APIMethod<CloudWatchLogs$20140328$PutMetricFilterRequest, void>;
    putRetentionPolicy: $APIMethod<CloudWatchLogs$20140328$PutRetentionPolicyRequest, void>;
    putSubscriptionFilter: $APIMethod<CloudWatchLogs$20140328$PutSubscriptionFilterRequest, void>;
    testMetricFilter: $APIMethod<CloudWatchLogs$20140328$TestMetricFilterRequest, CloudWatchLogs$20140328$TestMetricFilterResponse>;
  }
  declare class CloudWatchLogs {
    constructor(config: $ConfigOptions & {
      apiVersion: '2014-03-28';
    }): CloudWatchLogs$20140328;
    constructor(): CloudWatchLogs$20140328;
  }
  declare class CodeCommit$20150413 {
    batchGetRepositories: $APIMethod<CodeCommit$20150413$BatchGetRepositoriesInput, CodeCommit$20150413$BatchGetRepositoriesOutput>;
    createBranch: $APIMethod<CodeCommit$20150413$CreateBranchInput, void>;
    createRepository: $APIMethod<CodeCommit$20150413$CreateRepositoryInput, CodeCommit$20150413$CreateRepositoryOutput>;
    deleteRepository: $APIMethod<CodeCommit$20150413$DeleteRepositoryInput, CodeCommit$20150413$DeleteRepositoryOutput>;
    getBranch: $APIMethod<CodeCommit$20150413$GetBranchInput, CodeCommit$20150413$GetBranchOutput>;
    getCommit: $APIMethod<CodeCommit$20150413$GetCommitInput, CodeCommit$20150413$GetCommitOutput>;
    getRepository: $APIMethod<CodeCommit$20150413$GetRepositoryInput, CodeCommit$20150413$GetRepositoryOutput>;
    getRepositoryTriggers: $APIMethod<CodeCommit$20150413$GetRepositoryTriggersInput, CodeCommit$20150413$GetRepositoryTriggersOutput>;
    listBranches: $APIMethod<CodeCommit$20150413$ListBranchesInput, CodeCommit$20150413$ListBranchesOutput>;
    listRepositories: $APIMethod<CodeCommit$20150413$ListRepositoriesInput, CodeCommit$20150413$ListRepositoriesOutput>;
    putRepositoryTriggers: $APIMethod<CodeCommit$20150413$PutRepositoryTriggersInput, CodeCommit$20150413$PutRepositoryTriggersOutput>;
    testRepositoryTriggers: $APIMethod<CodeCommit$20150413$TestRepositoryTriggersInput, CodeCommit$20150413$TestRepositoryTriggersOutput>;
    updateDefaultBranch: $APIMethod<CodeCommit$20150413$UpdateDefaultBranchInput, void>;
    updateRepositoryDescription: $APIMethod<CodeCommit$20150413$UpdateRepositoryDescriptionInput, void>;
    updateRepositoryName: $APIMethod<CodeCommit$20150413$UpdateRepositoryNameInput, void>;
  }
  declare class CodeCommit {
    constructor(config: $ConfigOptions & {
      apiVersion: '2015-04-13';
    }): CodeCommit$20150413;
    constructor(): CodeCommit$20150413;
  }
  declare class CodeDeploy$20141006 {
    addTagsToOnPremisesInstances: $APIMethod<CodeDeploy$20141006$AddTagsToOnPremisesInstancesInput, void>;
    batchGetApplicationRevisions: $APIMethod<CodeDeploy$20141006$BatchGetApplicationRevisionsInput, CodeDeploy$20141006$BatchGetApplicationRevisionsOutput>;
    batchGetApplications: $APIMethod<CodeDeploy$20141006$BatchGetApplicationsInput, CodeDeploy$20141006$BatchGetApplicationsOutput>;
    batchGetDeploymentGroups: $APIMethod<CodeDeploy$20141006$BatchGetDeploymentGroupsInput, CodeDeploy$20141006$BatchGetDeploymentGroupsOutput>;
    batchGetDeploymentInstances: $APIMethod<CodeDeploy$20141006$BatchGetDeploymentInstancesInput, CodeDeploy$20141006$BatchGetDeploymentInstancesOutput>;
    batchGetDeployments: $APIMethod<CodeDeploy$20141006$BatchGetDeploymentsInput, CodeDeploy$20141006$BatchGetDeploymentsOutput>;
    batchGetOnPremisesInstances: $APIMethod<CodeDeploy$20141006$BatchGetOnPremisesInstancesInput, CodeDeploy$20141006$BatchGetOnPremisesInstancesOutput>;
    createApplication: $APIMethod<CodeDeploy$20141006$CreateApplicationInput, CodeDeploy$20141006$CreateApplicationOutput>;
    createDeployment: $APIMethod<CodeDeploy$20141006$CreateDeploymentInput, CodeDeploy$20141006$CreateDeploymentOutput>;
    createDeploymentConfig: $APIMethod<CodeDeploy$20141006$CreateDeploymentConfigInput, CodeDeploy$20141006$CreateDeploymentConfigOutput>;
    createDeploymentGroup: $APIMethod<CodeDeploy$20141006$CreateDeploymentGroupInput, CodeDeploy$20141006$CreateDeploymentGroupOutput>;
    deleteApplication: $APIMethod<CodeDeploy$20141006$DeleteApplicationInput, void>;
    deleteDeploymentConfig: $APIMethod<CodeDeploy$20141006$DeleteDeploymentConfigInput, void>;
    deleteDeploymentGroup: $APIMethod<CodeDeploy$20141006$DeleteDeploymentGroupInput, CodeDeploy$20141006$DeleteDeploymentGroupOutput>;
    deregisterOnPremisesInstance: $APIMethod<CodeDeploy$20141006$DeregisterOnPremisesInstanceInput, void>;
    getApplication: $APIMethod<CodeDeploy$20141006$GetApplicationInput, CodeDeploy$20141006$GetApplicationOutput>;
    getApplicationRevision: $APIMethod<CodeDeploy$20141006$GetApplicationRevisionInput, CodeDeploy$20141006$GetApplicationRevisionOutput>;
    getDeployment: $APIMethod<CodeDeploy$20141006$GetDeploymentInput, CodeDeploy$20141006$GetDeploymentOutput>;
    getDeploymentConfig: $APIMethod<CodeDeploy$20141006$GetDeploymentConfigInput, CodeDeploy$20141006$GetDeploymentConfigOutput>;
    getDeploymentGroup: $APIMethod<CodeDeploy$20141006$GetDeploymentGroupInput, CodeDeploy$20141006$GetDeploymentGroupOutput>;
    getDeploymentInstance: $APIMethod<CodeDeploy$20141006$GetDeploymentInstanceInput, CodeDeploy$20141006$GetDeploymentInstanceOutput>;
    getOnPremisesInstance: $APIMethod<CodeDeploy$20141006$GetOnPremisesInstanceInput, CodeDeploy$20141006$GetOnPremisesInstanceOutput>;
    listApplicationRevisions: $APIMethod<CodeDeploy$20141006$ListApplicationRevisionsInput, CodeDeploy$20141006$ListApplicationRevisionsOutput>;
    listApplications: $APIMethod<CodeDeploy$20141006$ListApplicationsInput, CodeDeploy$20141006$ListApplicationsOutput>;
    listDeploymentConfigs: $APIMethod<CodeDeploy$20141006$ListDeploymentConfigsInput, CodeDeploy$20141006$ListDeploymentConfigsOutput>;
    listDeploymentGroups: $APIMethod<CodeDeploy$20141006$ListDeploymentGroupsInput, CodeDeploy$20141006$ListDeploymentGroupsOutput>;
    listDeploymentInstances: $APIMethod<CodeDeploy$20141006$ListDeploymentInstancesInput, CodeDeploy$20141006$ListDeploymentInstancesOutput>;
    listDeployments: $APIMethod<CodeDeploy$20141006$ListDeploymentsInput, CodeDeploy$20141006$ListDeploymentsOutput>;
    listOnPremisesInstances: $APIMethod<CodeDeploy$20141006$ListOnPremisesInstancesInput, CodeDeploy$20141006$ListOnPremisesInstancesOutput>;
    registerApplicationRevision: $APIMethod<CodeDeploy$20141006$RegisterApplicationRevisionInput, void>;
    registerOnPremisesInstance: $APIMethod<CodeDeploy$20141006$RegisterOnPremisesInstanceInput, void>;
    removeTagsFromOnPremisesInstances: $APIMethod<CodeDeploy$20141006$RemoveTagsFromOnPremisesInstancesInput, void>;
    stopDeployment: $APIMethod<CodeDeploy$20141006$StopDeploymentInput, CodeDeploy$20141006$StopDeploymentOutput>;
    updateApplication: $APIMethod<CodeDeploy$20141006$UpdateApplicationInput, void>;
    updateDeploymentGroup: $APIMethod<CodeDeploy$20141006$UpdateDeploymentGroupInput, CodeDeploy$20141006$UpdateDeploymentGroupOutput>;
  }
  declare class CodeDeploy {
    constructor(config: $ConfigOptions & {
      apiVersion: '2014-10-06';
    }): CodeDeploy$20141006;
    constructor(): CodeDeploy$20141006;
  }
  declare class CodePipeline$20150709 {
    acknowledgeJob: $APIMethod<CodePipeline$20150709$AcknowledgeJobInput, CodePipeline$20150709$AcknowledgeJobOutput>;
    acknowledgeThirdPartyJob: $APIMethod<CodePipeline$20150709$AcknowledgeThirdPartyJobInput, CodePipeline$20150709$AcknowledgeThirdPartyJobOutput>;
    createCustomActionType: $APIMethod<CodePipeline$20150709$CreateCustomActionTypeInput, CodePipeline$20150709$CreateCustomActionTypeOutput>;
    createPipeline: $APIMethod<CodePipeline$20150709$CreatePipelineInput, CodePipeline$20150709$CreatePipelineOutput>;
    deleteCustomActionType: $APIMethod<CodePipeline$20150709$DeleteCustomActionTypeInput, void>;
    deletePipeline: $APIMethod<CodePipeline$20150709$DeletePipelineInput, void>;
    disableStageTransition: $APIMethod<CodePipeline$20150709$DisableStageTransitionInput, void>;
    enableStageTransition: $APIMethod<CodePipeline$20150709$EnableStageTransitionInput, void>;
    getJobDetails: $APIMethod<CodePipeline$20150709$GetJobDetailsInput, CodePipeline$20150709$GetJobDetailsOutput>;
    getPipeline: $APIMethod<CodePipeline$20150709$GetPipelineInput, CodePipeline$20150709$GetPipelineOutput>;
    getPipelineState: $APIMethod<CodePipeline$20150709$GetPipelineStateInput, CodePipeline$20150709$GetPipelineStateOutput>;
    getThirdPartyJobDetails: $APIMethod<CodePipeline$20150709$GetThirdPartyJobDetailsInput, CodePipeline$20150709$GetThirdPartyJobDetailsOutput>;
    listActionTypes: $APIMethod<CodePipeline$20150709$ListActionTypesInput, CodePipeline$20150709$ListActionTypesOutput>;
    listPipelines: $APIMethod<CodePipeline$20150709$ListPipelinesInput, CodePipeline$20150709$ListPipelinesOutput>;
    pollForJobs: $APIMethod<CodePipeline$20150709$PollForJobsInput, CodePipeline$20150709$PollForJobsOutput>;
    pollForThirdPartyJobs: $APIMethod<CodePipeline$20150709$PollForThirdPartyJobsInput, CodePipeline$20150709$PollForThirdPartyJobsOutput>;
    putActionRevision: $APIMethod<CodePipeline$20150709$PutActionRevisionInput, CodePipeline$20150709$PutActionRevisionOutput>;
    putApprovalResult: $APIMethod<CodePipeline$20150709$PutApprovalResultInput, CodePipeline$20150709$PutApprovalResultOutput>;
    putJobFailureResult: $APIMethod<CodePipeline$20150709$PutJobFailureResultInput, void>;
    putJobSuccessResult: $APIMethod<CodePipeline$20150709$PutJobSuccessResultInput, void>;
    putThirdPartyJobFailureResult: $APIMethod<CodePipeline$20150709$PutThirdPartyJobFailureResultInput, void>;
    putThirdPartyJobSuccessResult: $APIMethod<CodePipeline$20150709$PutThirdPartyJobSuccessResultInput, void>;
    retryStageExecution: $APIMethod<CodePipeline$20150709$RetryStageExecutionInput, CodePipeline$20150709$RetryStageExecutionOutput>;
    startPipelineExecution: $APIMethod<CodePipeline$20150709$StartPipelineExecutionInput, CodePipeline$20150709$StartPipelineExecutionOutput>;
    updatePipeline: $APIMethod<CodePipeline$20150709$UpdatePipelineInput, CodePipeline$20150709$UpdatePipelineOutput>;
  }
  declare class CodePipeline {
    constructor(config: $ConfigOptions & {
      apiVersion: '2015-07-09';
    }): CodePipeline$20150709;
    constructor(): CodePipeline$20150709;
  }
  declare class CognitoIdentity$20140630 {
    createIdentityPool: $APIMethod<CognitoIdentity$20140630$CreateIdentityPoolInput, CognitoIdentity$20140630$IdentityPool>;
    deleteIdentities: $APIMethod<CognitoIdentity$20140630$DeleteIdentitiesInput, CognitoIdentity$20140630$DeleteIdentitiesResponse>;
    deleteIdentityPool: $APIMethod<CognitoIdentity$20140630$DeleteIdentityPoolInput, void>;
    describeIdentity: $APIMethod<CognitoIdentity$20140630$DescribeIdentityInput, CognitoIdentity$20140630$IdentityDescription>;
    describeIdentityPool: $APIMethod<CognitoIdentity$20140630$DescribeIdentityPoolInput, CognitoIdentity$20140630$IdentityPool>;
    getCredentialsForIdentity: $APIMethod<CognitoIdentity$20140630$GetCredentialsForIdentityInput, CognitoIdentity$20140630$GetCredentialsForIdentityResponse>;
    getId: $APIMethod<CognitoIdentity$20140630$GetIdInput, CognitoIdentity$20140630$GetIdResponse>;
    getIdentityPoolRoles: $APIMethod<CognitoIdentity$20140630$GetIdentityPoolRolesInput, CognitoIdentity$20140630$GetIdentityPoolRolesResponse>;
    getOpenIdToken: $APIMethod<CognitoIdentity$20140630$GetOpenIdTokenInput, CognitoIdentity$20140630$GetOpenIdTokenResponse>;
    getOpenIdTokenForDeveloperIdentity: $APIMethod<CognitoIdentity$20140630$GetOpenIdTokenForDeveloperIdentityInput, CognitoIdentity$20140630$GetOpenIdTokenForDeveloperIdentityResponse>;
    listIdentities: $APIMethod<CognitoIdentity$20140630$ListIdentitiesInput, CognitoIdentity$20140630$ListIdentitiesResponse>;
    listIdentityPools: $APIMethod<CognitoIdentity$20140630$ListIdentityPoolsInput, CognitoIdentity$20140630$ListIdentityPoolsResponse>;
    lookupDeveloperIdentity: $APIMethod<CognitoIdentity$20140630$LookupDeveloperIdentityInput, CognitoIdentity$20140630$LookupDeveloperIdentityResponse>;
    mergeDeveloperIdentities: $APIMethod<CognitoIdentity$20140630$MergeDeveloperIdentitiesInput, CognitoIdentity$20140630$MergeDeveloperIdentitiesResponse>;
    setIdentityPoolRoles: $APIMethod<CognitoIdentity$20140630$SetIdentityPoolRolesInput, void>;
    unlinkDeveloperIdentity: $APIMethod<CognitoIdentity$20140630$UnlinkDeveloperIdentityInput, void>;
    unlinkIdentity: $APIMethod<CognitoIdentity$20140630$UnlinkIdentityInput, void>;
    updateIdentityPool: $APIMethod<CognitoIdentity$20140630$IdentityPool, CognitoIdentity$20140630$IdentityPool>;
  }
  declare class CognitoIdentity {
    constructor(config: $ConfigOptions & {
      apiVersion: '2014-06-30';
    }): CognitoIdentity$20140630;
    constructor(): CognitoIdentity$20140630;
  }
  declare class CognitoIdentityServiceProvider$20160418 {
    addCustomAttributes: $APIMethod<CognitoIdentityServiceProvider$20160418$AddCustomAttributesRequest, CognitoIdentityServiceProvider$20160418$AddCustomAttributesResponse>;
    adminConfirmSignUp: $APIMethod<CognitoIdentityServiceProvider$20160418$AdminConfirmSignUpRequest, CognitoIdentityServiceProvider$20160418$AdminConfirmSignUpResponse>;
    adminDeleteUser: $APIMethod<CognitoIdentityServiceProvider$20160418$AdminDeleteUserRequest, void>;
    adminDeleteUserAttributes: $APIMethod<CognitoIdentityServiceProvider$20160418$AdminDeleteUserAttributesRequest, CognitoIdentityServiceProvider$20160418$AdminDeleteUserAttributesResponse>;
    adminDisableUser: $APIMethod<CognitoIdentityServiceProvider$20160418$AdminDisableUserRequest, CognitoIdentityServiceProvider$20160418$AdminDisableUserResponse>;
    adminEnableUser: $APIMethod<CognitoIdentityServiceProvider$20160418$AdminEnableUserRequest, CognitoIdentityServiceProvider$20160418$AdminEnableUserResponse>;
    adminForgetDevice: $APIMethod<CognitoIdentityServiceProvider$20160418$AdminForgetDeviceRequest, void>;
    adminGetDevice: $APIMethod<CognitoIdentityServiceProvider$20160418$AdminGetDeviceRequest, CognitoIdentityServiceProvider$20160418$AdminGetDeviceResponse>;
    adminGetUser: $APIMethod<CognitoIdentityServiceProvider$20160418$AdminGetUserRequest, CognitoIdentityServiceProvider$20160418$AdminGetUserResponse>;
    adminInitiateAuth: $APIMethod<CognitoIdentityServiceProvider$20160418$AdminInitiateAuthRequest, CognitoIdentityServiceProvider$20160418$AdminInitiateAuthResponse>;
    adminListDevices: $APIMethod<CognitoIdentityServiceProvider$20160418$AdminListDevicesRequest, CognitoIdentityServiceProvider$20160418$AdminListDevicesResponse>;
    adminResetUserPassword: $APIMethod<CognitoIdentityServiceProvider$20160418$AdminResetUserPasswordRequest, CognitoIdentityServiceProvider$20160418$AdminResetUserPasswordResponse>;
    adminRespondToAuthChallenge: $APIMethod<CognitoIdentityServiceProvider$20160418$AdminRespondToAuthChallengeRequest, CognitoIdentityServiceProvider$20160418$AdminRespondToAuthChallengeResponse>;
    adminSetUserSettings: $APIMethod<CognitoIdentityServiceProvider$20160418$AdminSetUserSettingsRequest, CognitoIdentityServiceProvider$20160418$AdminSetUserSettingsResponse>;
    adminUpdateDeviceStatus: $APIMethod<CognitoIdentityServiceProvider$20160418$AdminUpdateDeviceStatusRequest, CognitoIdentityServiceProvider$20160418$AdminUpdateDeviceStatusResponse>;
    adminUpdateUserAttributes: $APIMethod<CognitoIdentityServiceProvider$20160418$AdminUpdateUserAttributesRequest, CognitoIdentityServiceProvider$20160418$AdminUpdateUserAttributesResponse>;
    adminUserGlobalSignOut: $APIMethod<CognitoIdentityServiceProvider$20160418$AdminUserGlobalSignOutRequest, CognitoIdentityServiceProvider$20160418$AdminUserGlobalSignOutResponse>;
    changePassword: $APIMethod<CognitoIdentityServiceProvider$20160418$ChangePasswordRequest, CognitoIdentityServiceProvider$20160418$ChangePasswordResponse>;
    confirmDevice: $APIMethod<CognitoIdentityServiceProvider$20160418$ConfirmDeviceRequest, CognitoIdentityServiceProvider$20160418$ConfirmDeviceResponse>;
    confirmForgotPassword: $APIMethod<CognitoIdentityServiceProvider$20160418$ConfirmForgotPasswordRequest, CognitoIdentityServiceProvider$20160418$ConfirmForgotPasswordResponse>;
    confirmSignUp: $APIMethod<CognitoIdentityServiceProvider$20160418$ConfirmSignUpRequest, CognitoIdentityServiceProvider$20160418$ConfirmSignUpResponse>;
    createUserPool: $APIMethod<CognitoIdentityServiceProvider$20160418$CreateUserPoolRequest, CognitoIdentityServiceProvider$20160418$CreateUserPoolResponse>;
    createUserPoolClient: $APIMethod<CognitoIdentityServiceProvider$20160418$CreateUserPoolClientRequest, CognitoIdentityServiceProvider$20160418$CreateUserPoolClientResponse>;
    deleteUser: $APIMethod<CognitoIdentityServiceProvider$20160418$DeleteUserRequest, void>;
    deleteUserAttributes: $APIMethod<CognitoIdentityServiceProvider$20160418$DeleteUserAttributesRequest, CognitoIdentityServiceProvider$20160418$DeleteUserAttributesResponse>;
    deleteUserPool: $APIMethod<CognitoIdentityServiceProvider$20160418$DeleteUserPoolRequest, void>;
    deleteUserPoolClient: $APIMethod<CognitoIdentityServiceProvider$20160418$DeleteUserPoolClientRequest, void>;
    describeUserPool: $APIMethod<CognitoIdentityServiceProvider$20160418$DescribeUserPoolRequest, CognitoIdentityServiceProvider$20160418$DescribeUserPoolResponse>;
    describeUserPoolClient: $APIMethod<CognitoIdentityServiceProvider$20160418$DescribeUserPoolClientRequest, CognitoIdentityServiceProvider$20160418$DescribeUserPoolClientResponse>;
    forgetDevice: $APIMethod<CognitoIdentityServiceProvider$20160418$ForgetDeviceRequest, void>;
    forgotPassword: $APIMethod<CognitoIdentityServiceProvider$20160418$ForgotPasswordRequest, CognitoIdentityServiceProvider$20160418$ForgotPasswordResponse>;
    getDevice: $APIMethod<CognitoIdentityServiceProvider$20160418$GetDeviceRequest, CognitoIdentityServiceProvider$20160418$GetDeviceResponse>;
    getUser: $APIMethod<CognitoIdentityServiceProvider$20160418$GetUserRequest, CognitoIdentityServiceProvider$20160418$GetUserResponse>;
    getUserAttributeVerificationCode: $APIMethod<CognitoIdentityServiceProvider$20160418$GetUserAttributeVerificationCodeRequest, CognitoIdentityServiceProvider$20160418$GetUserAttributeVerificationCodeResponse>;
    globalSignOut: $APIMethod<CognitoIdentityServiceProvider$20160418$GlobalSignOutRequest, CognitoIdentityServiceProvider$20160418$GlobalSignOutResponse>;
    initiateAuth: $APIMethod<CognitoIdentityServiceProvider$20160418$InitiateAuthRequest, CognitoIdentityServiceProvider$20160418$InitiateAuthResponse>;
    listDevices: $APIMethod<CognitoIdentityServiceProvider$20160418$ListDevicesRequest, CognitoIdentityServiceProvider$20160418$ListDevicesResponse>;
    listUserPoolClients: $APIMethod<CognitoIdentityServiceProvider$20160418$ListUserPoolClientsRequest, CognitoIdentityServiceProvider$20160418$ListUserPoolClientsResponse>;
    listUserPools: $APIMethod<CognitoIdentityServiceProvider$20160418$ListUserPoolsRequest, CognitoIdentityServiceProvider$20160418$ListUserPoolsResponse>;
    listUsers: $APIMethod<CognitoIdentityServiceProvider$20160418$ListUsersRequest, CognitoIdentityServiceProvider$20160418$ListUsersResponse>;
    resendConfirmationCode: $APIMethod<CognitoIdentityServiceProvider$20160418$ResendConfirmationCodeRequest, CognitoIdentityServiceProvider$20160418$ResendConfirmationCodeResponse>;
    respondToAuthChallenge: $APIMethod<CognitoIdentityServiceProvider$20160418$RespondToAuthChallengeRequest, CognitoIdentityServiceProvider$20160418$RespondToAuthChallengeResponse>;
    setUserSettings: $APIMethod<CognitoIdentityServiceProvider$20160418$SetUserSettingsRequest, CognitoIdentityServiceProvider$20160418$SetUserSettingsResponse>;
    signUp: $APIMethod<CognitoIdentityServiceProvider$20160418$SignUpRequest, CognitoIdentityServiceProvider$20160418$SignUpResponse>;
    updateDeviceStatus: $APIMethod<CognitoIdentityServiceProvider$20160418$UpdateDeviceStatusRequest, CognitoIdentityServiceProvider$20160418$UpdateDeviceStatusResponse>;
    updateUserAttributes: $APIMethod<CognitoIdentityServiceProvider$20160418$UpdateUserAttributesRequest, CognitoIdentityServiceProvider$20160418$UpdateUserAttributesResponse>;
    updateUserPool: $APIMethod<CognitoIdentityServiceProvider$20160418$UpdateUserPoolRequest, CognitoIdentityServiceProvider$20160418$UpdateUserPoolResponse>;
    updateUserPoolClient: $APIMethod<CognitoIdentityServiceProvider$20160418$UpdateUserPoolClientRequest, CognitoIdentityServiceProvider$20160418$UpdateUserPoolClientResponse>;
    verifyUserAttribute: $APIMethod<CognitoIdentityServiceProvider$20160418$VerifyUserAttributeRequest, CognitoIdentityServiceProvider$20160418$VerifyUserAttributeResponse>;
  }
  declare class CognitoIdentityServiceProvider {
    constructor(config: $ConfigOptions & {
      apiVersion: '2016-04-18';
    }): CognitoIdentityServiceProvider$20160418;
    constructor(): CognitoIdentityServiceProvider$20160418;
  }
  declare class CognitoSync$20140630 {
    bulkPublish: $APIMethod<CognitoSync$20140630$BulkPublishRequest, CognitoSync$20140630$BulkPublishResponse>;
    deleteDataset: $APIMethod<CognitoSync$20140630$DeleteDatasetRequest, CognitoSync$20140630$DeleteDatasetResponse>;
    describeDataset: $APIMethod<CognitoSync$20140630$DescribeDatasetRequest, CognitoSync$20140630$DescribeDatasetResponse>;
    describeIdentityPoolUsage: $APIMethod<CognitoSync$20140630$DescribeIdentityPoolUsageRequest, CognitoSync$20140630$DescribeIdentityPoolUsageResponse>;
    describeIdentityUsage: $APIMethod<CognitoSync$20140630$DescribeIdentityUsageRequest, CognitoSync$20140630$DescribeIdentityUsageResponse>;
    getBulkPublishDetails: $APIMethod<CognitoSync$20140630$GetBulkPublishDetailsRequest, CognitoSync$20140630$GetBulkPublishDetailsResponse>;
    getCognitoEvents: $APIMethod<CognitoSync$20140630$GetCognitoEventsRequest, CognitoSync$20140630$GetCognitoEventsResponse>;
    getIdentityPoolConfiguration: $APIMethod<CognitoSync$20140630$GetIdentityPoolConfigurationRequest, CognitoSync$20140630$GetIdentityPoolConfigurationResponse>;
    listDatasets: $APIMethod<CognitoSync$20140630$ListDatasetsRequest, CognitoSync$20140630$ListDatasetsResponse>;
    listIdentityPoolUsage: $APIMethod<CognitoSync$20140630$ListIdentityPoolUsageRequest, CognitoSync$20140630$ListIdentityPoolUsageResponse>;
    listRecords: $APIMethod<CognitoSync$20140630$ListRecordsRequest, CognitoSync$20140630$ListRecordsResponse>;
    registerDevice: $APIMethod<CognitoSync$20140630$RegisterDeviceRequest, CognitoSync$20140630$RegisterDeviceResponse>;
    setCognitoEvents: $APIMethod<CognitoSync$20140630$SetCognitoEventsRequest, void>;
    setIdentityPoolConfiguration: $APIMethod<CognitoSync$20140630$SetIdentityPoolConfigurationRequest, CognitoSync$20140630$SetIdentityPoolConfigurationResponse>;
    subscribeToDataset: $APIMethod<CognitoSync$20140630$SubscribeToDatasetRequest, CognitoSync$20140630$SubscribeToDatasetResponse>;
    unsubscribeFromDataset: $APIMethod<CognitoSync$20140630$UnsubscribeFromDatasetRequest, CognitoSync$20140630$UnsubscribeFromDatasetResponse>;
    updateRecords: $APIMethod<CognitoSync$20140630$UpdateRecordsRequest, CognitoSync$20140630$UpdateRecordsResponse>;
  }
  declare class CognitoSync {
    constructor(config: $ConfigOptions & {
      apiVersion: '2014-06-30';
    }): CognitoSync$20140630;
    constructor(): CognitoSync$20140630;
  }
  declare class ConfigService$20141112 {
    deleteConfigRule: $APIMethod<ConfigService$20141112$DeleteConfigRuleRequest, void>;
    deleteConfigurationRecorder: $APIMethod<ConfigService$20141112$DeleteConfigurationRecorderRequest, void>;
    deleteDeliveryChannel: $APIMethod<ConfigService$20141112$DeleteDeliveryChannelRequest, void>;
    deleteEvaluationResults: $APIMethod<ConfigService$20141112$DeleteEvaluationResultsRequest, ConfigService$20141112$DeleteEvaluationResultsResponse>;
    deliverConfigSnapshot: $APIMethod<ConfigService$20141112$DeliverConfigSnapshotRequest, ConfigService$20141112$DeliverConfigSnapshotResponse>;
    describeComplianceByConfigRule: $APIMethod<ConfigService$20141112$DescribeComplianceByConfigRuleRequest, ConfigService$20141112$DescribeComplianceByConfigRuleResponse>;
    describeComplianceByResource: $APIMethod<ConfigService$20141112$DescribeComplianceByResourceRequest, ConfigService$20141112$DescribeComplianceByResourceResponse>;
    describeConfigRuleEvaluationStatus: $APIMethod<ConfigService$20141112$DescribeConfigRuleEvaluationStatusRequest, ConfigService$20141112$DescribeConfigRuleEvaluationStatusResponse>;
    describeConfigRules: $APIMethod<ConfigService$20141112$DescribeConfigRulesRequest, ConfigService$20141112$DescribeConfigRulesResponse>;
    describeConfigurationRecorderStatus: $APIMethod<ConfigService$20141112$DescribeConfigurationRecorderStatusRequest, ConfigService$20141112$DescribeConfigurationRecorderStatusResponse>;
    describeConfigurationRecorders: $APIMethod<ConfigService$20141112$DescribeConfigurationRecordersRequest, ConfigService$20141112$DescribeConfigurationRecordersResponse>;
    describeDeliveryChannelStatus: $APIMethod<ConfigService$20141112$DescribeDeliveryChannelStatusRequest, ConfigService$20141112$DescribeDeliveryChannelStatusResponse>;
    describeDeliveryChannels: $APIMethod<ConfigService$20141112$DescribeDeliveryChannelsRequest, ConfigService$20141112$DescribeDeliveryChannelsResponse>;
    getComplianceDetailsByConfigRule: $APIMethod<ConfigService$20141112$GetComplianceDetailsByConfigRuleRequest, ConfigService$20141112$GetComplianceDetailsByConfigRuleResponse>;
    getComplianceDetailsByResource: $APIMethod<ConfigService$20141112$GetComplianceDetailsByResourceRequest, ConfigService$20141112$GetComplianceDetailsByResourceResponse>;
    getComplianceSummaryByConfigRule: $APIMethod<void, ConfigService$20141112$GetComplianceSummaryByConfigRuleResponse>;
    getComplianceSummaryByResourceType: $APIMethod<ConfigService$20141112$GetComplianceSummaryByResourceTypeRequest, ConfigService$20141112$GetComplianceSummaryByResourceTypeResponse>;
    getResourceConfigHistory: $APIMethod<ConfigService$20141112$GetResourceConfigHistoryRequest, ConfigService$20141112$GetResourceConfigHistoryResponse>;
    listDiscoveredResources: $APIMethod<ConfigService$20141112$ListDiscoveredResourcesRequest, ConfigService$20141112$ListDiscoveredResourcesResponse>;
    putConfigRule: $APIMethod<ConfigService$20141112$PutConfigRuleRequest, void>;
    putConfigurationRecorder: $APIMethod<ConfigService$20141112$PutConfigurationRecorderRequest, void>;
    putDeliveryChannel: $APIMethod<ConfigService$20141112$PutDeliveryChannelRequest, void>;
    putEvaluations: $APIMethod<ConfigService$20141112$PutEvaluationsRequest, ConfigService$20141112$PutEvaluationsResponse>;
    startConfigRulesEvaluation: $APIMethod<ConfigService$20141112$StartConfigRulesEvaluationRequest, ConfigService$20141112$StartConfigRulesEvaluationResponse>;
    startConfigurationRecorder: $APIMethod<ConfigService$20141112$StartConfigurationRecorderRequest, void>;
    stopConfigurationRecorder: $APIMethod<ConfigService$20141112$StopConfigurationRecorderRequest, void>;
  }
  declare class ConfigService {
    constructor(config: $ConfigOptions & {
      apiVersion: '2014-11-12';
    }): ConfigService$20141112;
    constructor(): ConfigService$20141112;
  }
  declare class DataPipeline$20121029 {
    activatePipeline: $APIMethod<DataPipeline$20121029$ActivatePipelineInput, DataPipeline$20121029$ActivatePipelineOutput>;
    addTags: $APIMethod<DataPipeline$20121029$AddTagsInput, DataPipeline$20121029$AddTagsOutput>;
    createPipeline: $APIMethod<DataPipeline$20121029$CreatePipelineInput, DataPipeline$20121029$CreatePipelineOutput>;
    deactivatePipeline: $APIMethod<DataPipeline$20121029$DeactivatePipelineInput, DataPipeline$20121029$DeactivatePipelineOutput>;
    deletePipeline: $APIMethod<DataPipeline$20121029$DeletePipelineInput, void>;
    describeObjects: $APIMethod<DataPipeline$20121029$DescribeObjectsInput, DataPipeline$20121029$DescribeObjectsOutput>;
    describePipelines: $APIMethod<DataPipeline$20121029$DescribePipelinesInput, DataPipeline$20121029$DescribePipelinesOutput>;
    evaluateExpression: $APIMethod<DataPipeline$20121029$EvaluateExpressionInput, DataPipeline$20121029$EvaluateExpressionOutput>;
    getPipelineDefinition: $APIMethod<DataPipeline$20121029$GetPipelineDefinitionInput, DataPipeline$20121029$GetPipelineDefinitionOutput>;
    listPipelines: $APIMethod<DataPipeline$20121029$ListPipelinesInput, DataPipeline$20121029$ListPipelinesOutput>;
    pollForTask: $APIMethod<DataPipeline$20121029$PollForTaskInput, DataPipeline$20121029$PollForTaskOutput>;
    putPipelineDefinition: $APIMethod<DataPipeline$20121029$PutPipelineDefinitionInput, DataPipeline$20121029$PutPipelineDefinitionOutput>;
    queryObjects: $APIMethod<DataPipeline$20121029$QueryObjectsInput, DataPipeline$20121029$QueryObjectsOutput>;
    removeTags: $APIMethod<DataPipeline$20121029$RemoveTagsInput, DataPipeline$20121029$RemoveTagsOutput>;
    reportTaskProgress: $APIMethod<DataPipeline$20121029$ReportTaskProgressInput, DataPipeline$20121029$ReportTaskProgressOutput>;
    reportTaskRunnerHeartbeat: $APIMethod<DataPipeline$20121029$ReportTaskRunnerHeartbeatInput, DataPipeline$20121029$ReportTaskRunnerHeartbeatOutput>;
    setStatus: $APIMethod<DataPipeline$20121029$SetStatusInput, void>;
    setTaskStatus: $APIMethod<DataPipeline$20121029$SetTaskStatusInput, DataPipeline$20121029$SetTaskStatusOutput>;
    validatePipelineDefinition: $APIMethod<DataPipeline$20121029$ValidatePipelineDefinitionInput, DataPipeline$20121029$ValidatePipelineDefinitionOutput>;
  }
  declare class DataPipeline {
    constructor(config: $ConfigOptions & {
      apiVersion: '2012-10-29';
    }): DataPipeline$20121029;
    constructor(): DataPipeline$20121029;
  }
  declare class DeviceFarm$20150623 {
    createDevicePool: $APIMethod<DeviceFarm$20150623$CreateDevicePoolRequest, DeviceFarm$20150623$CreateDevicePoolResult>;
    createProject: $APIMethod<DeviceFarm$20150623$CreateProjectRequest, DeviceFarm$20150623$CreateProjectResult>;
    createRemoteAccessSession: $APIMethod<DeviceFarm$20150623$CreateRemoteAccessSessionRequest, DeviceFarm$20150623$CreateRemoteAccessSessionResult>;
    createUpload: $APIMethod<DeviceFarm$20150623$CreateUploadRequest, DeviceFarm$20150623$CreateUploadResult>;
    deleteDevicePool: $APIMethod<DeviceFarm$20150623$DeleteDevicePoolRequest, DeviceFarm$20150623$DeleteDevicePoolResult>;
    deleteProject: $APIMethod<DeviceFarm$20150623$DeleteProjectRequest, DeviceFarm$20150623$DeleteProjectResult>;
    deleteRemoteAccessSession: $APIMethod<DeviceFarm$20150623$DeleteRemoteAccessSessionRequest, DeviceFarm$20150623$DeleteRemoteAccessSessionResult>;
    deleteRun: $APIMethod<DeviceFarm$20150623$DeleteRunRequest, DeviceFarm$20150623$DeleteRunResult>;
    deleteUpload: $APIMethod<DeviceFarm$20150623$DeleteUploadRequest, DeviceFarm$20150623$DeleteUploadResult>;
    getAccountSettings: $APIMethod<DeviceFarm$20150623$GetAccountSettingsRequest, DeviceFarm$20150623$GetAccountSettingsResult>;
    getDevice: $APIMethod<DeviceFarm$20150623$GetDeviceRequest, DeviceFarm$20150623$GetDeviceResult>;
    getDevicePool: $APIMethod<DeviceFarm$20150623$GetDevicePoolRequest, DeviceFarm$20150623$GetDevicePoolResult>;
    getDevicePoolCompatibility: $APIMethod<DeviceFarm$20150623$GetDevicePoolCompatibilityRequest, DeviceFarm$20150623$GetDevicePoolCompatibilityResult>;
    getJob: $APIMethod<DeviceFarm$20150623$GetJobRequest, DeviceFarm$20150623$GetJobResult>;
    getOfferingStatus: $APIMethod<DeviceFarm$20150623$GetOfferingStatusRequest, DeviceFarm$20150623$GetOfferingStatusResult>;
    getProject: $APIMethod<DeviceFarm$20150623$GetProjectRequest, DeviceFarm$20150623$GetProjectResult>;
    getRemoteAccessSession: $APIMethod<DeviceFarm$20150623$GetRemoteAccessSessionRequest, DeviceFarm$20150623$GetRemoteAccessSessionResult>;
    getRun: $APIMethod<DeviceFarm$20150623$GetRunRequest, DeviceFarm$20150623$GetRunResult>;
    getSuite: $APIMethod<DeviceFarm$20150623$GetSuiteRequest, DeviceFarm$20150623$GetSuiteResult>;
    getTest: $APIMethod<DeviceFarm$20150623$GetTestRequest, DeviceFarm$20150623$GetTestResult>;
    getUpload: $APIMethod<DeviceFarm$20150623$GetUploadRequest, DeviceFarm$20150623$GetUploadResult>;
    installToRemoteAccessSession: $APIMethod<DeviceFarm$20150623$InstallToRemoteAccessSessionRequest, DeviceFarm$20150623$InstallToRemoteAccessSessionResult>;
    listArtifacts: $APIMethod<DeviceFarm$20150623$ListArtifactsRequest, DeviceFarm$20150623$ListArtifactsResult>;
    listDevicePools: $APIMethod<DeviceFarm$20150623$ListDevicePoolsRequest, DeviceFarm$20150623$ListDevicePoolsResult>;
    listDevices: $APIMethod<DeviceFarm$20150623$ListDevicesRequest, DeviceFarm$20150623$ListDevicesResult>;
    listJobs: $APIMethod<DeviceFarm$20150623$ListJobsRequest, DeviceFarm$20150623$ListJobsResult>;
    listOfferingTransactions: $APIMethod<DeviceFarm$20150623$ListOfferingTransactionsRequest, DeviceFarm$20150623$ListOfferingTransactionsResult>;
    listOfferings: $APIMethod<DeviceFarm$20150623$ListOfferingsRequest, DeviceFarm$20150623$ListOfferingsResult>;
    listProjects: $APIMethod<DeviceFarm$20150623$ListProjectsRequest, DeviceFarm$20150623$ListProjectsResult>;
    listRemoteAccessSessions: $APIMethod<DeviceFarm$20150623$ListRemoteAccessSessionsRequest, DeviceFarm$20150623$ListRemoteAccessSessionsResult>;
    listRuns: $APIMethod<DeviceFarm$20150623$ListRunsRequest, DeviceFarm$20150623$ListRunsResult>;
    listSamples: $APIMethod<DeviceFarm$20150623$ListSamplesRequest, DeviceFarm$20150623$ListSamplesResult>;
    listSuites: $APIMethod<DeviceFarm$20150623$ListSuitesRequest, DeviceFarm$20150623$ListSuitesResult>;
    listTests: $APIMethod<DeviceFarm$20150623$ListTestsRequest, DeviceFarm$20150623$ListTestsResult>;
    listUniqueProblems: $APIMethod<DeviceFarm$20150623$ListUniqueProblemsRequest, DeviceFarm$20150623$ListUniqueProblemsResult>;
    listUploads: $APIMethod<DeviceFarm$20150623$ListUploadsRequest, DeviceFarm$20150623$ListUploadsResult>;
    purchaseOffering: $APIMethod<DeviceFarm$20150623$PurchaseOfferingRequest, DeviceFarm$20150623$PurchaseOfferingResult>;
    renewOffering: $APIMethod<DeviceFarm$20150623$RenewOfferingRequest, DeviceFarm$20150623$RenewOfferingResult>;
    scheduleRun: $APIMethod<DeviceFarm$20150623$ScheduleRunRequest, DeviceFarm$20150623$ScheduleRunResult>;
    stopRemoteAccessSession: $APIMethod<DeviceFarm$20150623$StopRemoteAccessSessionRequest, DeviceFarm$20150623$StopRemoteAccessSessionResult>;
    stopRun: $APIMethod<DeviceFarm$20150623$StopRunRequest, DeviceFarm$20150623$StopRunResult>;
    updateDevicePool: $APIMethod<DeviceFarm$20150623$UpdateDevicePoolRequest, DeviceFarm$20150623$UpdateDevicePoolResult>;
    updateProject: $APIMethod<DeviceFarm$20150623$UpdateProjectRequest, DeviceFarm$20150623$UpdateProjectResult>;
  }
  declare class DeviceFarm {
    constructor(config: $ConfigOptions & {
      apiVersion: '2015-06-23';
    }): DeviceFarm$20150623;
    constructor(): DeviceFarm$20150623;
  }
  declare class DirectConnect$20121025 {
    allocateConnectionOnInterconnect: $APIMethod<DirectConnect$20121025$AllocateConnectionOnInterconnectRequest, DirectConnect$20121025$Connection>;
    allocatePrivateVirtualInterface: $APIMethod<DirectConnect$20121025$AllocatePrivateVirtualInterfaceRequest, DirectConnect$20121025$VirtualInterface>;
    allocatePublicVirtualInterface: $APIMethod<DirectConnect$20121025$AllocatePublicVirtualInterfaceRequest, DirectConnect$20121025$VirtualInterface>;
    confirmConnection: $APIMethod<DirectConnect$20121025$ConfirmConnectionRequest, DirectConnect$20121025$ConfirmConnectionResponse>;
    confirmPrivateVirtualInterface: $APIMethod<DirectConnect$20121025$ConfirmPrivateVirtualInterfaceRequest, DirectConnect$20121025$ConfirmPrivateVirtualInterfaceResponse>;
    confirmPublicVirtualInterface: $APIMethod<DirectConnect$20121025$ConfirmPublicVirtualInterfaceRequest, DirectConnect$20121025$ConfirmPublicVirtualInterfaceResponse>;
    createConnection: $APIMethod<DirectConnect$20121025$CreateConnectionRequest, DirectConnect$20121025$Connection>;
    createInterconnect: $APIMethod<DirectConnect$20121025$CreateInterconnectRequest, DirectConnect$20121025$Interconnect>;
    createPrivateVirtualInterface: $APIMethod<DirectConnect$20121025$CreatePrivateVirtualInterfaceRequest, DirectConnect$20121025$VirtualInterface>;
    createPublicVirtualInterface: $APIMethod<DirectConnect$20121025$CreatePublicVirtualInterfaceRequest, DirectConnect$20121025$VirtualInterface>;
    deleteConnection: $APIMethod<DirectConnect$20121025$DeleteConnectionRequest, DirectConnect$20121025$Connection>;
    deleteInterconnect: $APIMethod<DirectConnect$20121025$DeleteInterconnectRequest, DirectConnect$20121025$DeleteInterconnectResponse>;
    deleteVirtualInterface: $APIMethod<DirectConnect$20121025$DeleteVirtualInterfaceRequest, DirectConnect$20121025$DeleteVirtualInterfaceResponse>;
    describeConnectionLoa: $APIMethod<DirectConnect$20121025$DescribeConnectionLoaRequest, DirectConnect$20121025$DescribeConnectionLoaResponse>;
    describeConnections: $APIMethod<DirectConnect$20121025$DescribeConnectionsRequest, DirectConnect$20121025$Connections>;
    describeConnectionsOnInterconnect: $APIMethod<DirectConnect$20121025$DescribeConnectionsOnInterconnectRequest, DirectConnect$20121025$Connections>;
    describeInterconnectLoa: $APIMethod<DirectConnect$20121025$DescribeInterconnectLoaRequest, DirectConnect$20121025$DescribeInterconnectLoaResponse>;
    describeInterconnects: $APIMethod<DirectConnect$20121025$DescribeInterconnectsRequest, DirectConnect$20121025$Interconnects>;
    describeLocations: $APIMethod<void, DirectConnect$20121025$Locations>;
    describeVirtualGateways: $APIMethod<void, DirectConnect$20121025$VirtualGateways>;
    describeVirtualInterfaces: $APIMethod<DirectConnect$20121025$DescribeVirtualInterfacesRequest, DirectConnect$20121025$VirtualInterfaces>;
  }
  declare class DirectConnect {
    constructor(config: $ConfigOptions & {
      apiVersion: '2012-10-25';
    }): DirectConnect$20121025;
    constructor(): DirectConnect$20121025;
  }
  declare class DirectoryService$20150416 {
    addIpRoutes: $APIMethod<DirectoryService$20150416$AddIpRoutesRequest, DirectoryService$20150416$AddIpRoutesResult>;
    addTagsToResource: $APIMethod<DirectoryService$20150416$AddTagsToResourceRequest, DirectoryService$20150416$AddTagsToResourceResult>;
    connectDirectory: $APIMethod<DirectoryService$20150416$ConnectDirectoryRequest, DirectoryService$20150416$ConnectDirectoryResult>;
    createAlias: $APIMethod<DirectoryService$20150416$CreateAliasRequest, DirectoryService$20150416$CreateAliasResult>;
    createComputer: $APIMethod<DirectoryService$20150416$CreateComputerRequest, DirectoryService$20150416$CreateComputerResult>;
    createConditionalForwarder: $APIMethod<DirectoryService$20150416$CreateConditionalForwarderRequest, DirectoryService$20150416$CreateConditionalForwarderResult>;
    createDirectory: $APIMethod<DirectoryService$20150416$CreateDirectoryRequest, DirectoryService$20150416$CreateDirectoryResult>;
    createMicrosoftAD: $APIMethod<DirectoryService$20150416$CreateMicrosoftADRequest, DirectoryService$20150416$CreateMicrosoftADResult>;
    createSnapshot: $APIMethod<DirectoryService$20150416$CreateSnapshotRequest, DirectoryService$20150416$CreateSnapshotResult>;
    createTrust: $APIMethod<DirectoryService$20150416$CreateTrustRequest, DirectoryService$20150416$CreateTrustResult>;
    deleteConditionalForwarder: $APIMethod<DirectoryService$20150416$DeleteConditionalForwarderRequest, DirectoryService$20150416$DeleteConditionalForwarderResult>;
    deleteDirectory: $APIMethod<DirectoryService$20150416$DeleteDirectoryRequest, DirectoryService$20150416$DeleteDirectoryResult>;
    deleteSnapshot: $APIMethod<DirectoryService$20150416$DeleteSnapshotRequest, DirectoryService$20150416$DeleteSnapshotResult>;
    deleteTrust: $APIMethod<DirectoryService$20150416$DeleteTrustRequest, DirectoryService$20150416$DeleteTrustResult>;
    deregisterEventTopic: $APIMethod<DirectoryService$20150416$DeregisterEventTopicRequest, DirectoryService$20150416$DeregisterEventTopicResult>;
    describeConditionalForwarders: $APIMethod<DirectoryService$20150416$DescribeConditionalForwardersRequest, DirectoryService$20150416$DescribeConditionalForwardersResult>;
    describeDirectories: $APIMethod<DirectoryService$20150416$DescribeDirectoriesRequest, DirectoryService$20150416$DescribeDirectoriesResult>;
    describeEventTopics: $APIMethod<DirectoryService$20150416$DescribeEventTopicsRequest, DirectoryService$20150416$DescribeEventTopicsResult>;
    describeSnapshots: $APIMethod<DirectoryService$20150416$DescribeSnapshotsRequest, DirectoryService$20150416$DescribeSnapshotsResult>;
    describeTrusts: $APIMethod<DirectoryService$20150416$DescribeTrustsRequest, DirectoryService$20150416$DescribeTrustsResult>;
    disableRadius: $APIMethod<DirectoryService$20150416$DisableRadiusRequest, DirectoryService$20150416$DisableRadiusResult>;
    disableSso: $APIMethod<DirectoryService$20150416$DisableSsoRequest, DirectoryService$20150416$DisableSsoResult>;
    enableRadius: $APIMethod<DirectoryService$20150416$EnableRadiusRequest, DirectoryService$20150416$EnableRadiusResult>;
    enableSso: $APIMethod<DirectoryService$20150416$EnableSsoRequest, DirectoryService$20150416$EnableSsoResult>;
    getDirectoryLimits: $APIMethod<DirectoryService$20150416$GetDirectoryLimitsRequest, DirectoryService$20150416$GetDirectoryLimitsResult>;
    getSnapshotLimits: $APIMethod<DirectoryService$20150416$GetSnapshotLimitsRequest, DirectoryService$20150416$GetSnapshotLimitsResult>;
    listIpRoutes: $APIMethod<DirectoryService$20150416$ListIpRoutesRequest, DirectoryService$20150416$ListIpRoutesResult>;
    listTagsForResource: $APIMethod<DirectoryService$20150416$ListTagsForResourceRequest, DirectoryService$20150416$ListTagsForResourceResult>;
    registerEventTopic: $APIMethod<DirectoryService$20150416$RegisterEventTopicRequest, DirectoryService$20150416$RegisterEventTopicResult>;
    removeIpRoutes: $APIMethod<DirectoryService$20150416$RemoveIpRoutesRequest, DirectoryService$20150416$RemoveIpRoutesResult>;
    removeTagsFromResource: $APIMethod<DirectoryService$20150416$RemoveTagsFromResourceRequest, DirectoryService$20150416$RemoveTagsFromResourceResult>;
    restoreFromSnapshot: $APIMethod<DirectoryService$20150416$RestoreFromSnapshotRequest, DirectoryService$20150416$RestoreFromSnapshotResult>;
    updateConditionalForwarder: $APIMethod<DirectoryService$20150416$UpdateConditionalForwarderRequest, DirectoryService$20150416$UpdateConditionalForwarderResult>;
    updateRadius: $APIMethod<DirectoryService$20150416$UpdateRadiusRequest, DirectoryService$20150416$UpdateRadiusResult>;
    verifyTrust: $APIMethod<DirectoryService$20150416$VerifyTrustRequest, DirectoryService$20150416$VerifyTrustResult>;
  }
  declare class DirectoryService {
    constructor(config: $ConfigOptions & {
      apiVersion: '2015-04-16';
    }): DirectoryService$20150416;
    constructor(): DirectoryService$20150416;
  }
  declare class Discovery$20151101 {
    createTags: $APIMethod<Discovery$20151101$CreateTagsRequest, Discovery$20151101$CreateTagsResponse>;
    deleteTags: $APIMethod<Discovery$20151101$DeleteTagsRequest, Discovery$20151101$DeleteTagsResponse>;
    describeAgents: $APIMethod<Discovery$20151101$DescribeAgentsRequest, Discovery$20151101$DescribeAgentsResponse>;
    describeConfigurations: $APIMethod<Discovery$20151101$DescribeConfigurationsRequest, Discovery$20151101$DescribeConfigurationsResponse>;
    describeExportConfigurations: $APIMethod<Discovery$20151101$DescribeExportConfigurationsRequest, Discovery$20151101$DescribeExportConfigurationsResponse>;
    describeTags: $APIMethod<Discovery$20151101$DescribeTagsRequest, Discovery$20151101$DescribeTagsResponse>;
    exportConfigurations: $APIMethod<void, Discovery$20151101$ExportConfigurationsResponse>;
    listConfigurations: $APIMethod<Discovery$20151101$ListConfigurationsRequest, Discovery$20151101$ListConfigurationsResponse>;
    startDataCollectionByAgentIds: $APIMethod<Discovery$20151101$StartDataCollectionByAgentIdsRequest, Discovery$20151101$StartDataCollectionByAgentIdsResponse>;
    stopDataCollectionByAgentIds: $APIMethod<Discovery$20151101$StopDataCollectionByAgentIdsRequest, Discovery$20151101$StopDataCollectionByAgentIdsResponse>;
  }
  declare class Discovery {
    constructor(config: $ConfigOptions & {
      apiVersion: '2015-11-01';
    }): Discovery$20151101;
    constructor(): Discovery$20151101;
  }
  declare class DMS$20160101 {
    addTagsToResource: $APIMethod<DMS$20160101$AddTagsToResourceMessage, DMS$20160101$AddTagsToResourceResponse>;
    createEndpoint: $APIMethod<DMS$20160101$CreateEndpointMessage, DMS$20160101$CreateEndpointResponse>;
    createReplicationInstance: $APIMethod<DMS$20160101$CreateReplicationInstanceMessage, DMS$20160101$CreateReplicationInstanceResponse>;
    createReplicationSubnetGroup: $APIMethod<DMS$20160101$CreateReplicationSubnetGroupMessage, DMS$20160101$CreateReplicationSubnetGroupResponse>;
    createReplicationTask: $APIMethod<DMS$20160101$CreateReplicationTaskMessage, DMS$20160101$CreateReplicationTaskResponse>;
    deleteCertificate: $APIMethod<DMS$20160101$DeleteCertificateMessage, DMS$20160101$DeleteCertificateResponse>;
    deleteEndpoint: $APIMethod<DMS$20160101$DeleteEndpointMessage, DMS$20160101$DeleteEndpointResponse>;
    deleteReplicationInstance: $APIMethod<DMS$20160101$DeleteReplicationInstanceMessage, DMS$20160101$DeleteReplicationInstanceResponse>;
    deleteReplicationSubnetGroup: $APIMethod<DMS$20160101$DeleteReplicationSubnetGroupMessage, DMS$20160101$DeleteReplicationSubnetGroupResponse>;
    deleteReplicationTask: $APIMethod<DMS$20160101$DeleteReplicationTaskMessage, DMS$20160101$DeleteReplicationTaskResponse>;
    describeAccountAttributes: $APIMethod<DMS$20160101$DescribeAccountAttributesMessage, DMS$20160101$DescribeAccountAttributesResponse>;
    describeCertificates: $APIMethod<DMS$20160101$DescribeCertificatesMessage, DMS$20160101$DescribeCertificatesResponse>;
    describeConnections: $APIMethod<DMS$20160101$DescribeConnectionsMessage, DMS$20160101$DescribeConnectionsResponse>;
    describeEndpointTypes: $APIMethod<DMS$20160101$DescribeEndpointTypesMessage, DMS$20160101$DescribeEndpointTypesResponse>;
    describeEndpoints: $APIMethod<DMS$20160101$DescribeEndpointsMessage, DMS$20160101$DescribeEndpointsResponse>;
    describeOrderableReplicationInstances: $APIMethod<DMS$20160101$DescribeOrderableReplicationInstancesMessage, DMS$20160101$DescribeOrderableReplicationInstancesResponse>;
    describeRefreshSchemasStatus: $APIMethod<DMS$20160101$DescribeRefreshSchemasStatusMessage, DMS$20160101$DescribeRefreshSchemasStatusResponse>;
    describeReplicationInstances: $APIMethod<DMS$20160101$DescribeReplicationInstancesMessage, DMS$20160101$DescribeReplicationInstancesResponse>;
    describeReplicationSubnetGroups: $APIMethod<DMS$20160101$DescribeReplicationSubnetGroupsMessage, DMS$20160101$DescribeReplicationSubnetGroupsResponse>;
    describeReplicationTasks: $APIMethod<DMS$20160101$DescribeReplicationTasksMessage, DMS$20160101$DescribeReplicationTasksResponse>;
    describeSchemas: $APIMethod<DMS$20160101$DescribeSchemasMessage, DMS$20160101$DescribeSchemasResponse>;
    describeTableStatistics: $APIMethod<DMS$20160101$DescribeTableStatisticsMessage, DMS$20160101$DescribeTableStatisticsResponse>;
    importCertificate: $APIMethod<DMS$20160101$ImportCertificateMessage, DMS$20160101$ImportCertificateResponse>;
    listTagsForResource: $APIMethod<DMS$20160101$ListTagsForResourceMessage, DMS$20160101$ListTagsForResourceResponse>;
    modifyEndpoint: $APIMethod<DMS$20160101$ModifyEndpointMessage, DMS$20160101$ModifyEndpointResponse>;
    modifyReplicationInstance: $APIMethod<DMS$20160101$ModifyReplicationInstanceMessage, DMS$20160101$ModifyReplicationInstanceResponse>;
    modifyReplicationSubnetGroup: $APIMethod<DMS$20160101$ModifyReplicationSubnetGroupMessage, DMS$20160101$ModifyReplicationSubnetGroupResponse>;
    refreshSchemas: $APIMethod<DMS$20160101$RefreshSchemasMessage, DMS$20160101$RefreshSchemasResponse>;
    removeTagsFromResource: $APIMethod<DMS$20160101$RemoveTagsFromResourceMessage, DMS$20160101$RemoveTagsFromResourceResponse>;
    startReplicationTask: $APIMethod<DMS$20160101$StartReplicationTaskMessage, DMS$20160101$StartReplicationTaskResponse>;
    stopReplicationTask: $APIMethod<DMS$20160101$StopReplicationTaskMessage, DMS$20160101$StopReplicationTaskResponse>;
    testConnection: $APIMethod<DMS$20160101$TestConnectionMessage, DMS$20160101$TestConnectionResponse>;
  }
  declare class DMS {
    constructor(config: $ConfigOptions & {
      apiVersion: '2016-01-01';
    }): DMS$20160101;
    constructor(): DMS$20160101;
  }
  declare class DynamoDB$20111205 {
    batchGetItem: $APIMethod<DynamoDB$20111205$BatchGetItemInput, DynamoDB$20111205$BatchGetItemOutput>;
    batchWriteItem: $APIMethod<DynamoDB$20111205$BatchWriteItemInput, DynamoDB$20111205$BatchWriteItemOutput>;
    createTable: $APIMethod<DynamoDB$20111205$CreateTableInput, DynamoDB$20111205$CreateTableOutput>;
    deleteItem: $APIMethod<DynamoDB$20111205$DeleteItemInput, DynamoDB$20111205$DeleteItemOutput>;
    deleteTable: $APIMethod<DynamoDB$20111205$DeleteTableInput, DynamoDB$20111205$DeleteTableOutput>;
    describeTable: $APIMethod<DynamoDB$20111205$DescribeTableInput, DynamoDB$20111205$DescribeTableOutput>;
    getItem: $APIMethod<DynamoDB$20111205$GetItemInput, DynamoDB$20111205$GetItemOutput>;
    listTables: $APIMethod<DynamoDB$20111205$ListTablesInput, DynamoDB$20111205$ListTablesOutput>;
    putItem: $APIMethod<DynamoDB$20111205$PutItemInput, DynamoDB$20111205$PutItemOutput>;
    query: $APIMethod<DynamoDB$20111205$QueryInput, DynamoDB$20111205$QueryOutput>;
    scan: $APIMethod<DynamoDB$20111205$ScanInput, DynamoDB$20111205$ScanOutput>;
    updateItem: $APIMethod<DynamoDB$20111205$UpdateItemInput, DynamoDB$20111205$UpdateItemOutput>;
    updateTable: $APIMethod<DynamoDB$20111205$UpdateTableInput, DynamoDB$20111205$UpdateTableOutput>;
  }
  declare class DynamoDB$20120810 {
    batchGetItem: $APIMethod<DynamoDB$20120810$BatchGetItemInput, DynamoDB$20120810$BatchGetItemOutput>;
    batchWriteItem: $APIMethod<DynamoDB$20120810$BatchWriteItemInput, DynamoDB$20120810$BatchWriteItemOutput>;
    createTable: $APIMethod<DynamoDB$20120810$CreateTableInput, DynamoDB$20120810$CreateTableOutput>;
    deleteItem: $APIMethod<DynamoDB$20120810$DeleteItemInput, DynamoDB$20120810$DeleteItemOutput>;
    deleteTable: $APIMethod<DynamoDB$20120810$DeleteTableInput, DynamoDB$20120810$DeleteTableOutput>;
    describeLimits: $APIMethod<DynamoDB$20120810$DescribeLimitsInput, DynamoDB$20120810$DescribeLimitsOutput>;
    describeTable: $APIMethod<DynamoDB$20120810$DescribeTableInput, DynamoDB$20120810$DescribeTableOutput>;
    getItem: $APIMethod<DynamoDB$20120810$GetItemInput, DynamoDB$20120810$GetItemOutput>;
    listTables: $APIMethod<DynamoDB$20120810$ListTablesInput, DynamoDB$20120810$ListTablesOutput>;
    putItem: $APIMethod<DynamoDB$20120810$PutItemInput, DynamoDB$20120810$PutItemOutput>;
    query: $APIMethod<DynamoDB$20120810$QueryInput, DynamoDB$20120810$QueryOutput>;
    scan: $APIMethod<DynamoDB$20120810$ScanInput, DynamoDB$20120810$ScanOutput>;
    updateItem: $APIMethod<DynamoDB$20120810$UpdateItemInput, DynamoDB$20120810$UpdateItemOutput>;
    updateTable: $APIMethod<DynamoDB$20120810$UpdateTableInput, DynamoDB$20120810$UpdateTableOutput>;
  }
  declare class DynamoDB {
    constructor(config: $ConfigOptions & {
      apiVersion: '2011-12-05';
    }): DynamoDB$20111205;
    constructor(config: $ConfigOptions & {
      apiVersion: '2012-08-10';
    }): DynamoDB$20120810;
    constructor(): DynamoDB$20120810;
  }
  declare class DynamoDBStreams$20120810 {
    describeStream: $APIMethod<DynamoDBStreams$20120810$DescribeStreamInput, DynamoDBStreams$20120810$DescribeStreamOutput>;
    getRecords: $APIMethod<DynamoDBStreams$20120810$GetRecordsInput, DynamoDBStreams$20120810$GetRecordsOutput>;
    getShardIterator: $APIMethod<DynamoDBStreams$20120810$GetShardIteratorInput, DynamoDBStreams$20120810$GetShardIteratorOutput>;
    listStreams: $APIMethod<DynamoDBStreams$20120810$ListStreamsInput, DynamoDBStreams$20120810$ListStreamsOutput>;
  }
  declare class DynamoDBStreams {
    constructor(config: $ConfigOptions & {
      apiVersion: '2012-08-10';
    }): DynamoDBStreams$20120810;
    constructor(): DynamoDBStreams$20120810;
  }
  declare class EC2$20160401 {
    acceptVpcPeeringConnection: $APIMethod<EC2$20160401$AcceptVpcPeeringConnectionRequest, EC2$20160401$AcceptVpcPeeringConnectionResult>;
    allocateAddress: $APIMethod<EC2$20160401$AllocateAddressRequest, EC2$20160401$AllocateAddressResult>;
    allocateHosts: $APIMethod<EC2$20160401$AllocateHostsRequest, EC2$20160401$AllocateHostsResult>;
    assignPrivateIpAddresses: $APIMethod<EC2$20160401$AssignPrivateIpAddressesRequest, void>;
    associateAddress: $APIMethod<EC2$20160401$AssociateAddressRequest, EC2$20160401$AssociateAddressResult>;
    associateDhcpOptions: $APIMethod<EC2$20160401$AssociateDhcpOptionsRequest, void>;
    associateRouteTable: $APIMethod<EC2$20160401$AssociateRouteTableRequest, EC2$20160401$AssociateRouteTableResult>;
    attachClassicLinkVpc: $APIMethod<EC2$20160401$AttachClassicLinkVpcRequest, EC2$20160401$AttachClassicLinkVpcResult>;
    attachInternetGateway: $APIMethod<EC2$20160401$AttachInternetGatewayRequest, void>;
    attachNetworkInterface: $APIMethod<EC2$20160401$AttachNetworkInterfaceRequest, EC2$20160401$AttachNetworkInterfaceResult>;
    attachVolume: $APIMethod<EC2$20160401$AttachVolumeRequest, EC2$20160401$VolumeAttachment>;
    attachVpnGateway: $APIMethod<EC2$20160401$AttachVpnGatewayRequest, EC2$20160401$AttachVpnGatewayResult>;
    authorizeSecurityGroupEgress: $APIMethod<EC2$20160401$AuthorizeSecurityGroupEgressRequest, void>;
    authorizeSecurityGroupIngress: $APIMethod<EC2$20160401$AuthorizeSecurityGroupIngressRequest, void>;
    bundleInstance: $APIMethod<EC2$20160401$BundleInstanceRequest, EC2$20160401$BundleInstanceResult>;
    cancelBundleTask: $APIMethod<EC2$20160401$CancelBundleTaskRequest, EC2$20160401$CancelBundleTaskResult>;
    cancelConversionTask: $APIMethod<EC2$20160401$CancelConversionRequest, void>;
    cancelExportTask: $APIMethod<EC2$20160401$CancelExportTaskRequest, void>;
    cancelImportTask: $APIMethod<EC2$20160401$CancelImportTaskRequest, EC2$20160401$CancelImportTaskResult>;
    cancelReservedInstancesListing: $APIMethod<EC2$20160401$CancelReservedInstancesListingRequest, EC2$20160401$CancelReservedInstancesListingResult>;
    cancelSpotFleetRequests: $APIMethod<EC2$20160401$CancelSpotFleetRequestsRequest, EC2$20160401$CancelSpotFleetRequestsResponse>;
    cancelSpotInstanceRequests: $APIMethod<EC2$20160401$CancelSpotInstanceRequestsRequest, EC2$20160401$CancelSpotInstanceRequestsResult>;
    confirmProductInstance: $APIMethod<EC2$20160401$ConfirmProductInstanceRequest, EC2$20160401$ConfirmProductInstanceResult>;
    copyImage: $APIMethod<EC2$20160401$CopyImageRequest, EC2$20160401$CopyImageResult>;
    copySnapshot: $APIMethod<EC2$20160401$CopySnapshotRequest, EC2$20160401$CopySnapshotResult>;
    createCustomerGateway: $APIMethod<EC2$20160401$CreateCustomerGatewayRequest, EC2$20160401$CreateCustomerGatewayResult>;
    createDhcpOptions: $APIMethod<EC2$20160401$CreateDhcpOptionsRequest, EC2$20160401$CreateDhcpOptionsResult>;
    createFlowLogs: $APIMethod<EC2$20160401$CreateFlowLogsRequest, EC2$20160401$CreateFlowLogsResult>;
    createImage: $APIMethod<EC2$20160401$CreateImageRequest, EC2$20160401$CreateImageResult>;
    createInstanceExportTask: $APIMethod<EC2$20160401$CreateInstanceExportTaskRequest, EC2$20160401$CreateInstanceExportTaskResult>;
    createInternetGateway: $APIMethod<EC2$20160401$CreateInternetGatewayRequest, EC2$20160401$CreateInternetGatewayResult>;
    createKeyPair: $APIMethod<EC2$20160401$CreateKeyPairRequest, EC2$20160401$KeyPair>;
    createNatGateway: $APIMethod<EC2$20160401$CreateNatGatewayRequest, EC2$20160401$CreateNatGatewayResult>;
    createNetworkAcl: $APIMethod<EC2$20160401$CreateNetworkAclRequest, EC2$20160401$CreateNetworkAclResult>;
    createNetworkAclEntry: $APIMethod<EC2$20160401$CreateNetworkAclEntryRequest, void>;
    createNetworkInterface: $APIMethod<EC2$20160401$CreateNetworkInterfaceRequest, EC2$20160401$CreateNetworkInterfaceResult>;
    createPlacementGroup: $APIMethod<EC2$20160401$CreatePlacementGroupRequest, void>;
    createReservedInstancesListing: $APIMethod<EC2$20160401$CreateReservedInstancesListingRequest, EC2$20160401$CreateReservedInstancesListingResult>;
    createRoute: $APIMethod<EC2$20160401$CreateRouteRequest, EC2$20160401$CreateRouteResult>;
    createRouteTable: $APIMethod<EC2$20160401$CreateRouteTableRequest, EC2$20160401$CreateRouteTableResult>;
    createSecurityGroup: $APIMethod<EC2$20160401$CreateSecurityGroupRequest, EC2$20160401$CreateSecurityGroupResult>;
    createSnapshot: $APIMethod<EC2$20160401$CreateSnapshotRequest, EC2$20160401$Snapshot>;
    createSpotDatafeedSubscription: $APIMethod<EC2$20160401$CreateSpotDatafeedSubscriptionRequest, EC2$20160401$CreateSpotDatafeedSubscriptionResult>;
    createSubnet: $APIMethod<EC2$20160401$CreateSubnetRequest, EC2$20160401$CreateSubnetResult>;
    createTags: $APIMethod<EC2$20160401$CreateTagsRequest, void>;
    createVolume: $APIMethod<EC2$20160401$CreateVolumeRequest, EC2$20160401$Volume>;
    createVpc: $APIMethod<EC2$20160401$CreateVpcRequest, EC2$20160401$CreateVpcResult>;
    createVpcEndpoint: $APIMethod<EC2$20160401$CreateVpcEndpointRequest, EC2$20160401$CreateVpcEndpointResult>;
    createVpcPeeringConnection: $APIMethod<EC2$20160401$CreateVpcPeeringConnectionRequest, EC2$20160401$CreateVpcPeeringConnectionResult>;
    createVpnConnection: $APIMethod<EC2$20160401$CreateVpnConnectionRequest, EC2$20160401$CreateVpnConnectionResult>;
    createVpnConnectionRoute: $APIMethod<EC2$20160401$CreateVpnConnectionRouteRequest, void>;
    createVpnGateway: $APIMethod<EC2$20160401$CreateVpnGatewayRequest, EC2$20160401$CreateVpnGatewayResult>;
    deleteCustomerGateway: $APIMethod<EC2$20160401$DeleteCustomerGatewayRequest, void>;
    deleteDhcpOptions: $APIMethod<EC2$20160401$DeleteDhcpOptionsRequest, void>;
    deleteFlowLogs: $APIMethod<EC2$20160401$DeleteFlowLogsRequest, EC2$20160401$DeleteFlowLogsResult>;
    deleteInternetGateway: $APIMethod<EC2$20160401$DeleteInternetGatewayRequest, void>;
    deleteKeyPair: $APIMethod<EC2$20160401$DeleteKeyPairRequest, void>;
    deleteNatGateway: $APIMethod<EC2$20160401$DeleteNatGatewayRequest, EC2$20160401$DeleteNatGatewayResult>;
    deleteNetworkAcl: $APIMethod<EC2$20160401$DeleteNetworkAclRequest, void>;
    deleteNetworkAclEntry: $APIMethod<EC2$20160401$DeleteNetworkAclEntryRequest, void>;
    deleteNetworkInterface: $APIMethod<EC2$20160401$DeleteNetworkInterfaceRequest, void>;
    deletePlacementGroup: $APIMethod<EC2$20160401$DeletePlacementGroupRequest, void>;
    deleteRoute: $APIMethod<EC2$20160401$DeleteRouteRequest, void>;
    deleteRouteTable: $APIMethod<EC2$20160401$DeleteRouteTableRequest, void>;
    deleteSecurityGroup: $APIMethod<EC2$20160401$DeleteSecurityGroupRequest, void>;
    deleteSnapshot: $APIMethod<EC2$20160401$DeleteSnapshotRequest, void>;
    deleteSpotDatafeedSubscription: $APIMethod<EC2$20160401$DeleteSpotDatafeedSubscriptionRequest, void>;
    deleteSubnet: $APIMethod<EC2$20160401$DeleteSubnetRequest, void>;
    deleteTags: $APIMethod<EC2$20160401$DeleteTagsRequest, void>;
    deleteVolume: $APIMethod<EC2$20160401$DeleteVolumeRequest, void>;
    deleteVpc: $APIMethod<EC2$20160401$DeleteVpcRequest, void>;
    deleteVpcEndpoints: $APIMethod<EC2$20160401$DeleteVpcEndpointsRequest, EC2$20160401$DeleteVpcEndpointsResult>;
    deleteVpcPeeringConnection: $APIMethod<EC2$20160401$DeleteVpcPeeringConnectionRequest, EC2$20160401$DeleteVpcPeeringConnectionResult>;
    deleteVpnConnection: $APIMethod<EC2$20160401$DeleteVpnConnectionRequest, void>;
    deleteVpnConnectionRoute: $APIMethod<EC2$20160401$DeleteVpnConnectionRouteRequest, void>;
    deleteVpnGateway: $APIMethod<EC2$20160401$DeleteVpnGatewayRequest, void>;
    deregisterImage: $APIMethod<EC2$20160401$DeregisterImageRequest, void>;
    describeAccountAttributes: $APIMethod<EC2$20160401$DescribeAccountAttributesRequest, EC2$20160401$DescribeAccountAttributesResult>;
    describeAddresses: $APIMethod<EC2$20160401$DescribeAddressesRequest, EC2$20160401$DescribeAddressesResult>;
    describeAvailabilityZones: $APIMethod<EC2$20160401$DescribeAvailabilityZonesRequest, EC2$20160401$DescribeAvailabilityZonesResult>;
    describeBundleTasks: $APIMethod<EC2$20160401$DescribeBundleTasksRequest, EC2$20160401$DescribeBundleTasksResult>;
    describeClassicLinkInstances: $APIMethod<EC2$20160401$DescribeClassicLinkInstancesRequest, EC2$20160401$DescribeClassicLinkInstancesResult>;
    describeConversionTasks: $APIMethod<EC2$20160401$DescribeConversionTasksRequest, EC2$20160401$DescribeConversionTasksResult>;
    describeCustomerGateways: $APIMethod<EC2$20160401$DescribeCustomerGatewaysRequest, EC2$20160401$DescribeCustomerGatewaysResult>;
    describeDhcpOptions: $APIMethod<EC2$20160401$DescribeDhcpOptionsRequest, EC2$20160401$DescribeDhcpOptionsResult>;
    describeExportTasks: $APIMethod<EC2$20160401$DescribeExportTasksRequest, EC2$20160401$DescribeExportTasksResult>;
    describeFlowLogs: $APIMethod<EC2$20160401$DescribeFlowLogsRequest, EC2$20160401$DescribeFlowLogsResult>;
    describeHosts: $APIMethod<EC2$20160401$DescribeHostsRequest, EC2$20160401$DescribeHostsResult>;
    describeIdFormat: $APIMethod<EC2$20160401$DescribeIdFormatRequest, EC2$20160401$DescribeIdFormatResult>;
    describeIdentityIdFormat: $APIMethod<EC2$20160401$DescribeIdentityIdFormatRequest, EC2$20160401$DescribeIdentityIdFormatResult>;
    describeImageAttribute: $APIMethod<EC2$20160401$DescribeImageAttributeRequest, EC2$20160401$ImageAttribute>;
    describeImages: $APIMethod<EC2$20160401$DescribeImagesRequest, EC2$20160401$DescribeImagesResult>;
    describeImportImageTasks: $APIMethod<EC2$20160401$DescribeImportImageTasksRequest, EC2$20160401$DescribeImportImageTasksResult>;
    describeImportSnapshotTasks: $APIMethod<EC2$20160401$DescribeImportSnapshotTasksRequest, EC2$20160401$DescribeImportSnapshotTasksResult>;
    describeInstanceAttribute: $APIMethod<EC2$20160401$DescribeInstanceAttributeRequest, EC2$20160401$InstanceAttribute>;
    describeInstanceStatus: $APIMethod<EC2$20160401$DescribeInstanceStatusRequest, EC2$20160401$DescribeInstanceStatusResult>;
    describeInstances: $APIMethod<EC2$20160401$DescribeInstancesRequest, EC2$20160401$DescribeInstancesResult>;
    describeInternetGateways: $APIMethod<EC2$20160401$DescribeInternetGatewaysRequest, EC2$20160401$DescribeInternetGatewaysResult>;
    describeKeyPairs: $APIMethod<EC2$20160401$DescribeKeyPairsRequest, EC2$20160401$DescribeKeyPairsResult>;
    describeMovingAddresses: $APIMethod<EC2$20160401$DescribeMovingAddressesRequest, EC2$20160401$DescribeMovingAddressesResult>;
    describeNatGateways: $APIMethod<EC2$20160401$DescribeNatGatewaysRequest, EC2$20160401$DescribeNatGatewaysResult>;
    describeNetworkAcls: $APIMethod<EC2$20160401$DescribeNetworkAclsRequest, EC2$20160401$DescribeNetworkAclsResult>;
    describeNetworkInterfaceAttribute: $APIMethod<EC2$20160401$DescribeNetworkInterfaceAttributeRequest, EC2$20160401$DescribeNetworkInterfaceAttributeResult>;
    describeNetworkInterfaces: $APIMethod<EC2$20160401$DescribeNetworkInterfacesRequest, EC2$20160401$DescribeNetworkInterfacesResult>;
    describePlacementGroups: $APIMethod<EC2$20160401$DescribePlacementGroupsRequest, EC2$20160401$DescribePlacementGroupsResult>;
    describePrefixLists: $APIMethod<EC2$20160401$DescribePrefixListsRequest, EC2$20160401$DescribePrefixListsResult>;
    describeRegions: $APIMethod<EC2$20160401$DescribeRegionsRequest, EC2$20160401$DescribeRegionsResult>;
    describeReservedInstances: $APIMethod<EC2$20160401$DescribeReservedInstancesRequest, EC2$20160401$DescribeReservedInstancesResult>;
    describeReservedInstancesListings: $APIMethod<EC2$20160401$DescribeReservedInstancesListingsRequest, EC2$20160401$DescribeReservedInstancesListingsResult>;
    describeReservedInstancesModifications: $APIMethod<EC2$20160401$DescribeReservedInstancesModificationsRequest, EC2$20160401$DescribeReservedInstancesModificationsResult>;
    describeReservedInstancesOfferings: $APIMethod<EC2$20160401$DescribeReservedInstancesOfferingsRequest, EC2$20160401$DescribeReservedInstancesOfferingsResult>;
    describeRouteTables: $APIMethod<EC2$20160401$DescribeRouteTablesRequest, EC2$20160401$DescribeRouteTablesResult>;
    describeScheduledInstanceAvailability: $APIMethod<EC2$20160401$DescribeScheduledInstanceAvailabilityRequest, EC2$20160401$DescribeScheduledInstanceAvailabilityResult>;
    describeScheduledInstances: $APIMethod<EC2$20160401$DescribeScheduledInstancesRequest, EC2$20160401$DescribeScheduledInstancesResult>;
    describeSecurityGroupReferences: $APIMethod<EC2$20160401$DescribeSecurityGroupReferencesRequest, EC2$20160401$DescribeSecurityGroupReferencesResult>;
    describeSecurityGroups: $APIMethod<EC2$20160401$DescribeSecurityGroupsRequest, EC2$20160401$DescribeSecurityGroupsResult>;
    describeSnapshotAttribute: $APIMethod<EC2$20160401$DescribeSnapshotAttributeRequest, EC2$20160401$DescribeSnapshotAttributeResult>;
    describeSnapshots: $APIMethod<EC2$20160401$DescribeSnapshotsRequest, EC2$20160401$DescribeSnapshotsResult>;
    describeSpotDatafeedSubscription: $APIMethod<EC2$20160401$DescribeSpotDatafeedSubscriptionRequest, EC2$20160401$DescribeSpotDatafeedSubscriptionResult>;
    describeSpotFleetInstances: $APIMethod<EC2$20160401$DescribeSpotFleetInstancesRequest, EC2$20160401$DescribeSpotFleetInstancesResponse>;
    describeSpotFleetRequestHistory: $APIMethod<EC2$20160401$DescribeSpotFleetRequestHistoryRequest, EC2$20160401$DescribeSpotFleetRequestHistoryResponse>;
    describeSpotFleetRequests: $APIMethod<EC2$20160401$DescribeSpotFleetRequestsRequest, EC2$20160401$DescribeSpotFleetRequestsResponse>;
    describeSpotInstanceRequests: $APIMethod<EC2$20160401$DescribeSpotInstanceRequestsRequest, EC2$20160401$DescribeSpotInstanceRequestsResult>;
    describeSpotPriceHistory: $APIMethod<EC2$20160401$DescribeSpotPriceHistoryRequest, EC2$20160401$DescribeSpotPriceHistoryResult>;
    describeStaleSecurityGroups: $APIMethod<EC2$20160401$DescribeStaleSecurityGroupsRequest, EC2$20160401$DescribeStaleSecurityGroupsResult>;
    describeSubnets: $APIMethod<EC2$20160401$DescribeSubnetsRequest, EC2$20160401$DescribeSubnetsResult>;
    describeTags: $APIMethod<EC2$20160401$DescribeTagsRequest, EC2$20160401$DescribeTagsResult>;
    describeVolumeAttribute: $APIMethod<EC2$20160401$DescribeVolumeAttributeRequest, EC2$20160401$DescribeVolumeAttributeResult>;
    describeVolumeStatus: $APIMethod<EC2$20160401$DescribeVolumeStatusRequest, EC2$20160401$DescribeVolumeStatusResult>;
    describeVolumes: $APIMethod<EC2$20160401$DescribeVolumesRequest, EC2$20160401$DescribeVolumesResult>;
    describeVpcAttribute: $APIMethod<EC2$20160401$DescribeVpcAttributeRequest, EC2$20160401$DescribeVpcAttributeResult>;
    describeVpcClassicLink: $APIMethod<EC2$20160401$DescribeVpcClassicLinkRequest, EC2$20160401$DescribeVpcClassicLinkResult>;
    describeVpcClassicLinkDnsSupport: $APIMethod<EC2$20160401$DescribeVpcClassicLinkDnsSupportRequest, EC2$20160401$DescribeVpcClassicLinkDnsSupportResult>;
    describeVpcEndpointServices: $APIMethod<EC2$20160401$DescribeVpcEndpointServicesRequest, EC2$20160401$DescribeVpcEndpointServicesResult>;
    describeVpcEndpoints: $APIMethod<EC2$20160401$DescribeVpcEndpointsRequest, EC2$20160401$DescribeVpcEndpointsResult>;
    describeVpcPeeringConnections: $APIMethod<EC2$20160401$DescribeVpcPeeringConnectionsRequest, EC2$20160401$DescribeVpcPeeringConnectionsResult>;
    describeVpcs: $APIMethod<EC2$20160401$DescribeVpcsRequest, EC2$20160401$DescribeVpcsResult>;
    describeVpnConnections: $APIMethod<EC2$20160401$DescribeVpnConnectionsRequest, EC2$20160401$DescribeVpnConnectionsResult>;
    describeVpnGateways: $APIMethod<EC2$20160401$DescribeVpnGatewaysRequest, EC2$20160401$DescribeVpnGatewaysResult>;
    detachClassicLinkVpc: $APIMethod<EC2$20160401$DetachClassicLinkVpcRequest, EC2$20160401$DetachClassicLinkVpcResult>;
    detachInternetGateway: $APIMethod<EC2$20160401$DetachInternetGatewayRequest, void>;
    detachNetworkInterface: $APIMethod<EC2$20160401$DetachNetworkInterfaceRequest, void>;
    detachVolume: $APIMethod<EC2$20160401$DetachVolumeRequest, EC2$20160401$VolumeAttachment>;
    detachVpnGateway: $APIMethod<EC2$20160401$DetachVpnGatewayRequest, void>;
    disableVgwRoutePropagation: $APIMethod<EC2$20160401$DisableVgwRoutePropagationRequest, void>;
    disableVpcClassicLink: $APIMethod<EC2$20160401$DisableVpcClassicLinkRequest, EC2$20160401$DisableVpcClassicLinkResult>;
    disableVpcClassicLinkDnsSupport: $APIMethod<EC2$20160401$DisableVpcClassicLinkDnsSupportRequest, EC2$20160401$DisableVpcClassicLinkDnsSupportResult>;
    disassociateAddress: $APIMethod<EC2$20160401$DisassociateAddressRequest, void>;
    disassociateRouteTable: $APIMethod<EC2$20160401$DisassociateRouteTableRequest, void>;
    enableVgwRoutePropagation: $APIMethod<EC2$20160401$EnableVgwRoutePropagationRequest, void>;
    enableVolumeIO: $APIMethod<EC2$20160401$EnableVolumeIORequest, void>;
    enableVpcClassicLink: $APIMethod<EC2$20160401$EnableVpcClassicLinkRequest, EC2$20160401$EnableVpcClassicLinkResult>;
    enableVpcClassicLinkDnsSupport: $APIMethod<EC2$20160401$EnableVpcClassicLinkDnsSupportRequest, EC2$20160401$EnableVpcClassicLinkDnsSupportResult>;
    getConsoleOutput: $APIMethod<EC2$20160401$GetConsoleOutputRequest, EC2$20160401$GetConsoleOutputResult>;
    getConsoleScreenshot: $APIMethod<EC2$20160401$GetConsoleScreenshotRequest, EC2$20160401$GetConsoleScreenshotResult>;
    getPasswordData: $APIMethod<EC2$20160401$GetPasswordDataRequest, EC2$20160401$GetPasswordDataResult>;
    importImage: $APIMethod<EC2$20160401$ImportImageRequest, EC2$20160401$ImportImageResult>;
    importInstance: $APIMethod<EC2$20160401$ImportInstanceRequest, EC2$20160401$ImportInstanceResult>;
    importKeyPair: $APIMethod<EC2$20160401$ImportKeyPairRequest, EC2$20160401$ImportKeyPairResult>;
    importSnapshot: $APIMethod<EC2$20160401$ImportSnapshotRequest, EC2$20160401$ImportSnapshotResult>;
    importVolume: $APIMethod<EC2$20160401$ImportVolumeRequest, EC2$20160401$ImportVolumeResult>;
    modifyHosts: $APIMethod<EC2$20160401$ModifyHostsRequest, EC2$20160401$ModifyHostsResult>;
    modifyIdFormat: $APIMethod<EC2$20160401$ModifyIdFormatRequest, void>;
    modifyIdentityIdFormat: $APIMethod<EC2$20160401$ModifyIdentityIdFormatRequest, void>;
    modifyImageAttribute: $APIMethod<EC2$20160401$ModifyImageAttributeRequest, void>;
    modifyInstanceAttribute: $APIMethod<EC2$20160401$ModifyInstanceAttributeRequest, void>;
    modifyInstancePlacement: $APIMethod<EC2$20160401$ModifyInstancePlacementRequest, EC2$20160401$ModifyInstancePlacementResult>;
    modifyNetworkInterfaceAttribute: $APIMethod<EC2$20160401$ModifyNetworkInterfaceAttributeRequest, void>;
    modifyReservedInstances: $APIMethod<EC2$20160401$ModifyReservedInstancesRequest, EC2$20160401$ModifyReservedInstancesResult>;
    modifySnapshotAttribute: $APIMethod<EC2$20160401$ModifySnapshotAttributeRequest, void>;
    modifySpotFleetRequest: $APIMethod<EC2$20160401$ModifySpotFleetRequestRequest, EC2$20160401$ModifySpotFleetRequestResponse>;
    modifySubnetAttribute: $APIMethod<EC2$20160401$ModifySubnetAttributeRequest, void>;
    modifyVolumeAttribute: $APIMethod<EC2$20160401$ModifyVolumeAttributeRequest, void>;
    modifyVpcAttribute: $APIMethod<EC2$20160401$ModifyVpcAttributeRequest, void>;
    modifyVpcEndpoint: $APIMethod<EC2$20160401$ModifyVpcEndpointRequest, EC2$20160401$ModifyVpcEndpointResult>;
    modifyVpcPeeringConnectionOptions: $APIMethod<EC2$20160401$ModifyVpcPeeringConnectionOptionsRequest, EC2$20160401$ModifyVpcPeeringConnectionOptionsResult>;
    monitorInstances: $APIMethod<EC2$20160401$MonitorInstancesRequest, EC2$20160401$MonitorInstancesResult>;
    moveAddressToVpc: $APIMethod<EC2$20160401$MoveAddressToVpcRequest, EC2$20160401$MoveAddressToVpcResult>;
    purchaseReservedInstancesOffering: $APIMethod<EC2$20160401$PurchaseReservedInstancesOfferingRequest, EC2$20160401$PurchaseReservedInstancesOfferingResult>;
    purchaseScheduledInstances: $APIMethod<EC2$20160401$PurchaseScheduledInstancesRequest, EC2$20160401$PurchaseScheduledInstancesResult>;
    rebootInstances: $APIMethod<EC2$20160401$RebootInstancesRequest, void>;
    registerImage: $APIMethod<EC2$20160401$RegisterImageRequest, EC2$20160401$RegisterImageResult>;
    rejectVpcPeeringConnection: $APIMethod<EC2$20160401$RejectVpcPeeringConnectionRequest, EC2$20160401$RejectVpcPeeringConnectionResult>;
    releaseAddress: $APIMethod<EC2$20160401$ReleaseAddressRequest, void>;
    releaseHosts: $APIMethod<EC2$20160401$ReleaseHostsRequest, EC2$20160401$ReleaseHostsResult>;
    replaceNetworkAclAssociation: $APIMethod<EC2$20160401$ReplaceNetworkAclAssociationRequest, EC2$20160401$ReplaceNetworkAclAssociationResult>;
    replaceNetworkAclEntry: $APIMethod<EC2$20160401$ReplaceNetworkAclEntryRequest, void>;
    replaceRoute: $APIMethod<EC2$20160401$ReplaceRouteRequest, void>;
    replaceRouteTableAssociation: $APIMethod<EC2$20160401$ReplaceRouteTableAssociationRequest, EC2$20160401$ReplaceRouteTableAssociationResult>;
    reportInstanceStatus: $APIMethod<EC2$20160401$ReportInstanceStatusRequest, void>;
    requestSpotFleet: $APIMethod<EC2$20160401$RequestSpotFleetRequest, EC2$20160401$RequestSpotFleetResponse>;
    requestSpotInstances: $APIMethod<EC2$20160401$RequestSpotInstancesRequest, EC2$20160401$RequestSpotInstancesResult>;
    resetImageAttribute: $APIMethod<EC2$20160401$ResetImageAttributeRequest, void>;
    resetInstanceAttribute: $APIMethod<EC2$20160401$ResetInstanceAttributeRequest, void>;
    resetNetworkInterfaceAttribute: $APIMethod<EC2$20160401$ResetNetworkInterfaceAttributeRequest, void>;
    resetSnapshotAttribute: $APIMethod<EC2$20160401$ResetSnapshotAttributeRequest, void>;
    restoreAddressToClassic: $APIMethod<EC2$20160401$RestoreAddressToClassicRequest, EC2$20160401$RestoreAddressToClassicResult>;
    revokeSecurityGroupEgress: $APIMethod<EC2$20160401$RevokeSecurityGroupEgressRequest, void>;
    revokeSecurityGroupIngress: $APIMethod<EC2$20160401$RevokeSecurityGroupIngressRequest, void>;
    runInstances: $APIMethod<EC2$20160401$RunInstancesRequest, EC2$20160401$Reservation>;
    runScheduledInstances: $APIMethod<EC2$20160401$RunScheduledInstancesRequest, EC2$20160401$RunScheduledInstancesResult>;
    startInstances: $APIMethod<EC2$20160401$StartInstancesRequest, EC2$20160401$StartInstancesResult>;
    stopInstances: $APIMethod<EC2$20160401$StopInstancesRequest, EC2$20160401$StopInstancesResult>;
    terminateInstances: $APIMethod<EC2$20160401$TerminateInstancesRequest, EC2$20160401$TerminateInstancesResult>;
    unassignPrivateIpAddresses: $APIMethod<EC2$20160401$UnassignPrivateIpAddressesRequest, void>;
    unmonitorInstances: $APIMethod<EC2$20160401$UnmonitorInstancesRequest, EC2$20160401$UnmonitorInstancesResult>;
  }
  declare class EC2 {
    constructor(config: $ConfigOptions & {
      apiVersion: '2016-04-01';
    }): EC2$20160401;
    constructor(): EC2$20160401;
  }
  declare class ECR$20150921 {
    batchCheckLayerAvailability: $APIMethod<ECR$20150921$BatchCheckLayerAvailabilityRequest, ECR$20150921$BatchCheckLayerAvailabilityResponse>;
    batchDeleteImage: $APIMethod<ECR$20150921$BatchDeleteImageRequest, ECR$20150921$BatchDeleteImageResponse>;
    batchGetImage: $APIMethod<ECR$20150921$BatchGetImageRequest, ECR$20150921$BatchGetImageResponse>;
    completeLayerUpload: $APIMethod<ECR$20150921$CompleteLayerUploadRequest, ECR$20150921$CompleteLayerUploadResponse>;
    createRepository: $APIMethod<ECR$20150921$CreateRepositoryRequest, ECR$20150921$CreateRepositoryResponse>;
    deleteRepository: $APIMethod<ECR$20150921$DeleteRepositoryRequest, ECR$20150921$DeleteRepositoryResponse>;
    deleteRepositoryPolicy: $APIMethod<ECR$20150921$DeleteRepositoryPolicyRequest, ECR$20150921$DeleteRepositoryPolicyResponse>;
    describeRepositories: $APIMethod<ECR$20150921$DescribeRepositoriesRequest, ECR$20150921$DescribeRepositoriesResponse>;
    getAuthorizationToken: $APIMethod<ECR$20150921$GetAuthorizationTokenRequest, ECR$20150921$GetAuthorizationTokenResponse>;
    getDownloadUrlForLayer: $APIMethod<ECR$20150921$GetDownloadUrlForLayerRequest, ECR$20150921$GetDownloadUrlForLayerResponse>;
    getRepositoryPolicy: $APIMethod<ECR$20150921$GetRepositoryPolicyRequest, ECR$20150921$GetRepositoryPolicyResponse>;
    initiateLayerUpload: $APIMethod<ECR$20150921$InitiateLayerUploadRequest, ECR$20150921$InitiateLayerUploadResponse>;
    listImages: $APIMethod<ECR$20150921$ListImagesRequest, ECR$20150921$ListImagesResponse>;
    putImage: $APIMethod<ECR$20150921$PutImageRequest, ECR$20150921$PutImageResponse>;
    setRepositoryPolicy: $APIMethod<ECR$20150921$SetRepositoryPolicyRequest, ECR$20150921$SetRepositoryPolicyResponse>;
    uploadLayerPart: $APIMethod<ECR$20150921$UploadLayerPartRequest, ECR$20150921$UploadLayerPartResponse>;
  }
  declare class ECR {
    constructor(config: $ConfigOptions & {
      apiVersion: '2015-09-21';
    }): ECR$20150921;
    constructor(): ECR$20150921;
  }
  declare class ECS$20141113 {
    createCluster: $APIMethod<ECS$20141113$CreateClusterRequest, ECS$20141113$CreateClusterResponse>;
    createService: $APIMethod<ECS$20141113$CreateServiceRequest, ECS$20141113$CreateServiceResponse>;
    deleteCluster: $APIMethod<ECS$20141113$DeleteClusterRequest, ECS$20141113$DeleteClusterResponse>;
    deleteService: $APIMethod<ECS$20141113$DeleteServiceRequest, ECS$20141113$DeleteServiceResponse>;
    deregisterContainerInstance: $APIMethod<ECS$20141113$DeregisterContainerInstanceRequest, ECS$20141113$DeregisterContainerInstanceResponse>;
    deregisterTaskDefinition: $APIMethod<ECS$20141113$DeregisterTaskDefinitionRequest, ECS$20141113$DeregisterTaskDefinitionResponse>;
    describeClusters: $APIMethod<ECS$20141113$DescribeClustersRequest, ECS$20141113$DescribeClustersResponse>;
    describeContainerInstances: $APIMethod<ECS$20141113$DescribeContainerInstancesRequest, ECS$20141113$DescribeContainerInstancesResponse>;
    describeServices: $APIMethod<ECS$20141113$DescribeServicesRequest, ECS$20141113$DescribeServicesResponse>;
    describeTaskDefinition: $APIMethod<ECS$20141113$DescribeTaskDefinitionRequest, ECS$20141113$DescribeTaskDefinitionResponse>;
    describeTasks: $APIMethod<ECS$20141113$DescribeTasksRequest, ECS$20141113$DescribeTasksResponse>;
    discoverPollEndpoint: $APIMethod<ECS$20141113$DiscoverPollEndpointRequest, ECS$20141113$DiscoverPollEndpointResponse>;
    listClusters: $APIMethod<ECS$20141113$ListClustersRequest, ECS$20141113$ListClustersResponse>;
    listContainerInstances: $APIMethod<ECS$20141113$ListContainerInstancesRequest, ECS$20141113$ListContainerInstancesResponse>;
    listServices: $APIMethod<ECS$20141113$ListServicesRequest, ECS$20141113$ListServicesResponse>;
    listTaskDefinitionFamilies: $APIMethod<ECS$20141113$ListTaskDefinitionFamiliesRequest, ECS$20141113$ListTaskDefinitionFamiliesResponse>;
    listTaskDefinitions: $APIMethod<ECS$20141113$ListTaskDefinitionsRequest, ECS$20141113$ListTaskDefinitionsResponse>;
    listTasks: $APIMethod<ECS$20141113$ListTasksRequest, ECS$20141113$ListTasksResponse>;
    registerContainerInstance: $APIMethod<ECS$20141113$RegisterContainerInstanceRequest, ECS$20141113$RegisterContainerInstanceResponse>;
    registerTaskDefinition: $APIMethod<ECS$20141113$RegisterTaskDefinitionRequest, ECS$20141113$RegisterTaskDefinitionResponse>;
    runTask: $APIMethod<ECS$20141113$RunTaskRequest, ECS$20141113$RunTaskResponse>;
    startTask: $APIMethod<ECS$20141113$StartTaskRequest, ECS$20141113$StartTaskResponse>;
    stopTask: $APIMethod<ECS$20141113$StopTaskRequest, ECS$20141113$StopTaskResponse>;
    submitContainerStateChange: $APIMethod<ECS$20141113$SubmitContainerStateChangeRequest, ECS$20141113$SubmitContainerStateChangeResponse>;
    submitTaskStateChange: $APIMethod<ECS$20141113$SubmitTaskStateChangeRequest, ECS$20141113$SubmitTaskStateChangeResponse>;
    updateContainerAgent: $APIMethod<ECS$20141113$UpdateContainerAgentRequest, ECS$20141113$UpdateContainerAgentResponse>;
    updateService: $APIMethod<ECS$20141113$UpdateServiceRequest, ECS$20141113$UpdateServiceResponse>;
  }
  declare class ECS {
    constructor(config: $ConfigOptions & {
      apiVersion: '2014-11-13';
    }): ECS$20141113;
    constructor(): ECS$20141113;
  }
  declare class EFS$20150201 {
    createFileSystem: $APIMethod<EFS$20150201$CreateFileSystemRequest, EFS$20150201$FileSystemDescription>;
    createMountTarget: $APIMethod<EFS$20150201$CreateMountTargetRequest, EFS$20150201$MountTargetDescription>;
    createTags: $APIMethod<EFS$20150201$CreateTagsRequest, void>;
    deleteFileSystem: $APIMethod<EFS$20150201$DeleteFileSystemRequest, void>;
    deleteMountTarget: $APIMethod<EFS$20150201$DeleteMountTargetRequest, void>;
    deleteTags: $APIMethod<EFS$20150201$DeleteTagsRequest, void>;
    describeFileSystems: $APIMethod<EFS$20150201$DescribeFileSystemsRequest, EFS$20150201$DescribeFileSystemsResponse>;
    describeMountTargetSecurityGroups: $APIMethod<EFS$20150201$DescribeMountTargetSecurityGroupsRequest, EFS$20150201$DescribeMountTargetSecurityGroupsResponse>;
    describeMountTargets: $APIMethod<EFS$20150201$DescribeMountTargetsRequest, EFS$20150201$DescribeMountTargetsResponse>;
    describeTags: $APIMethod<EFS$20150201$DescribeTagsRequest, EFS$20150201$DescribeTagsResponse>;
    modifyMountTargetSecurityGroups: $APIMethod<EFS$20150201$ModifyMountTargetSecurityGroupsRequest, void>;
  }
  declare class EFS {
    constructor(config: $ConfigOptions & {
      apiVersion: '2015-02-01';
    }): EFS$20150201;
    constructor(): EFS$20150201;
  }
  declare class ElastiCache$20150202 {
    addTagsToResource: $APIMethod<ElastiCache$20150202$AddTagsToResourceMessage, ElastiCache$20150202$TagListMessage>;
    authorizeCacheSecurityGroupIngress: $APIMethod<ElastiCache$20150202$AuthorizeCacheSecurityGroupIngressMessage, ElastiCache$20150202$AuthorizeCacheSecurityGroupIngressResult>;
    copySnapshot: $APIMethod<ElastiCache$20150202$CopySnapshotMessage, ElastiCache$20150202$CopySnapshotResult>;
    createCacheCluster: $APIMethod<ElastiCache$20150202$CreateCacheClusterMessage, ElastiCache$20150202$CreateCacheClusterResult>;
    createCacheParameterGroup: $APIMethod<ElastiCache$20150202$CreateCacheParameterGroupMessage, ElastiCache$20150202$CreateCacheParameterGroupResult>;
    createCacheSecurityGroup: $APIMethod<ElastiCache$20150202$CreateCacheSecurityGroupMessage, ElastiCache$20150202$CreateCacheSecurityGroupResult>;
    createCacheSubnetGroup: $APIMethod<ElastiCache$20150202$CreateCacheSubnetGroupMessage, ElastiCache$20150202$CreateCacheSubnetGroupResult>;
    createReplicationGroup: $APIMethod<ElastiCache$20150202$CreateReplicationGroupMessage, ElastiCache$20150202$CreateReplicationGroupResult>;
    createSnapshot: $APIMethod<ElastiCache$20150202$CreateSnapshotMessage, ElastiCache$20150202$CreateSnapshotResult>;
    deleteCacheCluster: $APIMethod<ElastiCache$20150202$DeleteCacheClusterMessage, ElastiCache$20150202$DeleteCacheClusterResult>;
    deleteCacheParameterGroup: $APIMethod<ElastiCache$20150202$DeleteCacheParameterGroupMessage, void>;
    deleteCacheSecurityGroup: $APIMethod<ElastiCache$20150202$DeleteCacheSecurityGroupMessage, void>;
    deleteCacheSubnetGroup: $APIMethod<ElastiCache$20150202$DeleteCacheSubnetGroupMessage, void>;
    deleteReplicationGroup: $APIMethod<ElastiCache$20150202$DeleteReplicationGroupMessage, ElastiCache$20150202$DeleteReplicationGroupResult>;
    deleteSnapshot: $APIMethod<ElastiCache$20150202$DeleteSnapshotMessage, ElastiCache$20150202$DeleteSnapshotResult>;
    describeCacheClusters: $APIMethod<ElastiCache$20150202$DescribeCacheClustersMessage, ElastiCache$20150202$CacheClusterMessage>;
    describeCacheEngineVersions: $APIMethod<ElastiCache$20150202$DescribeCacheEngineVersionsMessage, ElastiCache$20150202$CacheEngineVersionMessage>;
    describeCacheParameterGroups: $APIMethod<ElastiCache$20150202$DescribeCacheParameterGroupsMessage, ElastiCache$20150202$CacheParameterGroupsMessage>;
    describeCacheParameters: $APIMethod<ElastiCache$20150202$DescribeCacheParametersMessage, ElastiCache$20150202$CacheParameterGroupDetails>;
    describeCacheSecurityGroups: $APIMethod<ElastiCache$20150202$DescribeCacheSecurityGroupsMessage, ElastiCache$20150202$CacheSecurityGroupMessage>;
    describeCacheSubnetGroups: $APIMethod<ElastiCache$20150202$DescribeCacheSubnetGroupsMessage, ElastiCache$20150202$CacheSubnetGroupMessage>;
    describeEngineDefaultParameters: $APIMethod<ElastiCache$20150202$DescribeEngineDefaultParametersMessage, ElastiCache$20150202$DescribeEngineDefaultParametersResult>;
    describeEvents: $APIMethod<ElastiCache$20150202$DescribeEventsMessage, ElastiCache$20150202$EventsMessage>;
    describeReplicationGroups: $APIMethod<ElastiCache$20150202$DescribeReplicationGroupsMessage, ElastiCache$20150202$ReplicationGroupMessage>;
    describeReservedCacheNodes: $APIMethod<ElastiCache$20150202$DescribeReservedCacheNodesMessage, ElastiCache$20150202$ReservedCacheNodeMessage>;
    describeReservedCacheNodesOfferings: $APIMethod<ElastiCache$20150202$DescribeReservedCacheNodesOfferingsMessage, ElastiCache$20150202$ReservedCacheNodesOfferingMessage>;
    describeSnapshots: $APIMethod<ElastiCache$20150202$DescribeSnapshotsMessage, ElastiCache$20150202$DescribeSnapshotsListMessage>;
    listAllowedNodeTypeModifications: $APIMethod<ElastiCache$20150202$ListAllowedNodeTypeModificationsMessage, ElastiCache$20150202$AllowedNodeTypeModificationsMessage>;
    listTagsForResource: $APIMethod<ElastiCache$20150202$ListTagsForResourceMessage, ElastiCache$20150202$TagListMessage>;
    modifyCacheCluster: $APIMethod<ElastiCache$20150202$ModifyCacheClusterMessage, ElastiCache$20150202$ModifyCacheClusterResult>;
    modifyCacheParameterGroup: $APIMethod<ElastiCache$20150202$ModifyCacheParameterGroupMessage, ElastiCache$20150202$CacheParameterGroupNameMessage>;
    modifyCacheSubnetGroup: $APIMethod<ElastiCache$20150202$ModifyCacheSubnetGroupMessage, ElastiCache$20150202$ModifyCacheSubnetGroupResult>;
    modifyReplicationGroup: $APIMethod<ElastiCache$20150202$ModifyReplicationGroupMessage, ElastiCache$20150202$ModifyReplicationGroupResult>;
    purchaseReservedCacheNodesOffering: $APIMethod<ElastiCache$20150202$PurchaseReservedCacheNodesOfferingMessage, ElastiCache$20150202$PurchaseReservedCacheNodesOfferingResult>;
    rebootCacheCluster: $APIMethod<ElastiCache$20150202$RebootCacheClusterMessage, ElastiCache$20150202$RebootCacheClusterResult>;
    removeTagsFromResource: $APIMethod<ElastiCache$20150202$RemoveTagsFromResourceMessage, ElastiCache$20150202$TagListMessage>;
    resetCacheParameterGroup: $APIMethod<ElastiCache$20150202$ResetCacheParameterGroupMessage, ElastiCache$20150202$CacheParameterGroupNameMessage>;
    revokeCacheSecurityGroupIngress: $APIMethod<ElastiCache$20150202$RevokeCacheSecurityGroupIngressMessage, ElastiCache$20150202$RevokeCacheSecurityGroupIngressResult>;
  }
  declare class ElastiCache {
    constructor(config: $ConfigOptions & {
      apiVersion: '2015-02-02';
    }): ElastiCache$20150202;
    constructor(): ElastiCache$20150202;
  }
  declare class ElasticBeanstalk$20101201 {
    abortEnvironmentUpdate: $APIMethod<ElasticBeanstalk$20101201$AbortEnvironmentUpdateMessage, void>;
    applyEnvironmentManagedAction: $APIMethod<ElasticBeanstalk$20101201$ApplyEnvironmentManagedActionRequest, ElasticBeanstalk$20101201$ApplyEnvironmentManagedActionResult>;
    checkDNSAvailability: $APIMethod<ElasticBeanstalk$20101201$CheckDNSAvailabilityMessage, ElasticBeanstalk$20101201$CheckDNSAvailabilityResultMessage>;
    composeEnvironments: $APIMethod<ElasticBeanstalk$20101201$ComposeEnvironmentsMessage, ElasticBeanstalk$20101201$EnvironmentDescriptionsMessage>;
    createApplication: $APIMethod<ElasticBeanstalk$20101201$CreateApplicationMessage, ElasticBeanstalk$20101201$ApplicationDescriptionMessage>;
    createApplicationVersion: $APIMethod<ElasticBeanstalk$20101201$CreateApplicationVersionMessage, ElasticBeanstalk$20101201$ApplicationVersionDescriptionMessage>;
    createConfigurationTemplate: $APIMethod<ElasticBeanstalk$20101201$CreateConfigurationTemplateMessage, ElasticBeanstalk$20101201$ConfigurationSettingsDescription>;
    createEnvironment: $APIMethod<ElasticBeanstalk$20101201$CreateEnvironmentMessage, ElasticBeanstalk$20101201$EnvironmentDescription>;
    createStorageLocation: $APIMethod<void, ElasticBeanstalk$20101201$CreateStorageLocationResultMessage>;
    deleteApplication: $APIMethod<ElasticBeanstalk$20101201$DeleteApplicationMessage, void>;
    deleteApplicationVersion: $APIMethod<ElasticBeanstalk$20101201$DeleteApplicationVersionMessage, void>;
    deleteConfigurationTemplate: $APIMethod<ElasticBeanstalk$20101201$DeleteConfigurationTemplateMessage, void>;
    deleteEnvironmentConfiguration: $APIMethod<ElasticBeanstalk$20101201$DeleteEnvironmentConfigurationMessage, void>;
    describeApplicationVersions: $APIMethod<ElasticBeanstalk$20101201$DescribeApplicationVersionsMessage, ElasticBeanstalk$20101201$ApplicationVersionDescriptionsMessage>;
    describeApplications: $APIMethod<ElasticBeanstalk$20101201$DescribeApplicationsMessage, ElasticBeanstalk$20101201$ApplicationDescriptionsMessage>;
    describeConfigurationOptions: $APIMethod<ElasticBeanstalk$20101201$DescribeConfigurationOptionsMessage, ElasticBeanstalk$20101201$ConfigurationOptionsDescription>;
    describeConfigurationSettings: $APIMethod<ElasticBeanstalk$20101201$DescribeConfigurationSettingsMessage, ElasticBeanstalk$20101201$ConfigurationSettingsDescriptions>;
    describeEnvironmentHealth: $APIMethod<ElasticBeanstalk$20101201$DescribeEnvironmentHealthRequest, ElasticBeanstalk$20101201$DescribeEnvironmentHealthResult>;
    describeEnvironmentManagedActionHistory: $APIMethod<ElasticBeanstalk$20101201$DescribeEnvironmentManagedActionHistoryRequest, ElasticBeanstalk$20101201$DescribeEnvironmentManagedActionHistoryResult>;
    describeEnvironmentManagedActions: $APIMethod<ElasticBeanstalk$20101201$DescribeEnvironmentManagedActionsRequest, ElasticBeanstalk$20101201$DescribeEnvironmentManagedActionsResult>;
    describeEnvironmentResources: $APIMethod<ElasticBeanstalk$20101201$DescribeEnvironmentResourcesMessage, ElasticBeanstalk$20101201$EnvironmentResourceDescriptionsMessage>;
    describeEnvironments: $APIMethod<ElasticBeanstalk$20101201$DescribeEnvironmentsMessage, ElasticBeanstalk$20101201$EnvironmentDescriptionsMessage>;
    describeEvents: $APIMethod<ElasticBeanstalk$20101201$DescribeEventsMessage, ElasticBeanstalk$20101201$EventDescriptionsMessage>;
    describeInstancesHealth: $APIMethod<ElasticBeanstalk$20101201$DescribeInstancesHealthRequest, ElasticBeanstalk$20101201$DescribeInstancesHealthResult>;
    listAvailableSolutionStacks: $APIMethod<void, ElasticBeanstalk$20101201$ListAvailableSolutionStacksResultMessage>;
    rebuildEnvironment: $APIMethod<ElasticBeanstalk$20101201$RebuildEnvironmentMessage, void>;
    requestEnvironmentInfo: $APIMethod<ElasticBeanstalk$20101201$RequestEnvironmentInfoMessage, void>;
    restartAppServer: $APIMethod<ElasticBeanstalk$20101201$RestartAppServerMessage, void>;
    retrieveEnvironmentInfo: $APIMethod<ElasticBeanstalk$20101201$RetrieveEnvironmentInfoMessage, ElasticBeanstalk$20101201$RetrieveEnvironmentInfoResultMessage>;
    swapEnvironmentCNAMEs: $APIMethod<ElasticBeanstalk$20101201$SwapEnvironmentCNAMEsMessage, void>;
    terminateEnvironment: $APIMethod<ElasticBeanstalk$20101201$TerminateEnvironmentMessage, ElasticBeanstalk$20101201$EnvironmentDescription>;
    updateApplication: $APIMethod<ElasticBeanstalk$20101201$UpdateApplicationMessage, ElasticBeanstalk$20101201$ApplicationDescriptionMessage>;
    updateApplicationVersion: $APIMethod<ElasticBeanstalk$20101201$UpdateApplicationVersionMessage, ElasticBeanstalk$20101201$ApplicationVersionDescriptionMessage>;
    updateConfigurationTemplate: $APIMethod<ElasticBeanstalk$20101201$UpdateConfigurationTemplateMessage, ElasticBeanstalk$20101201$ConfigurationSettingsDescription>;
    updateEnvironment: $APIMethod<ElasticBeanstalk$20101201$UpdateEnvironmentMessage, ElasticBeanstalk$20101201$EnvironmentDescription>;
    validateConfigurationSettings: $APIMethod<ElasticBeanstalk$20101201$ValidateConfigurationSettingsMessage, ElasticBeanstalk$20101201$ConfigurationSettingsValidationMessages>;
  }
  declare class ElasticBeanstalk {
    constructor(config: $ConfigOptions & {
      apiVersion: '2010-12-01';
    }): ElasticBeanstalk$20101201;
    constructor(): ElasticBeanstalk$20101201;
  }
  declare class ELB$20120601 {
    addTags: $APIMethod<ELB$20120601$AddTagsInput, ELB$20120601$AddTagsOutput>;
    applySecurityGroupsToLoadBalancer: $APIMethod<ELB$20120601$ApplySecurityGroupsToLoadBalancerInput, ELB$20120601$ApplySecurityGroupsToLoadBalancerOutput>;
    attachLoadBalancerToSubnets: $APIMethod<ELB$20120601$AttachLoadBalancerToSubnetsInput, ELB$20120601$AttachLoadBalancerToSubnetsOutput>;
    configureHealthCheck: $APIMethod<ELB$20120601$ConfigureHealthCheckInput, ELB$20120601$ConfigureHealthCheckOutput>;
    createAppCookieStickinessPolicy: $APIMethod<ELB$20120601$CreateAppCookieStickinessPolicyInput, ELB$20120601$CreateAppCookieStickinessPolicyOutput>;
    createLBCookieStickinessPolicy: $APIMethod<ELB$20120601$CreateLBCookieStickinessPolicyInput, ELB$20120601$CreateLBCookieStickinessPolicyOutput>;
    createLoadBalancer: $APIMethod<ELB$20120601$CreateAccessPointInput, ELB$20120601$CreateAccessPointOutput>;
    createLoadBalancerListeners: $APIMethod<ELB$20120601$CreateLoadBalancerListenerInput, ELB$20120601$CreateLoadBalancerListenerOutput>;
    createLoadBalancerPolicy: $APIMethod<ELB$20120601$CreateLoadBalancerPolicyInput, ELB$20120601$CreateLoadBalancerPolicyOutput>;
    deleteLoadBalancer: $APIMethod<ELB$20120601$DeleteAccessPointInput, ELB$20120601$DeleteAccessPointOutput>;
    deleteLoadBalancerListeners: $APIMethod<ELB$20120601$DeleteLoadBalancerListenerInput, ELB$20120601$DeleteLoadBalancerListenerOutput>;
    deleteLoadBalancerPolicy: $APIMethod<ELB$20120601$DeleteLoadBalancerPolicyInput, ELB$20120601$DeleteLoadBalancerPolicyOutput>;
    deregisterInstancesFromLoadBalancer: $APIMethod<ELB$20120601$DeregisterEndPointsInput, ELB$20120601$DeregisterEndPointsOutput>;
    describeInstanceHealth: $APIMethod<ELB$20120601$DescribeEndPointStateInput, ELB$20120601$DescribeEndPointStateOutput>;
    describeLoadBalancerAttributes: $APIMethod<ELB$20120601$DescribeLoadBalancerAttributesInput, ELB$20120601$DescribeLoadBalancerAttributesOutput>;
    describeLoadBalancerPolicies: $APIMethod<ELB$20120601$DescribeLoadBalancerPoliciesInput, ELB$20120601$DescribeLoadBalancerPoliciesOutput>;
    describeLoadBalancerPolicyTypes: $APIMethod<ELB$20120601$DescribeLoadBalancerPolicyTypesInput, ELB$20120601$DescribeLoadBalancerPolicyTypesOutput>;
    describeLoadBalancers: $APIMethod<ELB$20120601$DescribeAccessPointsInput, ELB$20120601$DescribeAccessPointsOutput>;
    describeTags: $APIMethod<ELB$20120601$DescribeTagsInput, ELB$20120601$DescribeTagsOutput>;
    detachLoadBalancerFromSubnets: $APIMethod<ELB$20120601$DetachLoadBalancerFromSubnetsInput, ELB$20120601$DetachLoadBalancerFromSubnetsOutput>;
    disableAvailabilityZonesForLoadBalancer: $APIMethod<ELB$20120601$RemoveAvailabilityZonesInput, ELB$20120601$RemoveAvailabilityZonesOutput>;
    enableAvailabilityZonesForLoadBalancer: $APIMethod<ELB$20120601$AddAvailabilityZonesInput, ELB$20120601$AddAvailabilityZonesOutput>;
    modifyLoadBalancerAttributes: $APIMethod<ELB$20120601$ModifyLoadBalancerAttributesInput, ELB$20120601$ModifyLoadBalancerAttributesOutput>;
    registerInstancesWithLoadBalancer: $APIMethod<ELB$20120601$RegisterEndPointsInput, ELB$20120601$RegisterEndPointsOutput>;
    removeTags: $APIMethod<ELB$20120601$RemoveTagsInput, ELB$20120601$RemoveTagsOutput>;
    setLoadBalancerListenerSSLCertificate: $APIMethod<ELB$20120601$SetLoadBalancerListenerSSLCertificateInput, ELB$20120601$SetLoadBalancerListenerSSLCertificateOutput>;
    setLoadBalancerPoliciesForBackendServer: $APIMethod<ELB$20120601$SetLoadBalancerPoliciesForBackendServerInput, ELB$20120601$SetLoadBalancerPoliciesForBackendServerOutput>;
    setLoadBalancerPoliciesOfListener: $APIMethod<ELB$20120601$SetLoadBalancerPoliciesOfListenerInput, ELB$20120601$SetLoadBalancerPoliciesOfListenerOutput>;
  }
  declare class ELB {
    constructor(config: $ConfigOptions & {
      apiVersion: '2012-06-01';
    }): ELB$20120601;
    constructor(): ELB$20120601;
  }
  declare class ELBv2$20151201 {
    addTags: $APIMethod<ELBv2$20151201$AddTagsInput, ELBv2$20151201$AddTagsOutput>;
    createListener: $APIMethod<ELBv2$20151201$CreateListenerInput, ELBv2$20151201$CreateListenerOutput>;
    createLoadBalancer: $APIMethod<ELBv2$20151201$CreateLoadBalancerInput, ELBv2$20151201$CreateLoadBalancerOutput>;
    createRule: $APIMethod<ELBv2$20151201$CreateRuleInput, ELBv2$20151201$CreateRuleOutput>;
    createTargetGroup: $APIMethod<ELBv2$20151201$CreateTargetGroupInput, ELBv2$20151201$CreateTargetGroupOutput>;
    deleteListener: $APIMethod<ELBv2$20151201$DeleteListenerInput, ELBv2$20151201$DeleteListenerOutput>;
    deleteLoadBalancer: $APIMethod<ELBv2$20151201$DeleteLoadBalancerInput, ELBv2$20151201$DeleteLoadBalancerOutput>;
    deleteRule: $APIMethod<ELBv2$20151201$DeleteRuleInput, ELBv2$20151201$DeleteRuleOutput>;
    deleteTargetGroup: $APIMethod<ELBv2$20151201$DeleteTargetGroupInput, ELBv2$20151201$DeleteTargetGroupOutput>;
    deregisterTargets: $APIMethod<ELBv2$20151201$DeregisterTargetsInput, ELBv2$20151201$DeregisterTargetsOutput>;
    describeListeners: $APIMethod<ELBv2$20151201$DescribeListenersInput, ELBv2$20151201$DescribeListenersOutput>;
    describeLoadBalancerAttributes: $APIMethod<ELBv2$20151201$DescribeLoadBalancerAttributesInput, ELBv2$20151201$DescribeLoadBalancerAttributesOutput>;
    describeLoadBalancers: $APIMethod<ELBv2$20151201$DescribeLoadBalancersInput, ELBv2$20151201$DescribeLoadBalancersOutput>;
    describeRules: $APIMethod<ELBv2$20151201$DescribeRulesInput, ELBv2$20151201$DescribeRulesOutput>;
    describeSSLPolicies: $APIMethod<ELBv2$20151201$DescribeSSLPoliciesInput, ELBv2$20151201$DescribeSSLPoliciesOutput>;
    describeTags: $APIMethod<ELBv2$20151201$DescribeTagsInput, ELBv2$20151201$DescribeTagsOutput>;
    describeTargetGroupAttributes: $APIMethod<ELBv2$20151201$DescribeTargetGroupAttributesInput, ELBv2$20151201$DescribeTargetGroupAttributesOutput>;
    describeTargetGroups: $APIMethod<ELBv2$20151201$DescribeTargetGroupsInput, ELBv2$20151201$DescribeTargetGroupsOutput>;
    describeTargetHealth: $APIMethod<ELBv2$20151201$DescribeTargetHealthInput, ELBv2$20151201$DescribeTargetHealthOutput>;
    modifyListener: $APIMethod<ELBv2$20151201$ModifyListenerInput, ELBv2$20151201$ModifyListenerOutput>;
    modifyLoadBalancerAttributes: $APIMethod<ELBv2$20151201$ModifyLoadBalancerAttributesInput, ELBv2$20151201$ModifyLoadBalancerAttributesOutput>;
    modifyRule: $APIMethod<ELBv2$20151201$ModifyRuleInput, ELBv2$20151201$ModifyRuleOutput>;
    modifyTargetGroup: $APIMethod<ELBv2$20151201$ModifyTargetGroupInput, ELBv2$20151201$ModifyTargetGroupOutput>;
    modifyTargetGroupAttributes: $APIMethod<ELBv2$20151201$ModifyTargetGroupAttributesInput, ELBv2$20151201$ModifyTargetGroupAttributesOutput>;
    registerTargets: $APIMethod<ELBv2$20151201$RegisterTargetsInput, ELBv2$20151201$RegisterTargetsOutput>;
    removeTags: $APIMethod<ELBv2$20151201$RemoveTagsInput, ELBv2$20151201$RemoveTagsOutput>;
    setRulePriorities: $APIMethod<ELBv2$20151201$SetRulePrioritiesInput, ELBv2$20151201$SetRulePrioritiesOutput>;
    setSecurityGroups: $APIMethod<ELBv2$20151201$SetSecurityGroupsInput, ELBv2$20151201$SetSecurityGroupsOutput>;
    setSubnets: $APIMethod<ELBv2$20151201$SetSubnetsInput, ELBv2$20151201$SetSubnetsOutput>;
  }
  declare class ELBv2 {
    constructor(config: $ConfigOptions & {
      apiVersion: '2015-12-01';
    }): ELBv2$20151201;
    constructor(): ELBv2$20151201;
  }
  declare class EMR$20090331 {
    addInstanceGroups: $APIMethod<EMR$20090331$AddInstanceGroupsInput, EMR$20090331$AddInstanceGroupsOutput>;
    addJobFlowSteps: $APIMethod<EMR$20090331$AddJobFlowStepsInput, EMR$20090331$AddJobFlowStepsOutput>;
    addTags: $APIMethod<EMR$20090331$AddTagsInput, EMR$20090331$AddTagsOutput>;
    describeCluster: $APIMethod<EMR$20090331$DescribeClusterInput, EMR$20090331$DescribeClusterOutput>;
    describeJobFlows: $APIMethod<EMR$20090331$DescribeJobFlowsInput, EMR$20090331$DescribeJobFlowsOutput>;
    describeStep: $APIMethod<EMR$20090331$DescribeStepInput, EMR$20090331$DescribeStepOutput>;
    listBootstrapActions: $APIMethod<EMR$20090331$ListBootstrapActionsInput, EMR$20090331$ListBootstrapActionsOutput>;
    listClusters: $APIMethod<EMR$20090331$ListClustersInput, EMR$20090331$ListClustersOutput>;
    listInstanceGroups: $APIMethod<EMR$20090331$ListInstanceGroupsInput, EMR$20090331$ListInstanceGroupsOutput>;
    listInstances: $APIMethod<EMR$20090331$ListInstancesInput, EMR$20090331$ListInstancesOutput>;
    listSteps: $APIMethod<EMR$20090331$ListStepsInput, EMR$20090331$ListStepsOutput>;
    modifyInstanceGroups: $APIMethod<EMR$20090331$ModifyInstanceGroupsInput, void>;
    removeTags: $APIMethod<EMR$20090331$RemoveTagsInput, EMR$20090331$RemoveTagsOutput>;
    runJobFlow: $APIMethod<EMR$20090331$RunJobFlowInput, EMR$20090331$RunJobFlowOutput>;
    setTerminationProtection: $APIMethod<EMR$20090331$SetTerminationProtectionInput, void>;
    setVisibleToAllUsers: $APIMethod<EMR$20090331$SetVisibleToAllUsersInput, void>;
    terminateJobFlows: $APIMethod<EMR$20090331$TerminateJobFlowsInput, void>;
  }
  declare class EMR {
    constructor(config: $ConfigOptions & {
      apiVersion: '2009-03-31';
    }): EMR$20090331;
    constructor(): EMR$20090331;
  }
  declare class ES$20150101 {
    addTags: $APIMethod<ES$20150101$AddTagsRequest, void>;
    createElasticsearchDomain: $APIMethod<ES$20150101$CreateElasticsearchDomainRequest, ES$20150101$CreateElasticsearchDomainResponse>;
    deleteElasticsearchDomain: $APIMethod<ES$20150101$DeleteElasticsearchDomainRequest, ES$20150101$DeleteElasticsearchDomainResponse>;
    describeElasticsearchDomain: $APIMethod<ES$20150101$DescribeElasticsearchDomainRequest, ES$20150101$DescribeElasticsearchDomainResponse>;
    describeElasticsearchDomainConfig: $APIMethod<ES$20150101$DescribeElasticsearchDomainConfigRequest, ES$20150101$DescribeElasticsearchDomainConfigResponse>;
    describeElasticsearchDomains: $APIMethod<ES$20150101$DescribeElasticsearchDomainsRequest, ES$20150101$DescribeElasticsearchDomainsResponse>;
    listDomainNames: $APIMethod<void, ES$20150101$ListDomainNamesResponse>;
    listTags: $APIMethod<ES$20150101$ListTagsRequest, ES$20150101$ListTagsResponse>;
    removeTags: $APIMethod<ES$20150101$RemoveTagsRequest, void>;
    updateElasticsearchDomainConfig: $APIMethod<ES$20150101$UpdateElasticsearchDomainConfigRequest, ES$20150101$UpdateElasticsearchDomainConfigResponse>;
  }
  declare class ES {
    constructor(config: $ConfigOptions & {
      apiVersion: '2015-01-01';
    }): ES$20150101;
    constructor(): ES$20150101;
  }
  declare class ElasticTranscoder$20120925 {
    cancelJob: $APIMethod<ElasticTranscoder$20120925$CancelJobRequest, ElasticTranscoder$20120925$CancelJobResponse>;
    createJob: $APIMethod<ElasticTranscoder$20120925$CreateJobRequest, ElasticTranscoder$20120925$CreateJobResponse>;
    createPipeline: $APIMethod<ElasticTranscoder$20120925$CreatePipelineRequest, ElasticTranscoder$20120925$CreatePipelineResponse>;
    createPreset: $APIMethod<ElasticTranscoder$20120925$CreatePresetRequest, ElasticTranscoder$20120925$CreatePresetResponse>;
    deletePipeline: $APIMethod<ElasticTranscoder$20120925$DeletePipelineRequest, ElasticTranscoder$20120925$DeletePipelineResponse>;
    deletePreset: $APIMethod<ElasticTranscoder$20120925$DeletePresetRequest, ElasticTranscoder$20120925$DeletePresetResponse>;
    listJobsByPipeline: $APIMethod<ElasticTranscoder$20120925$ListJobsByPipelineRequest, ElasticTranscoder$20120925$ListJobsByPipelineResponse>;
    listJobsByStatus: $APIMethod<ElasticTranscoder$20120925$ListJobsByStatusRequest, ElasticTranscoder$20120925$ListJobsByStatusResponse>;
    listPipelines: $APIMethod<ElasticTranscoder$20120925$ListPipelinesRequest, ElasticTranscoder$20120925$ListPipelinesResponse>;
    listPresets: $APIMethod<ElasticTranscoder$20120925$ListPresetsRequest, ElasticTranscoder$20120925$ListPresetsResponse>;
    readJob: $APIMethod<ElasticTranscoder$20120925$ReadJobRequest, ElasticTranscoder$20120925$ReadJobResponse>;
    readPipeline: $APIMethod<ElasticTranscoder$20120925$ReadPipelineRequest, ElasticTranscoder$20120925$ReadPipelineResponse>;
    readPreset: $APIMethod<ElasticTranscoder$20120925$ReadPresetRequest, ElasticTranscoder$20120925$ReadPresetResponse>;
    testRole: $APIMethod<ElasticTranscoder$20120925$TestRoleRequest, ElasticTranscoder$20120925$TestRoleResponse>;
    updatePipeline: $APIMethod<ElasticTranscoder$20120925$UpdatePipelineRequest, ElasticTranscoder$20120925$UpdatePipelineResponse>;
    updatePipelineNotifications: $APIMethod<ElasticTranscoder$20120925$UpdatePipelineNotificationsRequest, ElasticTranscoder$20120925$UpdatePipelineNotificationsResponse>;
    updatePipelineStatus: $APIMethod<ElasticTranscoder$20120925$UpdatePipelineStatusRequest, ElasticTranscoder$20120925$UpdatePipelineStatusResponse>;
  }
  declare class ElasticTranscoder {
    constructor(config: $ConfigOptions & {
      apiVersion: '2012-09-25';
    }): ElasticTranscoder$20120925;
    constructor(): ElasticTranscoder$20120925;
  }
  declare class Firehose$20150804 {
    createDeliveryStream: $APIMethod<Firehose$20150804$CreateDeliveryStreamInput, Firehose$20150804$CreateDeliveryStreamOutput>;
    deleteDeliveryStream: $APIMethod<Firehose$20150804$DeleteDeliveryStreamInput, Firehose$20150804$DeleteDeliveryStreamOutput>;
    describeDeliveryStream: $APIMethod<Firehose$20150804$DescribeDeliveryStreamInput, Firehose$20150804$DescribeDeliveryStreamOutput>;
    listDeliveryStreams: $APIMethod<Firehose$20150804$ListDeliveryStreamsInput, Firehose$20150804$ListDeliveryStreamsOutput>;
    putRecord: $APIMethod<Firehose$20150804$PutRecordInput, Firehose$20150804$PutRecordOutput>;
    putRecordBatch: $APIMethod<Firehose$20150804$PutRecordBatchInput, Firehose$20150804$PutRecordBatchOutput>;
    updateDestination: $APIMethod<Firehose$20150804$UpdateDestinationInput, Firehose$20150804$UpdateDestinationOutput>;
  }
  declare class Firehose {
    constructor(config: $ConfigOptions & {
      apiVersion: '2015-08-04';
    }): Firehose$20150804;
    constructor(): Firehose$20150804;
  }
  declare class GameLift$20151001 {
    createAlias: $APIMethod<GameLift$20151001$CreateAliasInput, GameLift$20151001$CreateAliasOutput>;
    createBuild: $APIMethod<GameLift$20151001$CreateBuildInput, GameLift$20151001$CreateBuildOutput>;
    createFleet: $APIMethod<GameLift$20151001$CreateFleetInput, GameLift$20151001$CreateFleetOutput>;
    createGameSession: $APIMethod<GameLift$20151001$CreateGameSessionInput, GameLift$20151001$CreateGameSessionOutput>;
    createPlayerSession: $APIMethod<GameLift$20151001$CreatePlayerSessionInput, GameLift$20151001$CreatePlayerSessionOutput>;
    createPlayerSessions: $APIMethod<GameLift$20151001$CreatePlayerSessionsInput, GameLift$20151001$CreatePlayerSessionsOutput>;
    deleteAlias: $APIMethod<GameLift$20151001$DeleteAliasInput, void>;
    deleteBuild: $APIMethod<GameLift$20151001$DeleteBuildInput, void>;
    deleteFleet: $APIMethod<GameLift$20151001$DeleteFleetInput, void>;
    deleteScalingPolicy: $APIMethod<GameLift$20151001$DeleteScalingPolicyInput, void>;
    describeAlias: $APIMethod<GameLift$20151001$DescribeAliasInput, GameLift$20151001$DescribeAliasOutput>;
    describeBuild: $APIMethod<GameLift$20151001$DescribeBuildInput, GameLift$20151001$DescribeBuildOutput>;
    describeEC2InstanceLimits: $APIMethod<GameLift$20151001$DescribeEC2InstanceLimitsInput, GameLift$20151001$DescribeEC2InstanceLimitsOutput>;
    describeFleetAttributes: $APIMethod<GameLift$20151001$DescribeFleetAttributesInput, GameLift$20151001$DescribeFleetAttributesOutput>;
    describeFleetCapacity: $APIMethod<GameLift$20151001$DescribeFleetCapacityInput, GameLift$20151001$DescribeFleetCapacityOutput>;
    describeFleetEvents: $APIMethod<GameLift$20151001$DescribeFleetEventsInput, GameLift$20151001$DescribeFleetEventsOutput>;
    describeFleetPortSettings: $APIMethod<GameLift$20151001$DescribeFleetPortSettingsInput, GameLift$20151001$DescribeFleetPortSettingsOutput>;
    describeFleetUtilization: $APIMethod<GameLift$20151001$DescribeFleetUtilizationInput, GameLift$20151001$DescribeFleetUtilizationOutput>;
    describeGameSessionDetails: $APIMethod<GameLift$20151001$DescribeGameSessionDetailsInput, GameLift$20151001$DescribeGameSessionDetailsOutput>;
    describeGameSessions: $APIMethod<GameLift$20151001$DescribeGameSessionsInput, GameLift$20151001$DescribeGameSessionsOutput>;
    describePlayerSessions: $APIMethod<GameLift$20151001$DescribePlayerSessionsInput, GameLift$20151001$DescribePlayerSessionsOutput>;
    describeRuntimeConfiguration: $APIMethod<GameLift$20151001$DescribeRuntimeConfigurationInput, GameLift$20151001$DescribeRuntimeConfigurationOutput>;
    describeScalingPolicies: $APIMethod<GameLift$20151001$DescribeScalingPoliciesInput, GameLift$20151001$DescribeScalingPoliciesOutput>;
    getGameSessionLogUrl: $APIMethod<GameLift$20151001$GetGameSessionLogUrlInput, GameLift$20151001$GetGameSessionLogUrlOutput>;
    listAliases: $APIMethod<GameLift$20151001$ListAliasesInput, GameLift$20151001$ListAliasesOutput>;
    listBuilds: $APIMethod<GameLift$20151001$ListBuildsInput, GameLift$20151001$ListBuildsOutput>;
    listFleets: $APIMethod<GameLift$20151001$ListFleetsInput, GameLift$20151001$ListFleetsOutput>;
    putScalingPolicy: $APIMethod<GameLift$20151001$PutScalingPolicyInput, GameLift$20151001$PutScalingPolicyOutput>;
    requestUploadCredentials: $APIMethod<GameLift$20151001$RequestUploadCredentialsInput, GameLift$20151001$RequestUploadCredentialsOutput>;
    resolveAlias: $APIMethod<GameLift$20151001$ResolveAliasInput, GameLift$20151001$ResolveAliasOutput>;
    searchGameSessions: $APIMethod<GameLift$20151001$SearchGameSessionsInput, GameLift$20151001$SearchGameSessionsOutput>;
    updateAlias: $APIMethod<GameLift$20151001$UpdateAliasInput, GameLift$20151001$UpdateAliasOutput>;
    updateBuild: $APIMethod<GameLift$20151001$UpdateBuildInput, GameLift$20151001$UpdateBuildOutput>;
    updateFleetAttributes: $APIMethod<GameLift$20151001$UpdateFleetAttributesInput, GameLift$20151001$UpdateFleetAttributesOutput>;
    updateFleetCapacity: $APIMethod<GameLift$20151001$UpdateFleetCapacityInput, GameLift$20151001$UpdateFleetCapacityOutput>;
    updateFleetPortSettings: $APIMethod<GameLift$20151001$UpdateFleetPortSettingsInput, GameLift$20151001$UpdateFleetPortSettingsOutput>;
    updateGameSession: $APIMethod<GameLift$20151001$UpdateGameSessionInput, GameLift$20151001$UpdateGameSessionOutput>;
    updateRuntimeConfiguration: $APIMethod<GameLift$20151001$UpdateRuntimeConfigurationInput, GameLift$20151001$UpdateRuntimeConfigurationOutput>;
  }
  declare class GameLift {
    constructor(config: $ConfigOptions & {
      apiVersion: '2015-10-01';
    }): GameLift$20151001;
    constructor(): GameLift$20151001;
  }
  declare class Glacier$20120601 {
    abortMultipartUpload: $APIMethod<Glacier$20120601$AbortMultipartUploadInput, void>;
    abortVaultLock: $APIMethod<Glacier$20120601$AbortVaultLockInput, void>;
    addTagsToVault: $APIMethod<Glacier$20120601$AddTagsToVaultInput, void>;
    completeMultipartUpload: $APIMethod<Glacier$20120601$CompleteMultipartUploadInput, Glacier$20120601$ArchiveCreationOutput>;
    completeVaultLock: $APIMethod<Glacier$20120601$CompleteVaultLockInput, void>;
    createVault: $APIMethod<Glacier$20120601$CreateVaultInput, Glacier$20120601$CreateVaultOutput>;
    deleteArchive: $APIMethod<Glacier$20120601$DeleteArchiveInput, void>;
    deleteVault: $APIMethod<Glacier$20120601$DeleteVaultInput, void>;
    deleteVaultAccessPolicy: $APIMethod<Glacier$20120601$DeleteVaultAccessPolicyInput, void>;
    deleteVaultNotifications: $APIMethod<Glacier$20120601$DeleteVaultNotificationsInput, void>;
    describeJob: $APIMethod<Glacier$20120601$DescribeJobInput, Glacier$20120601$GlacierJobDescription>;
    describeVault: $APIMethod<Glacier$20120601$DescribeVaultInput, Glacier$20120601$DescribeVaultOutput>;
    getDataRetrievalPolicy: $APIMethod<Glacier$20120601$GetDataRetrievalPolicyInput, Glacier$20120601$GetDataRetrievalPolicyOutput>;
    getJobOutput: $APIMethod<Glacier$20120601$GetJobOutputInput, Glacier$20120601$GetJobOutputOutput>;
    getVaultAccessPolicy: $APIMethod<Glacier$20120601$GetVaultAccessPolicyInput, Glacier$20120601$GetVaultAccessPolicyOutput>;
    getVaultLock: $APIMethod<Glacier$20120601$GetVaultLockInput, Glacier$20120601$GetVaultLockOutput>;
    getVaultNotifications: $APIMethod<Glacier$20120601$GetVaultNotificationsInput, Glacier$20120601$GetVaultNotificationsOutput>;
    initiateJob: $APIMethod<Glacier$20120601$InitiateJobInput, Glacier$20120601$InitiateJobOutput>;
    initiateMultipartUpload: $APIMethod<Glacier$20120601$InitiateMultipartUploadInput, Glacier$20120601$InitiateMultipartUploadOutput>;
    initiateVaultLock: $APIMethod<Glacier$20120601$InitiateVaultLockInput, Glacier$20120601$InitiateVaultLockOutput>;
    listJobs: $APIMethod<Glacier$20120601$ListJobsInput, Glacier$20120601$ListJobsOutput>;
    listMultipartUploads: $APIMethod<Glacier$20120601$ListMultipartUploadsInput, Glacier$20120601$ListMultipartUploadsOutput>;
    listParts: $APIMethod<Glacier$20120601$ListPartsInput, Glacier$20120601$ListPartsOutput>;
    listTagsForVault: $APIMethod<Glacier$20120601$ListTagsForVaultInput, Glacier$20120601$ListTagsForVaultOutput>;
    listVaults: $APIMethod<Glacier$20120601$ListVaultsInput, Glacier$20120601$ListVaultsOutput>;
    removeTagsFromVault: $APIMethod<Glacier$20120601$RemoveTagsFromVaultInput, void>;
    setDataRetrievalPolicy: $APIMethod<Glacier$20120601$SetDataRetrievalPolicyInput, void>;
    setVaultAccessPolicy: $APIMethod<Glacier$20120601$SetVaultAccessPolicyInput, void>;
    setVaultNotifications: $APIMethod<Glacier$20120601$SetVaultNotificationsInput, void>;
    uploadArchive: $APIMethod<Glacier$20120601$UploadArchiveInput, Glacier$20120601$ArchiveCreationOutput>;
    uploadMultipartPart: $APIMethod<Glacier$20120601$UploadMultipartPartInput, Glacier$20120601$UploadMultipartPartOutput>;
  }
  declare class Glacier {
    constructor(config: $ConfigOptions & {
      apiVersion: '2012-06-01';
    }): Glacier$20120601;
    constructor(): Glacier$20120601;
  }
  declare class IAM$20100508 {
    addClientIDToOpenIDConnectProvider: $APIMethod<IAM$20100508$AddClientIDToOpenIDConnectProviderRequest, void>;
    addRoleToInstanceProfile: $APIMethod<IAM$20100508$AddRoleToInstanceProfileRequest, void>;
    addUserToGroup: $APIMethod<IAM$20100508$AddUserToGroupRequest, void>;
    attachGroupPolicy: $APIMethod<IAM$20100508$AttachGroupPolicyRequest, void>;
    attachRolePolicy: $APIMethod<IAM$20100508$AttachRolePolicyRequest, void>;
    attachUserPolicy: $APIMethod<IAM$20100508$AttachUserPolicyRequest, void>;
    changePassword: $APIMethod<IAM$20100508$ChangePasswordRequest, void>;
    createAccessKey: $APIMethod<IAM$20100508$CreateAccessKeyRequest, IAM$20100508$CreateAccessKeyResponse>;
    createAccountAlias: $APIMethod<IAM$20100508$CreateAccountAliasRequest, void>;
    createGroup: $APIMethod<IAM$20100508$CreateGroupRequest, IAM$20100508$CreateGroupResponse>;
    createInstanceProfile: $APIMethod<IAM$20100508$CreateInstanceProfileRequest, IAM$20100508$CreateInstanceProfileResponse>;
    createLoginProfile: $APIMethod<IAM$20100508$CreateLoginProfileRequest, IAM$20100508$CreateLoginProfileResponse>;
    createOpenIDConnectProvider: $APIMethod<IAM$20100508$CreateOpenIDConnectProviderRequest, IAM$20100508$CreateOpenIDConnectProviderResponse>;
    createPolicy: $APIMethod<IAM$20100508$CreatePolicyRequest, IAM$20100508$CreatePolicyResponse>;
    createPolicyVersion: $APIMethod<IAM$20100508$CreatePolicyVersionRequest, IAM$20100508$CreatePolicyVersionResponse>;
    createRole: $APIMethod<IAM$20100508$CreateRoleRequest, IAM$20100508$CreateRoleResponse>;
    createSAMLProvider: $APIMethod<IAM$20100508$CreateSAMLProviderRequest, IAM$20100508$CreateSAMLProviderResponse>;
    createUser: $APIMethod<IAM$20100508$CreateUserRequest, IAM$20100508$CreateUserResponse>;
    createVirtualMFADevice: $APIMethod<IAM$20100508$CreateVirtualMFADeviceRequest, IAM$20100508$CreateVirtualMFADeviceResponse>;
    deactivateMFADevice: $APIMethod<IAM$20100508$DeactivateMFADeviceRequest, void>;
    deleteAccessKey: $APIMethod<IAM$20100508$DeleteAccessKeyRequest, void>;
    deleteAccountAlias: $APIMethod<IAM$20100508$DeleteAccountAliasRequest, void>;
    deleteAccountPasswordPolicy: $APIMethod<void, void>;
    deleteGroup: $APIMethod<IAM$20100508$DeleteGroupRequest, void>;
    deleteGroupPolicy: $APIMethod<IAM$20100508$DeleteGroupPolicyRequest, void>;
    deleteInstanceProfile: $APIMethod<IAM$20100508$DeleteInstanceProfileRequest, void>;
    deleteLoginProfile: $APIMethod<IAM$20100508$DeleteLoginProfileRequest, void>;
    deleteOpenIDConnectProvider: $APIMethod<IAM$20100508$DeleteOpenIDConnectProviderRequest, void>;
    deletePolicy: $APIMethod<IAM$20100508$DeletePolicyRequest, void>;
    deletePolicyVersion: $APIMethod<IAM$20100508$DeletePolicyVersionRequest, void>;
    deleteRole: $APIMethod<IAM$20100508$DeleteRoleRequest, void>;
    deleteRolePolicy: $APIMethod<IAM$20100508$DeleteRolePolicyRequest, void>;
    deleteSAMLProvider: $APIMethod<IAM$20100508$DeleteSAMLProviderRequest, void>;
    deleteSSHPublicKey: $APIMethod<IAM$20100508$DeleteSSHPublicKeyRequest, void>;
    deleteServerCertificate: $APIMethod<IAM$20100508$DeleteServerCertificateRequest, void>;
    deleteSigningCertificate: $APIMethod<IAM$20100508$DeleteSigningCertificateRequest, void>;
    deleteUser: $APIMethod<IAM$20100508$DeleteUserRequest, void>;
    deleteUserPolicy: $APIMethod<IAM$20100508$DeleteUserPolicyRequest, void>;
    deleteVirtualMFADevice: $APIMethod<IAM$20100508$DeleteVirtualMFADeviceRequest, void>;
    detachGroupPolicy: $APIMethod<IAM$20100508$DetachGroupPolicyRequest, void>;
    detachRolePolicy: $APIMethod<IAM$20100508$DetachRolePolicyRequest, void>;
    detachUserPolicy: $APIMethod<IAM$20100508$DetachUserPolicyRequest, void>;
    enableMFADevice: $APIMethod<IAM$20100508$EnableMFADeviceRequest, void>;
    generateCredentialReport: $APIMethod<void, IAM$20100508$GenerateCredentialReportResponse>;
    getAccessKeyLastUsed: $APIMethod<IAM$20100508$GetAccessKeyLastUsedRequest, IAM$20100508$GetAccessKeyLastUsedResponse>;
    getAccountAuthorizationDetails: $APIMethod<IAM$20100508$GetAccountAuthorizationDetailsRequest, IAM$20100508$GetAccountAuthorizationDetailsResponse>;
    getAccountPasswordPolicy: $APIMethod<void, IAM$20100508$GetAccountPasswordPolicyResponse>;
    getAccountSummary: $APIMethod<void, IAM$20100508$GetAccountSummaryResponse>;
    getContextKeysForCustomPolicy: $APIMethod<IAM$20100508$GetContextKeysForCustomPolicyRequest, IAM$20100508$GetContextKeysForPolicyResponse>;
    getContextKeysForPrincipalPolicy: $APIMethod<IAM$20100508$GetContextKeysForPrincipalPolicyRequest, IAM$20100508$GetContextKeysForPolicyResponse>;
    getCredentialReport: $APIMethod<void, IAM$20100508$GetCredentialReportResponse>;
    getGroup: $APIMethod<IAM$20100508$GetGroupRequest, IAM$20100508$GetGroupResponse>;
    getGroupPolicy: $APIMethod<IAM$20100508$GetGroupPolicyRequest, IAM$20100508$GetGroupPolicyResponse>;
    getInstanceProfile: $APIMethod<IAM$20100508$GetInstanceProfileRequest, IAM$20100508$GetInstanceProfileResponse>;
    getLoginProfile: $APIMethod<IAM$20100508$GetLoginProfileRequest, IAM$20100508$GetLoginProfileResponse>;
    getOpenIDConnectProvider: $APIMethod<IAM$20100508$GetOpenIDConnectProviderRequest, IAM$20100508$GetOpenIDConnectProviderResponse>;
    getPolicy: $APIMethod<IAM$20100508$GetPolicyRequest, IAM$20100508$GetPolicyResponse>;
    getPolicyVersion: $APIMethod<IAM$20100508$GetPolicyVersionRequest, IAM$20100508$GetPolicyVersionResponse>;
    getRole: $APIMethod<IAM$20100508$GetRoleRequest, IAM$20100508$GetRoleResponse>;
    getRolePolicy: $APIMethod<IAM$20100508$GetRolePolicyRequest, IAM$20100508$GetRolePolicyResponse>;
    getSAMLProvider: $APIMethod<IAM$20100508$GetSAMLProviderRequest, IAM$20100508$GetSAMLProviderResponse>;
    getSSHPublicKey: $APIMethod<IAM$20100508$GetSSHPublicKeyRequest, IAM$20100508$GetSSHPublicKeyResponse>;
    getServerCertificate: $APIMethod<IAM$20100508$GetServerCertificateRequest, IAM$20100508$GetServerCertificateResponse>;
    getUser: $APIMethod<IAM$20100508$GetUserRequest, IAM$20100508$GetUserResponse>;
    getUserPolicy: $APIMethod<IAM$20100508$GetUserPolicyRequest, IAM$20100508$GetUserPolicyResponse>;
    listAccessKeys: $APIMethod<IAM$20100508$ListAccessKeysRequest, IAM$20100508$ListAccessKeysResponse>;
    listAccountAliases: $APIMethod<IAM$20100508$ListAccountAliasesRequest, IAM$20100508$ListAccountAliasesResponse>;
    listAttachedGroupPolicies: $APIMethod<IAM$20100508$ListAttachedGroupPoliciesRequest, IAM$20100508$ListAttachedGroupPoliciesResponse>;
    listAttachedRolePolicies: $APIMethod<IAM$20100508$ListAttachedRolePoliciesRequest, IAM$20100508$ListAttachedRolePoliciesResponse>;
    listAttachedUserPolicies: $APIMethod<IAM$20100508$ListAttachedUserPoliciesRequest, IAM$20100508$ListAttachedUserPoliciesResponse>;
    listEntitiesForPolicy: $APIMethod<IAM$20100508$ListEntitiesForPolicyRequest, IAM$20100508$ListEntitiesForPolicyResponse>;
    listGroupPolicies: $APIMethod<IAM$20100508$ListGroupPoliciesRequest, IAM$20100508$ListGroupPoliciesResponse>;
    listGroups: $APIMethod<IAM$20100508$ListGroupsRequest, IAM$20100508$ListGroupsResponse>;
    listGroupsForUser: $APIMethod<IAM$20100508$ListGroupsForUserRequest, IAM$20100508$ListGroupsForUserResponse>;
    listInstanceProfiles: $APIMethod<IAM$20100508$ListInstanceProfilesRequest, IAM$20100508$ListInstanceProfilesResponse>;
    listInstanceProfilesForRole: $APIMethod<IAM$20100508$ListInstanceProfilesForRoleRequest, IAM$20100508$ListInstanceProfilesForRoleResponse>;
    listMFADevices: $APIMethod<IAM$20100508$ListMFADevicesRequest, IAM$20100508$ListMFADevicesResponse>;
    listOpenIDConnectProviders: $APIMethod<IAM$20100508$ListOpenIDConnectProvidersRequest, IAM$20100508$ListOpenIDConnectProvidersResponse>;
    listPolicies: $APIMethod<IAM$20100508$ListPoliciesRequest, IAM$20100508$ListPoliciesResponse>;
    listPolicyVersions: $APIMethod<IAM$20100508$ListPolicyVersionsRequest, IAM$20100508$ListPolicyVersionsResponse>;
    listRolePolicies: $APIMethod<IAM$20100508$ListRolePoliciesRequest, IAM$20100508$ListRolePoliciesResponse>;
    listRoles: $APIMethod<IAM$20100508$ListRolesRequest, IAM$20100508$ListRolesResponse>;
    listSAMLProviders: $APIMethod<IAM$20100508$ListSAMLProvidersRequest, IAM$20100508$ListSAMLProvidersResponse>;
    listSSHPublicKeys: $APIMethod<IAM$20100508$ListSSHPublicKeysRequest, IAM$20100508$ListSSHPublicKeysResponse>;
    listServerCertificates: $APIMethod<IAM$20100508$ListServerCertificatesRequest, IAM$20100508$ListServerCertificatesResponse>;
    listSigningCertificates: $APIMethod<IAM$20100508$ListSigningCertificatesRequest, IAM$20100508$ListSigningCertificatesResponse>;
    listUserPolicies: $APIMethod<IAM$20100508$ListUserPoliciesRequest, IAM$20100508$ListUserPoliciesResponse>;
    listUsers: $APIMethod<IAM$20100508$ListUsersRequest, IAM$20100508$ListUsersResponse>;
    listVirtualMFADevices: $APIMethod<IAM$20100508$ListVirtualMFADevicesRequest, IAM$20100508$ListVirtualMFADevicesResponse>;
    putGroupPolicy: $APIMethod<IAM$20100508$PutGroupPolicyRequest, void>;
    putRolePolicy: $APIMethod<IAM$20100508$PutRolePolicyRequest, void>;
    putUserPolicy: $APIMethod<IAM$20100508$PutUserPolicyRequest, void>;
    removeClientIDFromOpenIDConnectProvider: $APIMethod<IAM$20100508$RemoveClientIDFromOpenIDConnectProviderRequest, void>;
    removeRoleFromInstanceProfile: $APIMethod<IAM$20100508$RemoveRoleFromInstanceProfileRequest, void>;
    removeUserFromGroup: $APIMethod<IAM$20100508$RemoveUserFromGroupRequest, void>;
    resyncMFADevice: $APIMethod<IAM$20100508$ResyncMFADeviceRequest, void>;
    setDefaultPolicyVersion: $APIMethod<IAM$20100508$SetDefaultPolicyVersionRequest, void>;
    simulateCustomPolicy: $APIMethod<IAM$20100508$SimulateCustomPolicyRequest, IAM$20100508$SimulatePolicyResponse>;
    simulatePrincipalPolicy: $APIMethod<IAM$20100508$SimulatePrincipalPolicyRequest, IAM$20100508$SimulatePolicyResponse>;
    updateAccessKey: $APIMethod<IAM$20100508$UpdateAccessKeyRequest, void>;
    updateAccountPasswordPolicy: $APIMethod<IAM$20100508$UpdateAccountPasswordPolicyRequest, void>;
    updateAssumeRolePolicy: $APIMethod<IAM$20100508$UpdateAssumeRolePolicyRequest, void>;
    updateGroup: $APIMethod<IAM$20100508$UpdateGroupRequest, void>;
    updateLoginProfile: $APIMethod<IAM$20100508$UpdateLoginProfileRequest, void>;
    updateOpenIDConnectProviderThumbprint: $APIMethod<IAM$20100508$UpdateOpenIDConnectProviderThumbprintRequest, void>;
    updateSAMLProvider: $APIMethod<IAM$20100508$UpdateSAMLProviderRequest, IAM$20100508$UpdateSAMLProviderResponse>;
    updateSSHPublicKey: $APIMethod<IAM$20100508$UpdateSSHPublicKeyRequest, void>;
    updateServerCertificate: $APIMethod<IAM$20100508$UpdateServerCertificateRequest, void>;
    updateSigningCertificate: $APIMethod<IAM$20100508$UpdateSigningCertificateRequest, void>;
    updateUser: $APIMethod<IAM$20100508$UpdateUserRequest, void>;
    uploadSSHPublicKey: $APIMethod<IAM$20100508$UploadSSHPublicKeyRequest, IAM$20100508$UploadSSHPublicKeyResponse>;
    uploadServerCertificate: $APIMethod<IAM$20100508$UploadServerCertificateRequest, IAM$20100508$UploadServerCertificateResponse>;
    uploadSigningCertificate: $APIMethod<IAM$20100508$UploadSigningCertificateRequest, IAM$20100508$UploadSigningCertificateResponse>;
  }
  declare class IAM {
    constructor(config: $ConfigOptions & {
      apiVersion: '2010-05-08';
    }): IAM$20100508;
    constructor(): IAM$20100508;
  }
  declare class ImportExport$20100601 {
    cancelJob: $APIMethod<ImportExport$20100601$CancelJobInput, ImportExport$20100601$CancelJobOutput>;
    createJob: $APIMethod<ImportExport$20100601$CreateJobInput, ImportExport$20100601$CreateJobOutput>;
    getShippingLabel: $APIMethod<ImportExport$20100601$GetShippingLabelInput, ImportExport$20100601$GetShippingLabelOutput>;
    getStatus: $APIMethod<ImportExport$20100601$GetStatusInput, ImportExport$20100601$GetStatusOutput>;
    listJobs: $APIMethod<ImportExport$20100601$ListJobsInput, ImportExport$20100601$ListJobsOutput>;
    updateJob: $APIMethod<ImportExport$20100601$UpdateJobInput, ImportExport$20100601$UpdateJobOutput>;
  }
  declare class ImportExport {
    constructor(config: $ConfigOptions & {
      apiVersion: '2010-06-01';
    }): ImportExport$20100601;
    constructor(): ImportExport$20100601;
  }
  declare class Inspector$20160216 {
    addAttributesToFindings: $APIMethod<Inspector$20160216$AddAttributesToFindingsRequest, Inspector$20160216$AddAttributesToFindingsResponse>;
    createAssessmentTarget: $APIMethod<Inspector$20160216$CreateAssessmentTargetRequest, Inspector$20160216$CreateAssessmentTargetResponse>;
    createAssessmentTemplate: $APIMethod<Inspector$20160216$CreateAssessmentTemplateRequest, Inspector$20160216$CreateAssessmentTemplateResponse>;
    createResourceGroup: $APIMethod<Inspector$20160216$CreateResourceGroupRequest, Inspector$20160216$CreateResourceGroupResponse>;
    deleteAssessmentRun: $APIMethod<Inspector$20160216$DeleteAssessmentRunRequest, void>;
    deleteAssessmentTarget: $APIMethod<Inspector$20160216$DeleteAssessmentTargetRequest, void>;
    deleteAssessmentTemplate: $APIMethod<Inspector$20160216$DeleteAssessmentTemplateRequest, void>;
    describeAssessmentRuns: $APIMethod<Inspector$20160216$DescribeAssessmentRunsRequest, Inspector$20160216$DescribeAssessmentRunsResponse>;
    describeAssessmentTargets: $APIMethod<Inspector$20160216$DescribeAssessmentTargetsRequest, Inspector$20160216$DescribeAssessmentTargetsResponse>;
    describeAssessmentTemplates: $APIMethod<Inspector$20160216$DescribeAssessmentTemplatesRequest, Inspector$20160216$DescribeAssessmentTemplatesResponse>;
    describeCrossAccountAccessRole: $APIMethod<void, Inspector$20160216$DescribeCrossAccountAccessRoleResponse>;
    describeFindings: $APIMethod<Inspector$20160216$DescribeFindingsRequest, Inspector$20160216$DescribeFindingsResponse>;
    describeResourceGroups: $APIMethod<Inspector$20160216$DescribeResourceGroupsRequest, Inspector$20160216$DescribeResourceGroupsResponse>;
    describeRulesPackages: $APIMethod<Inspector$20160216$DescribeRulesPackagesRequest, Inspector$20160216$DescribeRulesPackagesResponse>;
    getTelemetryMetadata: $APIMethod<Inspector$20160216$GetTelemetryMetadataRequest, Inspector$20160216$GetTelemetryMetadataResponse>;
    listAssessmentRunAgents: $APIMethod<Inspector$20160216$ListAssessmentRunAgentsRequest, Inspector$20160216$ListAssessmentRunAgentsResponse>;
    listAssessmentRuns: $APIMethod<Inspector$20160216$ListAssessmentRunsRequest, Inspector$20160216$ListAssessmentRunsResponse>;
    listAssessmentTargets: $APIMethod<Inspector$20160216$ListAssessmentTargetsRequest, Inspector$20160216$ListAssessmentTargetsResponse>;
    listAssessmentTemplates: $APIMethod<Inspector$20160216$ListAssessmentTemplatesRequest, Inspector$20160216$ListAssessmentTemplatesResponse>;
    listEventSubscriptions: $APIMethod<Inspector$20160216$ListEventSubscriptionsRequest, Inspector$20160216$ListEventSubscriptionsResponse>;
    listFindings: $APIMethod<Inspector$20160216$ListFindingsRequest, Inspector$20160216$ListFindingsResponse>;
    listRulesPackages: $APIMethod<Inspector$20160216$ListRulesPackagesRequest, Inspector$20160216$ListRulesPackagesResponse>;
    listTagsForResource: $APIMethod<Inspector$20160216$ListTagsForResourceRequest, Inspector$20160216$ListTagsForResourceResponse>;
    previewAgents: $APIMethod<Inspector$20160216$PreviewAgentsRequest, Inspector$20160216$PreviewAgentsResponse>;
    registerCrossAccountAccessRole: $APIMethod<Inspector$20160216$RegisterCrossAccountAccessRoleRequest, void>;
    removeAttributesFromFindings: $APIMethod<Inspector$20160216$RemoveAttributesFromFindingsRequest, Inspector$20160216$RemoveAttributesFromFindingsResponse>;
    setTagsForResource: $APIMethod<Inspector$20160216$SetTagsForResourceRequest, void>;
    startAssessmentRun: $APIMethod<Inspector$20160216$StartAssessmentRunRequest, Inspector$20160216$StartAssessmentRunResponse>;
    stopAssessmentRun: $APIMethod<Inspector$20160216$StopAssessmentRunRequest, void>;
    subscribeToEvent: $APIMethod<Inspector$20160216$SubscribeToEventRequest, void>;
    unsubscribeFromEvent: $APIMethod<Inspector$20160216$UnsubscribeFromEventRequest, void>;
    updateAssessmentTarget: $APIMethod<Inspector$20160216$UpdateAssessmentTargetRequest, void>;
  }
  declare class Inspector {
    constructor(config: $ConfigOptions & {
      apiVersion: '2016-02-16';
    }): Inspector$20160216;
    constructor(): Inspector$20160216;
  }
  declare class Iot$20150528 {
    acceptCertificateTransfer: $APIMethod<Iot$20150528$AcceptCertificateTransferRequest, void>;
    attachPrincipalPolicy: $APIMethod<Iot$20150528$AttachPrincipalPolicyRequest, void>;
    attachThingPrincipal: $APIMethod<Iot$20150528$AttachThingPrincipalRequest, Iot$20150528$AttachThingPrincipalResponse>;
    cancelCertificateTransfer: $APIMethod<Iot$20150528$CancelCertificateTransferRequest, void>;
    createCertificateFromCsr: $APIMethod<Iot$20150528$CreateCertificateFromCsrRequest, Iot$20150528$CreateCertificateFromCsrResponse>;
    createKeysAndCertificate: $APIMethod<Iot$20150528$CreateKeysAndCertificateRequest, Iot$20150528$CreateKeysAndCertificateResponse>;
    createPolicy: $APIMethod<Iot$20150528$CreatePolicyRequest, Iot$20150528$CreatePolicyResponse>;
    createPolicyVersion: $APIMethod<Iot$20150528$CreatePolicyVersionRequest, Iot$20150528$CreatePolicyVersionResponse>;
    createThing: $APIMethod<Iot$20150528$CreateThingRequest, Iot$20150528$CreateThingResponse>;
    createThingType: $APIMethod<Iot$20150528$CreateThingTypeRequest, Iot$20150528$CreateThingTypeResponse>;
    createTopicRule: $APIMethod<Iot$20150528$CreateTopicRuleRequest, void>;
    deleteCACertificate: $APIMethod<Iot$20150528$DeleteCACertificateRequest, Iot$20150528$DeleteCACertificateResponse>;
    deleteCertificate: $APIMethod<Iot$20150528$DeleteCertificateRequest, void>;
    deletePolicy: $APIMethod<Iot$20150528$DeletePolicyRequest, void>;
    deletePolicyVersion: $APIMethod<Iot$20150528$DeletePolicyVersionRequest, void>;
    deleteRegistrationCode: $APIMethod<Iot$20150528$DeleteRegistrationCodeRequest, Iot$20150528$DeleteRegistrationCodeResponse>;
    deleteThing: $APIMethod<Iot$20150528$DeleteThingRequest, Iot$20150528$DeleteThingResponse>;
    deleteThingType: $APIMethod<Iot$20150528$DeleteThingTypeRequest, Iot$20150528$DeleteThingTypeResponse>;
    deleteTopicRule: $APIMethod<Iot$20150528$DeleteTopicRuleRequest, void>;
    deprecateThingType: $APIMethod<Iot$20150528$DeprecateThingTypeRequest, Iot$20150528$DeprecateThingTypeResponse>;
    describeCACertificate: $APIMethod<Iot$20150528$DescribeCACertificateRequest, Iot$20150528$DescribeCACertificateResponse>;
    describeCertificate: $APIMethod<Iot$20150528$DescribeCertificateRequest, Iot$20150528$DescribeCertificateResponse>;
    describeEndpoint: $APIMethod<Iot$20150528$DescribeEndpointRequest, Iot$20150528$DescribeEndpointResponse>;
    describeThing: $APIMethod<Iot$20150528$DescribeThingRequest, Iot$20150528$DescribeThingResponse>;
    describeThingType: $APIMethod<Iot$20150528$DescribeThingTypeRequest, Iot$20150528$DescribeThingTypeResponse>;
    detachPrincipalPolicy: $APIMethod<Iot$20150528$DetachPrincipalPolicyRequest, void>;
    detachThingPrincipal: $APIMethod<Iot$20150528$DetachThingPrincipalRequest, Iot$20150528$DetachThingPrincipalResponse>;
    disableTopicRule: $APIMethod<Iot$20150528$DisableTopicRuleRequest, void>;
    enableTopicRule: $APIMethod<Iot$20150528$EnableTopicRuleRequest, void>;
    getLoggingOptions: $APIMethod<Iot$20150528$GetLoggingOptionsRequest, Iot$20150528$GetLoggingOptionsResponse>;
    getPolicy: $APIMethod<Iot$20150528$GetPolicyRequest, Iot$20150528$GetPolicyResponse>;
    getPolicyVersion: $APIMethod<Iot$20150528$GetPolicyVersionRequest, Iot$20150528$GetPolicyVersionResponse>;
    getRegistrationCode: $APIMethod<Iot$20150528$GetRegistrationCodeRequest, Iot$20150528$GetRegistrationCodeResponse>;
    getTopicRule: $APIMethod<Iot$20150528$GetTopicRuleRequest, Iot$20150528$GetTopicRuleResponse>;
    listCACertificates: $APIMethod<Iot$20150528$ListCACertificatesRequest, Iot$20150528$ListCACertificatesResponse>;
    listCertificates: $APIMethod<Iot$20150528$ListCertificatesRequest, Iot$20150528$ListCertificatesResponse>;
    listCertificatesByCA: $APIMethod<Iot$20150528$ListCertificatesByCARequest, Iot$20150528$ListCertificatesByCAResponse>;
    listOutgoingCertificates: $APIMethod<Iot$20150528$ListOutgoingCertificatesRequest, Iot$20150528$ListOutgoingCertificatesResponse>;
    listPolicies: $APIMethod<Iot$20150528$ListPoliciesRequest, Iot$20150528$ListPoliciesResponse>;
    listPolicyPrincipals: $APIMethod<Iot$20150528$ListPolicyPrincipalsRequest, Iot$20150528$ListPolicyPrincipalsResponse>;
    listPolicyVersions: $APIMethod<Iot$20150528$ListPolicyVersionsRequest, Iot$20150528$ListPolicyVersionsResponse>;
    listPrincipalPolicies: $APIMethod<Iot$20150528$ListPrincipalPoliciesRequest, Iot$20150528$ListPrincipalPoliciesResponse>;
    listPrincipalThings: $APIMethod<Iot$20150528$ListPrincipalThingsRequest, Iot$20150528$ListPrincipalThingsResponse>;
    listThingPrincipals: $APIMethod<Iot$20150528$ListThingPrincipalsRequest, Iot$20150528$ListThingPrincipalsResponse>;
    listThingTypes: $APIMethod<Iot$20150528$ListThingTypesRequest, Iot$20150528$ListThingTypesResponse>;
    listThings: $APIMethod<Iot$20150528$ListThingsRequest, Iot$20150528$ListThingsResponse>;
    listTopicRules: $APIMethod<Iot$20150528$ListTopicRulesRequest, Iot$20150528$ListTopicRulesResponse>;
    registerCACertificate: $APIMethod<Iot$20150528$RegisterCACertificateRequest, Iot$20150528$RegisterCACertificateResponse>;
    registerCertificate: $APIMethod<Iot$20150528$RegisterCertificateRequest, Iot$20150528$RegisterCertificateResponse>;
    rejectCertificateTransfer: $APIMethod<Iot$20150528$RejectCertificateTransferRequest, void>;
    replaceTopicRule: $APIMethod<Iot$20150528$ReplaceTopicRuleRequest, void>;
    setDefaultPolicyVersion: $APIMethod<Iot$20150528$SetDefaultPolicyVersionRequest, void>;
    setLoggingOptions: $APIMethod<Iot$20150528$SetLoggingOptionsRequest, void>;
    transferCertificate: $APIMethod<Iot$20150528$TransferCertificateRequest, Iot$20150528$TransferCertificateResponse>;
    updateCACertificate: $APIMethod<Iot$20150528$UpdateCACertificateRequest, void>;
    updateCertificate: $APIMethod<Iot$20150528$UpdateCertificateRequest, void>;
    updateThing: $APIMethod<Iot$20150528$UpdateThingRequest, Iot$20150528$UpdateThingResponse>;
  }
  declare class Iot {
    constructor(config: $ConfigOptions & {
      apiVersion: '2015-05-28';
    }): Iot$20150528;
    constructor(): Iot$20150528;
  }
  declare class IotData$20150528 {
    deleteThingShadow: $APIMethod<IotData$20150528$DeleteThingShadowRequest, IotData$20150528$DeleteThingShadowResponse>;
    getThingShadow: $APIMethod<IotData$20150528$GetThingShadowRequest, IotData$20150528$GetThingShadowResponse>;
    publish: $APIMethod<IotData$20150528$PublishRequest, void>;
    updateThingShadow: $APIMethod<IotData$20150528$UpdateThingShadowRequest, IotData$20150528$UpdateThingShadowResponse>;
  }
  declare class IotData {
    constructor(config: $ConfigOptions & {
      apiVersion: '2015-05-28';
    }): IotData$20150528;
    constructor(): IotData$20150528;
  }
  declare class Kinesis$20131202 {
    addTagsToStream: $APIMethod<Kinesis$20131202$AddTagsToStreamInput, void>;
    createStream: $APIMethod<Kinesis$20131202$CreateStreamInput, void>;
    decreaseStreamRetentionPeriod: $APIMethod<Kinesis$20131202$DecreaseStreamRetentionPeriodInput, void>;
    deleteStream: $APIMethod<Kinesis$20131202$DeleteStreamInput, void>;
    describeStream: $APIMethod<Kinesis$20131202$DescribeStreamInput, Kinesis$20131202$DescribeStreamOutput>;
    disableEnhancedMonitoring: $APIMethod<Kinesis$20131202$DisableEnhancedMonitoringInput, Kinesis$20131202$EnhancedMonitoringOutput>;
    enableEnhancedMonitoring: $APIMethod<Kinesis$20131202$EnableEnhancedMonitoringInput, Kinesis$20131202$EnhancedMonitoringOutput>;
    getRecords: $APIMethod<Kinesis$20131202$GetRecordsInput, Kinesis$20131202$GetRecordsOutput>;
    getShardIterator: $APIMethod<Kinesis$20131202$GetShardIteratorInput, Kinesis$20131202$GetShardIteratorOutput>;
    increaseStreamRetentionPeriod: $APIMethod<Kinesis$20131202$IncreaseStreamRetentionPeriodInput, void>;
    listStreams: $APIMethod<Kinesis$20131202$ListStreamsInput, Kinesis$20131202$ListStreamsOutput>;
    listTagsForStream: $APIMethod<Kinesis$20131202$ListTagsForStreamInput, Kinesis$20131202$ListTagsForStreamOutput>;
    mergeShards: $APIMethod<Kinesis$20131202$MergeShardsInput, void>;
    putRecord: $APIMethod<Kinesis$20131202$PutRecordInput, Kinesis$20131202$PutRecordOutput>;
    putRecords: $APIMethod<Kinesis$20131202$PutRecordsInput, Kinesis$20131202$PutRecordsOutput>;
    removeTagsFromStream: $APIMethod<Kinesis$20131202$RemoveTagsFromStreamInput, void>;
    splitShard: $APIMethod<Kinesis$20131202$SplitShardInput, void>;
  }
  declare class Kinesis {
    constructor(config: $ConfigOptions & {
      apiVersion: '2013-12-02';
    }): Kinesis$20131202;
    constructor(): Kinesis$20131202;
  }
  declare class KinesisAnalytics$20150814 {
    addApplicationInput: $APIMethod<KinesisAnalytics$20150814$AddApplicationInputRequest, KinesisAnalytics$20150814$AddApplicationInputResponse>;
    addApplicationOutput: $APIMethod<KinesisAnalytics$20150814$AddApplicationOutputRequest, KinesisAnalytics$20150814$AddApplicationOutputResponse>;
    addApplicationReferenceDataSource: $APIMethod<KinesisAnalytics$20150814$AddApplicationReferenceDataSourceRequest, KinesisAnalytics$20150814$AddApplicationReferenceDataSourceResponse>;
    createApplication: $APIMethod<KinesisAnalytics$20150814$CreateApplicationRequest, KinesisAnalytics$20150814$CreateApplicationResponse>;
    deleteApplication: $APIMethod<KinesisAnalytics$20150814$DeleteApplicationRequest, KinesisAnalytics$20150814$DeleteApplicationResponse>;
    deleteApplicationOutput: $APIMethod<KinesisAnalytics$20150814$DeleteApplicationOutputRequest, KinesisAnalytics$20150814$DeleteApplicationOutputResponse>;
    deleteApplicationReferenceDataSource: $APIMethod<KinesisAnalytics$20150814$DeleteApplicationReferenceDataSourceRequest, KinesisAnalytics$20150814$DeleteApplicationReferenceDataSourceResponse>;
    describeApplication: $APIMethod<KinesisAnalytics$20150814$DescribeApplicationRequest, KinesisAnalytics$20150814$DescribeApplicationResponse>;
    discoverInputSchema: $APIMethod<KinesisAnalytics$20150814$DiscoverInputSchemaRequest, KinesisAnalytics$20150814$DiscoverInputSchemaResponse>;
    listApplications: $APIMethod<KinesisAnalytics$20150814$ListApplicationsRequest, KinesisAnalytics$20150814$ListApplicationsResponse>;
    startApplication: $APIMethod<KinesisAnalytics$20150814$StartApplicationRequest, KinesisAnalytics$20150814$StartApplicationResponse>;
    stopApplication: $APIMethod<KinesisAnalytics$20150814$StopApplicationRequest, KinesisAnalytics$20150814$StopApplicationResponse>;
    updateApplication: $APIMethod<KinesisAnalytics$20150814$UpdateApplicationRequest, KinesisAnalytics$20150814$UpdateApplicationResponse>;
  }
  declare class KinesisAnalytics {
    constructor(config: $ConfigOptions & {
      apiVersion: '2015-08-14';
    }): KinesisAnalytics$20150814;
    constructor(): KinesisAnalytics$20150814;
  }
  declare class KMS$20141101 {
    cancelKeyDeletion: $APIMethod<KMS$20141101$CancelKeyDeletionRequest, KMS$20141101$CancelKeyDeletionResponse>;
    createAlias: $APIMethod<KMS$20141101$CreateAliasRequest, void>;
    createGrant: $APIMethod<KMS$20141101$CreateGrantRequest, KMS$20141101$CreateGrantResponse>;
    createKey: $APIMethod<KMS$20141101$CreateKeyRequest, KMS$20141101$CreateKeyResponse>;
    decrypt: $APIMethod<KMS$20141101$DecryptRequest, KMS$20141101$DecryptResponse>;
    deleteAlias: $APIMethod<KMS$20141101$DeleteAliasRequest, void>;
    deleteImportedKeyMaterial: $APIMethod<KMS$20141101$DeleteImportedKeyMaterialRequest, void>;
    describeKey: $APIMethod<KMS$20141101$DescribeKeyRequest, KMS$20141101$DescribeKeyResponse>;
    disableKey: $APIMethod<KMS$20141101$DisableKeyRequest, void>;
    disableKeyRotation: $APIMethod<KMS$20141101$DisableKeyRotationRequest, void>;
    enableKey: $APIMethod<KMS$20141101$EnableKeyRequest, void>;
    enableKeyRotation: $APIMethod<KMS$20141101$EnableKeyRotationRequest, void>;
    encrypt: $APIMethod<KMS$20141101$EncryptRequest, KMS$20141101$EncryptResponse>;
    generateDataKey: $APIMethod<KMS$20141101$GenerateDataKeyRequest, KMS$20141101$GenerateDataKeyResponse>;
    generateDataKeyWithoutPlaintext: $APIMethod<KMS$20141101$GenerateDataKeyWithoutPlaintextRequest, KMS$20141101$GenerateDataKeyWithoutPlaintextResponse>;
    generateRandom: $APIMethod<KMS$20141101$GenerateRandomRequest, KMS$20141101$GenerateRandomResponse>;
    getKeyPolicy: $APIMethod<KMS$20141101$GetKeyPolicyRequest, KMS$20141101$GetKeyPolicyResponse>;
    getKeyRotationStatus: $APIMethod<KMS$20141101$GetKeyRotationStatusRequest, KMS$20141101$GetKeyRotationStatusResponse>;
    getParametersForImport: $APIMethod<KMS$20141101$GetParametersForImportRequest, KMS$20141101$GetParametersForImportResponse>;
    importKeyMaterial: $APIMethod<KMS$20141101$ImportKeyMaterialRequest, KMS$20141101$ImportKeyMaterialResponse>;
    listAliases: $APIMethod<KMS$20141101$ListAliasesRequest, KMS$20141101$ListAliasesResponse>;
    listGrants: $APIMethod<KMS$20141101$ListGrantsRequest, KMS$20141101$ListGrantsResponse>;
    listKeyPolicies: $APIMethod<KMS$20141101$ListKeyPoliciesRequest, KMS$20141101$ListKeyPoliciesResponse>;
    listKeys: $APIMethod<KMS$20141101$ListKeysRequest, KMS$20141101$ListKeysResponse>;
    listRetirableGrants: $APIMethod<KMS$20141101$ListRetirableGrantsRequest, KMS$20141101$ListGrantsResponse>;
    putKeyPolicy: $APIMethod<KMS$20141101$PutKeyPolicyRequest, void>;
    reEncrypt: $APIMethod<KMS$20141101$ReEncryptRequest, KMS$20141101$ReEncryptResponse>;
    retireGrant: $APIMethod<KMS$20141101$RetireGrantRequest, void>;
    revokeGrant: $APIMethod<KMS$20141101$RevokeGrantRequest, void>;
    scheduleKeyDeletion: $APIMethod<KMS$20141101$ScheduleKeyDeletionRequest, KMS$20141101$ScheduleKeyDeletionResponse>;
    updateAlias: $APIMethod<KMS$20141101$UpdateAliasRequest, void>;
    updateKeyDescription: $APIMethod<KMS$20141101$UpdateKeyDescriptionRequest, void>;
  }
  declare class KMS {
    constructor(config: $ConfigOptions & {
      apiVersion: '2014-11-01';
    }): KMS$20141101;
    constructor(): KMS$20141101;
  }
  declare class Lambda$20141111 {
    addEventSource: $APIMethod<Lambda$20141111$AddEventSourceRequest, Lambda$20141111$EventSourceConfiguration>;
    deleteFunction: $APIMethod<Lambda$20141111$DeleteFunctionRequest, void>;
    getEventSource: $APIMethod<Lambda$20141111$GetEventSourceRequest, Lambda$20141111$EventSourceConfiguration>;
    getFunction: $APIMethod<Lambda$20141111$GetFunctionRequest, Lambda$20141111$GetFunctionResponse>;
    getFunctionConfiguration: $APIMethod<Lambda$20141111$GetFunctionConfigurationRequest, Lambda$20141111$FunctionConfiguration>;
    invokeAsync: $APIMethod<Lambda$20141111$InvokeAsyncRequest, Lambda$20141111$InvokeAsyncResponse>;
    listEventSources: $APIMethod<Lambda$20141111$ListEventSourcesRequest, Lambda$20141111$ListEventSourcesResponse>;
    listFunctions: $APIMethod<Lambda$20141111$ListFunctionsRequest, Lambda$20141111$ListFunctionsResponse>;
    removeEventSource: $APIMethod<Lambda$20141111$RemoveEventSourceRequest, void>;
    updateFunctionConfiguration: $APIMethod<Lambda$20141111$UpdateFunctionConfigurationRequest, Lambda$20141111$FunctionConfiguration>;
    uploadFunction: $APIMethod<Lambda$20141111$UploadFunctionRequest, Lambda$20141111$FunctionConfiguration>;
  }
  declare class Lambda$20150331 {
    addPermission: $APIMethod<Lambda$20150331$AddPermissionRequest, Lambda$20150331$AddPermissionResponse>;
    createAlias: $APIMethod<Lambda$20150331$CreateAliasRequest, Lambda$20150331$AliasConfiguration>;
    createEventSourceMapping: $APIMethod<Lambda$20150331$CreateEventSourceMappingRequest, Lambda$20150331$EventSourceMappingConfiguration>;
    createFunction: $APIMethod<Lambda$20150331$CreateFunctionRequest, Lambda$20150331$FunctionConfiguration>;
    deleteAlias: $APIMethod<Lambda$20150331$DeleteAliasRequest, void>;
    deleteEventSourceMapping: $APIMethod<Lambda$20150331$DeleteEventSourceMappingRequest, Lambda$20150331$EventSourceMappingConfiguration>;
    deleteFunction: $APIMethod<Lambda$20150331$DeleteFunctionRequest, void>;
    getAlias: $APIMethod<Lambda$20150331$GetAliasRequest, Lambda$20150331$AliasConfiguration>;
    getEventSourceMapping: $APIMethod<Lambda$20150331$GetEventSourceMappingRequest, Lambda$20150331$EventSourceMappingConfiguration>;
    getFunction: $APIMethod<Lambda$20150331$GetFunctionRequest, Lambda$20150331$GetFunctionResponse>;
    getFunctionConfiguration: $APIMethod<Lambda$20150331$GetFunctionConfigurationRequest, Lambda$20150331$FunctionConfiguration>;
    getPolicy: $APIMethod<Lambda$20150331$GetPolicyRequest, Lambda$20150331$GetPolicyResponse>;
    invoke: $APIMethod<Lambda$20150331$InvocationRequest, Lambda$20150331$InvocationResponse>;
    invokeAsync: $APIMethod<Lambda$20150331$InvokeAsyncRequest, Lambda$20150331$InvokeAsyncResponse>;
    listAliases: $APIMethod<Lambda$20150331$ListAliasesRequest, Lambda$20150331$ListAliasesResponse>;
    listEventSourceMappings: $APIMethod<Lambda$20150331$ListEventSourceMappingsRequest, Lambda$20150331$ListEventSourceMappingsResponse>;
    listFunctions: $APIMethod<Lambda$20150331$ListFunctionsRequest, Lambda$20150331$ListFunctionsResponse>;
    listVersionsByFunction: $APIMethod<Lambda$20150331$ListVersionsByFunctionRequest, Lambda$20150331$ListVersionsByFunctionResponse>;
    publishVersion: $APIMethod<Lambda$20150331$PublishVersionRequest, Lambda$20150331$FunctionConfiguration>;
    removePermission: $APIMethod<Lambda$20150331$RemovePermissionRequest, void>;
    updateAlias: $APIMethod<Lambda$20150331$UpdateAliasRequest, Lambda$20150331$AliasConfiguration>;
    updateEventSourceMapping: $APIMethod<Lambda$20150331$UpdateEventSourceMappingRequest, Lambda$20150331$EventSourceMappingConfiguration>;
    updateFunctionCode: $APIMethod<Lambda$20150331$UpdateFunctionCodeRequest, Lambda$20150331$FunctionConfiguration>;
    updateFunctionConfiguration: $APIMethod<Lambda$20150331$UpdateFunctionConfigurationRequest, Lambda$20150331$FunctionConfiguration>;
  }
  declare class Lambda {
    constructor(config: $ConfigOptions & {
      apiVersion: '2014-11-11';
    }): Lambda$20141111;
    constructor(config: $ConfigOptions & {
      apiVersion: '2015-03-31';
    }): Lambda$20150331;
    constructor(): Lambda$20150331;
  }
  declare class MachineLearning$20141212 {
    addTags: $APIMethod<MachineLearning$20141212$AddTagsInput, MachineLearning$20141212$AddTagsOutput>;
    createBatchPrediction: $APIMethod<MachineLearning$20141212$CreateBatchPredictionInput, MachineLearning$20141212$CreateBatchPredictionOutput>;
    createDataSourceFromRDS: $APIMethod<MachineLearning$20141212$CreateDataSourceFromRDSInput, MachineLearning$20141212$CreateDataSourceFromRDSOutput>;
    createDataSourceFromRedshift: $APIMethod<MachineLearning$20141212$CreateDataSourceFromRedshiftInput, MachineLearning$20141212$CreateDataSourceFromRedshiftOutput>;
    createDataSourceFromS3: $APIMethod<MachineLearning$20141212$CreateDataSourceFromS3Input, MachineLearning$20141212$CreateDataSourceFromS3Output>;
    createEvaluation: $APIMethod<MachineLearning$20141212$CreateEvaluationInput, MachineLearning$20141212$CreateEvaluationOutput>;
    createMLModel: $APIMethod<MachineLearning$20141212$CreateMLModelInput, MachineLearning$20141212$CreateMLModelOutput>;
    createRealtimeEndpoint: $APIMethod<MachineLearning$20141212$CreateRealtimeEndpointInput, MachineLearning$20141212$CreateRealtimeEndpointOutput>;
    deleteBatchPrediction: $APIMethod<MachineLearning$20141212$DeleteBatchPredictionInput, MachineLearning$20141212$DeleteBatchPredictionOutput>;
    deleteDataSource: $APIMethod<MachineLearning$20141212$DeleteDataSourceInput, MachineLearning$20141212$DeleteDataSourceOutput>;
    deleteEvaluation: $APIMethod<MachineLearning$20141212$DeleteEvaluationInput, MachineLearning$20141212$DeleteEvaluationOutput>;
    deleteMLModel: $APIMethod<MachineLearning$20141212$DeleteMLModelInput, MachineLearning$20141212$DeleteMLModelOutput>;
    deleteRealtimeEndpoint: $APIMethod<MachineLearning$20141212$DeleteRealtimeEndpointInput, MachineLearning$20141212$DeleteRealtimeEndpointOutput>;
    deleteTags: $APIMethod<MachineLearning$20141212$DeleteTagsInput, MachineLearning$20141212$DeleteTagsOutput>;
    describeBatchPredictions: $APIMethod<MachineLearning$20141212$DescribeBatchPredictionsInput, MachineLearning$20141212$DescribeBatchPredictionsOutput>;
    describeDataSources: $APIMethod<MachineLearning$20141212$DescribeDataSourcesInput, MachineLearning$20141212$DescribeDataSourcesOutput>;
    describeEvaluations: $APIMethod<MachineLearning$20141212$DescribeEvaluationsInput, MachineLearning$20141212$DescribeEvaluationsOutput>;
    describeMLModels: $APIMethod<MachineLearning$20141212$DescribeMLModelsInput, MachineLearning$20141212$DescribeMLModelsOutput>;
    describeTags: $APIMethod<MachineLearning$20141212$DescribeTagsInput, MachineLearning$20141212$DescribeTagsOutput>;
    getBatchPrediction: $APIMethod<MachineLearning$20141212$GetBatchPredictionInput, MachineLearning$20141212$GetBatchPredictionOutput>;
    getDataSource: $APIMethod<MachineLearning$20141212$GetDataSourceInput, MachineLearning$20141212$GetDataSourceOutput>;
    getEvaluation: $APIMethod<MachineLearning$20141212$GetEvaluationInput, MachineLearning$20141212$GetEvaluationOutput>;
    getMLModel: $APIMethod<MachineLearning$20141212$GetMLModelInput, MachineLearning$20141212$GetMLModelOutput>;
    predict: $APIMethod<MachineLearning$20141212$PredictInput, MachineLearning$20141212$PredictOutput>;
    updateBatchPrediction: $APIMethod<MachineLearning$20141212$UpdateBatchPredictionInput, MachineLearning$20141212$UpdateBatchPredictionOutput>;
    updateDataSource: $APIMethod<MachineLearning$20141212$UpdateDataSourceInput, MachineLearning$20141212$UpdateDataSourceOutput>;
    updateEvaluation: $APIMethod<MachineLearning$20141212$UpdateEvaluationInput, MachineLearning$20141212$UpdateEvaluationOutput>;
    updateMLModel: $APIMethod<MachineLearning$20141212$UpdateMLModelInput, MachineLearning$20141212$UpdateMLModelOutput>;
  }
  declare class MachineLearning {
    constructor(config: $ConfigOptions & {
      apiVersion: '2014-12-12';
    }): MachineLearning$20141212;
    constructor(): MachineLearning$20141212;
  }
  declare class MarketplaceCommerceAnalytics$20150701 {
    generateDataSet: $APIMethod<MarketplaceCommerceAnalytics$20150701$GenerateDataSetRequest, MarketplaceCommerceAnalytics$20150701$GenerateDataSetResult>;
    startSupportDataExport: $APIMethod<MarketplaceCommerceAnalytics$20150701$StartSupportDataExportRequest, MarketplaceCommerceAnalytics$20150701$StartSupportDataExportResult>;
  }
  declare class MarketplaceCommerceAnalytics {
    constructor(config: $ConfigOptions & {
      apiVersion: '2015-07-01';
    }): MarketplaceCommerceAnalytics$20150701;
    constructor(): MarketplaceCommerceAnalytics$20150701;
  }
  declare class MarketplaceMetering$20160114 {
    meterUsage: $APIMethod<MarketplaceMetering$20160114$MeterUsageRequest, MarketplaceMetering$20160114$MeterUsageResult>;
  }
  declare class MarketplaceMetering {
    constructor(config: $ConfigOptions & {
      apiVersion: '2016-01-14';
    }): MarketplaceMetering$20160114;
    constructor(): MarketplaceMetering$20160114;
  }
  declare class MobileAnalytics$20140605 {
    putEvents: $APIMethod<MobileAnalytics$20140605$PutEventsInput, void>;
  }
  declare class MobileAnalytics {
    constructor(config: $ConfigOptions & {
      apiVersion: '2014-06-05';
    }): MobileAnalytics$20140605;
    constructor(): MobileAnalytics$20140605;
  }
  declare class OpsWorks$20130218 {
    assignInstance: $APIMethod<OpsWorks$20130218$AssignInstanceRequest, void>;
    assignVolume: $APIMethod<OpsWorks$20130218$AssignVolumeRequest, void>;
    associateElasticIp: $APIMethod<OpsWorks$20130218$AssociateElasticIpRequest, void>;
    attachElasticLoadBalancer: $APIMethod<OpsWorks$20130218$AttachElasticLoadBalancerRequest, void>;
    cloneStack: $APIMethod<OpsWorks$20130218$CloneStackRequest, OpsWorks$20130218$CloneStackResult>;
    createApp: $APIMethod<OpsWorks$20130218$CreateAppRequest, OpsWorks$20130218$CreateAppResult>;
    createDeployment: $APIMethod<OpsWorks$20130218$CreateDeploymentRequest, OpsWorks$20130218$CreateDeploymentResult>;
    createInstance: $APIMethod<OpsWorks$20130218$CreateInstanceRequest, OpsWorks$20130218$CreateInstanceResult>;
    createLayer: $APIMethod<OpsWorks$20130218$CreateLayerRequest, OpsWorks$20130218$CreateLayerResult>;
    createStack: $APIMethod<OpsWorks$20130218$CreateStackRequest, OpsWorks$20130218$CreateStackResult>;
    createUserProfile: $APIMethod<OpsWorks$20130218$CreateUserProfileRequest, OpsWorks$20130218$CreateUserProfileResult>;
    deleteApp: $APIMethod<OpsWorks$20130218$DeleteAppRequest, void>;
    deleteInstance: $APIMethod<OpsWorks$20130218$DeleteInstanceRequest, void>;
    deleteLayer: $APIMethod<OpsWorks$20130218$DeleteLayerRequest, void>;
    deleteStack: $APIMethod<OpsWorks$20130218$DeleteStackRequest, void>;
    deleteUserProfile: $APIMethod<OpsWorks$20130218$DeleteUserProfileRequest, void>;
    deregisterEcsCluster: $APIMethod<OpsWorks$20130218$DeregisterEcsClusterRequest, void>;
    deregisterElasticIp: $APIMethod<OpsWorks$20130218$DeregisterElasticIpRequest, void>;
    deregisterInstance: $APIMethod<OpsWorks$20130218$DeregisterInstanceRequest, void>;
    deregisterRdsDbInstance: $APIMethod<OpsWorks$20130218$DeregisterRdsDbInstanceRequest, void>;
    deregisterVolume: $APIMethod<OpsWorks$20130218$DeregisterVolumeRequest, void>;
    describeAgentVersions: $APIMethod<OpsWorks$20130218$DescribeAgentVersionsRequest, OpsWorks$20130218$DescribeAgentVersionsResult>;
    describeApps: $APIMethod<OpsWorks$20130218$DescribeAppsRequest, OpsWorks$20130218$DescribeAppsResult>;
    describeCommands: $APIMethod<OpsWorks$20130218$DescribeCommandsRequest, OpsWorks$20130218$DescribeCommandsResult>;
    describeDeployments: $APIMethod<OpsWorks$20130218$DescribeDeploymentsRequest, OpsWorks$20130218$DescribeDeploymentsResult>;
    describeEcsClusters: $APIMethod<OpsWorks$20130218$DescribeEcsClustersRequest, OpsWorks$20130218$DescribeEcsClustersResult>;
    describeElasticIps: $APIMethod<OpsWorks$20130218$DescribeElasticIpsRequest, OpsWorks$20130218$DescribeElasticIpsResult>;
    describeElasticLoadBalancers: $APIMethod<OpsWorks$20130218$DescribeElasticLoadBalancersRequest, OpsWorks$20130218$DescribeElasticLoadBalancersResult>;
    describeInstances: $APIMethod<OpsWorks$20130218$DescribeInstancesRequest, OpsWorks$20130218$DescribeInstancesResult>;
    describeLayers: $APIMethod<OpsWorks$20130218$DescribeLayersRequest, OpsWorks$20130218$DescribeLayersResult>;
    describeLoadBasedAutoScaling: $APIMethod<OpsWorks$20130218$DescribeLoadBasedAutoScalingRequest, OpsWorks$20130218$DescribeLoadBasedAutoScalingResult>;
    describeMyUserProfile: $APIMethod<void, OpsWorks$20130218$DescribeMyUserProfileResult>;
    describePermissions: $APIMethod<OpsWorks$20130218$DescribePermissionsRequest, OpsWorks$20130218$DescribePermissionsResult>;
    describeRaidArrays: $APIMethod<OpsWorks$20130218$DescribeRaidArraysRequest, OpsWorks$20130218$DescribeRaidArraysResult>;
    describeRdsDbInstances: $APIMethod<OpsWorks$20130218$DescribeRdsDbInstancesRequest, OpsWorks$20130218$DescribeRdsDbInstancesResult>;
    describeServiceErrors: $APIMethod<OpsWorks$20130218$DescribeServiceErrorsRequest, OpsWorks$20130218$DescribeServiceErrorsResult>;
    describeStackProvisioningParameters: $APIMethod<OpsWorks$20130218$DescribeStackProvisioningParametersRequest, OpsWorks$20130218$DescribeStackProvisioningParametersResult>;
    describeStackSummary: $APIMethod<OpsWorks$20130218$DescribeStackSummaryRequest, OpsWorks$20130218$DescribeStackSummaryResult>;
    describeStacks: $APIMethod<OpsWorks$20130218$DescribeStacksRequest, OpsWorks$20130218$DescribeStacksResult>;
    describeTimeBasedAutoScaling: $APIMethod<OpsWorks$20130218$DescribeTimeBasedAutoScalingRequest, OpsWorks$20130218$DescribeTimeBasedAutoScalingResult>;
    describeUserProfiles: $APIMethod<OpsWorks$20130218$DescribeUserProfilesRequest, OpsWorks$20130218$DescribeUserProfilesResult>;
    describeVolumes: $APIMethod<OpsWorks$20130218$DescribeVolumesRequest, OpsWorks$20130218$DescribeVolumesResult>;
    detachElasticLoadBalancer: $APIMethod<OpsWorks$20130218$DetachElasticLoadBalancerRequest, void>;
    disassociateElasticIp: $APIMethod<OpsWorks$20130218$DisassociateElasticIpRequest, void>;
    getHostnameSuggestion: $APIMethod<OpsWorks$20130218$GetHostnameSuggestionRequest, OpsWorks$20130218$GetHostnameSuggestionResult>;
    grantAccess: $APIMethod<OpsWorks$20130218$GrantAccessRequest, OpsWorks$20130218$GrantAccessResult>;
    rebootInstance: $APIMethod<OpsWorks$20130218$RebootInstanceRequest, void>;
    registerEcsCluster: $APIMethod<OpsWorks$20130218$RegisterEcsClusterRequest, OpsWorks$20130218$RegisterEcsClusterResult>;
    registerElasticIp: $APIMethod<OpsWorks$20130218$RegisterElasticIpRequest, OpsWorks$20130218$RegisterElasticIpResult>;
    registerInstance: $APIMethod<OpsWorks$20130218$RegisterInstanceRequest, OpsWorks$20130218$RegisterInstanceResult>;
    registerRdsDbInstance: $APIMethod<OpsWorks$20130218$RegisterRdsDbInstanceRequest, void>;
    registerVolume: $APIMethod<OpsWorks$20130218$RegisterVolumeRequest, OpsWorks$20130218$RegisterVolumeResult>;
    setLoadBasedAutoScaling: $APIMethod<OpsWorks$20130218$SetLoadBasedAutoScalingRequest, void>;
    setPermission: $APIMethod<OpsWorks$20130218$SetPermissionRequest, void>;
    setTimeBasedAutoScaling: $APIMethod<OpsWorks$20130218$SetTimeBasedAutoScalingRequest, void>;
    startInstance: $APIMethod<OpsWorks$20130218$StartInstanceRequest, void>;
    startStack: $APIMethod<OpsWorks$20130218$StartStackRequest, void>;
    stopInstance: $APIMethod<OpsWorks$20130218$StopInstanceRequest, void>;
    stopStack: $APIMethod<OpsWorks$20130218$StopStackRequest, void>;
    unassignInstance: $APIMethod<OpsWorks$20130218$UnassignInstanceRequest, void>;
    unassignVolume: $APIMethod<OpsWorks$20130218$UnassignVolumeRequest, void>;
    updateApp: $APIMethod<OpsWorks$20130218$UpdateAppRequest, void>;
    updateElasticIp: $APIMethod<OpsWorks$20130218$UpdateElasticIpRequest, void>;
    updateInstance: $APIMethod<OpsWorks$20130218$UpdateInstanceRequest, void>;
    updateLayer: $APIMethod<OpsWorks$20130218$UpdateLayerRequest, void>;
    updateMyUserProfile: $APIMethod<OpsWorks$20130218$UpdateMyUserProfileRequest, void>;
    updateRdsDbInstance: $APIMethod<OpsWorks$20130218$UpdateRdsDbInstanceRequest, void>;
    updateStack: $APIMethod<OpsWorks$20130218$UpdateStackRequest, void>;
    updateUserProfile: $APIMethod<OpsWorks$20130218$UpdateUserProfileRequest, void>;
    updateVolume: $APIMethod<OpsWorks$20130218$UpdateVolumeRequest, void>;
  }
  declare class OpsWorks {
    constructor(config: $ConfigOptions & {
      apiVersion: '2013-02-18';
    }): OpsWorks$20130218;
    constructor(): OpsWorks$20130218;
  }
  declare class RDS$20130110 {
    addSourceIdentifierToSubscription: $APIMethod<RDS$20130110$AddSourceIdentifierToSubscriptionMessage, RDS$20130110$AddSourceIdentifierToSubscriptionResult>;
    addTagsToResource: $APIMethod<RDS$20130110$AddTagsToResourceMessage, void>;
    authorizeDBSecurityGroupIngress: $APIMethod<RDS$20130110$AuthorizeDBSecurityGroupIngressMessage, RDS$20130110$AuthorizeDBSecurityGroupIngressResult>;
    copyDBSnapshot: $APIMethod<RDS$20130110$CopyDBSnapshotMessage, RDS$20130110$CopyDBSnapshotResult>;
    createDBInstance: $APIMethod<RDS$20130110$CreateDBInstanceMessage, RDS$20130110$CreateDBInstanceResult>;
    createDBInstanceReadReplica: $APIMethod<RDS$20130110$CreateDBInstanceReadReplicaMessage, RDS$20130110$CreateDBInstanceReadReplicaResult>;
    createDBParameterGroup: $APIMethod<RDS$20130110$CreateDBParameterGroupMessage, RDS$20130110$CreateDBParameterGroupResult>;
    createDBSecurityGroup: $APIMethod<RDS$20130110$CreateDBSecurityGroupMessage, RDS$20130110$CreateDBSecurityGroupResult>;
    createDBSnapshot: $APIMethod<RDS$20130110$CreateDBSnapshotMessage, RDS$20130110$CreateDBSnapshotResult>;
    createDBSubnetGroup: $APIMethod<RDS$20130110$CreateDBSubnetGroupMessage, RDS$20130110$CreateDBSubnetGroupResult>;
    createEventSubscription: $APIMethod<RDS$20130110$CreateEventSubscriptionMessage, RDS$20130110$CreateEventSubscriptionResult>;
    createOptionGroup: $APIMethod<RDS$20130110$CreateOptionGroupMessage, RDS$20130110$CreateOptionGroupResult>;
    deleteDBInstance: $APIMethod<RDS$20130110$DeleteDBInstanceMessage, RDS$20130110$DeleteDBInstanceResult>;
    deleteDBParameterGroup: $APIMethod<RDS$20130110$DeleteDBParameterGroupMessage, void>;
    deleteDBSecurityGroup: $APIMethod<RDS$20130110$DeleteDBSecurityGroupMessage, void>;
    deleteDBSnapshot: $APIMethod<RDS$20130110$DeleteDBSnapshotMessage, RDS$20130110$DeleteDBSnapshotResult>;
    deleteDBSubnetGroup: $APIMethod<RDS$20130110$DeleteDBSubnetGroupMessage, void>;
    deleteEventSubscription: $APIMethod<RDS$20130110$DeleteEventSubscriptionMessage, RDS$20130110$DeleteEventSubscriptionResult>;
    deleteOptionGroup: $APIMethod<RDS$20130110$DeleteOptionGroupMessage, void>;
    describeDBEngineVersions: $APIMethod<RDS$20130110$DescribeDBEngineVersionsMessage, RDS$20130110$DBEngineVersionMessage>;
    describeDBInstances: $APIMethod<RDS$20130110$DescribeDBInstancesMessage, RDS$20130110$DBInstanceMessage>;
    describeDBParameterGroups: $APIMethod<RDS$20130110$DescribeDBParameterGroupsMessage, RDS$20130110$DBParameterGroupsMessage>;
    describeDBParameters: $APIMethod<RDS$20130110$DescribeDBParametersMessage, RDS$20130110$DBParameterGroupDetails>;
    describeDBSecurityGroups: $APIMethod<RDS$20130110$DescribeDBSecurityGroupsMessage, RDS$20130110$DBSecurityGroupMessage>;
    describeDBSnapshots: $APIMethod<RDS$20130110$DescribeDBSnapshotsMessage, RDS$20130110$DBSnapshotMessage>;
    describeDBSubnetGroups: $APIMethod<RDS$20130110$DescribeDBSubnetGroupsMessage, RDS$20130110$DBSubnetGroupMessage>;
    describeEngineDefaultParameters: $APIMethod<RDS$20130110$DescribeEngineDefaultParametersMessage, RDS$20130110$DescribeEngineDefaultParametersResult>;
    describeEventCategories: $APIMethod<RDS$20130110$DescribeEventCategoriesMessage, RDS$20130110$EventCategoriesMessage>;
    describeEventSubscriptions: $APIMethod<RDS$20130110$DescribeEventSubscriptionsMessage, RDS$20130110$EventSubscriptionsMessage>;
    describeEvents: $APIMethod<RDS$20130110$DescribeEventsMessage, RDS$20130110$EventsMessage>;
    describeOptionGroupOptions: $APIMethod<RDS$20130110$DescribeOptionGroupOptionsMessage, RDS$20130110$OptionGroupOptionsMessage>;
    describeOptionGroups: $APIMethod<RDS$20130110$DescribeOptionGroupsMessage, RDS$20130110$OptionGroups>;
    describeOrderableDBInstanceOptions: $APIMethod<RDS$20130110$DescribeOrderableDBInstanceOptionsMessage, RDS$20130110$OrderableDBInstanceOptionsMessage>;
    describeReservedDBInstances: $APIMethod<RDS$20130110$DescribeReservedDBInstancesMessage, RDS$20130110$ReservedDBInstanceMessage>;
    describeReservedDBInstancesOfferings: $APIMethod<RDS$20130110$DescribeReservedDBInstancesOfferingsMessage, RDS$20130110$ReservedDBInstancesOfferingMessage>;
    listTagsForResource: $APIMethod<RDS$20130110$ListTagsForResourceMessage, RDS$20130110$TagListMessage>;
    modifyDBInstance: $APIMethod<RDS$20130110$ModifyDBInstanceMessage, RDS$20130110$ModifyDBInstanceResult>;
    modifyDBParameterGroup: $APIMethod<RDS$20130110$ModifyDBParameterGroupMessage, RDS$20130110$DBParameterGroupNameMessage>;
    modifyDBSubnetGroup: $APIMethod<RDS$20130110$ModifyDBSubnetGroupMessage, RDS$20130110$ModifyDBSubnetGroupResult>;
    modifyEventSubscription: $APIMethod<RDS$20130110$ModifyEventSubscriptionMessage, RDS$20130110$ModifyEventSubscriptionResult>;
    modifyOptionGroup: $APIMethod<RDS$20130110$ModifyOptionGroupMessage, RDS$20130110$ModifyOptionGroupResult>;
    promoteReadReplica: $APIMethod<RDS$20130110$PromoteReadReplicaMessage, RDS$20130110$PromoteReadReplicaResult>;
    purchaseReservedDBInstancesOffering: $APIMethod<RDS$20130110$PurchaseReservedDBInstancesOfferingMessage, RDS$20130110$PurchaseReservedDBInstancesOfferingResult>;
    rebootDBInstance: $APIMethod<RDS$20130110$RebootDBInstanceMessage, RDS$20130110$RebootDBInstanceResult>;
    removeSourceIdentifierFromSubscription: $APIMethod<RDS$20130110$RemoveSourceIdentifierFromSubscriptionMessage, RDS$20130110$RemoveSourceIdentifierFromSubscriptionResult>;
    removeTagsFromResource: $APIMethod<RDS$20130110$RemoveTagsFromResourceMessage, void>;
    resetDBParameterGroup: $APIMethod<RDS$20130110$ResetDBParameterGroupMessage, RDS$20130110$DBParameterGroupNameMessage>;
    restoreDBInstanceFromDBSnapshot: $APIMethod<RDS$20130110$RestoreDBInstanceFromDBSnapshotMessage, RDS$20130110$RestoreDBInstanceFromDBSnapshotResult>;
    restoreDBInstanceToPointInTime: $APIMethod<RDS$20130110$RestoreDBInstanceToPointInTimeMessage, RDS$20130110$RestoreDBInstanceToPointInTimeResult>;
    revokeDBSecurityGroupIngress: $APIMethod<RDS$20130110$RevokeDBSecurityGroupIngressMessage, RDS$20130110$RevokeDBSecurityGroupIngressResult>;
  }
  declare class RDS$20130212 {
    addSourceIdentifierToSubscription: $APIMethod<RDS$20130212$AddSourceIdentifierToSubscriptionMessage, RDS$20130212$AddSourceIdentifierToSubscriptionResult>;
    addTagsToResource: $APIMethod<RDS$20130212$AddTagsToResourceMessage, void>;
    authorizeDBSecurityGroupIngress: $APIMethod<RDS$20130212$AuthorizeDBSecurityGroupIngressMessage, RDS$20130212$AuthorizeDBSecurityGroupIngressResult>;
    copyDBSnapshot: $APIMethod<RDS$20130212$CopyDBSnapshotMessage, RDS$20130212$CopyDBSnapshotResult>;
    createDBInstance: $APIMethod<RDS$20130212$CreateDBInstanceMessage, RDS$20130212$CreateDBInstanceResult>;
    createDBInstanceReadReplica: $APIMethod<RDS$20130212$CreateDBInstanceReadReplicaMessage, RDS$20130212$CreateDBInstanceReadReplicaResult>;
    createDBParameterGroup: $APIMethod<RDS$20130212$CreateDBParameterGroupMessage, RDS$20130212$CreateDBParameterGroupResult>;
    createDBSecurityGroup: $APIMethod<RDS$20130212$CreateDBSecurityGroupMessage, RDS$20130212$CreateDBSecurityGroupResult>;
    createDBSnapshot: $APIMethod<RDS$20130212$CreateDBSnapshotMessage, RDS$20130212$CreateDBSnapshotResult>;
    createDBSubnetGroup: $APIMethod<RDS$20130212$CreateDBSubnetGroupMessage, RDS$20130212$CreateDBSubnetGroupResult>;
    createEventSubscription: $APIMethod<RDS$20130212$CreateEventSubscriptionMessage, RDS$20130212$CreateEventSubscriptionResult>;
    createOptionGroup: $APIMethod<RDS$20130212$CreateOptionGroupMessage, RDS$20130212$CreateOptionGroupResult>;
    deleteDBInstance: $APIMethod<RDS$20130212$DeleteDBInstanceMessage, RDS$20130212$DeleteDBInstanceResult>;
    deleteDBParameterGroup: $APIMethod<RDS$20130212$DeleteDBParameterGroupMessage, void>;
    deleteDBSecurityGroup: $APIMethod<RDS$20130212$DeleteDBSecurityGroupMessage, void>;
    deleteDBSnapshot: $APIMethod<RDS$20130212$DeleteDBSnapshotMessage, RDS$20130212$DeleteDBSnapshotResult>;
    deleteDBSubnetGroup: $APIMethod<RDS$20130212$DeleteDBSubnetGroupMessage, void>;
    deleteEventSubscription: $APIMethod<RDS$20130212$DeleteEventSubscriptionMessage, RDS$20130212$DeleteEventSubscriptionResult>;
    deleteOptionGroup: $APIMethod<RDS$20130212$DeleteOptionGroupMessage, void>;
    describeDBEngineVersions: $APIMethod<RDS$20130212$DescribeDBEngineVersionsMessage, RDS$20130212$DBEngineVersionMessage>;
    describeDBInstances: $APIMethod<RDS$20130212$DescribeDBInstancesMessage, RDS$20130212$DBInstanceMessage>;
    describeDBLogFiles: $APIMethod<RDS$20130212$DescribeDBLogFilesMessage, RDS$20130212$DescribeDBLogFilesResponse>;
    describeDBParameterGroups: $APIMethod<RDS$20130212$DescribeDBParameterGroupsMessage, RDS$20130212$DBParameterGroupsMessage>;
    describeDBParameters: $APIMethod<RDS$20130212$DescribeDBParametersMessage, RDS$20130212$DBParameterGroupDetails>;
    describeDBSecurityGroups: $APIMethod<RDS$20130212$DescribeDBSecurityGroupsMessage, RDS$20130212$DBSecurityGroupMessage>;
    describeDBSnapshots: $APIMethod<RDS$20130212$DescribeDBSnapshotsMessage, RDS$20130212$DBSnapshotMessage>;
    describeDBSubnetGroups: $APIMethod<RDS$20130212$DescribeDBSubnetGroupsMessage, RDS$20130212$DBSubnetGroupMessage>;
    describeEngineDefaultParameters: $APIMethod<RDS$20130212$DescribeEngineDefaultParametersMessage, RDS$20130212$DescribeEngineDefaultParametersResult>;
    describeEventCategories: $APIMethod<RDS$20130212$DescribeEventCategoriesMessage, RDS$20130212$EventCategoriesMessage>;
    describeEventSubscriptions: $APIMethod<RDS$20130212$DescribeEventSubscriptionsMessage, RDS$20130212$EventSubscriptionsMessage>;
    describeEvents: $APIMethod<RDS$20130212$DescribeEventsMessage, RDS$20130212$EventsMessage>;
    describeOptionGroupOptions: $APIMethod<RDS$20130212$DescribeOptionGroupOptionsMessage, RDS$20130212$OptionGroupOptionsMessage>;
    describeOptionGroups: $APIMethod<RDS$20130212$DescribeOptionGroupsMessage, RDS$20130212$OptionGroups>;
    describeOrderableDBInstanceOptions: $APIMethod<RDS$20130212$DescribeOrderableDBInstanceOptionsMessage, RDS$20130212$OrderableDBInstanceOptionsMessage>;
    describeReservedDBInstances: $APIMethod<RDS$20130212$DescribeReservedDBInstancesMessage, RDS$20130212$ReservedDBInstanceMessage>;
    describeReservedDBInstancesOfferings: $APIMethod<RDS$20130212$DescribeReservedDBInstancesOfferingsMessage, RDS$20130212$ReservedDBInstancesOfferingMessage>;
    downloadDBLogFilePortion: $APIMethod<RDS$20130212$DownloadDBLogFilePortionMessage, RDS$20130212$DownloadDBLogFilePortionDetails>;
    listTagsForResource: $APIMethod<RDS$20130212$ListTagsForResourceMessage, RDS$20130212$TagListMessage>;
    modifyDBInstance: $APIMethod<RDS$20130212$ModifyDBInstanceMessage, RDS$20130212$ModifyDBInstanceResult>;
    modifyDBParameterGroup: $APIMethod<RDS$20130212$ModifyDBParameterGroupMessage, RDS$20130212$DBParameterGroupNameMessage>;
    modifyDBSubnetGroup: $APIMethod<RDS$20130212$ModifyDBSubnetGroupMessage, RDS$20130212$ModifyDBSubnetGroupResult>;
    modifyEventSubscription: $APIMethod<RDS$20130212$ModifyEventSubscriptionMessage, RDS$20130212$ModifyEventSubscriptionResult>;
    modifyOptionGroup: $APIMethod<RDS$20130212$ModifyOptionGroupMessage, RDS$20130212$ModifyOptionGroupResult>;
    promoteReadReplica: $APIMethod<RDS$20130212$PromoteReadReplicaMessage, RDS$20130212$PromoteReadReplicaResult>;
    purchaseReservedDBInstancesOffering: $APIMethod<RDS$20130212$PurchaseReservedDBInstancesOfferingMessage, RDS$20130212$PurchaseReservedDBInstancesOfferingResult>;
    rebootDBInstance: $APIMethod<RDS$20130212$RebootDBInstanceMessage, RDS$20130212$RebootDBInstanceResult>;
    removeSourceIdentifierFromSubscription: $APIMethod<RDS$20130212$RemoveSourceIdentifierFromSubscriptionMessage, RDS$20130212$RemoveSourceIdentifierFromSubscriptionResult>;
    removeTagsFromResource: $APIMethod<RDS$20130212$RemoveTagsFromResourceMessage, void>;
    resetDBParameterGroup: $APIMethod<RDS$20130212$ResetDBParameterGroupMessage, RDS$20130212$DBParameterGroupNameMessage>;
    restoreDBInstanceFromDBSnapshot: $APIMethod<RDS$20130212$RestoreDBInstanceFromDBSnapshotMessage, RDS$20130212$RestoreDBInstanceFromDBSnapshotResult>;
    restoreDBInstanceToPointInTime: $APIMethod<RDS$20130212$RestoreDBInstanceToPointInTimeMessage, RDS$20130212$RestoreDBInstanceToPointInTimeResult>;
    revokeDBSecurityGroupIngress: $APIMethod<RDS$20130212$RevokeDBSecurityGroupIngressMessage, RDS$20130212$RevokeDBSecurityGroupIngressResult>;
  }
  declare class RDS$20130909 {
    addSourceIdentifierToSubscription: $APIMethod<RDS$20130909$AddSourceIdentifierToSubscriptionMessage, RDS$20130909$AddSourceIdentifierToSubscriptionResult>;
    addTagsToResource: $APIMethod<RDS$20130909$AddTagsToResourceMessage, void>;
    authorizeDBSecurityGroupIngress: $APIMethod<RDS$20130909$AuthorizeDBSecurityGroupIngressMessage, RDS$20130909$AuthorizeDBSecurityGroupIngressResult>;
    copyDBSnapshot: $APIMethod<RDS$20130909$CopyDBSnapshotMessage, RDS$20130909$CopyDBSnapshotResult>;
    createDBInstance: $APIMethod<RDS$20130909$CreateDBInstanceMessage, RDS$20130909$CreateDBInstanceResult>;
    createDBInstanceReadReplica: $APIMethod<RDS$20130909$CreateDBInstanceReadReplicaMessage, RDS$20130909$CreateDBInstanceReadReplicaResult>;
    createDBParameterGroup: $APIMethod<RDS$20130909$CreateDBParameterGroupMessage, RDS$20130909$CreateDBParameterGroupResult>;
    createDBSecurityGroup: $APIMethod<RDS$20130909$CreateDBSecurityGroupMessage, RDS$20130909$CreateDBSecurityGroupResult>;
    createDBSnapshot: $APIMethod<RDS$20130909$CreateDBSnapshotMessage, RDS$20130909$CreateDBSnapshotResult>;
    createDBSubnetGroup: $APIMethod<RDS$20130909$CreateDBSubnetGroupMessage, RDS$20130909$CreateDBSubnetGroupResult>;
    createEventSubscription: $APIMethod<RDS$20130909$CreateEventSubscriptionMessage, RDS$20130909$CreateEventSubscriptionResult>;
    createOptionGroup: $APIMethod<RDS$20130909$CreateOptionGroupMessage, RDS$20130909$CreateOptionGroupResult>;
    deleteDBInstance: $APIMethod<RDS$20130909$DeleteDBInstanceMessage, RDS$20130909$DeleteDBInstanceResult>;
    deleteDBParameterGroup: $APIMethod<RDS$20130909$DeleteDBParameterGroupMessage, void>;
    deleteDBSecurityGroup: $APIMethod<RDS$20130909$DeleteDBSecurityGroupMessage, void>;
    deleteDBSnapshot: $APIMethod<RDS$20130909$DeleteDBSnapshotMessage, RDS$20130909$DeleteDBSnapshotResult>;
    deleteDBSubnetGroup: $APIMethod<RDS$20130909$DeleteDBSubnetGroupMessage, void>;
    deleteEventSubscription: $APIMethod<RDS$20130909$DeleteEventSubscriptionMessage, RDS$20130909$DeleteEventSubscriptionResult>;
    deleteOptionGroup: $APIMethod<RDS$20130909$DeleteOptionGroupMessage, void>;
    describeDBEngineVersions: $APIMethod<RDS$20130909$DescribeDBEngineVersionsMessage, RDS$20130909$DBEngineVersionMessage>;
    describeDBInstances: $APIMethod<RDS$20130909$DescribeDBInstancesMessage, RDS$20130909$DBInstanceMessage>;
    describeDBLogFiles: $APIMethod<RDS$20130909$DescribeDBLogFilesMessage, RDS$20130909$DescribeDBLogFilesResponse>;
    describeDBParameterGroups: $APIMethod<RDS$20130909$DescribeDBParameterGroupsMessage, RDS$20130909$DBParameterGroupsMessage>;
    describeDBParameters: $APIMethod<RDS$20130909$DescribeDBParametersMessage, RDS$20130909$DBParameterGroupDetails>;
    describeDBSecurityGroups: $APIMethod<RDS$20130909$DescribeDBSecurityGroupsMessage, RDS$20130909$DBSecurityGroupMessage>;
    describeDBSnapshots: $APIMethod<RDS$20130909$DescribeDBSnapshotsMessage, RDS$20130909$DBSnapshotMessage>;
    describeDBSubnetGroups: $APIMethod<RDS$20130909$DescribeDBSubnetGroupsMessage, RDS$20130909$DBSubnetGroupMessage>;
    describeEngineDefaultParameters: $APIMethod<RDS$20130909$DescribeEngineDefaultParametersMessage, RDS$20130909$DescribeEngineDefaultParametersResult>;
    describeEventCategories: $APIMethod<RDS$20130909$DescribeEventCategoriesMessage, RDS$20130909$EventCategoriesMessage>;
    describeEventSubscriptions: $APIMethod<RDS$20130909$DescribeEventSubscriptionsMessage, RDS$20130909$EventSubscriptionsMessage>;
    describeEvents: $APIMethod<RDS$20130909$DescribeEventsMessage, RDS$20130909$EventsMessage>;
    describeOptionGroupOptions: $APIMethod<RDS$20130909$DescribeOptionGroupOptionsMessage, RDS$20130909$OptionGroupOptionsMessage>;
    describeOptionGroups: $APIMethod<RDS$20130909$DescribeOptionGroupsMessage, RDS$20130909$OptionGroups>;
    describeOrderableDBInstanceOptions: $APIMethod<RDS$20130909$DescribeOrderableDBInstanceOptionsMessage, RDS$20130909$OrderableDBInstanceOptionsMessage>;
    describeReservedDBInstances: $APIMethod<RDS$20130909$DescribeReservedDBInstancesMessage, RDS$20130909$ReservedDBInstanceMessage>;
    describeReservedDBInstancesOfferings: $APIMethod<RDS$20130909$DescribeReservedDBInstancesOfferingsMessage, RDS$20130909$ReservedDBInstancesOfferingMessage>;
    downloadDBLogFilePortion: $APIMethod<RDS$20130909$DownloadDBLogFilePortionMessage, RDS$20130909$DownloadDBLogFilePortionDetails>;
    listTagsForResource: $APIMethod<RDS$20130909$ListTagsForResourceMessage, RDS$20130909$TagListMessage>;
    modifyDBInstance: $APIMethod<RDS$20130909$ModifyDBInstanceMessage, RDS$20130909$ModifyDBInstanceResult>;
    modifyDBParameterGroup: $APIMethod<RDS$20130909$ModifyDBParameterGroupMessage, RDS$20130909$DBParameterGroupNameMessage>;
    modifyDBSubnetGroup: $APIMethod<RDS$20130909$ModifyDBSubnetGroupMessage, RDS$20130909$ModifyDBSubnetGroupResult>;
    modifyEventSubscription: $APIMethod<RDS$20130909$ModifyEventSubscriptionMessage, RDS$20130909$ModifyEventSubscriptionResult>;
    modifyOptionGroup: $APIMethod<RDS$20130909$ModifyOptionGroupMessage, RDS$20130909$ModifyOptionGroupResult>;
    promoteReadReplica: $APIMethod<RDS$20130909$PromoteReadReplicaMessage, RDS$20130909$PromoteReadReplicaResult>;
    purchaseReservedDBInstancesOffering: $APIMethod<RDS$20130909$PurchaseReservedDBInstancesOfferingMessage, RDS$20130909$PurchaseReservedDBInstancesOfferingResult>;
    rebootDBInstance: $APIMethod<RDS$20130909$RebootDBInstanceMessage, RDS$20130909$RebootDBInstanceResult>;
    removeSourceIdentifierFromSubscription: $APIMethod<RDS$20130909$RemoveSourceIdentifierFromSubscriptionMessage, RDS$20130909$RemoveSourceIdentifierFromSubscriptionResult>;
    removeTagsFromResource: $APIMethod<RDS$20130909$RemoveTagsFromResourceMessage, void>;
    resetDBParameterGroup: $APIMethod<RDS$20130909$ResetDBParameterGroupMessage, RDS$20130909$DBParameterGroupNameMessage>;
    restoreDBInstanceFromDBSnapshot: $APIMethod<RDS$20130909$RestoreDBInstanceFromDBSnapshotMessage, RDS$20130909$RestoreDBInstanceFromDBSnapshotResult>;
    restoreDBInstanceToPointInTime: $APIMethod<RDS$20130909$RestoreDBInstanceToPointInTimeMessage, RDS$20130909$RestoreDBInstanceToPointInTimeResult>;
    revokeDBSecurityGroupIngress: $APIMethod<RDS$20130909$RevokeDBSecurityGroupIngressMessage, RDS$20130909$RevokeDBSecurityGroupIngressResult>;
  }
  declare class RDS$20141031 {
    addSourceIdentifierToSubscription: $APIMethod<RDS$20141031$AddSourceIdentifierToSubscriptionMessage, RDS$20141031$AddSourceIdentifierToSubscriptionResult>;
    addTagsToResource: $APIMethod<RDS$20141031$AddTagsToResourceMessage, void>;
    applyPendingMaintenanceAction: $APIMethod<RDS$20141031$ApplyPendingMaintenanceActionMessage, RDS$20141031$ApplyPendingMaintenanceActionResult>;
    authorizeDBSecurityGroupIngress: $APIMethod<RDS$20141031$AuthorizeDBSecurityGroupIngressMessage, RDS$20141031$AuthorizeDBSecurityGroupIngressResult>;
    copyDBClusterParameterGroup: $APIMethod<RDS$20141031$CopyDBClusterParameterGroupMessage, RDS$20141031$CopyDBClusterParameterGroupResult>;
    copyDBClusterSnapshot: $APIMethod<RDS$20141031$CopyDBClusterSnapshotMessage, RDS$20141031$CopyDBClusterSnapshotResult>;
    copyDBParameterGroup: $APIMethod<RDS$20141031$CopyDBParameterGroupMessage, RDS$20141031$CopyDBParameterGroupResult>;
    copyDBSnapshot: $APIMethod<RDS$20141031$CopyDBSnapshotMessage, RDS$20141031$CopyDBSnapshotResult>;
    copyOptionGroup: $APIMethod<RDS$20141031$CopyOptionGroupMessage, RDS$20141031$CopyOptionGroupResult>;
    createDBCluster: $APIMethod<RDS$20141031$CreateDBClusterMessage, RDS$20141031$CreateDBClusterResult>;
    createDBClusterParameterGroup: $APIMethod<RDS$20141031$CreateDBClusterParameterGroupMessage, RDS$20141031$CreateDBClusterParameterGroupResult>;
    createDBClusterSnapshot: $APIMethod<RDS$20141031$CreateDBClusterSnapshotMessage, RDS$20141031$CreateDBClusterSnapshotResult>;
    createDBInstance: $APIMethod<RDS$20141031$CreateDBInstanceMessage, RDS$20141031$CreateDBInstanceResult>;
    createDBInstanceReadReplica: $APIMethod<RDS$20141031$CreateDBInstanceReadReplicaMessage, RDS$20141031$CreateDBInstanceReadReplicaResult>;
    createDBParameterGroup: $APIMethod<RDS$20141031$CreateDBParameterGroupMessage, RDS$20141031$CreateDBParameterGroupResult>;
    createDBSecurityGroup: $APIMethod<RDS$20141031$CreateDBSecurityGroupMessage, RDS$20141031$CreateDBSecurityGroupResult>;
    createDBSnapshot: $APIMethod<RDS$20141031$CreateDBSnapshotMessage, RDS$20141031$CreateDBSnapshotResult>;
    createDBSubnetGroup: $APIMethod<RDS$20141031$CreateDBSubnetGroupMessage, RDS$20141031$CreateDBSubnetGroupResult>;
    createEventSubscription: $APIMethod<RDS$20141031$CreateEventSubscriptionMessage, RDS$20141031$CreateEventSubscriptionResult>;
    createOptionGroup: $APIMethod<RDS$20141031$CreateOptionGroupMessage, RDS$20141031$CreateOptionGroupResult>;
    deleteDBCluster: $APIMethod<RDS$20141031$DeleteDBClusterMessage, RDS$20141031$DeleteDBClusterResult>;
    deleteDBClusterParameterGroup: $APIMethod<RDS$20141031$DeleteDBClusterParameterGroupMessage, void>;
    deleteDBClusterSnapshot: $APIMethod<RDS$20141031$DeleteDBClusterSnapshotMessage, RDS$20141031$DeleteDBClusterSnapshotResult>;
    deleteDBInstance: $APIMethod<RDS$20141031$DeleteDBInstanceMessage, RDS$20141031$DeleteDBInstanceResult>;
    deleteDBParameterGroup: $APIMethod<RDS$20141031$DeleteDBParameterGroupMessage, void>;
    deleteDBSecurityGroup: $APIMethod<RDS$20141031$DeleteDBSecurityGroupMessage, void>;
    deleteDBSnapshot: $APIMethod<RDS$20141031$DeleteDBSnapshotMessage, RDS$20141031$DeleteDBSnapshotResult>;
    deleteDBSubnetGroup: $APIMethod<RDS$20141031$DeleteDBSubnetGroupMessage, void>;
    deleteEventSubscription: $APIMethod<RDS$20141031$DeleteEventSubscriptionMessage, RDS$20141031$DeleteEventSubscriptionResult>;
    deleteOptionGroup: $APIMethod<RDS$20141031$DeleteOptionGroupMessage, void>;
    describeAccountAttributes: $APIMethod<RDS$20141031$DescribeAccountAttributesMessage, RDS$20141031$AccountAttributesMessage>;
    describeCertificates: $APIMethod<RDS$20141031$DescribeCertificatesMessage, RDS$20141031$CertificateMessage>;
    describeDBClusterParameterGroups: $APIMethod<RDS$20141031$DescribeDBClusterParameterGroupsMessage, RDS$20141031$DBClusterParameterGroupsMessage>;
    describeDBClusterParameters: $APIMethod<RDS$20141031$DescribeDBClusterParametersMessage, RDS$20141031$DBClusterParameterGroupDetails>;
    describeDBClusterSnapshotAttributes: $APIMethod<RDS$20141031$DescribeDBClusterSnapshotAttributesMessage, RDS$20141031$DescribeDBClusterSnapshotAttributesResult>;
    describeDBClusterSnapshots: $APIMethod<RDS$20141031$DescribeDBClusterSnapshotsMessage, RDS$20141031$DBClusterSnapshotMessage>;
    describeDBClusters: $APIMethod<RDS$20141031$DescribeDBClustersMessage, RDS$20141031$DBClusterMessage>;
    describeDBEngineVersions: $APIMethod<RDS$20141031$DescribeDBEngineVersionsMessage, RDS$20141031$DBEngineVersionMessage>;
    describeDBInstances: $APIMethod<RDS$20141031$DescribeDBInstancesMessage, RDS$20141031$DBInstanceMessage>;
    describeDBLogFiles: $APIMethod<RDS$20141031$DescribeDBLogFilesMessage, RDS$20141031$DescribeDBLogFilesResponse>;
    describeDBParameterGroups: $APIMethod<RDS$20141031$DescribeDBParameterGroupsMessage, RDS$20141031$DBParameterGroupsMessage>;
    describeDBParameters: $APIMethod<RDS$20141031$DescribeDBParametersMessage, RDS$20141031$DBParameterGroupDetails>;
    describeDBSecurityGroups: $APIMethod<RDS$20141031$DescribeDBSecurityGroupsMessage, RDS$20141031$DBSecurityGroupMessage>;
    describeDBSnapshotAttributes: $APIMethod<RDS$20141031$DescribeDBSnapshotAttributesMessage, RDS$20141031$DescribeDBSnapshotAttributesResult>;
    describeDBSnapshots: $APIMethod<RDS$20141031$DescribeDBSnapshotsMessage, RDS$20141031$DBSnapshotMessage>;
    describeDBSubnetGroups: $APIMethod<RDS$20141031$DescribeDBSubnetGroupsMessage, RDS$20141031$DBSubnetGroupMessage>;
    describeEngineDefaultClusterParameters: $APIMethod<RDS$20141031$DescribeEngineDefaultClusterParametersMessage, RDS$20141031$DescribeEngineDefaultClusterParametersResult>;
    describeEngineDefaultParameters: $APIMethod<RDS$20141031$DescribeEngineDefaultParametersMessage, RDS$20141031$DescribeEngineDefaultParametersResult>;
    describeEventCategories: $APIMethod<RDS$20141031$DescribeEventCategoriesMessage, RDS$20141031$EventCategoriesMessage>;
    describeEventSubscriptions: $APIMethod<RDS$20141031$DescribeEventSubscriptionsMessage, RDS$20141031$EventSubscriptionsMessage>;
    describeEvents: $APIMethod<RDS$20141031$DescribeEventsMessage, RDS$20141031$EventsMessage>;
    describeOptionGroupOptions: $APIMethod<RDS$20141031$DescribeOptionGroupOptionsMessage, RDS$20141031$OptionGroupOptionsMessage>;
    describeOptionGroups: $APIMethod<RDS$20141031$DescribeOptionGroupsMessage, RDS$20141031$OptionGroups>;
    describeOrderableDBInstanceOptions: $APIMethod<RDS$20141031$DescribeOrderableDBInstanceOptionsMessage, RDS$20141031$OrderableDBInstanceOptionsMessage>;
    describePendingMaintenanceActions: $APIMethod<RDS$20141031$DescribePendingMaintenanceActionsMessage, RDS$20141031$PendingMaintenanceActionsMessage>;
    describeReservedDBInstances: $APIMethod<RDS$20141031$DescribeReservedDBInstancesMessage, RDS$20141031$ReservedDBInstanceMessage>;
    describeReservedDBInstancesOfferings: $APIMethod<RDS$20141031$DescribeReservedDBInstancesOfferingsMessage, RDS$20141031$ReservedDBInstancesOfferingMessage>;
    downloadDBLogFilePortion: $APIMethod<RDS$20141031$DownloadDBLogFilePortionMessage, RDS$20141031$DownloadDBLogFilePortionDetails>;
    failoverDBCluster: $APIMethod<RDS$20141031$FailoverDBClusterMessage, RDS$20141031$FailoverDBClusterResult>;
    listTagsForResource: $APIMethod<RDS$20141031$ListTagsForResourceMessage, RDS$20141031$TagListMessage>;
    modifyDBCluster: $APIMethod<RDS$20141031$ModifyDBClusterMessage, RDS$20141031$ModifyDBClusterResult>;
    modifyDBClusterParameterGroup: $APIMethod<RDS$20141031$ModifyDBClusterParameterGroupMessage, RDS$20141031$DBClusterParameterGroupNameMessage>;
    modifyDBClusterSnapshotAttribute: $APIMethod<RDS$20141031$ModifyDBClusterSnapshotAttributeMessage, RDS$20141031$ModifyDBClusterSnapshotAttributeResult>;
    modifyDBInstance: $APIMethod<RDS$20141031$ModifyDBInstanceMessage, RDS$20141031$ModifyDBInstanceResult>;
    modifyDBParameterGroup: $APIMethod<RDS$20141031$ModifyDBParameterGroupMessage, RDS$20141031$DBParameterGroupNameMessage>;
    modifyDBSnapshotAttribute: $APIMethod<RDS$20141031$ModifyDBSnapshotAttributeMessage, RDS$20141031$ModifyDBSnapshotAttributeResult>;
    modifyDBSubnetGroup: $APIMethod<RDS$20141031$ModifyDBSubnetGroupMessage, RDS$20141031$ModifyDBSubnetGroupResult>;
    modifyEventSubscription: $APIMethod<RDS$20141031$ModifyEventSubscriptionMessage, RDS$20141031$ModifyEventSubscriptionResult>;
    modifyOptionGroup: $APIMethod<RDS$20141031$ModifyOptionGroupMessage, RDS$20141031$ModifyOptionGroupResult>;
    promoteReadReplica: $APIMethod<RDS$20141031$PromoteReadReplicaMessage, RDS$20141031$PromoteReadReplicaResult>;
    promoteReadReplicaDBCluster: $APIMethod<RDS$20141031$PromoteReadReplicaDBClusterMessage, RDS$20141031$PromoteReadReplicaDBClusterResult>;
    purchaseReservedDBInstancesOffering: $APIMethod<RDS$20141031$PurchaseReservedDBInstancesOfferingMessage, RDS$20141031$PurchaseReservedDBInstancesOfferingResult>;
    rebootDBInstance: $APIMethod<RDS$20141031$RebootDBInstanceMessage, RDS$20141031$RebootDBInstanceResult>;
    removeSourceIdentifierFromSubscription: $APIMethod<RDS$20141031$RemoveSourceIdentifierFromSubscriptionMessage, RDS$20141031$RemoveSourceIdentifierFromSubscriptionResult>;
    removeTagsFromResource: $APIMethod<RDS$20141031$RemoveTagsFromResourceMessage, void>;
    resetDBClusterParameterGroup: $APIMethod<RDS$20141031$ResetDBClusterParameterGroupMessage, RDS$20141031$DBClusterParameterGroupNameMessage>;
    resetDBParameterGroup: $APIMethod<RDS$20141031$ResetDBParameterGroupMessage, RDS$20141031$DBParameterGroupNameMessage>;
    restoreDBClusterFromS3: $APIMethod<RDS$20141031$RestoreDBClusterFromS3Message, RDS$20141031$RestoreDBClusterFromS3Result>;
    restoreDBClusterFromSnapshot: $APIMethod<RDS$20141031$RestoreDBClusterFromSnapshotMessage, RDS$20141031$RestoreDBClusterFromSnapshotResult>;
    restoreDBClusterToPointInTime: $APIMethod<RDS$20141031$RestoreDBClusterToPointInTimeMessage, RDS$20141031$RestoreDBClusterToPointInTimeResult>;
    restoreDBInstanceFromDBSnapshot: $APIMethod<RDS$20141031$RestoreDBInstanceFromDBSnapshotMessage, RDS$20141031$RestoreDBInstanceFromDBSnapshotResult>;
    restoreDBInstanceToPointInTime: $APIMethod<RDS$20141031$RestoreDBInstanceToPointInTimeMessage, RDS$20141031$RestoreDBInstanceToPointInTimeResult>;
    revokeDBSecurityGroupIngress: $APIMethod<RDS$20141031$RevokeDBSecurityGroupIngressMessage, RDS$20141031$RevokeDBSecurityGroupIngressResult>;
  }
  declare class RDS {
    constructor(config: $ConfigOptions & {
      apiVersion: '2013-01-10';
    }): RDS$20130110;
    constructor(config: $ConfigOptions & {
      apiVersion: '2013-02-12';
    }): RDS$20130212;
    constructor(config: $ConfigOptions & {
      apiVersion: '2013-09-09';
    }): RDS$20130909;
    constructor(config: $ConfigOptions & {
      apiVersion: '2014-10-31';
    }): RDS$20141031;
    constructor(): RDS$20141031;
  }
  declare class Redshift$20121201 {
    authorizeClusterSecurityGroupIngress: $APIMethod<Redshift$20121201$AuthorizeClusterSecurityGroupIngressMessage, Redshift$20121201$AuthorizeClusterSecurityGroupIngressResult>;
    authorizeSnapshotAccess: $APIMethod<Redshift$20121201$AuthorizeSnapshotAccessMessage, Redshift$20121201$AuthorizeSnapshotAccessResult>;
    copyClusterSnapshot: $APIMethod<Redshift$20121201$CopyClusterSnapshotMessage, Redshift$20121201$CopyClusterSnapshotResult>;
    createCluster: $APIMethod<Redshift$20121201$CreateClusterMessage, Redshift$20121201$CreateClusterResult>;
    createClusterParameterGroup: $APIMethod<Redshift$20121201$CreateClusterParameterGroupMessage, Redshift$20121201$CreateClusterParameterGroupResult>;
    createClusterSecurityGroup: $APIMethod<Redshift$20121201$CreateClusterSecurityGroupMessage, Redshift$20121201$CreateClusterSecurityGroupResult>;
    createClusterSnapshot: $APIMethod<Redshift$20121201$CreateClusterSnapshotMessage, Redshift$20121201$CreateClusterSnapshotResult>;
    createClusterSubnetGroup: $APIMethod<Redshift$20121201$CreateClusterSubnetGroupMessage, Redshift$20121201$CreateClusterSubnetGroupResult>;
    createEventSubscription: $APIMethod<Redshift$20121201$CreateEventSubscriptionMessage, Redshift$20121201$CreateEventSubscriptionResult>;
    createHsmClientCertificate: $APIMethod<Redshift$20121201$CreateHsmClientCertificateMessage, Redshift$20121201$CreateHsmClientCertificateResult>;
    createHsmConfiguration: $APIMethod<Redshift$20121201$CreateHsmConfigurationMessage, Redshift$20121201$CreateHsmConfigurationResult>;
    createSnapshotCopyGrant: $APIMethod<Redshift$20121201$CreateSnapshotCopyGrantMessage, Redshift$20121201$CreateSnapshotCopyGrantResult>;
    createTags: $APIMethod<Redshift$20121201$CreateTagsMessage, void>;
    deleteCluster: $APIMethod<Redshift$20121201$DeleteClusterMessage, Redshift$20121201$DeleteClusterResult>;
    deleteClusterParameterGroup: $APIMethod<Redshift$20121201$DeleteClusterParameterGroupMessage, void>;
    deleteClusterSecurityGroup: $APIMethod<Redshift$20121201$DeleteClusterSecurityGroupMessage, void>;
    deleteClusterSnapshot: $APIMethod<Redshift$20121201$DeleteClusterSnapshotMessage, Redshift$20121201$DeleteClusterSnapshotResult>;
    deleteClusterSubnetGroup: $APIMethod<Redshift$20121201$DeleteClusterSubnetGroupMessage, void>;
    deleteEventSubscription: $APIMethod<Redshift$20121201$DeleteEventSubscriptionMessage, void>;
    deleteHsmClientCertificate: $APIMethod<Redshift$20121201$DeleteHsmClientCertificateMessage, void>;
    deleteHsmConfiguration: $APIMethod<Redshift$20121201$DeleteHsmConfigurationMessage, void>;
    deleteSnapshotCopyGrant: $APIMethod<Redshift$20121201$DeleteSnapshotCopyGrantMessage, void>;
    deleteTags: $APIMethod<Redshift$20121201$DeleteTagsMessage, void>;
    describeClusterParameterGroups: $APIMethod<Redshift$20121201$DescribeClusterParameterGroupsMessage, Redshift$20121201$ClusterParameterGroupsMessage>;
    describeClusterParameters: $APIMethod<Redshift$20121201$DescribeClusterParametersMessage, Redshift$20121201$ClusterParameterGroupDetails>;
    describeClusterSecurityGroups: $APIMethod<Redshift$20121201$DescribeClusterSecurityGroupsMessage, Redshift$20121201$ClusterSecurityGroupMessage>;
    describeClusterSnapshots: $APIMethod<Redshift$20121201$DescribeClusterSnapshotsMessage, Redshift$20121201$SnapshotMessage>;
    describeClusterSubnetGroups: $APIMethod<Redshift$20121201$DescribeClusterSubnetGroupsMessage, Redshift$20121201$ClusterSubnetGroupMessage>;
    describeClusterVersions: $APIMethod<Redshift$20121201$DescribeClusterVersionsMessage, Redshift$20121201$ClusterVersionsMessage>;
    describeClusters: $APIMethod<Redshift$20121201$DescribeClustersMessage, Redshift$20121201$ClustersMessage>;
    describeDefaultClusterParameters: $APIMethod<Redshift$20121201$DescribeDefaultClusterParametersMessage, Redshift$20121201$DescribeDefaultClusterParametersResult>;
    describeEventCategories: $APIMethod<Redshift$20121201$DescribeEventCategoriesMessage, Redshift$20121201$EventCategoriesMessage>;
    describeEventSubscriptions: $APIMethod<Redshift$20121201$DescribeEventSubscriptionsMessage, Redshift$20121201$EventSubscriptionsMessage>;
    describeEvents: $APIMethod<Redshift$20121201$DescribeEventsMessage, Redshift$20121201$EventsMessage>;
    describeHsmClientCertificates: $APIMethod<Redshift$20121201$DescribeHsmClientCertificatesMessage, Redshift$20121201$HsmClientCertificateMessage>;
    describeHsmConfigurations: $APIMethod<Redshift$20121201$DescribeHsmConfigurationsMessage, Redshift$20121201$HsmConfigurationMessage>;
    describeLoggingStatus: $APIMethod<Redshift$20121201$DescribeLoggingStatusMessage, Redshift$20121201$LoggingStatus>;
    describeOrderableClusterOptions: $APIMethod<Redshift$20121201$DescribeOrderableClusterOptionsMessage, Redshift$20121201$OrderableClusterOptionsMessage>;
    describeReservedNodeOfferings: $APIMethod<Redshift$20121201$DescribeReservedNodeOfferingsMessage, Redshift$20121201$ReservedNodeOfferingsMessage>;
    describeReservedNodes: $APIMethod<Redshift$20121201$DescribeReservedNodesMessage, Redshift$20121201$ReservedNodesMessage>;
    describeResize: $APIMethod<Redshift$20121201$DescribeResizeMessage, Redshift$20121201$ResizeProgressMessage>;
    describeSnapshotCopyGrants: $APIMethod<Redshift$20121201$DescribeSnapshotCopyGrantsMessage, Redshift$20121201$SnapshotCopyGrantMessage>;
    describeTableRestoreStatus: $APIMethod<Redshift$20121201$DescribeTableRestoreStatusMessage, Redshift$20121201$TableRestoreStatusMessage>;
    describeTags: $APIMethod<Redshift$20121201$DescribeTagsMessage, Redshift$20121201$TaggedResourceListMessage>;
    disableLogging: $APIMethod<Redshift$20121201$DisableLoggingMessage, Redshift$20121201$LoggingStatus>;
    disableSnapshotCopy: $APIMethod<Redshift$20121201$DisableSnapshotCopyMessage, Redshift$20121201$DisableSnapshotCopyResult>;
    enableLogging: $APIMethod<Redshift$20121201$EnableLoggingMessage, Redshift$20121201$LoggingStatus>;
    enableSnapshotCopy: $APIMethod<Redshift$20121201$EnableSnapshotCopyMessage, Redshift$20121201$EnableSnapshotCopyResult>;
    modifyCluster: $APIMethod<Redshift$20121201$ModifyClusterMessage, Redshift$20121201$ModifyClusterResult>;
    modifyClusterIamRoles: $APIMethod<Redshift$20121201$ModifyClusterIamRolesMessage, Redshift$20121201$ModifyClusterIamRolesResult>;
    modifyClusterParameterGroup: $APIMethod<Redshift$20121201$ModifyClusterParameterGroupMessage, Redshift$20121201$ClusterParameterGroupNameMessage>;
    modifyClusterSubnetGroup: $APIMethod<Redshift$20121201$ModifyClusterSubnetGroupMessage, Redshift$20121201$ModifyClusterSubnetGroupResult>;
    modifyEventSubscription: $APIMethod<Redshift$20121201$ModifyEventSubscriptionMessage, Redshift$20121201$ModifyEventSubscriptionResult>;
    modifySnapshotCopyRetentionPeriod: $APIMethod<Redshift$20121201$ModifySnapshotCopyRetentionPeriodMessage, Redshift$20121201$ModifySnapshotCopyRetentionPeriodResult>;
    purchaseReservedNodeOffering: $APIMethod<Redshift$20121201$PurchaseReservedNodeOfferingMessage, Redshift$20121201$PurchaseReservedNodeOfferingResult>;
    rebootCluster: $APIMethod<Redshift$20121201$RebootClusterMessage, Redshift$20121201$RebootClusterResult>;
    resetClusterParameterGroup: $APIMethod<Redshift$20121201$ResetClusterParameterGroupMessage, Redshift$20121201$ClusterParameterGroupNameMessage>;
    restoreFromClusterSnapshot: $APIMethod<Redshift$20121201$RestoreFromClusterSnapshotMessage, Redshift$20121201$RestoreFromClusterSnapshotResult>;
    restoreTableFromClusterSnapshot: $APIMethod<Redshift$20121201$RestoreTableFromClusterSnapshotMessage, Redshift$20121201$RestoreTableFromClusterSnapshotResult>;
    revokeClusterSecurityGroupIngress: $APIMethod<Redshift$20121201$RevokeClusterSecurityGroupIngressMessage, Redshift$20121201$RevokeClusterSecurityGroupIngressResult>;
    revokeSnapshotAccess: $APIMethod<Redshift$20121201$RevokeSnapshotAccessMessage, Redshift$20121201$RevokeSnapshotAccessResult>;
    rotateEncryptionKey: $APIMethod<Redshift$20121201$RotateEncryptionKeyMessage, Redshift$20121201$RotateEncryptionKeyResult>;
  }
  declare class Redshift {
    constructor(config: $ConfigOptions & {
      apiVersion: '2012-12-01';
    }): Redshift$20121201;
    constructor(): Redshift$20121201;
  }
  declare class Route53$20130401 {
    associateVPCWithHostedZone: $APIMethod<Route53$20130401$AssociateVPCWithHostedZoneRequest, Route53$20130401$AssociateVPCWithHostedZoneResponse>;
    changeResourceRecordSets: $APIMethod<Route53$20130401$ChangeResourceRecordSetsRequest, Route53$20130401$ChangeResourceRecordSetsResponse>;
    changeTagsForResource: $APIMethod<Route53$20130401$ChangeTagsForResourceRequest, Route53$20130401$ChangeTagsForResourceResponse>;
    createHealthCheck: $APIMethod<Route53$20130401$CreateHealthCheckRequest, Route53$20130401$CreateHealthCheckResponse>;
    createHostedZone: $APIMethod<Route53$20130401$CreateHostedZoneRequest, Route53$20130401$CreateHostedZoneResponse>;
    createReusableDelegationSet: $APIMethod<Route53$20130401$CreateReusableDelegationSetRequest, Route53$20130401$CreateReusableDelegationSetResponse>;
    createTrafficPolicy: $APIMethod<Route53$20130401$CreateTrafficPolicyRequest, Route53$20130401$CreateTrafficPolicyResponse>;
    createTrafficPolicyInstance: $APIMethod<Route53$20130401$CreateTrafficPolicyInstanceRequest, Route53$20130401$CreateTrafficPolicyInstanceResponse>;
    createTrafficPolicyVersion: $APIMethod<Route53$20130401$CreateTrafficPolicyVersionRequest, Route53$20130401$CreateTrafficPolicyVersionResponse>;
    deleteHealthCheck: $APIMethod<Route53$20130401$DeleteHealthCheckRequest, Route53$20130401$DeleteHealthCheckResponse>;
    deleteHostedZone: $APIMethod<Route53$20130401$DeleteHostedZoneRequest, Route53$20130401$DeleteHostedZoneResponse>;
    deleteReusableDelegationSet: $APIMethod<Route53$20130401$DeleteReusableDelegationSetRequest, Route53$20130401$DeleteReusableDelegationSetResponse>;
    deleteTrafficPolicy: $APIMethod<Route53$20130401$DeleteTrafficPolicyRequest, Route53$20130401$DeleteTrafficPolicyResponse>;
    deleteTrafficPolicyInstance: $APIMethod<Route53$20130401$DeleteTrafficPolicyInstanceRequest, Route53$20130401$DeleteTrafficPolicyInstanceResponse>;
    disassociateVPCFromHostedZone: $APIMethod<Route53$20130401$DisassociateVPCFromHostedZoneRequest, Route53$20130401$DisassociateVPCFromHostedZoneResponse>;
    getChange: $APIMethod<Route53$20130401$GetChangeRequest, Route53$20130401$GetChangeResponse>;
    getChangeDetails: $APIMethod<Route53$20130401$GetChangeDetailsRequest, Route53$20130401$GetChangeDetailsResponse>;
    getCheckerIpRanges: $APIMethod<Route53$20130401$GetCheckerIpRangesRequest, Route53$20130401$GetCheckerIpRangesResponse>;
    getGeoLocation: $APIMethod<Route53$20130401$GetGeoLocationRequest, Route53$20130401$GetGeoLocationResponse>;
    getHealthCheck: $APIMethod<Route53$20130401$GetHealthCheckRequest, Route53$20130401$GetHealthCheckResponse>;
    getHealthCheckCount: $APIMethod<Route53$20130401$GetHealthCheckCountRequest, Route53$20130401$GetHealthCheckCountResponse>;
    getHealthCheckLastFailureReason: $APIMethod<Route53$20130401$GetHealthCheckLastFailureReasonRequest, Route53$20130401$GetHealthCheckLastFailureReasonResponse>;
    getHealthCheckStatus: $APIMethod<Route53$20130401$GetHealthCheckStatusRequest, Route53$20130401$GetHealthCheckStatusResponse>;
    getHostedZone: $APIMethod<Route53$20130401$GetHostedZoneRequest, Route53$20130401$GetHostedZoneResponse>;
    getHostedZoneCount: $APIMethod<Route53$20130401$GetHostedZoneCountRequest, Route53$20130401$GetHostedZoneCountResponse>;
    getReusableDelegationSet: $APIMethod<Route53$20130401$GetReusableDelegationSetRequest, Route53$20130401$GetReusableDelegationSetResponse>;
    getTrafficPolicy: $APIMethod<Route53$20130401$GetTrafficPolicyRequest, Route53$20130401$GetTrafficPolicyResponse>;
    getTrafficPolicyInstance: $APIMethod<Route53$20130401$GetTrafficPolicyInstanceRequest, Route53$20130401$GetTrafficPolicyInstanceResponse>;
    getTrafficPolicyInstanceCount: $APIMethod<Route53$20130401$GetTrafficPolicyInstanceCountRequest, Route53$20130401$GetTrafficPolicyInstanceCountResponse>;
    listChangeBatchesByHostedZone: $APIMethod<Route53$20130401$ListChangeBatchesByHostedZoneRequest, Route53$20130401$ListChangeBatchesByHostedZoneResponse>;
    listChangeBatchesByRRSet: $APIMethod<Route53$20130401$ListChangeBatchesByRRSetRequest, Route53$20130401$ListChangeBatchesByRRSetResponse>;
    listGeoLocations: $APIMethod<Route53$20130401$ListGeoLocationsRequest, Route53$20130401$ListGeoLocationsResponse>;
    listHealthChecks: $APIMethod<Route53$20130401$ListHealthChecksRequest, Route53$20130401$ListHealthChecksResponse>;
    listHostedZones: $APIMethod<Route53$20130401$ListHostedZonesRequest, Route53$20130401$ListHostedZonesResponse>;
    listHostedZonesByName: $APIMethod<Route53$20130401$ListHostedZonesByNameRequest, Route53$20130401$ListHostedZonesByNameResponse>;
    listResourceRecordSets: $APIMethod<Route53$20130401$ListResourceRecordSetsRequest, Route53$20130401$ListResourceRecordSetsResponse>;
    listReusableDelegationSets: $APIMethod<Route53$20130401$ListReusableDelegationSetsRequest, Route53$20130401$ListReusableDelegationSetsResponse>;
    listTagsForResource: $APIMethod<Route53$20130401$ListTagsForResourceRequest, Route53$20130401$ListTagsForResourceResponse>;
    listTagsForResources: $APIMethod<Route53$20130401$ListTagsForResourcesRequest, Route53$20130401$ListTagsForResourcesResponse>;
    listTrafficPolicies: $APIMethod<Route53$20130401$ListTrafficPoliciesRequest, Route53$20130401$ListTrafficPoliciesResponse>;
    listTrafficPolicyInstances: $APIMethod<Route53$20130401$ListTrafficPolicyInstancesRequest, Route53$20130401$ListTrafficPolicyInstancesResponse>;
    listTrafficPolicyInstancesByHostedZone: $APIMethod<Route53$20130401$ListTrafficPolicyInstancesByHostedZoneRequest, Route53$20130401$ListTrafficPolicyInstancesByHostedZoneResponse>;
    listTrafficPolicyInstancesByPolicy: $APIMethod<Route53$20130401$ListTrafficPolicyInstancesByPolicyRequest, Route53$20130401$ListTrafficPolicyInstancesByPolicyResponse>;
    listTrafficPolicyVersions: $APIMethod<Route53$20130401$ListTrafficPolicyVersionsRequest, Route53$20130401$ListTrafficPolicyVersionsResponse>;
    updateHealthCheck: $APIMethod<Route53$20130401$UpdateHealthCheckRequest, Route53$20130401$UpdateHealthCheckResponse>;
    updateHostedZoneComment: $APIMethod<Route53$20130401$UpdateHostedZoneCommentRequest, Route53$20130401$UpdateHostedZoneCommentResponse>;
    updateTrafficPolicyComment: $APIMethod<Route53$20130401$UpdateTrafficPolicyCommentRequest, Route53$20130401$UpdateTrafficPolicyCommentResponse>;
    updateTrafficPolicyInstance: $APIMethod<Route53$20130401$UpdateTrafficPolicyInstanceRequest, Route53$20130401$UpdateTrafficPolicyInstanceResponse>;
  }
  declare class Route53 {
    constructor(config: $ConfigOptions & {
      apiVersion: '2013-04-01';
    }): Route53$20130401;
    constructor(): Route53$20130401;
  }
  declare class Route53Domains$20140515 {
    checkDomainAvailability: $APIMethod<Route53Domains$20140515$CheckDomainAvailabilityRequest, Route53Domains$20140515$CheckDomainAvailabilityResponse>;
    deleteTagsForDomain: $APIMethod<Route53Domains$20140515$DeleteTagsForDomainRequest, Route53Domains$20140515$DeleteTagsForDomainResponse>;
    disableDomainAutoRenew: $APIMethod<Route53Domains$20140515$DisableDomainAutoRenewRequest, Route53Domains$20140515$DisableDomainAutoRenewResponse>;
    disableDomainTransferLock: $APIMethod<Route53Domains$20140515$DisableDomainTransferLockRequest, Route53Domains$20140515$DisableDomainTransferLockResponse>;
    enableDomainAutoRenew: $APIMethod<Route53Domains$20140515$EnableDomainAutoRenewRequest, Route53Domains$20140515$EnableDomainAutoRenewResponse>;
    enableDomainTransferLock: $APIMethod<Route53Domains$20140515$EnableDomainTransferLockRequest, Route53Domains$20140515$EnableDomainTransferLockResponse>;
    getContactReachabilityStatus: $APIMethod<Route53Domains$20140515$GetContactReachabilityStatusRequest, Route53Domains$20140515$GetContactReachabilityStatusResponse>;
    getDomainDetail: $APIMethod<Route53Domains$20140515$GetDomainDetailRequest, Route53Domains$20140515$GetDomainDetailResponse>;
    getDomainSuggestions: $APIMethod<Route53Domains$20140515$GetDomainSuggestionsRequest, Route53Domains$20140515$GetDomainSuggestionsResponse>;
    getOperationDetail: $APIMethod<Route53Domains$20140515$GetOperationDetailRequest, Route53Domains$20140515$GetOperationDetailResponse>;
    listDomains: $APIMethod<Route53Domains$20140515$ListDomainsRequest, Route53Domains$20140515$ListDomainsResponse>;
    listOperations: $APIMethod<Route53Domains$20140515$ListOperationsRequest, Route53Domains$20140515$ListOperationsResponse>;
    listTagsForDomain: $APIMethod<Route53Domains$20140515$ListTagsForDomainRequest, Route53Domains$20140515$ListTagsForDomainResponse>;
    registerDomain: $APIMethod<Route53Domains$20140515$RegisterDomainRequest, Route53Domains$20140515$RegisterDomainResponse>;
    renewDomain: $APIMethod<Route53Domains$20140515$RenewDomainRequest, Route53Domains$20140515$RenewDomainResponse>;
    resendContactReachabilityEmail: $APIMethod<Route53Domains$20140515$ResendContactReachabilityEmailRequest, Route53Domains$20140515$ResendContactReachabilityEmailResponse>;
    retrieveDomainAuthCode: $APIMethod<Route53Domains$20140515$RetrieveDomainAuthCodeRequest, Route53Domains$20140515$RetrieveDomainAuthCodeResponse>;
    transferDomain: $APIMethod<Route53Domains$20140515$TransferDomainRequest, Route53Domains$20140515$TransferDomainResponse>;
    updateDomainContact: $APIMethod<Route53Domains$20140515$UpdateDomainContactRequest, Route53Domains$20140515$UpdateDomainContactResponse>;
    updateDomainContactPrivacy: $APIMethod<Route53Domains$20140515$UpdateDomainContactPrivacyRequest, Route53Domains$20140515$UpdateDomainContactPrivacyResponse>;
    updateDomainNameservers: $APIMethod<Route53Domains$20140515$UpdateDomainNameserversRequest, Route53Domains$20140515$UpdateDomainNameserversResponse>;
    updateTagsForDomain: $APIMethod<Route53Domains$20140515$UpdateTagsForDomainRequest, Route53Domains$20140515$UpdateTagsForDomainResponse>;
    viewBilling: $APIMethod<Route53Domains$20140515$ViewBillingRequest, Route53Domains$20140515$ViewBillingResponse>;
  }
  declare class Route53Domains {
    constructor(config: $ConfigOptions & {
      apiVersion: '2014-05-15';
    }): Route53Domains$20140515;
    constructor(): Route53Domains$20140515;
  }
  declare class S3$20060301 {
    abortMultipartUpload: $APIMethod<S3$20060301$AbortMultipartUploadRequest, S3$20060301$AbortMultipartUploadOutput>;
    completeMultipartUpload: $APIMethod<S3$20060301$CompleteMultipartUploadRequest, S3$20060301$CompleteMultipartUploadOutput>;
    copyObject: $APIMethod<S3$20060301$CopyObjectRequest, S3$20060301$CopyObjectOutput>;
    createBucket: $APIMethod<S3$20060301$CreateBucketRequest, S3$20060301$CreateBucketOutput>;
    createMultipartUpload: $APIMethod<S3$20060301$CreateMultipartUploadRequest, S3$20060301$CreateMultipartUploadOutput>;
    deleteBucket: $APIMethod<S3$20060301$DeleteBucketRequest, void>;
    deleteBucketCors: $APIMethod<S3$20060301$DeleteBucketCorsRequest, void>;
    deleteBucketLifecycle: $APIMethod<S3$20060301$DeleteBucketLifecycleRequest, void>;
    deleteBucketPolicy: $APIMethod<S3$20060301$DeleteBucketPolicyRequest, void>;
    deleteBucketReplication: $APIMethod<S3$20060301$DeleteBucketReplicationRequest, void>;
    deleteBucketTagging: $APIMethod<S3$20060301$DeleteBucketTaggingRequest, void>;
    deleteBucketWebsite: $APIMethod<S3$20060301$DeleteBucketWebsiteRequest, void>;
    deleteObject: $APIMethod<S3$20060301$DeleteObjectRequest, S3$20060301$DeleteObjectOutput>;
    deleteObjects: $APIMethod<S3$20060301$DeleteObjectsRequest, S3$20060301$DeleteObjectsOutput>;
    getBucketAccelerateConfiguration: $APIMethod<S3$20060301$GetBucketAccelerateConfigurationRequest, S3$20060301$GetBucketAccelerateConfigurationOutput>;
    getBucketAcl: $APIMethod<S3$20060301$GetBucketAclRequest, S3$20060301$GetBucketAclOutput>;
    getBucketCors: $APIMethod<S3$20060301$GetBucketCorsRequest, S3$20060301$GetBucketCorsOutput>;
    getBucketLifecycle: $APIMethod<S3$20060301$GetBucketLifecycleRequest, S3$20060301$GetBucketLifecycleOutput>;
    getBucketLifecycleConfiguration: $APIMethod<S3$20060301$GetBucketLifecycleConfigurationRequest, S3$20060301$GetBucketLifecycleConfigurationOutput>;
    getBucketLocation: $APIMethod<S3$20060301$GetBucketLocationRequest, S3$20060301$GetBucketLocationOutput>;
    getBucketLogging: $APIMethod<S3$20060301$GetBucketLoggingRequest, S3$20060301$GetBucketLoggingOutput>;
    getBucketNotification: $APIMethod<S3$20060301$GetBucketNotificationConfigurationRequest, S3$20060301$NotificationConfigurationDeprecated>;
    getBucketNotificationConfiguration: $APIMethod<S3$20060301$GetBucketNotificationConfigurationRequest, S3$20060301$NotificationConfiguration>;
    getBucketPolicy: $APIMethod<S3$20060301$GetBucketPolicyRequest, S3$20060301$GetBucketPolicyOutput>;
    getBucketReplication: $APIMethod<S3$20060301$GetBucketReplicationRequest, S3$20060301$GetBucketReplicationOutput>;
    getBucketRequestPayment: $APIMethod<S3$20060301$GetBucketRequestPaymentRequest, S3$20060301$GetBucketRequestPaymentOutput>;
    getBucketTagging: $APIMethod<S3$20060301$GetBucketTaggingRequest, S3$20060301$GetBucketTaggingOutput>;
    getBucketVersioning: $APIMethod<S3$20060301$GetBucketVersioningRequest, S3$20060301$GetBucketVersioningOutput>;
    getBucketWebsite: $APIMethod<S3$20060301$GetBucketWebsiteRequest, S3$20060301$GetBucketWebsiteOutput>;
    getObject: $APIMethod<S3$20060301$GetObjectRequest, S3$20060301$GetObjectOutput>;
    getObjectAcl: $APIMethod<S3$20060301$GetObjectAclRequest, S3$20060301$GetObjectAclOutput>;
    getObjectTorrent: $APIMethod<S3$20060301$GetObjectTorrentRequest, S3$20060301$GetObjectTorrentOutput>;
    headBucket: $APIMethod<S3$20060301$HeadBucketRequest, void>;
    headObject: $APIMethod<S3$20060301$HeadObjectRequest, S3$20060301$HeadObjectOutput>;
    listBuckets: $APIMethod<void, S3$20060301$ListBucketsOutput>;
    listMultipartUploads: $APIMethod<S3$20060301$ListMultipartUploadsRequest, S3$20060301$ListMultipartUploadsOutput>;
    listObjectVersions: $APIMethod<S3$20060301$ListObjectVersionsRequest, S3$20060301$ListObjectVersionsOutput>;
    listObjects: $APIMethod<S3$20060301$ListObjectsRequest, S3$20060301$ListObjectsOutput>;
    listObjectsV2: $APIMethod<S3$20060301$ListObjectsV2Request, S3$20060301$ListObjectsV2Output>;
    listParts: $APIMethod<S3$20060301$ListPartsRequest, S3$20060301$ListPartsOutput>;
    putBucketAccelerateConfiguration: $APIMethod<S3$20060301$PutBucketAccelerateConfigurationRequest, void>;
    putBucketAcl: $APIMethod<S3$20060301$PutBucketAclRequest, void>;
    putBucketCors: $APIMethod<S3$20060301$PutBucketCorsRequest, void>;
    putBucketLifecycle: $APIMethod<S3$20060301$PutBucketLifecycleRequest, void>;
    putBucketLifecycleConfiguration: $APIMethod<S3$20060301$PutBucketLifecycleConfigurationRequest, void>;
    putBucketLogging: $APIMethod<S3$20060301$PutBucketLoggingRequest, void>;
    putBucketNotification: $APIMethod<S3$20060301$PutBucketNotificationRequest, void>;
    putBucketNotificationConfiguration: $APIMethod<S3$20060301$PutBucketNotificationConfigurationRequest, void>;
    putBucketPolicy: $APIMethod<S3$20060301$PutBucketPolicyRequest, void>;
    putBucketReplication: $APIMethod<S3$20060301$PutBucketReplicationRequest, void>;
    putBucketRequestPayment: $APIMethod<S3$20060301$PutBucketRequestPaymentRequest, void>;
    putBucketTagging: $APIMethod<S3$20060301$PutBucketTaggingRequest, void>;
    putBucketVersioning: $APIMethod<S3$20060301$PutBucketVersioningRequest, void>;
    putBucketWebsite: $APIMethod<S3$20060301$PutBucketWebsiteRequest, void>;
    putObject: $APIMethod<S3$20060301$PutObjectRequest, S3$20060301$PutObjectOutput>;
    putObjectAcl: $APIMethod<S3$20060301$PutObjectAclRequest, S3$20060301$PutObjectAclOutput>;
    restoreObject: $APIMethod<S3$20060301$RestoreObjectRequest, S3$20060301$RestoreObjectOutput>;
    uploadPart: $APIMethod<S3$20060301$UploadPartRequest, S3$20060301$UploadPartOutput>;
    uploadPartCopy: $APIMethod<S3$20060301$UploadPartCopyRequest, S3$20060301$UploadPartCopyOutput>;
  }
  declare class S3 {
    constructor(config: $ConfigOptions & {
      apiVersion: '2006-03-01';
    }): S3$20060301;
    constructor(): S3$20060301;
  }
  declare class ServiceCatalog$20151210 {
    describeProduct: $APIMethod<ServiceCatalog$20151210$DescribeProductInput, ServiceCatalog$20151210$DescribeProductOutput>;
    describeProductView: $APIMethod<ServiceCatalog$20151210$DescribeProductViewInput, ServiceCatalog$20151210$DescribeProductViewOutput>;
    describeProvisioningParameters: $APIMethod<ServiceCatalog$20151210$DescribeProvisioningParametersInput, ServiceCatalog$20151210$DescribeProvisioningParametersOutput>;
    describeRecord: $APIMethod<ServiceCatalog$20151210$DescribeRecordInput, ServiceCatalog$20151210$DescribeRecordOutput>;
    listLaunchPaths: $APIMethod<ServiceCatalog$20151210$ListLaunchPathsInput, ServiceCatalog$20151210$ListLaunchPathsOutput>;
    listRecordHistory: $APIMethod<ServiceCatalog$20151210$ListRecordHistoryInput, ServiceCatalog$20151210$ListRecordHistoryOutput>;
    provisionProduct: $APIMethod<ServiceCatalog$20151210$ProvisionProductInput, ServiceCatalog$20151210$ProvisionProductOutput>;
    scanProvisionedProducts: $APIMethod<ServiceCatalog$20151210$ScanProvisionedProductsInput, ServiceCatalog$20151210$ScanProvisionedProductsOutput>;
    searchProducts: $APIMethod<ServiceCatalog$20151210$SearchProductsInput, ServiceCatalog$20151210$SearchProductsOutput>;
    terminateProvisionedProduct: $APIMethod<ServiceCatalog$20151210$TerminateProvisionedProductInput, ServiceCatalog$20151210$TerminateProvisionedProductOutput>;
    updateProvisionedProduct: $APIMethod<ServiceCatalog$20151210$UpdateProvisionedProductInput, ServiceCatalog$20151210$UpdateProvisionedProductOutput>;
  }
  declare class ServiceCatalog {
    constructor(config: $ConfigOptions & {
      apiVersion: '2015-12-10';
    }): ServiceCatalog$20151210;
    constructor(): ServiceCatalog$20151210;
  }
  declare class SES$20101201 {
    cloneReceiptRuleSet: $APIMethod<SES$20101201$CloneReceiptRuleSetRequest, SES$20101201$CloneReceiptRuleSetResponse>;
    createReceiptFilter: $APIMethod<SES$20101201$CreateReceiptFilterRequest, SES$20101201$CreateReceiptFilterResponse>;
    createReceiptRule: $APIMethod<SES$20101201$CreateReceiptRuleRequest, SES$20101201$CreateReceiptRuleResponse>;
    createReceiptRuleSet: $APIMethod<SES$20101201$CreateReceiptRuleSetRequest, SES$20101201$CreateReceiptRuleSetResponse>;
    deleteIdentity: $APIMethod<SES$20101201$DeleteIdentityRequest, SES$20101201$DeleteIdentityResponse>;
    deleteIdentityPolicy: $APIMethod<SES$20101201$DeleteIdentityPolicyRequest, SES$20101201$DeleteIdentityPolicyResponse>;
    deleteReceiptFilter: $APIMethod<SES$20101201$DeleteReceiptFilterRequest, SES$20101201$DeleteReceiptFilterResponse>;
    deleteReceiptRule: $APIMethod<SES$20101201$DeleteReceiptRuleRequest, SES$20101201$DeleteReceiptRuleResponse>;
    deleteReceiptRuleSet: $APIMethod<SES$20101201$DeleteReceiptRuleSetRequest, SES$20101201$DeleteReceiptRuleSetResponse>;
    deleteVerifiedEmailAddress: $APIMethod<SES$20101201$DeleteVerifiedEmailAddressRequest, void>;
    describeActiveReceiptRuleSet: $APIMethod<SES$20101201$DescribeActiveReceiptRuleSetRequest, SES$20101201$DescribeActiveReceiptRuleSetResponse>;
    describeReceiptRule: $APIMethod<SES$20101201$DescribeReceiptRuleRequest, SES$20101201$DescribeReceiptRuleResponse>;
    describeReceiptRuleSet: $APIMethod<SES$20101201$DescribeReceiptRuleSetRequest, SES$20101201$DescribeReceiptRuleSetResponse>;
    getIdentityDkimAttributes: $APIMethod<SES$20101201$GetIdentityDkimAttributesRequest, SES$20101201$GetIdentityDkimAttributesResponse>;
    getIdentityMailFromDomainAttributes: $APIMethod<SES$20101201$GetIdentityMailFromDomainAttributesRequest, SES$20101201$GetIdentityMailFromDomainAttributesResponse>;
    getIdentityNotificationAttributes: $APIMethod<SES$20101201$GetIdentityNotificationAttributesRequest, SES$20101201$GetIdentityNotificationAttributesResponse>;
    getIdentityPolicies: $APIMethod<SES$20101201$GetIdentityPoliciesRequest, SES$20101201$GetIdentityPoliciesResponse>;
    getIdentityVerificationAttributes: $APIMethod<SES$20101201$GetIdentityVerificationAttributesRequest, SES$20101201$GetIdentityVerificationAttributesResponse>;
    getSendQuota: $APIMethod<void, SES$20101201$GetSendQuotaResponse>;
    getSendStatistics: $APIMethod<void, SES$20101201$GetSendStatisticsResponse>;
    listIdentities: $APIMethod<SES$20101201$ListIdentitiesRequest, SES$20101201$ListIdentitiesResponse>;
    listIdentityPolicies: $APIMethod<SES$20101201$ListIdentityPoliciesRequest, SES$20101201$ListIdentityPoliciesResponse>;
    listReceiptFilters: $APIMethod<SES$20101201$ListReceiptFiltersRequest, SES$20101201$ListReceiptFiltersResponse>;
    listReceiptRuleSets: $APIMethod<SES$20101201$ListReceiptRuleSetsRequest, SES$20101201$ListReceiptRuleSetsResponse>;
    listVerifiedEmailAddresses: $APIMethod<void, SES$20101201$ListVerifiedEmailAddressesResponse>;
    putIdentityPolicy: $APIMethod<SES$20101201$PutIdentityPolicyRequest, SES$20101201$PutIdentityPolicyResponse>;
    reorderReceiptRuleSet: $APIMethod<SES$20101201$ReorderReceiptRuleSetRequest, SES$20101201$ReorderReceiptRuleSetResponse>;
    sendBounce: $APIMethod<SES$20101201$SendBounceRequest, SES$20101201$SendBounceResponse>;
    sendEmail: $APIMethod<SES$20101201$SendEmailRequest, SES$20101201$SendEmailResponse>;
    sendRawEmail: $APIMethod<SES$20101201$SendRawEmailRequest, SES$20101201$SendRawEmailResponse>;
    setActiveReceiptRuleSet: $APIMethod<SES$20101201$SetActiveReceiptRuleSetRequest, SES$20101201$SetActiveReceiptRuleSetResponse>;
    setIdentityDkimEnabled: $APIMethod<SES$20101201$SetIdentityDkimEnabledRequest, SES$20101201$SetIdentityDkimEnabledResponse>;
    setIdentityFeedbackForwardingEnabled: $APIMethod<SES$20101201$SetIdentityFeedbackForwardingEnabledRequest, SES$20101201$SetIdentityFeedbackForwardingEnabledResponse>;
    setIdentityHeadersInNotificationsEnabled: $APIMethod<SES$20101201$SetIdentityHeadersInNotificationsEnabledRequest, SES$20101201$SetIdentityHeadersInNotificationsEnabledResponse>;
    setIdentityMailFromDomain: $APIMethod<SES$20101201$SetIdentityMailFromDomainRequest, SES$20101201$SetIdentityMailFromDomainResponse>;
    setIdentityNotificationTopic: $APIMethod<SES$20101201$SetIdentityNotificationTopicRequest, SES$20101201$SetIdentityNotificationTopicResponse>;
    setReceiptRulePosition: $APIMethod<SES$20101201$SetReceiptRulePositionRequest, SES$20101201$SetReceiptRulePositionResponse>;
    updateReceiptRule: $APIMethod<SES$20101201$UpdateReceiptRuleRequest, SES$20101201$UpdateReceiptRuleResponse>;
    verifyDomainDkim: $APIMethod<SES$20101201$VerifyDomainDkimRequest, SES$20101201$VerifyDomainDkimResponse>;
    verifyDomainIdentity: $APIMethod<SES$20101201$VerifyDomainIdentityRequest, SES$20101201$VerifyDomainIdentityResponse>;
    verifyEmailAddress: $APIMethod<SES$20101201$VerifyEmailAddressRequest, void>;
    verifyEmailIdentity: $APIMethod<SES$20101201$VerifyEmailIdentityRequest, SES$20101201$VerifyEmailIdentityResponse>;
  }
  declare class SES {
    constructor(config: $ConfigOptions & {
      apiVersion: '2010-12-01';
    }): SES$20101201;
    constructor(): SES$20101201;
  }
  declare class SimpleDB$20090415 {
    batchDeleteAttributes: $APIMethod<SimpleDB$20090415$BatchDeleteAttributesRequest, void>;
    batchPutAttributes: $APIMethod<SimpleDB$20090415$BatchPutAttributesRequest, void>;
    createDomain: $APIMethod<SimpleDB$20090415$CreateDomainRequest, void>;
    deleteAttributes: $APIMethod<SimpleDB$20090415$DeleteAttributesRequest, void>;
    deleteDomain: $APIMethod<SimpleDB$20090415$DeleteDomainRequest, void>;
    domainMetadata: $APIMethod<SimpleDB$20090415$DomainMetadataRequest, SimpleDB$20090415$DomainMetadataResult>;
    getAttributes: $APIMethod<SimpleDB$20090415$GetAttributesRequest, SimpleDB$20090415$GetAttributesResult>;
    listDomains: $APIMethod<SimpleDB$20090415$ListDomainsRequest, SimpleDB$20090415$ListDomainsResult>;
    putAttributes: $APIMethod<SimpleDB$20090415$PutAttributesRequest, void>;
    select: $APIMethod<SimpleDB$20090415$SelectRequest, SimpleDB$20090415$SelectResult>;
  }
  declare class SimpleDB {
    constructor(config: $ConfigOptions & {
      apiVersion: '2009-04-15';
    }): SimpleDB$20090415;
    constructor(): SimpleDB$20090415;
  }
  declare class Snowball$20160630 {
    cancelJob: $APIMethod<Snowball$20160630$CancelJobRequest, Snowball$20160630$CancelJobResult>;
    createAddress: $APIMethod<Snowball$20160630$CreateAddressRequest, Snowball$20160630$CreateAddressResult>;
    createJob: $APIMethod<Snowball$20160630$CreateJobRequest, Snowball$20160630$CreateJobResult>;
    describeAddress: $APIMethod<Snowball$20160630$DescribeAddressRequest, Snowball$20160630$DescribeAddressResult>;
    describeAddresses: $APIMethod<Snowball$20160630$DescribeAddressesRequest, Snowball$20160630$DescribeAddressesResult>;
    describeJob: $APIMethod<Snowball$20160630$DescribeJobRequest, Snowball$20160630$DescribeJobResult>;
    getJobManifest: $APIMethod<Snowball$20160630$GetJobManifestRequest, Snowball$20160630$GetJobManifestResult>;
    getJobUnlockCode: $APIMethod<Snowball$20160630$GetJobUnlockCodeRequest, Snowball$20160630$GetJobUnlockCodeResult>;
    getSnowballUsage: $APIMethod<Snowball$20160630$GetSnowballUsageRequest, Snowball$20160630$GetSnowballUsageResult>;
    listJobs: $APIMethod<Snowball$20160630$ListJobsRequest, Snowball$20160630$ListJobsResult>;
    updateJob: $APIMethod<Snowball$20160630$UpdateJobRequest, Snowball$20160630$UpdateJobResult>;
  }
  declare class Snowball {
    constructor(config: $ConfigOptions & {
      apiVersion: '2016-06-30';
    }): Snowball$20160630;
    constructor(): Snowball$20160630;
  }
  declare class SNS$20100331 {
    addPermission: $APIMethod<SNS$20100331$AddPermissionInput, void>;
    checkIfPhoneNumberIsOptedOut: $APIMethod<SNS$20100331$CheckIfPhoneNumberIsOptedOutInput, SNS$20100331$CheckIfPhoneNumberIsOptedOutResponse>;
    confirmSubscription: $APIMethod<SNS$20100331$ConfirmSubscriptionInput, SNS$20100331$ConfirmSubscriptionResponse>;
    createPlatformApplication: $APIMethod<SNS$20100331$CreatePlatformApplicationInput, SNS$20100331$CreatePlatformApplicationResponse>;
    createPlatformEndpoint: $APIMethod<SNS$20100331$CreatePlatformEndpointInput, SNS$20100331$CreateEndpointResponse>;
    createTopic: $APIMethod<SNS$20100331$CreateTopicInput, SNS$20100331$CreateTopicResponse>;
    deleteEndpoint: $APIMethod<SNS$20100331$DeleteEndpointInput, void>;
    deletePlatformApplication: $APIMethod<SNS$20100331$DeletePlatformApplicationInput, void>;
    deleteTopic: $APIMethod<SNS$20100331$DeleteTopicInput, void>;
    getEndpointAttributes: $APIMethod<SNS$20100331$GetEndpointAttributesInput, SNS$20100331$GetEndpointAttributesResponse>;
    getPlatformApplicationAttributes: $APIMethod<SNS$20100331$GetPlatformApplicationAttributesInput, SNS$20100331$GetPlatformApplicationAttributesResponse>;
    getSMSAttributes: $APIMethod<SNS$20100331$GetSMSAttributesInput, SNS$20100331$GetSMSAttributesResponse>;
    getSubscriptionAttributes: $APIMethod<SNS$20100331$GetSubscriptionAttributesInput, SNS$20100331$GetSubscriptionAttributesResponse>;
    getTopicAttributes: $APIMethod<SNS$20100331$GetTopicAttributesInput, SNS$20100331$GetTopicAttributesResponse>;
    listEndpointsByPlatformApplication: $APIMethod<SNS$20100331$ListEndpointsByPlatformApplicationInput, SNS$20100331$ListEndpointsByPlatformApplicationResponse>;
    listPhoneNumbersOptedOut: $APIMethod<SNS$20100331$ListPhoneNumbersOptedOutInput, SNS$20100331$ListPhoneNumbersOptedOutResponse>;
    listPlatformApplications: $APIMethod<SNS$20100331$ListPlatformApplicationsInput, SNS$20100331$ListPlatformApplicationsResponse>;
    listSubscriptions: $APIMethod<SNS$20100331$ListSubscriptionsInput, SNS$20100331$ListSubscriptionsResponse>;
    listSubscriptionsByTopic: $APIMethod<SNS$20100331$ListSubscriptionsByTopicInput, SNS$20100331$ListSubscriptionsByTopicResponse>;
    listTopics: $APIMethod<SNS$20100331$ListTopicsInput, SNS$20100331$ListTopicsResponse>;
    optInPhoneNumber: $APIMethod<SNS$20100331$OptInPhoneNumberInput, SNS$20100331$OptInPhoneNumberResponse>;
    publish: $APIMethod<SNS$20100331$PublishInput, SNS$20100331$PublishResponse>;
    removePermission: $APIMethod<SNS$20100331$RemovePermissionInput, void>;
    setEndpointAttributes: $APIMethod<SNS$20100331$SetEndpointAttributesInput, void>;
    setPlatformApplicationAttributes: $APIMethod<SNS$20100331$SetPlatformApplicationAttributesInput, void>;
    setSMSAttributes: $APIMethod<SNS$20100331$SetSMSAttributesInput, SNS$20100331$SetSMSAttributesResponse>;
    setSubscriptionAttributes: $APIMethod<SNS$20100331$SetSubscriptionAttributesInput, void>;
    setTopicAttributes: $APIMethod<SNS$20100331$SetTopicAttributesInput, void>;
    subscribe: $APIMethod<SNS$20100331$SubscribeInput, SNS$20100331$SubscribeResponse>;
    unsubscribe: $APIMethod<SNS$20100331$UnsubscribeInput, void>;
  }
  declare class SNS {
    constructor(config: $ConfigOptions & {
      apiVersion: '2010-03-31';
    }): SNS$20100331;
    constructor(): SNS$20100331;
  }
  declare class SQS$20121105 {
    addPermission: $APIMethod<SQS$20121105$AddPermissionRequest, void>;
    changeMessageVisibility: $APIMethod<SQS$20121105$ChangeMessageVisibilityRequest, void>;
    changeMessageVisibilityBatch: $APIMethod<SQS$20121105$ChangeMessageVisibilityBatchRequest, SQS$20121105$ChangeMessageVisibilityBatchResult>;
    createQueue: $APIMethod<SQS$20121105$CreateQueueRequest, SQS$20121105$CreateQueueResult>;
    deleteMessage: $APIMethod<SQS$20121105$DeleteMessageRequest, void>;
    deleteMessageBatch: $APIMethod<SQS$20121105$DeleteMessageBatchRequest, SQS$20121105$DeleteMessageBatchResult>;
    deleteQueue: $APIMethod<SQS$20121105$DeleteQueueRequest, void>;
    getQueueAttributes: $APIMethod<SQS$20121105$GetQueueAttributesRequest, SQS$20121105$GetQueueAttributesResult>;
    getQueueUrl: $APIMethod<SQS$20121105$GetQueueUrlRequest, SQS$20121105$GetQueueUrlResult>;
    listDeadLetterSourceQueues: $APIMethod<SQS$20121105$ListDeadLetterSourceQueuesRequest, SQS$20121105$ListDeadLetterSourceQueuesResult>;
    listQueues: $APIMethod<SQS$20121105$ListQueuesRequest, SQS$20121105$ListQueuesResult>;
    purgeQueue: $APIMethod<SQS$20121105$PurgeQueueRequest, void>;
    receiveMessage: $APIMethod<SQS$20121105$ReceiveMessageRequest, SQS$20121105$ReceiveMessageResult>;
    removePermission: $APIMethod<SQS$20121105$RemovePermissionRequest, void>;
    sendMessage: $APIMethod<SQS$20121105$SendMessageRequest, SQS$20121105$SendMessageResult>;
    sendMessageBatch: $APIMethod<SQS$20121105$SendMessageBatchRequest, SQS$20121105$SendMessageBatchResult>;
    setQueueAttributes: $APIMethod<SQS$20121105$SetQueueAttributesRequest, void>;
  }
  declare class SQS {
    constructor(config: $ConfigOptions & {
      apiVersion: '2012-11-05';
    }): SQS$20121105;
    constructor(): SQS$20121105;
  }
  declare class SSM$20141106 {
    addTagsToResource: $APIMethod<SSM$20141106$AddTagsToResourceRequest, SSM$20141106$AddTagsToResourceResult>;
    cancelCommand: $APIMethod<SSM$20141106$CancelCommandRequest, SSM$20141106$CancelCommandResult>;
    createActivation: $APIMethod<SSM$20141106$CreateActivationRequest, SSM$20141106$CreateActivationResult>;
    createAssociation: $APIMethod<SSM$20141106$CreateAssociationRequest, SSM$20141106$CreateAssociationResult>;
    createAssociationBatch: $APIMethod<SSM$20141106$CreateAssociationBatchRequest, SSM$20141106$CreateAssociationBatchResult>;
    createDocument: $APIMethod<SSM$20141106$CreateDocumentRequest, SSM$20141106$CreateDocumentResult>;
    deleteActivation: $APIMethod<SSM$20141106$DeleteActivationRequest, SSM$20141106$DeleteActivationResult>;
    deleteAssociation: $APIMethod<SSM$20141106$DeleteAssociationRequest, SSM$20141106$DeleteAssociationResult>;
    deleteDocument: $APIMethod<SSM$20141106$DeleteDocumentRequest, SSM$20141106$DeleteDocumentResult>;
    deregisterManagedInstance: $APIMethod<SSM$20141106$DeregisterManagedInstanceRequest, SSM$20141106$DeregisterManagedInstanceResult>;
    describeActivations: $APIMethod<SSM$20141106$DescribeActivationsRequest, SSM$20141106$DescribeActivationsResult>;
    describeAssociation: $APIMethod<SSM$20141106$DescribeAssociationRequest, SSM$20141106$DescribeAssociationResult>;
    describeDocument: $APIMethod<SSM$20141106$DescribeDocumentRequest, SSM$20141106$DescribeDocumentResult>;
    describeDocumentPermission: $APIMethod<SSM$20141106$DescribeDocumentPermissionRequest, SSM$20141106$DescribeDocumentPermissionResponse>;
    describeInstanceInformation: $APIMethod<SSM$20141106$DescribeInstanceInformationRequest, SSM$20141106$DescribeInstanceInformationResult>;
    getDocument: $APIMethod<SSM$20141106$GetDocumentRequest, SSM$20141106$GetDocumentResult>;
    listAssociations: $APIMethod<SSM$20141106$ListAssociationsRequest, SSM$20141106$ListAssociationsResult>;
    listCommandInvocations: $APIMethod<SSM$20141106$ListCommandInvocationsRequest, SSM$20141106$ListCommandInvocationsResult>;
    listCommands: $APIMethod<SSM$20141106$ListCommandsRequest, SSM$20141106$ListCommandsResult>;
    listDocuments: $APIMethod<SSM$20141106$ListDocumentsRequest, SSM$20141106$ListDocumentsResult>;
    listTagsForResource: $APIMethod<SSM$20141106$ListTagsForResourceRequest, SSM$20141106$ListTagsForResourceResult>;
    modifyDocumentPermission: $APIMethod<SSM$20141106$ModifyDocumentPermissionRequest, SSM$20141106$ModifyDocumentPermissionResponse>;
    removeTagsFromResource: $APIMethod<SSM$20141106$RemoveTagsFromResourceRequest, SSM$20141106$RemoveTagsFromResourceResult>;
    sendCommand: $APIMethod<SSM$20141106$SendCommandRequest, SSM$20141106$SendCommandResult>;
    updateAssociationStatus: $APIMethod<SSM$20141106$UpdateAssociationStatusRequest, SSM$20141106$UpdateAssociationStatusResult>;
    updateManagedInstanceRole: $APIMethod<SSM$20141106$UpdateManagedInstanceRoleRequest, SSM$20141106$UpdateManagedInstanceRoleResult>;
  }
  declare class SSM {
    constructor(config: $ConfigOptions & {
      apiVersion: '2014-11-06';
    }): SSM$20141106;
    constructor(): SSM$20141106;
  }
  declare class StorageGateway$20130630 {
    activateGateway: $APIMethod<StorageGateway$20130630$ActivateGatewayInput, StorageGateway$20130630$ActivateGatewayOutput>;
    addCache: $APIMethod<StorageGateway$20130630$AddCacheInput, StorageGateway$20130630$AddCacheOutput>;
    addTagsToResource: $APIMethod<StorageGateway$20130630$AddTagsToResourceInput, StorageGateway$20130630$AddTagsToResourceOutput>;
    addUploadBuffer: $APIMethod<StorageGateway$20130630$AddUploadBufferInput, StorageGateway$20130630$AddUploadBufferOutput>;
    addWorkingStorage: $APIMethod<StorageGateway$20130630$AddWorkingStorageInput, StorageGateway$20130630$AddWorkingStorageOutput>;
    cancelArchival: $APIMethod<StorageGateway$20130630$CancelArchivalInput, StorageGateway$20130630$CancelArchivalOutput>;
    cancelRetrieval: $APIMethod<StorageGateway$20130630$CancelRetrievalInput, StorageGateway$20130630$CancelRetrievalOutput>;
    createCachediSCSIVolume: $APIMethod<StorageGateway$20130630$CreateCachediSCSIVolumeInput, StorageGateway$20130630$CreateCachediSCSIVolumeOutput>;
    createSnapshot: $APIMethod<StorageGateway$20130630$CreateSnapshotInput, StorageGateway$20130630$CreateSnapshotOutput>;
    createSnapshotFromVolumeRecoveryPoint: $APIMethod<StorageGateway$20130630$CreateSnapshotFromVolumeRecoveryPointInput, StorageGateway$20130630$CreateSnapshotFromVolumeRecoveryPointOutput>;
    createStorediSCSIVolume: $APIMethod<StorageGateway$20130630$CreateStorediSCSIVolumeInput, StorageGateway$20130630$CreateStorediSCSIVolumeOutput>;
    createTapeWithBarcode: $APIMethod<StorageGateway$20130630$CreateTapeWithBarcodeInput, StorageGateway$20130630$CreateTapeWithBarcodeOutput>;
    createTapes: $APIMethod<StorageGateway$20130630$CreateTapesInput, StorageGateway$20130630$CreateTapesOutput>;
    deleteBandwidthRateLimit: $APIMethod<StorageGateway$20130630$DeleteBandwidthRateLimitInput, StorageGateway$20130630$DeleteBandwidthRateLimitOutput>;
    deleteChapCredentials: $APIMethod<StorageGateway$20130630$DeleteChapCredentialsInput, StorageGateway$20130630$DeleteChapCredentialsOutput>;
    deleteGateway: $APIMethod<StorageGateway$20130630$DeleteGatewayInput, StorageGateway$20130630$DeleteGatewayOutput>;
    deleteSnapshotSchedule: $APIMethod<StorageGateway$20130630$DeleteSnapshotScheduleInput, StorageGateway$20130630$DeleteSnapshotScheduleOutput>;
    deleteTape: $APIMethod<StorageGateway$20130630$DeleteTapeInput, StorageGateway$20130630$DeleteTapeOutput>;
    deleteTapeArchive: $APIMethod<StorageGateway$20130630$DeleteTapeArchiveInput, StorageGateway$20130630$DeleteTapeArchiveOutput>;
    deleteVolume: $APIMethod<StorageGateway$20130630$DeleteVolumeInput, StorageGateway$20130630$DeleteVolumeOutput>;
    describeBandwidthRateLimit: $APIMethod<StorageGateway$20130630$DescribeBandwidthRateLimitInput, StorageGateway$20130630$DescribeBandwidthRateLimitOutput>;
    describeCache: $APIMethod<StorageGateway$20130630$DescribeCacheInput, StorageGateway$20130630$DescribeCacheOutput>;
    describeCachediSCSIVolumes: $APIMethod<StorageGateway$20130630$DescribeCachediSCSIVolumesInput, StorageGateway$20130630$DescribeCachediSCSIVolumesOutput>;
    describeChapCredentials: $APIMethod<StorageGateway$20130630$DescribeChapCredentialsInput, StorageGateway$20130630$DescribeChapCredentialsOutput>;
    describeGatewayInformation: $APIMethod<StorageGateway$20130630$DescribeGatewayInformationInput, StorageGateway$20130630$DescribeGatewayInformationOutput>;
    describeMaintenanceStartTime: $APIMethod<StorageGateway$20130630$DescribeMaintenanceStartTimeInput, StorageGateway$20130630$DescribeMaintenanceStartTimeOutput>;
    describeSnapshotSchedule: $APIMethod<StorageGateway$20130630$DescribeSnapshotScheduleInput, StorageGateway$20130630$DescribeSnapshotScheduleOutput>;
    describeStorediSCSIVolumes: $APIMethod<StorageGateway$20130630$DescribeStorediSCSIVolumesInput, StorageGateway$20130630$DescribeStorediSCSIVolumesOutput>;
    describeTapeArchives: $APIMethod<StorageGateway$20130630$DescribeTapeArchivesInput, StorageGateway$20130630$DescribeTapeArchivesOutput>;
    describeTapeRecoveryPoints: $APIMethod<StorageGateway$20130630$DescribeTapeRecoveryPointsInput, StorageGateway$20130630$DescribeTapeRecoveryPointsOutput>;
    describeTapes: $APIMethod<StorageGateway$20130630$DescribeTapesInput, StorageGateway$20130630$DescribeTapesOutput>;
    describeUploadBuffer: $APIMethod<StorageGateway$20130630$DescribeUploadBufferInput, StorageGateway$20130630$DescribeUploadBufferOutput>;
    describeVTLDevices: $APIMethod<StorageGateway$20130630$DescribeVTLDevicesInput, StorageGateway$20130630$DescribeVTLDevicesOutput>;
    describeWorkingStorage: $APIMethod<StorageGateway$20130630$DescribeWorkingStorageInput, StorageGateway$20130630$DescribeWorkingStorageOutput>;
    disableGateway: $APIMethod<StorageGateway$20130630$DisableGatewayInput, StorageGateway$20130630$DisableGatewayOutput>;
    listGateways: $APIMethod<StorageGateway$20130630$ListGatewaysInput, StorageGateway$20130630$ListGatewaysOutput>;
    listLocalDisks: $APIMethod<StorageGateway$20130630$ListLocalDisksInput, StorageGateway$20130630$ListLocalDisksOutput>;
    listTagsForResource: $APIMethod<StorageGateway$20130630$ListTagsForResourceInput, StorageGateway$20130630$ListTagsForResourceOutput>;
    listTapes: $APIMethod<StorageGateway$20130630$ListTapesInput, StorageGateway$20130630$ListTapesOutput>;
    listVolumeInitiators: $APIMethod<StorageGateway$20130630$ListVolumeInitiatorsInput, StorageGateway$20130630$ListVolumeInitiatorsOutput>;
    listVolumeRecoveryPoints: $APIMethod<StorageGateway$20130630$ListVolumeRecoveryPointsInput, StorageGateway$20130630$ListVolumeRecoveryPointsOutput>;
    listVolumes: $APIMethod<StorageGateway$20130630$ListVolumesInput, StorageGateway$20130630$ListVolumesOutput>;
    removeTagsFromResource: $APIMethod<StorageGateway$20130630$RemoveTagsFromResourceInput, StorageGateway$20130630$RemoveTagsFromResourceOutput>;
    resetCache: $APIMethod<StorageGateway$20130630$ResetCacheInput, StorageGateway$20130630$ResetCacheOutput>;
    retrieveTapeArchive: $APIMethod<StorageGateway$20130630$RetrieveTapeArchiveInput, StorageGateway$20130630$RetrieveTapeArchiveOutput>;
    retrieveTapeRecoveryPoint: $APIMethod<StorageGateway$20130630$RetrieveTapeRecoveryPointInput, StorageGateway$20130630$RetrieveTapeRecoveryPointOutput>;
    setLocalConsolePassword: $APIMethod<StorageGateway$20130630$SetLocalConsolePasswordInput, StorageGateway$20130630$SetLocalConsolePasswordOutput>;
    shutdownGateway: $APIMethod<StorageGateway$20130630$ShutdownGatewayInput, StorageGateway$20130630$ShutdownGatewayOutput>;
    startGateway: $APIMethod<StorageGateway$20130630$StartGatewayInput, StorageGateway$20130630$StartGatewayOutput>;
    updateBandwidthRateLimit: $APIMethod<StorageGateway$20130630$UpdateBandwidthRateLimitInput, StorageGateway$20130630$UpdateBandwidthRateLimitOutput>;
    updateChapCredentials: $APIMethod<StorageGateway$20130630$UpdateChapCredentialsInput, StorageGateway$20130630$UpdateChapCredentialsOutput>;
    updateGatewayInformation: $APIMethod<StorageGateway$20130630$UpdateGatewayInformationInput, StorageGateway$20130630$UpdateGatewayInformationOutput>;
    updateGatewaySoftwareNow: $APIMethod<StorageGateway$20130630$UpdateGatewaySoftwareNowInput, StorageGateway$20130630$UpdateGatewaySoftwareNowOutput>;
    updateMaintenanceStartTime: $APIMethod<StorageGateway$20130630$UpdateMaintenanceStartTimeInput, StorageGateway$20130630$UpdateMaintenanceStartTimeOutput>;
    updateSnapshotSchedule: $APIMethod<StorageGateway$20130630$UpdateSnapshotScheduleInput, StorageGateway$20130630$UpdateSnapshotScheduleOutput>;
    updateVTLDeviceType: $APIMethod<StorageGateway$20130630$UpdateVTLDeviceTypeInput, StorageGateway$20130630$UpdateVTLDeviceTypeOutput>;
  }
  declare class StorageGateway {
    constructor(config: $ConfigOptions & {
      apiVersion: '2013-06-30';
    }): StorageGateway$20130630;
    constructor(): StorageGateway$20130630;
  }
  declare class STS$20110615 {
    assumeRole: $APIMethod<STS$20110615$AssumeRoleRequest, STS$20110615$AssumeRoleResponse>;
    assumeRoleWithSAML: $APIMethod<STS$20110615$AssumeRoleWithSAMLRequest, STS$20110615$AssumeRoleWithSAMLResponse>;
    assumeRoleWithWebIdentity: $APIMethod<STS$20110615$AssumeRoleWithWebIdentityRequest, STS$20110615$AssumeRoleWithWebIdentityResponse>;
    decodeAuthorizationMessage: $APIMethod<STS$20110615$DecodeAuthorizationMessageRequest, STS$20110615$DecodeAuthorizationMessageResponse>;
    getCallerIdentity: $APIMethod<STS$20110615$GetCallerIdentityRequest, STS$20110615$GetCallerIdentityResponse>;
    getFederationToken: $APIMethod<STS$20110615$GetFederationTokenRequest, STS$20110615$GetFederationTokenResponse>;
    getSessionToken: $APIMethod<STS$20110615$GetSessionTokenRequest, STS$20110615$GetSessionTokenResponse>;
  }
  declare class STS {
    constructor(config: $ConfigOptions & {
      apiVersion: '2011-06-15';
    }): STS$20110615;
    constructor(): STS$20110615;
  }
  declare class Support$20130415 {
    addAttachmentsToSet: $APIMethod<Support$20130415$AddAttachmentsToSetRequest, Support$20130415$AddAttachmentsToSetResponse>;
    addCommunicationToCase: $APIMethod<Support$20130415$AddCommunicationToCaseRequest, Support$20130415$AddCommunicationToCaseResponse>;
    createCase: $APIMethod<Support$20130415$CreateCaseRequest, Support$20130415$CreateCaseResponse>;
    describeAttachment: $APIMethod<Support$20130415$DescribeAttachmentRequest, Support$20130415$DescribeAttachmentResponse>;
    describeCases: $APIMethod<Support$20130415$DescribeCasesRequest, Support$20130415$DescribeCasesResponse>;
    describeCommunications: $APIMethod<Support$20130415$DescribeCommunicationsRequest, Support$20130415$DescribeCommunicationsResponse>;
    describeServices: $APIMethod<Support$20130415$DescribeServicesRequest, Support$20130415$DescribeServicesResponse>;
    describeSeverityLevels: $APIMethod<Support$20130415$DescribeSeverityLevelsRequest, Support$20130415$DescribeSeverityLevelsResponse>;
    describeTrustedAdvisorCheckRefreshStatuses: $APIMethod<Support$20130415$DescribeTrustedAdvisorCheckRefreshStatusesRequest, Support$20130415$DescribeTrustedAdvisorCheckRefreshStatusesResponse>;
    describeTrustedAdvisorCheckResult: $APIMethod<Support$20130415$DescribeTrustedAdvisorCheckResultRequest, Support$20130415$DescribeTrustedAdvisorCheckResultResponse>;
    describeTrustedAdvisorCheckSummaries: $APIMethod<Support$20130415$DescribeTrustedAdvisorCheckSummariesRequest, Support$20130415$DescribeTrustedAdvisorCheckSummariesResponse>;
    describeTrustedAdvisorChecks: $APIMethod<Support$20130415$DescribeTrustedAdvisorChecksRequest, Support$20130415$DescribeTrustedAdvisorChecksResponse>;
    refreshTrustedAdvisorCheck: $APIMethod<Support$20130415$RefreshTrustedAdvisorCheckRequest, Support$20130415$RefreshTrustedAdvisorCheckResponse>;
    resolveCase: $APIMethod<Support$20130415$ResolveCaseRequest, Support$20130415$ResolveCaseResponse>;
  }
  declare class Support {
    constructor(config: $ConfigOptions & {
      apiVersion: '2013-04-15';
    }): Support$20130415;
    constructor(): Support$20130415;
  }
  declare class SWF$20120125 {
    countClosedWorkflowExecutions: $APIMethod<SWF$20120125$CountClosedWorkflowExecutionsInput, SWF$20120125$WorkflowExecutionCount>;
    countOpenWorkflowExecutions: $APIMethod<SWF$20120125$CountOpenWorkflowExecutionsInput, SWF$20120125$WorkflowExecutionCount>;
    countPendingActivityTasks: $APIMethod<SWF$20120125$CountPendingActivityTasksInput, SWF$20120125$PendingTaskCount>;
    countPendingDecisionTasks: $APIMethod<SWF$20120125$CountPendingDecisionTasksInput, SWF$20120125$PendingTaskCount>;
    deprecateActivityType: $APIMethod<SWF$20120125$DeprecateActivityTypeInput, void>;
    deprecateDomain: $APIMethod<SWF$20120125$DeprecateDomainInput, void>;
    deprecateWorkflowType: $APIMethod<SWF$20120125$DeprecateWorkflowTypeInput, void>;
    describeActivityType: $APIMethod<SWF$20120125$DescribeActivityTypeInput, SWF$20120125$ActivityTypeDetail>;
    describeDomain: $APIMethod<SWF$20120125$DescribeDomainInput, SWF$20120125$DomainDetail>;
    describeWorkflowExecution: $APIMethod<SWF$20120125$DescribeWorkflowExecutionInput, SWF$20120125$WorkflowExecutionDetail>;
    describeWorkflowType: $APIMethod<SWF$20120125$DescribeWorkflowTypeInput, SWF$20120125$WorkflowTypeDetail>;
    getWorkflowExecutionHistory: $APIMethod<SWF$20120125$GetWorkflowExecutionHistoryInput, SWF$20120125$History>;
    listActivityTypes: $APIMethod<SWF$20120125$ListActivityTypesInput, SWF$20120125$ActivityTypeInfos>;
    listClosedWorkflowExecutions: $APIMethod<SWF$20120125$ListClosedWorkflowExecutionsInput, SWF$20120125$WorkflowExecutionInfos>;
    listDomains: $APIMethod<SWF$20120125$ListDomainsInput, SWF$20120125$DomainInfos>;
    listOpenWorkflowExecutions: $APIMethod<SWF$20120125$ListOpenWorkflowExecutionsInput, SWF$20120125$WorkflowExecutionInfos>;
    listWorkflowTypes: $APIMethod<SWF$20120125$ListWorkflowTypesInput, SWF$20120125$WorkflowTypeInfos>;
    pollForActivityTask: $APIMethod<SWF$20120125$PollForActivityTaskInput, SWF$20120125$ActivityTask>;
    pollForDecisionTask: $APIMethod<SWF$20120125$PollForDecisionTaskInput, SWF$20120125$DecisionTask>;
    recordActivityTaskHeartbeat: $APIMethod<SWF$20120125$RecordActivityTaskHeartbeatInput, SWF$20120125$ActivityTaskStatus>;
    registerActivityType: $APIMethod<SWF$20120125$RegisterActivityTypeInput, void>;
    registerDomain: $APIMethod<SWF$20120125$RegisterDomainInput, void>;
    registerWorkflowType: $APIMethod<SWF$20120125$RegisterWorkflowTypeInput, void>;
    requestCancelWorkflowExecution: $APIMethod<SWF$20120125$RequestCancelWorkflowExecutionInput, void>;
    respondActivityTaskCanceled: $APIMethod<SWF$20120125$RespondActivityTaskCanceledInput, void>;
    respondActivityTaskCompleted: $APIMethod<SWF$20120125$RespondActivityTaskCompletedInput, void>;
    respondActivityTaskFailed: $APIMethod<SWF$20120125$RespondActivityTaskFailedInput, void>;
    respondDecisionTaskCompleted: $APIMethod<SWF$20120125$RespondDecisionTaskCompletedInput, void>;
    signalWorkflowExecution: $APIMethod<SWF$20120125$SignalWorkflowExecutionInput, void>;
    startWorkflowExecution: $APIMethod<SWF$20120125$StartWorkflowExecutionInput, SWF$20120125$Run>;
    terminateWorkflowExecution: $APIMethod<SWF$20120125$TerminateWorkflowExecutionInput, void>;
  }
  declare class SWF {
    constructor(config: $ConfigOptions & {
      apiVersion: '2012-01-25';
    }): SWF$20120125;
    constructor(): SWF$20120125;
  }
  declare class WAF$20150824 {
    createByteMatchSet: $APIMethod<WAF$20150824$CreateByteMatchSetRequest, WAF$20150824$CreateByteMatchSetResponse>;
    createIPSet: $APIMethod<WAF$20150824$CreateIPSetRequest, WAF$20150824$CreateIPSetResponse>;
    createRule: $APIMethod<WAF$20150824$CreateRuleRequest, WAF$20150824$CreateRuleResponse>;
    createSizeConstraintSet: $APIMethod<WAF$20150824$CreateSizeConstraintSetRequest, WAF$20150824$CreateSizeConstraintSetResponse>;
    createSqlInjectionMatchSet: $APIMethod<WAF$20150824$CreateSqlInjectionMatchSetRequest, WAF$20150824$CreateSqlInjectionMatchSetResponse>;
    createWebACL: $APIMethod<WAF$20150824$CreateWebACLRequest, WAF$20150824$CreateWebACLResponse>;
    createXssMatchSet: $APIMethod<WAF$20150824$CreateXssMatchSetRequest, WAF$20150824$CreateXssMatchSetResponse>;
    deleteByteMatchSet: $APIMethod<WAF$20150824$DeleteByteMatchSetRequest, WAF$20150824$DeleteByteMatchSetResponse>;
    deleteIPSet: $APIMethod<WAF$20150824$DeleteIPSetRequest, WAF$20150824$DeleteIPSetResponse>;
    deleteRule: $APIMethod<WAF$20150824$DeleteRuleRequest, WAF$20150824$DeleteRuleResponse>;
    deleteSizeConstraintSet: $APIMethod<WAF$20150824$DeleteSizeConstraintSetRequest, WAF$20150824$DeleteSizeConstraintSetResponse>;
    deleteSqlInjectionMatchSet: $APIMethod<WAF$20150824$DeleteSqlInjectionMatchSetRequest, WAF$20150824$DeleteSqlInjectionMatchSetResponse>;
    deleteWebACL: $APIMethod<WAF$20150824$DeleteWebACLRequest, WAF$20150824$DeleteWebACLResponse>;
    deleteXssMatchSet: $APIMethod<WAF$20150824$DeleteXssMatchSetRequest, WAF$20150824$DeleteXssMatchSetResponse>;
    getByteMatchSet: $APIMethod<WAF$20150824$GetByteMatchSetRequest, WAF$20150824$GetByteMatchSetResponse>;
    getChangeToken: $APIMethod<WAF$20150824$GetChangeTokenRequest, WAF$20150824$GetChangeTokenResponse>;
    getChangeTokenStatus: $APIMethod<WAF$20150824$GetChangeTokenStatusRequest, WAF$20150824$GetChangeTokenStatusResponse>;
    getIPSet: $APIMethod<WAF$20150824$GetIPSetRequest, WAF$20150824$GetIPSetResponse>;
    getRule: $APIMethod<WAF$20150824$GetRuleRequest, WAF$20150824$GetRuleResponse>;
    getSampledRequests: $APIMethod<WAF$20150824$GetSampledRequestsRequest, WAF$20150824$GetSampledRequestsResponse>;
    getSizeConstraintSet: $APIMethod<WAF$20150824$GetSizeConstraintSetRequest, WAF$20150824$GetSizeConstraintSetResponse>;
    getSqlInjectionMatchSet: $APIMethod<WAF$20150824$GetSqlInjectionMatchSetRequest, WAF$20150824$GetSqlInjectionMatchSetResponse>;
    getWebACL: $APIMethod<WAF$20150824$GetWebACLRequest, WAF$20150824$GetWebACLResponse>;
    getXssMatchSet: $APIMethod<WAF$20150824$GetXssMatchSetRequest, WAF$20150824$GetXssMatchSetResponse>;
    listByteMatchSets: $APIMethod<WAF$20150824$ListByteMatchSetsRequest, WAF$20150824$ListByteMatchSetsResponse>;
    listIPSets: $APIMethod<WAF$20150824$ListIPSetsRequest, WAF$20150824$ListIPSetsResponse>;
    listRules: $APIMethod<WAF$20150824$ListRulesRequest, WAF$20150824$ListRulesResponse>;
    listSizeConstraintSets: $APIMethod<WAF$20150824$ListSizeConstraintSetsRequest, WAF$20150824$ListSizeConstraintSetsResponse>;
    listSqlInjectionMatchSets: $APIMethod<WAF$20150824$ListSqlInjectionMatchSetsRequest, WAF$20150824$ListSqlInjectionMatchSetsResponse>;
    listWebACLs: $APIMethod<WAF$20150824$ListWebACLsRequest, WAF$20150824$ListWebACLsResponse>;
    listXssMatchSets: $APIMethod<WAF$20150824$ListXssMatchSetsRequest, WAF$20150824$ListXssMatchSetsResponse>;
    updateByteMatchSet: $APIMethod<WAF$20150824$UpdateByteMatchSetRequest, WAF$20150824$UpdateByteMatchSetResponse>;
    updateIPSet: $APIMethod<WAF$20150824$UpdateIPSetRequest, WAF$20150824$UpdateIPSetResponse>;
    updateRule: $APIMethod<WAF$20150824$UpdateRuleRequest, WAF$20150824$UpdateRuleResponse>;
    updateSizeConstraintSet: $APIMethod<WAF$20150824$UpdateSizeConstraintSetRequest, WAF$20150824$UpdateSizeConstraintSetResponse>;
    updateSqlInjectionMatchSet: $APIMethod<WAF$20150824$UpdateSqlInjectionMatchSetRequest, WAF$20150824$UpdateSqlInjectionMatchSetResponse>;
    updateWebACL: $APIMethod<WAF$20150824$UpdateWebACLRequest, WAF$20150824$UpdateWebACLResponse>;
    updateXssMatchSet: $APIMethod<WAF$20150824$UpdateXssMatchSetRequest, WAF$20150824$UpdateXssMatchSetResponse>;
  }
  declare class WAF {
    constructor(config: $ConfigOptions & {
      apiVersion: '2015-08-24';
    }): WAF$20150824;
    constructor(): WAF$20150824;
  }
  declare class WorkSpaces$20150408 {
    createTags: $APIMethod<WorkSpaces$20150408$CreateTagsRequest, WorkSpaces$20150408$CreateTagsResult>;
    createWorkspaces: $APIMethod<WorkSpaces$20150408$CreateWorkspacesRequest, WorkSpaces$20150408$CreateWorkspacesResult>;
    deleteTags: $APIMethod<WorkSpaces$20150408$DeleteTagsRequest, WorkSpaces$20150408$DeleteTagsResult>;
    describeTags: $APIMethod<WorkSpaces$20150408$DescribeTagsRequest, WorkSpaces$20150408$DescribeTagsResult>;
    describeWorkspaceBundles: $APIMethod<WorkSpaces$20150408$DescribeWorkspaceBundlesRequest, WorkSpaces$20150408$DescribeWorkspaceBundlesResult>;
    describeWorkspaceDirectories: $APIMethod<WorkSpaces$20150408$DescribeWorkspaceDirectoriesRequest, WorkSpaces$20150408$DescribeWorkspaceDirectoriesResult>;
    describeWorkspaces: $APIMethod<WorkSpaces$20150408$DescribeWorkspacesRequest, WorkSpaces$20150408$DescribeWorkspacesResult>;
    rebootWorkspaces: $APIMethod<WorkSpaces$20150408$RebootWorkspacesRequest, WorkSpaces$20150408$RebootWorkspacesResult>;
    rebuildWorkspaces: $APIMethod<WorkSpaces$20150408$RebuildWorkspacesRequest, WorkSpaces$20150408$RebuildWorkspacesResult>;
    terminateWorkspaces: $APIMethod<WorkSpaces$20150408$TerminateWorkspacesRequest, WorkSpaces$20150408$TerminateWorkspacesResult>;
  }
  declare class WorkSpaces {
    constructor(config: $ConfigOptions & {
      apiVersion: '2015-04-08';
    }): WorkSpaces$20150408;
    constructor(): WorkSpaces$20150408;
  }
}
